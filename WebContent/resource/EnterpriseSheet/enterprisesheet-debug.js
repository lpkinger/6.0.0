Ext.define("EnterpriseSheet.pure.lang.Language", {
	content: {
		absolute_coord: "Absolute coordinate",
		above_average: "Above average",
		absolute: "Absolute",
		aboutSheet: "About EnterpriseSheet",
		accounting: "Accounting",
		action_broken_merged: "This action is aborted, because it will cause some merged cell broken.",
		add_group: "Add group",
		add_variable: "Add variable",
		add_variable_for: "Add variable for : ",
		add_new_dateset: "Add new dataset",
		add: "Add",
		add_number_icon: "Add number icon to the title",
		add_date_icon: "Add date icon to the title",
		add_phone_icon: "Add phone icon to the title",
		add_url_icon: "Add url icon to the title",
		add_email_icon: "Add email icon to the title",
		add_checkbox_icon: "Add checkbox icon to the title",
		add_radio_icon: "Add radio icon to the title",
		add_attach_icon: "Add attachment icon to the title",
		add_currency_icon: "Add currency icon to the title",
		add_perent_icon: "Add percent icon to the title",
		add_text_icon: "Add text icon to the title",
		add_drop_icon: "Add dropdown icon to the title",
		after: "After",
		all: "All",
		allow_invalid: "Allow invalid data, but show hint",
		all_changes_are_saved: "Change saved",
		align_justify: "Align justify",
		align: "Align",
		align_left: "Align left",
		align_center: "Align center",
		align_right: "Align right",
		align_top: "Align top",
		align_middle: "Align middle",
		align_bottom: "Align bottom",
		apply_style_brush: "Apply style brush",
		apply: "Apply",
		area: "Area",
		at: "at",
		autofill_down: "Autofill down",
		autofill_up: "Autofill up",
		autofill_left: "Autofill left",
		autofill_right: "Autofill right",
		average: "Average",
		auto_adjust_row_height: "Auto adjust row height",
		auto_adjust_column_width: "Auto adjust column width",
		autofill: "Autofill",
		authorSharing: "Author, Sharing",
		bad: "Bad",
		bad_good_ok: "Bad, good and OK",
		backward: "Backward",
		between: "Between",
		before: "Before",
		begin_at: "Begin at",
		background_color: "Background color",
		back: "Back",
		below_average: "Below average",
		below_average: "Below average value",
		bottom_side_cell_move_top: "Bottom side cells move top",
		blue_theme: "Blue theme",
		blank: "Blank",
		bar: "Bar",
		boolstyle: "Bool condition",
		bold: "Bold",
		bold_tip: "<b>Bold (CTRL+B)</b><br/>Make your text bold.",
		bottom10: "Bottom 10",
		bottom_10_value: "Bottom 10",
		"bottom_10%": "Bottom 10%",
		bottom: "Bottom",
		bold_border_bottom: "Bold border bottom",
		border_color: "Border color",
		border_all: "Border all",
		border_top: "Border top",
		border_right: "Border right",
		border_bottom: "Border bottom",
		border_left: "Border left",
		border_outside: "Border outside",
		border_inside: "Border inside",
		border_none: "Border none",
		bold_border_outside: "Bold border outside",
		border_top_bottom: "Border top and bottom",
		border_top_bottom_bold: "Border top and bold border bottom",
		border_style: "Border style",
		border: "Border",
		brush: "Brush",
		broken_merge_cell_hint: "This action will break the merged cell, please cancel the related merge cell first.",
		calculate: "Calculate",
		calculate_highlight_cell: "Top/Bottom rules",
		cancel_split: "Cancel split",
		cancel_hide_row: "Cancel hide row",
		cancel_hide_column: "Cancel hide column",
		can_not_change_part_merged_cell: "Can not only change some part of a merged cell",
		case_sensitive: "Case sensitive",
		cannot_operate_merged_cell: "Can not process this action on merged cell",
		cannot_operate_table_tpl: "Can not process this action on table template",
		cannot_set_table_tpl_for_single_cell: "Can not apply table template for a single cell, please select a range.",
		change_group: "Change group",
		cancel_group: "Cancel group",
		cannot_calculate_value: 'Can not calculate the value of formula "{0}", please check the calling parameters.',
		cannot_set_tpl_for_selection: "Can not set template for selection, there is already a template in the selection.",
		cannot_delete_normal_tpl_cell: "Can not delete normal cells and template cells at the same time",
		cannot_insert_break_tpl_cell: "Can not insert at the selection, it will break the table template region",
		category: "Category",
		can_not_create_filter: "Can not create filter for selection",
		can_not_sort_range: "Can not sort a single cell or the whole sheet",
		can_not_sort_merged_or_table_tpl: "Can not sort range which contains merged cell(s) or table template",
		cancel: "Cancel",
		cancel_merge_cell: "Cancel merged cell",
		cancel_freeze: "Cancel freeze",
		cancel_filtering: "Cancel filtering",
		clear_filter: "Clear filter",
		copy_without_style: "Copy without style",
		create_filter_for: "Create filter for",
		clean: "Clean",
		clean_for: "Clean for",
		clean_content: "Clean content",
		clean_style: "Clean style",
		clean_border: "Clean border",
		count: "Count",
		clipboard: "Clipboard",
		check_cell: "Check cell",
		cell: "Cell",
		chart: "Chart",
		charts: "Charts",
		comma: "Comma",
		currency: "Currency",
		chart_type: "Chart type",
		chart_setting: "Chart Settings",
		circle_refer: "Circular reference",
		circle_refer_display: "There is a reference circule in the formula",
		change_file_title: "Change file title",
		change_tpl_summary: "Change the summary",
		check_all: "Check all",
		clean_all: "Clean all",
		copy_sheet_to: "Copy sheet to",
		cell_range: "Cell range",
		clearCheckboxRadio: "Clear Checkbox/Radio",
		checkbox: "Checkbox",
		change_property_for: "Change property for",
		change_border_for: "Change border for",
		change_condition_for: "Change condition for",
		change_column_width_for: "Change column width for",
		change_row_height_for: "Change row height for",
		clear_condition: "Clear condition",
		clear_selecttion_condition: "Clear condition of selection",
		clear_sheet_condition: "Clear condition of sheet",
		close: "Close",
		clear: "Clear",
		clear_table_tpl: "Clear table template",
		color: "Color",
		component: "Component",
		confirm: "Confirm",
		copy_cell: "Copy cell",
		contain: "Contain",
		column_absolute: "Column absolute",
		cell_styles: "Cell styles",
		comma_format: "Comma format",
		condition: "Condition",
		condition_style_manager: "Conditional style manager",
		custom_style: "Custom style",
		condition_highlight_cell: "Highlight cells rules",
		colorbar: "Data bars",
		color_scales: "Color scales",
		condition_management: "Condition management",
		collapse_column_group: "Collapse column group",
		collapse_row_group: "Collapse row group",
		criteria: "Criteria",
		create: "Create",
		create_chart: "Create chart",
		create_picture: "Create picture",
		create_sheet_from_tpl: "Create new sheet from existing template",
		custom_sort: "Custom sort",
		cut: "Cut",
		cut_tip: "<b>Cut (CTRL+X)</b><br/>Remove the selection and put it on the clipboard.",
		copy: "Copy",
		copy_tip: "<b>Copy (CTRL+C)</b><br/>Put a copy of selection on the clipboard.",
		comment: "Comment",
		column: "Column",
		column_width: "Column width",
		custom: "Custom",
		customFormat: "Add custom number format",
		customEnter: "Enter number format (Ex: $#,##0.00;[Red]-$#,##0.00;[Red]0)",
		currency: "Currency",
		currencyCodeUse: "Use currency code instead of symbol",
		data: "Data",
		date: "Date",
		date_ocurring_at: "A Date Occurring",
		data_range_select: "Select data range",
		data_range_for_mini_chart: "Data range for sparkline chart",
		data_modal: "Data and Modal",
		dataTypeConf: "Data type configure",
		dark_color: "Dark color",
		decimalDecrease: "Decrease decimal",
		decimalIncrease: "Increase decimal",
		decimalPlaces: "Decimal places",
		deep_dark_color: "Deep dark color",
		"delete": "Delete",
		delete_cell: "Delete cell",
		delete_row: "Delete row",
		delete_column: "Delete column",
		delete_sheet: "Delete sheet",
		delete_chart: "Delete chart",
		delete_chart: "Delete chart",
		decrease_font_size: "Decrease font size",
		delete_comment: "Delete comment",
		delete_picture: "Delete picture",
		delete_row_in_tabletpl: "You can only remove the whole row(s) for current selection in the table template, do you want to do it?",
		delete_column_in_tabletpl: "You can only remove the whole column(s) for current selection in the table template, do you want to do it?",
		direction: "Direction",
		do_u_really_wanna_delete: "Do you really want to delete",
		define_reference: "Define a reference",
		define_variable_for_cell: "Defined a variable for this cell : ",
		delete_condition_style: "Delete condition style",
		double_border_bottom: "Double border bottom",
		dot_move_left: "Dot move left",
		dot_move_right: "Dot move right",
		double_border_bottom_top_border: "Double border bottom and border top",
		documentation: "Documentation",
		drag_select_reference: "Drag to select a reference",
		dropdownURL: "Dropdown URL",
		enable_disable_edit: "Enable/Disable edit the selection",
		edit: "Edit",
		enter2char: "Please enter at least 2 characters to process search",
		equal: "Equal",
		explain_text: "Explain text",
		error: "Error",
		expand_whole_row: "Expand sort to whole row",
		expand_column_group: "Expand column group",
		expand_row_group: "Expand row group",
		exportExcel: "Export as Microsoft Excel",
		fail2add_dataset: "Fail to add dataset",
		fail2delete_dataset: "Fail to delete dataset",
		find: "Find",
		find_replace: "Find and replace",
		find_all: "Find all",
		file: "File",
		file_name: "File name",
		first_row_as_label: "Row label",
		first_col_as_label: "Column label",
		filter_condition: "Filtering by condition",
		filter_sort: "Filter and sort",
		fill_sequence: "Fill sequence",
		filtering: "Filtering",
		fill_without_style: "fill without style",
		file_not_saved: "File not saved yet",
		format: "Format",
		font: "Font",
		format_brush: "Format brush",
		font_family: "Font family",
		font_size: "Font size",
		font_color: "Font color",
		forward: "Forward",
		formatCells: "Format Cells",
		filter: "Filter",
		"function": "Function",
		functionList: "Function list",
		fraction: "Fraction",
		freeze: "Freeze",
		freeze_sheet: "Freeze sheet",
		freeze_first_row: "Freeze the first row",
		freeze_first_col: "Freeze the first column",
		gain_loss: "Win/Loss",
		green_fill_darkgreen_text: "Green fill with dark green text",
		good: "Good",
		go_to_link: "Go to link",
		greater_than: "Greater than",
		greater_equal: "Greater than or equal to",
		greater_or_equal: "Greater or equal",
		gray_theme: "Gray theme",
		gray_text: "Gray text",
		help: "Help",
		hint: "Hint",
		hide_column: "Hide column",
		hint_text: "Hint text",
		hide_cancel_hide: "Hide and cancel hide",
		hide_row: "Hide row",
		hide: "Hide",
		hide_grid_line: "Hide grid line",
		hyperlink: "Hyperlink",
		ignore_blank: "Ignore blank",
		image: "Image",
		image_type_not: "Please select an image file to import",
		image_not_available: "The image is not available",
		"import": "Import",
		importFile: "Import Excel file",
		ImportDesc: "Choose a CSV or XLSX type file to import.",
		ImportTakeAwhile: "It may take a few minutes to upload your file.",
		insert_copy_overlap: "Can not insert copied range when there is overlapped.",
		invalid_cell_content: "Invalid cell content",
		insert_copied: "Insert copied",
		insert_copied_option: "Insert copied option",
		insert_column_at: "Insert column at",
		insert_cell_at: "Insert cell at",
		insert_row_in_tabletpl: "You can only insert the whole row(s) for current selection in the table template, do you want to do it?",
		insert_column_in_tabletpl: "You can only insert the whole column(s) for current selection in the table template, do you want to do it?",
		insert_function: "Insert function",
		insert_sequence_no: "Insert sequence No.",
		insert_drop_list: "Dropdown list",
		input_drop_list: "Input drop list",
		input_variable_name: "Variable name (only allow to contain letters, numbers . (dot) and _)",
		input_reference_name: "Input reference name",
		input_file_name: "Input file name",
		input2search: "Input to search",
		input_sheet_name: "Input sheet name",
		intelnet_error: "Internal error, please try again.",
		invalid_refer: "Invalid reference",
		invalid_refer_display: 'Refer to a range does not exist, please check the spell of "{0}"',
		index_out_range: "Index out of range",
		index_out_param_range: 'The index is out of range in formula "{0}", please click <a href="{1}">here</a> to check more details.',
		inc_indent: "Increase indent",
		insert_whole_row: "Insert whole row",
		insert_whole_column: "Insert whole column",
		insert_comment: "Insert comment",
		insert_option: "Insert option",
		insert_picture_by_url: "Insert picture by URL",
		invalid_url: "Not a valid URL",
		italic: "Italic",
		italic_tip: "<b>Italic (CTRL+I)</b><br/>Italicize your text.",
		increase_font_size: "Increase font size",
		insert_hyperlink: "Insert hyperlink",
		inspector: "Inspector",
		input: "Input",
		item: "Item",
		insert_row_at: "Insert row at",
		insert: "Insert",
		insert_cell: "Insert cell",
		insert_row: "Insert row",
		insert_column: "Insert column",
		insert_sheet: "Insert sheet",
		include: "Include",
		inifnate_loop: "Infinite loop",
		is_valid_date: "Is valid date",
		is_valid_email: "Is valid email",
		is_valid_url: "Is valid URL",
		item_hint: 'Input like: apple, orange, banana. Separate items by ","',
		item_list: "Item list",
		keyboard_shortcuts: "Keyboard shortcuts (CTRL+/)",
		keyboard_shortcuts_desc: '<Table WIDTH="100%"><tr><th COLSPAN="4" align="left">Text formatting</th></tr><tr><td>Ctrl+B</td><td>Bold</td> <td>Ctrl+Shift+L</td><td>Align left</td></tr><tr><td>Ctrl+U</td><td>Underline</td> <td>Ctrl+Shift+E</td><td>Align center</td></tr><tr><td>Ctrl+I</td><td>Italic</td> <td>Ctrl+Shift+R</td><td>Align right</td></tr></Table><br/><Table WIDTH="100%"><tr><th COLSPAN="4" align="left">Actions</th></tr><tr><td>Ctrl+O</td><td>Open file</td> <td>Ctrl+K</td> <td>Insert link</td> </tr><tr><td>Ctrl+Z</td><td>Undo</td> <td>Ctrl+Y</td> <td>Redo</td></tr><tr><td>Ctrl+X</td><td>Cut</td> <td>Ctrl+C</td><td>Copy</td></tr><tr><td>Ctrl+V</td><td>Paste</td> <td>Ctrl+ALT+M</td><td>Insert/Edit Comment</td></tr><tr><td>Ctrl+F</td><td>Find and replace</td> <td></td><td></td></tr></Table>',
		label_setting: "Label settings",
		last_week: "Last week",
		last_month: "Last month",
		layout: "Layout",
		line_style: "Line style",
		less_than: "Less than",
		less_equal: "Less than or equal to",
		less_or_equal: "Less or equal",
		list_number: "List number",
		list_dot: "List dot",
		line_space: "Line space",
		line: "Line",
		left: "Left",
		legend_position: "Legend position",
		less_than: "Less than",
		light_color: "Light color",
		link_cell: "Link cell",
		link: "Link",
		loading: "Loading",
		login: "Login",
		logout: "Logout",
		locale: "Locale",
		locale_chinese: "Chinese (PRC)",
		locale_english_us: "English (United States)",
		lang_en: "English (英�)",
		lang_zh: "Chinese (�文)",
		language: "Language (�言)",
		mark_range: "Define named range",
		max: "Max",
		min: "Min",
		mini_charts: "Sparkline charts",
		merge_cell: "Merge cells",
		merge_cell_in_column: "Merge cell in column",
		merge_cell_in_row: "Merge cell in row",
		move_current_cell_right: "Move current cells right",
		move_current_cell_bottom: "Move current cells bottom",
		money_format: "Money format",
		money: "Money",
		money_denmark_krone: "Denmark Krone",
		money_china_rmb: "China RMB",
		money_us_dollar: "United States Dollar",
		money_korean_won: "Korean Won",
		money_russian_rouble: "Russian Ruble",
		money_indian_rupee: "Indian Rupee",
		money_european_euro: "Euro Member Countries",
		money_japanese_yen: "Japan Yen",
		money_brazil_real: "Brazil Real",
		money_english_pound: "United Kingdom Pound",
		money_canada_dollar: "Canadian Dollar",
		money_australian_dollar: "Australian Dollar",
		money_southAf_rand: "South African Rand",
		money_indonsia_rupiah: "Indonesian Rupiah",
		money_israel_shekel: "Israeli Shekel",
		money_turky_lira: "Turkey Lira",
		money_swit_franc: "Switzerland Franc",
		money_sigapore: "Singapore Dollar",
		money_argentina_peso: "Argentinan Peso",
		money_chile_peso: "Chile Peso",
		money_columbia_peso: "Colombian Peso",
		money_taiwan_yen: "Taiwan New Dollar",
		money_sweden: "Sweden Krona",
		money_norway: "Norway Krone",
		money_newzealand: "New Zealand Dollar",
		money_malaysia: "Malaysian Ringgit",
		money_hongkong: "Hong Kong Dollar",
		money_saudi: "Saudi Arabia Riyal",
		money_poland: "Poland Zloty",
		money_mexico: "Mexico Peso",
		money_iceland: "Iceland Krona",
		money_bolivia: "Bolivian Boliviano",
		money_bulgaria: "Bulgarian Lev",
		money_egypt: "Egypt Pound",
		money_lithuania: "Lithuanian Litas",
		money_viet: "Viet Nam Dong",
		money_ukraine: "Ukraine Hryvnia",
		money_iran: "Iran Rial",
		money_hungary: "Hungary Forint",
		money_cuba: "Cuban Peso",
		money_pakistan: "Pakistan Rupee",
		money_romania: "Romanian New Leu",
		money_jamaica: "Jamaican Dollar",
		money_kazakhstan: "Kazakhstan Tenge",
		money_lebanon: "Lebanon Pound",
		money_thailand: "Thailand Baht",
		money_afghan: "Afghanistan Afghani",
		money_nigeria: "Nigeria Naira",
		money_zimbabwe: "Zimbabwe Dollar",
		money_albania: "Albania Lek",
		money_czech: "Czech Republic Koruna",
		more_functions: "More functions",
		more: "More",
		nagativeNo: "Negative numbers",
		name_repeated_with_calculate: "This name is already taken by calculate",
		negative: "Negative",
		new_reference: "Create a new reference",
		new_validation: "New validation",
		"new": "New",
		new_customer_tpl: "New customer template",
		new_cell_tpl: "New cell template",
		new_dataset_name: "New dataset name",
		new_dataset_hint: "New dataset items, input like: apple, cat, bread. Separate items by comma (,)",
		next: "Next",
		next_week: "Next week",
		next_month: "Next month",
		note: "Note",
		none: "None",
		no_formula: "No formula",
		no_fill_color: "No fill color",
		number: "Number",
		number_format: "Number format",
		number_special: "Number Special",
		number_filters: "Number filters",
		number_not_right: "The value of number is not right.",
		no_selection_replace: "Please select a target cell to replace",
		not_valid_url: "Not a valid URL",
		no_reference_name: "No references to display",
		not_contain: "Not contain",
		not_between: "Not between",
		not_equal: "Not equal",
		no_related_calcualte: "No related calculate available",
		no_match_item: "No match item found",
		no_dataset_available: "No dataset available",
		ok: "OK",
		on_before: "On or before",
		on_after: "On or after",
		only_current_range: "Only sort current range",
		options: "Options",
		open: "Open",
		open_sheet: "Open an existing sheet file",
		output: "Output",
		organize: "Organize",
		other_chart: "Other charts",
		overline: "Overline",
		other_borders: "Other borders",
		only_fill_style: "Only fill style",
		only_fill_content: "Only fill content",
		only_allow_data_in_droplist: "Only allow input data included in the drop list for the cell",
		other_condition: "Other condition",
		other_options: "Other options",
		others: "Others",
		other_accounting_format: "Other accounting format",
		paste_at: "Paste at",
		paste_number: "Paste number",
		param_not_match: "The length of parameter not the same",
		param_should_be_same: 'The length of all parameters need be the same in formula "{0}".',
		param_type_wrong: "Parameter type error",
		param_need_be_num: 'The parameter of formula "{0}" need be a number',
		param_miss: "Parameter number is wrong",
		param_number_wrong: 'The calling parameter number for formula "{0}" is not right, please click <a href="{1}" target=_BLANK>here</a> to check more details.',
		paste_copy_not_same_shape: "The paste range should be the same shape as the copy range",
		paste_number: "Paste number",
		paste_calculate: "Paste only with data or calculate",
		paste_calculate_format: "Paste with calculate and format",
		paste_style: "Only paste style",
		paste_reverse: "Reverse paste",
		paste_value: "Only paste value",
		paste_value_format: "Paste value with format",
		paste_value_style: "Paste value with style",
		paste: "Paste",
		paste_tip: "<b>Paste (CTRL+V)</b><br/>Add content on the clipboard into the sheet.",
		paint_border: "Paint border",
		pie: "Pie",
		percentage: "Percentage",
		percent: "Percent",
		permissionDeny: "Permission Deny",
		picture_link: "Picture link",
		picture_url: "Picture URL",
		picture: "Picture",
		phoneNumber: "Phone number",
		placeInDoc: "Place in this document",
		positive: "Positive",
		preview: "Preview",
		preview_img_below: 'Click "Preview" to see the picture below after you enter the picture link.',
		preview_widget_below: 'Click "Preview" to see the widget below after you enter the widget link.',
		percent_set_as: "%, set as",
		percent_format: "Percent format",
		positive_number: "Should be a positive number or 0",
		pink_fill: "Red fill",
		pure_color_fill: "Pure color fill",
		preference: "Preference",
		prev: "Prev",
		radar: "Radar",
		range: "Range",
		radio: "Radio",
		redo: "Redo",
		remove_filter: "Remove filter",
		remove: "Remove",
		remove_indent: "Remove indent",
		relative_coord: "Relative coordinate",
		regular: "Regular",
		rename: "Rename",
		refresh: "Refresh",
		right: "Right",
		really_replace_all: "Do you really want to replace all found cells?",
		reference_name_invalid: 'This reference name is invalid, no blank is allowed or something like a cell/row/column reference range, <br/>such as "A1, B100". It should start with a letter or an underscore.',
		reference_range: "Reference range",
		remove_validation: "Remove validation",
		relative: "Relative",
		replace_find: "Replace/Find",
		replace: "Replace",
		replace_all: "Replace all",
		replace_with: "Replace with",
		remove_whole_row: "Remove whole row",
		remove_whole_column: "Remove whole column",
		remove_option: "Remove option",
		red_fill_darkred_text: "Red fill with dark red text",
		red_text: "Red text",
		repeat_value: "Repeat value",
		right_side_cell_move_left: "Right side cells move left",
		result_infinity: "The calculated result is infinity",
		row_absolute: "Row absolute",
		row: "Row",
		ready: "Ready",
		row_height: "Row height",
		remote_select: "Custom dropdown list",
		ref_select: "Reference dropdown list",
		remote_select_type_hint: "Please enter URL for access dropdown list. Return data from URL should be in json format with id and value. Such as:",
		ref_select_type_hint: "Please select a range of cells which will be used as dropdown list",
		saving: "Saving",
		saving_beforeload: "Saving before load",
		save_change_before_reload: "Do you really want to reload the page before all your changes are saved.",
		save: "Save",
		save_as: "Save as",
		save_sheet_as: "Save this sheet as",
		saveBeforeExport: "Please save file first before processing export",
		scatter: "Scatter",
		science: "Science",
		search: "Search",
		series_at_row: "Series at row",
		series_at_col: "Series at column",
		set_style_for_less: "Set style for cells less than below value",
		set_style_for_greater: "Set style for cells greater than below value",
		set_style_for_equal: "Set style for cells equal below value",
		set_style_for_include: "Set style for cells include below value",
		set_style_for_between: "Set style for cells between below values",
		set_style_begin_at: "Set style for cells begin at",
		set_style_date_ocurring_at: "Set style for cells date occurring",
		set_style_max_value: "Set style for cells with top value",
		set_style_top_value: "Set style for cells with top percent",
		set_style_min_value: "Set style for cells with bottom value",
		set_style_bottom_value: "Set style for cells with bottom percent",
		set_style_above_average: "Set style for cells above average value",
		set_style_below_average: "Set style for cells below average value",
		set_style_for_cell: "Set Style for cells with below condition",
		select_file2process: "Select a file and click Open button to process",
		select_tpl2process: "Select a template sheet and click Copy button to process",
		select_filter_condition: "Select a filtering condition",
		select_range_for_mini_chart: "Select a range for sparkline chart",
		select_all: "Select all",
		select_image: "Select an image to insert",
		set_table_tpl: "Set table template for",
		shape: "Shape",
		sheet_name_invalid: 'Sheet name is invalid, there is no char of "\'"+-*/!" allowed.',
		sheet: "Sheet",
		sheetTpl: "Template Sheet",
		sheetFromTpl: "Sheet from Template",
		sheetNewTpl: "Untitled sheet template",
		sheetTplUpdateTip: "You are updating template sheet",
		sheetPublicTip: "This file have a public view link",
		sort_option: "Sort option",
		sort_asc: "Sort ascending",
		sort_desc: "Sort descending",
		split: "Split",
		strike: "Strike",
		share: "Share",
		style: "Style",
		steps: "step(s)",
		set_as: "Set as",
		show: "Show",
		selection_range: "Selection range",
		standard_colors: "Standard colors",
		setting: "Settings",
		select_from_left_list: "Select a dataset from the left list",
		setup_droplist: "Setup drop list",
		select_data_source: "Select data set",
		should_be_one_of: "One of",
		show_grid_line: "Show grid line",
		show_condition_style_of: "Show condition style of",
		sole_value: "Sole value",
		split_sheet: "Split sheet",
		start: "Start",
		series_position: "Series position",
		series: "Series",
		selection_move2: "Move selection range to",
		strong: "Strong",
		swift_sheet: "EnterpriseSheet",
		swift_page: "Sheet Page",
		symbol: "Symbol",
		sort_filter: "Sort and filter at",
		summary: "Summary",
		subject_text: "Subject text",
		supportImportFormat: "Support file format: CSV and XLSX",
		support: "Support",
		sort: "Sort",
		symbol: "Symbol",
		sum: "Sum",
		ssn: "Social Security Number",
		tabColor: "Tab color",
		tab_width: "Tab width",
		target_range_shouldbe_same_size: "The target range should be the same size",
		table: "Table",
		table_styles: "Table style",
		text_filters: "Text filters",
		text: "Text",
		text_long: "Long text",
		text_html: "HTML text",
		template: "Template",
		theme_colors: "Theme colors",
		time: "Time",
		title: "Title",
		today: "Today",
		tomorrow: "Tomorrow",
		this_week: "This week",
		this_month: "This month",
		title_x_axis: "Title on X axis",
		title_y_axis: "Title on Y axis",
		total_sheet_number: "Total sheet number",
		top_10_value: "Top 10",
		"top_10%": "Top 10%",
		top10: "Top 10",
		top: "Top",
		tool: "Tool",
		to: "to",
		type: "Type",
		undo: "Undo",
		underline: "Underline",
		underline_tip: "<b>Underline (CTRL+U)</b><br/>Underline your text.",
		uncheck_all: "Uncheck all",
		untitle_spreadsheet: "Untitled spreadsheet",
		update_date: "Update Date",
		uploadHint: '<font color="blue">Please be aware, due to technical limitations, there may be some improper formatting after importing the file.</font>',
		var_already_defined: "This variable is already defined, please change to another name.",
		validation: "Validation",
		value: "Value",
		value_invalid: "Value is invalid",
		value_of_calculate_invalid: "The value of this calculate is not a number or a text.",
		value_not_available: "The value is not available to a function or formula.",
		view: "View",
		waiting: "In process, please wait ...",
		warning_text: "Warning text",
		want2delete_dataset: "Do you really want to delete this dataset?",
		word_wrap: "Word wrap",
		whoisediting: "Click to see who is editing now",
		listofediting: "List of editing user(s)",
		yesterday: "Yesterday",
		yellow_fill_darkyellow_text: "Yellow fill with dark yellow text",
		yellow_text: "Yellow text",
		zero: "Zero",
		"7day": "In the last 7 days",
		lookup: "Lookup",
		statistical: "Statistical",
		engineering: "Engineering",
		enterpriseSheet: "EnterpriseSheet",
		string: "Text",
		logic: "Logical",
		numeric: "Mathematical",
		finicial: "Financial",
		info: "Information",
		compatibility: "Compatibility",
		processing: "Processing",
		action_on_read_only: "Can not apply this action because this sheet is read only",
		tab_name_existed: "Can not add this new tab because this sheet name is already existed",
		cannot_rename_existed_tabname: "Can not rename this tab to an existed name",
		wedgit: "Widget",
		wedgit_url: "The url of widget",
		create_wedgit: "Create widget",
		delete_wedgit: "Delete widget",
		icon_set: "Icon sets",
		"public": "Public",
		enterEmailForNotif: 'Enter email below and click "Send" button to give notification',
		privateView: 'This file is not public yet, click "Make Public" button to public it and generate a link',
		privateKeep: "Make Private",
		publicFile: "Make Public",
		publicView: "Allow anyone with the link to view (no sign-in required)",
		publicFileEditable: "Allow anyone with the link to edit (no sign-in required)",
		publicViewFile: "This file have a public link which allow anyone to view",
		other_rule: "Other rule",
		iconset_rule: "Icon set rule",
		reverse_icon_set: "Reverse Icon set",
		show_icon_only: "Show icon only",
		customize: "Customize",
		when_value_is: "When value is",
		formula: "Formula",
		and: "and",
		backend_error_occur: 'Oops, there is a backend error, these changes are not updated. Please click "Report" to report this error to us, we will fix it ASAP.',
		disconnect_with_server: "Server connect error",
		reconnect_in: "reconnect in",
		seconds: "Seconds",
		second: "Second",
		reconnect: "Reconnect",
		connectiong_sever: "Connecting server",
		report: "Report",
		submit: "Submit",
		delete_repeat_item: "Delete repeat items",
		found_repeat_value: "Found {0} repeat value<br>{1} values will be reserved.",
		can_not_only_change_part_of_array_formula: "You changes are not made, because it can not only change part cells of the array formula",
		hide_title_region: "Hide title region",
		show_title_region: "Show title region",
		image_in_cell: "Image in cell",
		scope: "Scope",
		current_document: "Current document",
		invalid_name: "Invalid name",
		invalid_name_in_cal: "There is invalid name in this formula",
		calculating: "Calculating",
		input_array_formula: "Input array formula",
		first_row_as_label: "First row as label",
		first_col_as_label: "First column as label",
		not_rectangle_range: "Can not process this action, because the chart related range is not a rectangle",
		pivot_table: "Pivot table",
		set_header_title: "Set as header title",
		insert_date_picker: "Insert date picker",
		any_integer: "Any integer",
		any_number: "Any number",
		integer_only: "Integer only",
		col_icon: "Column icon",
		column_title: "Column title",
		input_column_title: "Input column title",
		configuration: "Configuration",
		column_data_type_config: "Column data type configuration",
		pick_data_type: "Pick a column data type",
		text: "Text",
		number: "Number",
		date: "Date",
		single_select: "Single select",
		multi_options: "Multiple options",
		phone: "Phone",
		email: "Email",
		url: "URL",
		currency: "Currency",
		attachment: "Attachment",
		text_type_hint: "A piece of text, preset a default value for empty cells if needed",
		text_type_hint2: "A piece of long text",
		phone_type_hint: "A phone number, which is composed of 3 numbers or more",
		url_type_hint: "A URL, like: http://www.enterprisesheet.com",
		email_type_hint: "An email address, like: info@abc.com",
		number_type_hint: "A number, preset a default value for empty cells if needed",
		date_type_hint: "A date, check below if you want to add time field",
		input_default_value: "Input default value here",
		add_time_field: "Add time field",
		checkbox_type_hint: "A checkbox, you can only check or uncheck it",
		radio_type_hint: "A radio box",
		default_value: "Default value",
		check_uncheck_only: "You can only check or uncheck it",
		hide_title: "Hide column title",
		show_title: "Show column title",
		min_value: "Minimum value",
		max_value: "Maximum value",
		is_date: "need be a valid date",
		clean_data_type: "Clean data type",
		single_select_type_hint: "Single select list, you can select one of these options",
		multi_options_type_hint: "Multiple options, you can select more than one of these options",
		should_be_part_of: "Should be part of",
		attach_type_hint: "Attachment, you can attach file or image in the cell",
		no_attach_yet: "No attachment yet, click above button to add",
		attachment: "Attachment",
		upload_file: "Upload file",
		link_file: "Link file",
		upload_linke_attachment: "Upload or link more attachment",
		enter_password: "Enter password",
		previous: "Previous",
		download: "Download",
		show_new_tab: "Show in new tab",
		on_current_page: "On current page",
		display: "Display",
		uploading: "Uploading",
		downloading: "Downloading",
		loading_calculating: "Loading related cells and calculating",
		prev_page: "Last page",
		next_page: "Next page",
		rendering: "Rendering",
		can_not_process_action_on_disabled_cell: "Can not process this action on disabled cell",
		skip_process_action_on_disabled_cell: "Skip to perform this action on some related disabled cells",
		confirm_process_action_on_disabled_cell: 'Can not process this action on disabled cell, click "Yes" to cancel the process, or click "No" to continue but skip the disabled cell',
		change_checked: "Change checked",
		print_setting: "Print setting",
		page: "Page",
		header: "Header",
		footer: "Footer",
		margins: "Margins",
		orientation: "Orientation",
		portrait: "Portrait",
		landscape: "Landscape",
		scaling: "Scaling",
		adjust_to: "Adjust to",
		normal_size: "Normal size",
		paper_size: "Paper size",
		black_and_white: "Black&White",
		top_margin: "Top margin",
		bottom_margin: "Bottom margin",
		left_margin: "Left margin",
		right_margin: "Right margin",
		header_margin: "Header margin",
		footer_margin: "Footer margin",
		define_header: "Define header",
		define_footer: "Define footer",
		different_on_odd_even_page: "Different on odd and even page",
		different_on_first_page: "Different on the first page",
		page_1: "Page &[Page No]",
		"page_&": "Page &P",
		page_1_total_page: "Page &[Page No], total page &[Total page]",
		"page_&_total_page": "Page &P, total page &N",
		first_page_header: "Header of the first page",
		odd_page_header: "Header of the odd page",
		even_page_header: "Header of the even page",
		first_page_footer: "Footer of the first page",
		odd_page_footer: "Footer of the odd page",
		even_page_footer: "Footer of the even page",
		center: "Center",
		insert_page_no: "Insert page No",
		insert_total_page: "Insert total page",
		insert_date: "Insert date",
		page_no: "Page No",
		total_page: "Total page",
		change_saved: "The change is saved successfully",
		fail2save: "Fail to save the change",
		first_page: "First page",
		odd_page: "Odd page",
		even_page: "Even page",
		other_page: "Other page",
		print_hint: "Due to some technique reason, you can not print this document directly, please export this file as a xlsx file, and then print in MS Excel.",
		cut_move_selection: "Cut and move selection",
		change_cells: "Change cells",
		changed_by_other_user: "Changed by other user",
		remove_defined_func: "Remove defined functions",
		update_defined_func: "Update defined functions",
		create_defined_func: "Create defined functions",
		locating_mouseup_render: "Locating...(release mouse to render)",
		broken_tpl_cell_hint: "This action will break the table template cell, please remove the related table template cells first.",
		conflict_check: "Checking to avoid any conflict with the editing from other user",
		other_do_conflict_action: "is making action which could cause conflict, please wait a moment",
		your_action_conflicted: "Your action is cancelled because confliction",
		lock_edit_for_all: "Lock editing of selection for all",
		lock_edit_for_other: "Lock editing of selection for others",
		set_lock_edit: "Lock editing of selection",
		check_user_can_edit_selection: "Check user who you allow to edit the selection",
		can_edit_selection: "can edit the selection",
		hide_row_name: "Hide row name",
		show_row_name: "Show row name",
		hide_col_name: "Hide column name",
		show_col_name: "Show column name",
		name: "Name",
		permission: "Permission",
		read_only: "Read only",
		can_edit: "Can edit",
		can_share: "Can share",
		can_edit_not_del: "Can edit but not delete",
		can_edit_not_export: "Can edit but not export",
		allow: "Allow",
		no_one_allow_edit_selection: "No one is allowed to edit the selection",
		edit_selection: "to edit the selection",
		zoom: "Zoom",
		userfilecomments: "Click this to add comments",
		changes_sent2_other_editors: "Changes are sent to other editing users",
		beyond_sort_limit: "Can not sort a file over 100000 cells or over 10000 rows",
		sort_time_cost: "This sort action will take some time, please wait, don't close the browser before it's finished",
		show_hidden_tabs: "Show hidden tabs",
		wanna_show_this_tab: "This tab is hidden, do you want to show it?",
		background: "Background",
		wanna_reomve_background: "Do you really want to remove the background?",
		page_break: "Page break",
		insert_page_break: "Insert page break",
		delete_page_break: "Delete page break",
		create_filter: "Create filter",
		should_be_a_number: "Should be a number",
		should_be_a_number_or_percent: "Should be a number or a percentage",
		FORMULA_NAME_LIST: [
			["ABS", "ABS(number1)", "<b>Syntax:</b> ABS(number)<br><br>Returns the absolute value of the given number", "numeric"],
			["ACOS", "ACOS(number)", "<b>Syntax:</b> ACOS(number)<br><br>Returns the arccosine, or inverse cosine, of a number. The arccosine is the angle whose cosine is number. The returned angle is given in radians in the range 0 (zero) to pi. Number is the cosine of the angle and must be from -1 to 1.", "numeric"],
			["ACOSH", "ACOSH(number)", "<b>Syntax:</b> ACOSH(number)<br><br>Returns the inverse hyperbolic cosine of a number. Number must be greater than or equal to 1.", "numeric"],
			["ACOT", "ACOT(number)", "<b>Syntax:</b> ACOT(number)<br><br>Returns the principal value of the arccotangent, or inverse cotangent, of a number.", "numeric"],
			["AND", "AND(logical1,logical2,...)", "<b>Syntax:</b> AND(logical1, logical2, ...)<br><br>Returns TRUE if all of its arguments are TRUE", "logic"],
			["AREAS", "AREAS(reference)", "<b>Syntax:</b> AREAS(reference)<br><br>This function returns the number of ranges in a reference. Reference is a range of cells.", "lookup"],
			["ASIN", "ASIN(number)", "<b>Syntax:</b> ASIN(number)<br><br>Returns the arcsine, or inverse sine, of a number. The arcsine is the angle whose sine is number. The returned angle is given in radians in the range -pi/2 to pi/2. Number is the sine of the angle and must be from -1 to 1.", "numeric"],
			["ASINH", "ASINH(number)", "<b>Syntax:</b> ASINH(number)<br><br>Returns the inverse hyperbolic sine of a number.", "numeric"],
			["ATAN", "ATAN(number)", "<b>Syntax:</b> ATAN(number)<br><br>Returns the arctangent, or inverse tangent, of a number. The arctangent is the angle whose tangent is number. The returned angle is given in radians in the range -pi/2 to pi/2. Number is the tangent of the angle and must be from -1 to 1.", "numeric"],
			["ATAN2", "ATAN2(x_num, y_num)", "<b>Syntax:</b> ATAN2(x_num, y_num)<br><br>Returns the arctangent, or inverse tangent, of the specified x- and y-coordinates.", "numeric"],
			["ATANH", "ATANH(number)", "<b>Syntax:</b> ATANH(number)<br><br>Returns the inverse hyperbolic tangent of a number. Number must be between -1 and 1.", "numeric"],
			["AVEDEV", "AVEDEV(number1, [number2], ...)", "<b>Syntax:</b> AVEDEV(number1, [number2], ...)<br><br>Returns the average of the absolute deviations of data points from their mean.", "statistical"],
			["AVERAGE", "AVERAGE(number1, number2, ...)", "<b>Syntax:</b> AVERAGE(number1, number2, ...)<br><br>Returns the average of the arguments. Number1, number2, ... are numerical values or ranges. Text is ignored.", "statistical"],
			["AVERAGEIF", "AVERAGEIF(range, criteria, average_range)", "<b>Syntax:</b> AVERAGEIF(range, criteria, average_range)<br><br>Returns the average (arithmetic mean) of all the cells in a range that meet a given criteria.", "statistical"],
			["AVERAGEIFS", "AVERAGEIFS(average_range, criteria_range1, criteria1, [criteria_range2, criteria2, ...])", "<b>Syntax:</b> AVERAGEIFS(average_range, criteria_range1, criteria1, [criteria_range2, criteria2, ...])<br><br>Returns the average (arithmetic mean) of all cells that meet multiple criteria.", "statistical"],
			["BESSELI", "BESSELI(X, N)", "<b>Syntax:</b> BESSELI(X, N) <br><br>Returns the modified Bessel function In(x), which is equivalent to the Bessel function evaluated for purely imaginary arguments.", "engineering"],
			["BESSELJ", "BESSELJ(X, N)", "<b>Syntax:</b> BESSELJ(X, N) <br><br>Returns the Bessel function Jn(x)", "engineering"],
			["BESSELK", "BESSELK(X, N)", "<b>Syntax:</b> BESSELK(X, N) <br><br>Returns the modified Bessel function Kn(x)", "engineering"],
			["BESSELY", "BESSELY(X, N)", "<b>Syntax:</b> BESSELY(X, N) <br><br>Returns the Bessel function Yn(x)", "engineering"],
			["BIN2DEC", "BIN2DEC(number)", "<b>Syntax:</b> BIN2DEC(number1) <br><br>Converts a binary number to decimal.", "engineering"],
			["BIN2HEX", "BIN2HEX(number, [places])", "<b>Syntax:</b> BIN2HEX(number, [places]) <br><br>Converts a binary number to hexadecimal.", "engineering"],
			["BIN2OCT", "BIN2OCT(number, [places])", "<b>Syntax:</b> BIN2OCT(number, [places]) <br><br>Converts a binary number to octal.", "engineering"],
			["BINOM.DIST", "BINOM.DIST (number_s,trials,probability_s,cumulative)", "<b>Syntax:</b> BINOM.DIST (number_s,trials,probability_s,cumulative)<br><br>Returns the individual term binomial distribution probability.", "statistical"],
			["BINOMDIST", "BINOMDIST (number_s,trials,probability_s,cumulative)", "<b>Syntax:</b> BINOMDIST (number_s,trials,probability_s,cumulative)<br><br>Returns the individual term binomial distribution probability.", "compatibility"],
			["BITAND", "BITAND(number1, number2)", "<b>Syntax:</b> BITAND( number1, number2) <br><br>Returns a bitwise 'AND' of two numbers.", "engineering"],
			["BITXOR", "BITXOR(number1, number2)", "<b>Syntax:</b> BITXOR(number1, number2) <br><br>Returns a bitwise 'XOR' of two numbers.", "engineering"],
			["BITOR", "BITOR(number1, number2)", "<b>Syntax:</b> BITOR( number1, number2) <br><br>Returns a bitwise 'OR' of two numbers.", "engineering"],
			["BITRSHIFT", "BITRSHIFT(number, shift_amount)", "<b>Syntax:</b> BITRSHIFT(number, shift_amount) <br><br>Returns a number shifted right by the specified number of bits.", "engineering"],
			["BITLSHIFT", "BITLSHIFT(number, shift_amount)", "<b>Syntax:</b> BITLSHIFT(number, shift_amount) <br><br>Returns a number shifted left by the specified number of bits.", "engineering"],
			["CEILING", "CEILING(number, significance)", "<b>Syntax:</b> CEILING(number, significance)<br><br>Returns number rounded up, away from zero, to the nearest multiple of significance.", "numeric"],
			["CHAR", "CHAR(ascii_value)", "<b>Syntax:</b> CHAR(ascii_value)<br><br>CHAR function returns the character based on the ASCII value.<br><br>ascii_value is the ASCII value used to retrieve the character.", "string"],
			["CHOOSE", "CHOOSE(position, value1, value2, ...)", "<b>Syntax:</b> Choose(position, value1, value2, ...)<br><br>Choose a value from a list of values. Position is position number in the list of values to return. It must be a number between 1 and 29.", "lookup"],
			["CLEAN", "CLEAN(text)", "<b>Syntax:</b> CLEAN(text)<br><br>Removes all nonprintable characters from text.", "string"],
			["CODE", "CODE(text)", "<b>Syntax:</b> CODE(text)<br><br>Returns a numeric code for the first character in a text string.", "string"],
			["COLUMN", "COLUMN(reference)", "<b>Syntax:</b> COLUMN(reference)<br><br>Column function returns the column number of a cell reference.", "lookup"],
			["COLUMNS", "COLUMNS(reference)", "<b>Syntax:</b> COLUMNS(reference)<br><br>Columns function returns the number of columns in a cell reference.", "lookup"],
			["COMBIN", "COMBIN(number, CHOOSE)", "<b>Syntax:</b> COMBIN(number, CHOOSE)<br><br>Returns the number of combinations for a given number of items. Use COMBIN to determine the total possible number of groups for a given number of items. <br><br>Number is the number of items. <br><br>Number_chosen is the number of items in each combination.", "numeric"],
			["COMBINA", "COMBINA(number, CHOOSE)", "<b>Syntax:</b> COMBINA(number, CHOOSE)<br><br>Returns the number of combinations (with repetitions) for a given number of items.", "numeric"],
			["CONCATENATE", "CONCATENATE(arg1,arg2,...)", "<b>Syntax:</b> CONCATENATE(text1, text2, ...)<br><br>Combines several text strings into one string. Text_1, text_2, ... are text passages that are to be combined into one string.", "string"],
			["CONVERT", "CONVERT(number, from_unit, to_unit)", "<b>Syntax:</b> CONVERT(number, from_unit, to_unit)<br><br>Converts a number from one measurement system to another.", "engineering"],
			["CORREL", "CORREL(array1, array2)", "<b>Syntax:</b> CORREL(array1, array2)<br><br>Returns the correlation coefficient of the array1 and array2 cell ranges. Use the correlation coefficient to determine the relationship between two properties.", "statistical"],
			["COS", "COS(number)", "<b>Syntax:</b> COS(number)<br><br>Returns a Double specifying the cosine of an angle. Number is a Double or any valid numeric expression that expresses an angle in radians.", "numeric"],
			["COSH", "COSH(number)", "<b>Syntax:</b> COSH(number)<br><br>Returns the hyperbolic cosine of a number.", "numeric"],
			["COT", "COT(number)", "<b>Syntax:</b> COT(number)<br><br>Return the cotangent of an angle specified in radians.", "numeric"],
			["COTH", "COTH(number)", "<b>Syntax:</b> COTH(number)<br><br>Return the hyperbolic cotangent of a hyperbolic angle.", "numeric"],
			["COUNT", "COUNT(value1, [value2], ...)", "<b>Syntax:</b> COUNT(value1, value2, ...)<br><br>Counts how many numbers are in the list of arguments. Text entries are ignored. Value1, value2, ... value30 are values or ranges which are to be counted.", "statistical"],
			["COUNTA", "COUNTA(value1, [value2], ...)", "<b>Syntax:</b> COUNTA(value1, [value2], ...)<br><br>Counts the number of cells that are not empty in a range.", "statistical"],
			["COUNTIF", "COUNTIF(range,criteria)", "<b>Syntax:</b> COUNTIF(range,criteria)<br><br>Counts the number of cells within a range that meet the given criteria.<br><br>range is the range of cells that you want to count based on the criteria.<br><br>criteria is used to determine which cells to count.", "statistical"],
			["COUNTIFS", "COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2, ...])", "<b>Syntax:</b>COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2, ...])<br><br>Applies criteria to cells across multiple ranges and counts the number of times all criteria are met.", "statistical"],
			["COUNTBLANK", "COUNTBLANK(range)", "<b>Syntax:</b> COUNTBLANK(range)<br><br>Counts empty cells in a specified range of cells.", "statistical"],
			["COUPDAYS", "COUPDAYS(settlement, maturity, frequency, [basis])", "<b>Syntax:</b> COUPDAYS(settlement, maturity, frequency, [basis])<br><br>Returns the number of days in the coupon period that contains the settlement date.", "finicial"],
			["COUPNCD", "COUPNCD(settlement, maturity, frequency, [basis])", "<b>Syntax:</b> COUPNCD(settlement, maturity, frequency, [basis])<br><br>Returns a number that represents the next coupon date before the settlement date.", "finicial"],
			["COUPNUM", "COUPNUM(settlement, maturity, frequency, [basis])", "<b>Syntax:</b> COUPNUM(settlement, maturity, frequency, [basis])<br><br>Returns the number of coupons payable between the settlement date and maturity date, rounded up to the nearest whole coupon.", "finicial"],
			["COUPPCD", "COUPPCD(settlement, maturity, frequency, [basis])", "<b>Syntax:</b> COUPPCD(settlement, maturity, frequency, [basis])<br><br>Returns a number that represents the previous coupon date before the settlement date.", "finicial"],
			["CSC", "CSC(number)", "<b>Syntax:</b> CSC(number)<br><br>Returns the cosecant of an angle specified in radians.", "numeric"],
			["CSCH", "CSCH(number)", "<b>Syntax:</b> CSCH(number)<br><br>Return the hyperbolic cosecant of an angle specified in radians.", "numeric"],
			["DAY", "DAY(date_value)", "<b>Syntax:</b> DAY(date_value)<br><br>This function returns the day of the month (a number from 1 to 31) given a date value.", "date"],
			["DATE", "DATE(year, month, day)", "<b>Syntax:</b> DATE(year, month, day)<br><br>Converts a date written as year, month, day to an internal serial number and displays it in the cell's formatting. Year is an integer between 1583 and 9956 or 0 and 99. Month is an integer between 1 and 12. Day is an integer between 1 and 31.", "date"],
			["DATEVALUE", "DATEVALUE(date_text)", "<b>Syntax:</b> DATEVALUE(date_text)<br><br>Converts a date that is stored as text to a serial number that it recognizes as a date.", "date"],
			["DAYS", "DAYS(end_date, start_date)", "<b>Syntax:</b> DAYS(end_date, start_date)<br><br>This function returns the number of days between two dates.", "date"],
			["DAYS360", "DAYS360(start_date, end_date, [method])", "<b>Syntax:</b> DAYS360(start_date, end_date, [method])<br><br>This function returns the number of days between two dates based on a 360-day year. <br><br>start_date and end_date are the two dates to calculate the difference between.<br><br>method is optional. It is a boolean value - either TRUE or FALSE. If TRUE is entered, the DAYS360 function will use the US method. If FALSE is entered, the DAYS360 function will use the European method.", "date"],
			["DB", "DB(cost, salvage, life, period, [number_months])", "<b>Syntax:</b> DB(cost, salvage, life, period, [number_months])<br><br>Returns the depreciation of an asset for a given time period based on the fixed-declining balance method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset. <br><br>period is the period that you wish to calculate the depreciation for. Use the same units as for the life. <br><br>number_months is optional. It is the number of months in the first year of depreciation. If this parameter is omitted, the DB function will assume that there are 12 months in the first year.", "finicial"],
			["DDB", "DDB(cost, salvage, life, period, [factor])", "<b>Syntax:</b> DDB(cost, salvage, life, period, [factor])<br><br>Returns the depreciation of an asset for a given time period based on the fixed-declining balance method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset. <br><br>period is the period that you wish to calculate the depreciation for. Use the same units as for the life. <br><br>factor is optional. It is the rate at which the balance declines. If this parameter is omitted, the DDB function will assume the factor to be 2.", "finicial"],
			["DEC2BIN", "DEC2BIN(number, [places])", "<b>Syntax:</b> DEC2BIN(number, [places]) <br><br>Converts a decimal number to binary.", "engineering"],
			["DEC2HEX", "DEC2HEX(number, [places])", "<b>Syntax:</b> DEC2HEX(number, [places]) <br><br>Converts a decimal number to hexadecimal.", "engineering"],
			["DEC2OCT", "DEC2OCT(number, [places])", "<b>Syntax:</b> DEC2OCT(number, [places]) <br><br>Converts a decimal number to octal.", "engineering"],
			["DEGREES", "DEGREES(number)", "<b>Syntax:</b> DEGREES(number)<br><br>This function converts radians into degrees.", "numeric"],
			["DELTA", "DELTA(number1, [number2])", "<b>Syntax: DELTA(number1, [number2])</b> <br><br>Tests whether two values are equal. Returns 1 if number1 = number2; returns 0 otherwise. If omitted, number2 is assumed to be zero.", "engineering"],
			["DEVSQ", "DEVSQ(number1, [number2], ...)", "<b>Syntax: DEVSQ(number1, [number2], ...)</b> <br><br>Returns the sum of squares of deviations of data points from their sample mean.", "statistical"],
			["DOLLAR", "DOLLAR(number, [Decimals])", "<b>Syntax:</b> DOLLAR(number, [Decimals])<br><br>Convert a number to text using currency format with the decimals round to the specified place.", "string"],
			["DOLLARDE", "DOLLARDE(fractional_dollar, fraction)", "<b>Syntax:</b> DOLLARDE(fractional_dollar, fraction)<br><br>Converts a dollar price expressed as an integer part and a fraction part, such as 1.02, into a dollar price expressed as a decimal number.", "finicial"],
			["DOLLARFR", "DOLLARFR(decimal_dollar, fraction)", "<b>Syntax:</b> DOLLARFR(decimal_dollar, fraction)<br><br>Converts a dollar price expressed as a decimal number into a dollar price expressed as a fraction.", "finicial"],
			["EDATE", "EDATE(start_date, months)", "<b>Syntax:</b> EDATE(start_date, months)<br><br>Returns the serial number that represents the date that is the indicated number of months before or after a specified date (the start_date)", "date"],
			["EFFECT", "EFFECT(nominal_rate, npery)", "<b>Syntax:</b> EFFECT(nominal_rate, npery)<br><br>Returns the effective annual interest rate, given the nominal annual interest rate and the number of compounding periods per year.", "finicial"],
			["EOMONTH", "EOMONTH(start_date, months)", "<b>Syntax:</b> EOMONTH(start_date, months)<br><br>Returns the serial number for the last day of the month that is the indicated number of months before or after start_date.", "date"],
			["ERF", "ERF(lower_limit,[upper_limit])", "<b>Syntax: ERF(lower_limit,[upper_limit])</b> <br><br>Returns the error function integrated between lower_limit and upper_limit. If upper_limit omitted, ERF integrates between zero and lower_limit.", "engineering"],
			["ERFC", "ERFC(lower_limit,[upper_limit])", "<b>Syntax: ERFC(lower_limit,[upper_limit])</b> <br><br>Returns the complementary error function integrated between lower_limit and upper_limit. If upper_limit omitted, ERFC integrates between lower_limit and infinity.", "engineering"],
			["ES_CHECKED", "ES_CHECKED(cell)", "<b>Syntax: ES_CHECKED(cell)</b> <br><br>This is EnterpriseSheet defined formula. It is used to check whether this cell checkbox is checked. If checked, return true, otherwise return false. If cell is not checkbox, throw #N/A.", "enterpriseSheet"],
			["EXACT", "EXACT(text1, text2)", "<b>Syntax:</b> EXACT(text1, text2)<br><br>This function compares two strings and returns TRUE if both values are the same. And it is case-sensitive.", "string"],
			["EXP", "EXP(number)", "<b>Syntax:</b> EXP(number)<br><br>Returns a Double specifying e (the base of natural logarithms) raised to a power.", "numeric"],
			["EXPON.DIST", "EXPON.DIST(number)", "<b>Syntax:</b> EXPON.DIST(number)<br><br>Returns the exponential distribution.", "statistical"],
			["EVEN", "EVEN(number)", "<b>Syntax:</b> EVEN(number)<br><br>Returns number rounded up to the nearest even integer.", "numeric"],
			["FACT", "FACT(number)", "<b>Syntax:</b> FACT(number)<br><br>Returns the factorial of a number. The factorial of a number is equal to 1*2*3*...* number.", "numeric"],
			["FACTDOUBLE", "FACTDOUBLE(number)", "<b>Syntax:</b> FACTDOUBLE(number)<br><br>Returns the double factorial of a number.", "numeric"],
			["FALSE", "FALSE()", "<b>Syntax:</b> FALSE()<br><br>Returns the logical value FALSE", "logic"],
			["FIND", "FIND(find_text, within_text, [start_num])", "<b>Syntax:</b> FIND(find_text, within_text, [start_num])<br><br>This function returns the location of a substring in a string. The search is case-sensitive. <br><br>Find_text is the text you want to find. <br><br>Within_text is the text containing the text you want to find. <br><br>Start_num(Optional) Specifies the character at which to start the search. The first character in within_text is character number 1. If you omit start_num, it is assumed to be 1.", "string"],
			["FISHER", "FISHER(x)", "<b>Syntax:</b> FISHER(x)<br><br>Returns the Fisher transformation at x", "statistical"],
			["FISHERINV", "FISHERINV(x)", "<b>Syntax:</b> FISHERINV(x)<br><br>Returns the inverse of the Fisher transformation.", "statistical"],
			["FIXED", "FIXED(number, [decimal_places], [no_commas])", "<b>Syntax:</b> FIXED(number, [decimal_places], [no_commas])<br><br>This function returns a text representation of a number rounded to a specified number of decimal places.", "string"],
			["FLOOR", "FLOOR(number, significance)", "<b>Syntax:</b> FLOOR(number, significance)<br><br>Rounds number down, toward zero, to the nearest multiple of significance.", "numeric"],
			["FV", "FV(interest_rate, number_payments, payment, [PV], [Type])", "<b>Syntax:</b> FV(interest_rate, number_payments, payment, [PV], [Type])<br><br>This function returns the future value of an investment based on an interest rate and a constant payment schedule.<br><br>interest_rate is the interest rate for the investment.<br><br>number_payments is the number of payments for the annuity. <br><br>payment is the amount of the payment for each period. This should be entered as a negative value.<br><br>PV is optional. It is the present value of the payments.<br><br>Type is optional. It indicates when the payments are due. Type can be one of the following values: 0 - Payments are due at the end of the period. (default), 1 - Payments are due at the beginning of the period.", "finicial"],
			["GAMMA", "GAMMA(number)", "<b>Syntax:</b> GAMMA(number)<br><br>Return the gamma function value.", "statistical"],
			["GAMMALN", "GAMMALN(number)", "<b>Syntax:</b> GAMMALN(number)<br><br>Returns the natural logarithm of the gamma function.", "statistical"],
			["GCD", "GCD(arg1,arg2,...)", "<b>Syntax:</b> GCD(number1, number2, ...)<br><br>Returns the greatest common divisor of two or more integers. The greatest common divisor is the largest integer that divides both number1 and number2 without a remainder.", "numeric"],
			["GEOMEAN", "GEOMEAN(number1, [number2], ...)", "<b>Syntax:</b> GEOMEAN(number1, [number2], ...)<br><br>Returns the geometric mean of an array or range of positive data.", "statistical"],
			["HARMEAN", "HARMEAN(number1, [number2], ...)", "<b>Syntax:</b> HARMEAN(number1, [number2], ...)<br><br>Returns the harmonic mean of an array or range of positive data.", "statistical"],
			["GESTEP", "GESTEP(number, [step])", "<b>Syntax:</b> GESTEP(number, [step]) <br><br>Returns 1 if number >= step; returns 0 (zero) otherwise. Use this function to filter a set of values.", "engineering"],
			["HEX2BIN", "HEX2BIN(number, [places])", "<b>Syntax:</b> HEX2BIN(number, [places]) <br><br>Converts a hexadecimal number to binary.", "engineering"],
			["HEX2DEC", "HEX2DEC(number)", "<b>Syntax:</b> HEX2DEC(number) <br><br>Converts a hexadecimal number to decimal.", "engineering"],
			["HEX2OCT", "HEX2OCT(number, [places])", "<b>Syntax:</b> HEX2OCT(number, [places]) <br><br>Converts a hexadecimal number to octal.", "engineering"],
			["HLOOKUP", "HLOOKUP(lookup_value, tabe_array, row_index, [not_exact_match])", "<b>Syntax:</b> HLOOKUP(lookup_value, tabe_array, row_index, [not_exact_match])<br><br>Search for value in the top row of tabe_array and returns the value in the same column based on the row_index.", "lookup"],
			["HOUR", "HOUR(arg1)", "<b>Syntax:</b> Hour(serial_number)<br><br>This function returns the hour of a time value (from 0 to 23).", "date"],
			["HYPERLINK", "HYPERLINK(link_location,friendly_name)", "<b>Syntax:</b> HYPERLINK(link_location,friendly_name)<br><br>Creates a shortcut or jump that opens a document stored on a network server, an intranet, or the Internet.", "lookup"],
			["IF", "IF(test, then_value, otherwise_value)", "<b>Syntax:</b> IF(test, then_value, otherwise_value)<br><br>Returns one value if a condition evaluates to TRUE and another value if it evaluates to FALSE. <br><br>Test is any value or expression that can be TRUE or FALSE. <br><br>Then_value is the value that is returned if the logical test is TRUE. <br><br>Otherwise_value is the value that is returned if the logical test is FALSE.", "logic"],
			["IFERROR", "IFERROR(test, value)", "<b>Syntax:</b> IFERROR(test, value)<br><br>If the first argument is an error, then the second argument will be returned. If the first argument is not an error, then it will be returned.", "logic"],
			["IFNA", "IFNA(test, value)", "<b>Syntax:</b> IFNA(test, value)<br><br>If the first argument is an not available, then the second argument will be returned. Otherwise it will be returned.", "logic"],
			["IMABS", "IMABS(inumber)", "<b>Syntax:</b> IMABS(inumber)<br><br>Returns the absolute value (modulus) of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the absolute value.", "engineering"],
			["IMAGINARY", "IMAGINARY(inumber)", "<b>Syntax:</b> IMAGINARY(inumber)<br><br>Returns the imaginary coefficient of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the imaginary coefficient.", "engineering"],
			["IMARGUMENT", "IMARGUMENT(inumber)", "<b>Syntax:</b> IMARGUMENT(inumber)<br><br>Returns the argument Theta (theta), an angle expressed in radians. <br/><br/>Inumber is a complex number for which you want the argument Theta.", "engineering"],
			["IMCOS", "IMCOS(inumber)", "<b>Syntax:</b> IMCOS(inumber)<br><br>Returns the cosine of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the cosine.", "engineering"],
			["IMCOSH", "IMCOSH(inumber)", "<b>Syntax:</b> IMCOSH(inumber)<br><br>Returns the hyperbolic cosine of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the hyperbolic cosine.", "engineering"],
			["IMCOT", "IMCOT(inumber)", "<b>Syntax:</b> IMCOT(inumber)<br><br>Returns the cotangent of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the cotangent.", "engineering"],
			["IMCSC", "IMCSC(inumber)", "<b>Syntax:</b> IMCSC(inumber)<br><br>Returns the cosecant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the cosecant.", "engineering"],
			["IMCSCH", "IMCSCH(inumber)", "<b>Syntax:</b> IMCSCH(inumber)<br><br>Returns the hyperbolic cosecant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the hyperbolic cosecant.", "engineering"],
			["IMCONJUGATE", "IMCONJUGATE(inumber)", "<b>Syntax:</b> IMCONJUGATE(inumber)<br><br>Returns the complex conjugate of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the conjugate.", "engineering"],
			["IMDIV", "IMDIV(inumber1, inumber2)", "<b>Syntax:</b> IMDIV(inumber1, inumber2)<br><br>Returns the quotient of two complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1 is the complex numerator or dividend. Inumber2 is the complex denominator or divisor.", "engineering"],
			["IMEXP", "IMEXP(inumber)", "<b>Syntax:</b> IMEXP(inumber)<br><br>Returns the exponential of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the exponential.", "engineering"],
			["IMLN", "IMLN(inumber)", "<b>Syntax:</b> IMLN(inumber)<br><br>Returns the natural logarithm of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the natural logarithm.", "engineering"],
			["IMLOG2", "IMLOG2(inumber)", "<b>Syntax:</b> IMLOG2(inumber)<br><br>Returns the base-2 logarithm of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the base-2 logarithm.", "engineering"],
			["IMLOG10", "IMLOG10(inumber)", "<b>Syntax:</b> IMLOG10(inumber)<br><br>Returns the common logarithm (base 10) of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the common logarithm.", "engineering"],
			["IMPOWER", "IMPOWER(inumber, number)", "<b>Syntax:</b> IMPOWER(inumber, number)<br><br>Returns a complex number in x + yi or x + yj text format raised to a power. <br/><br/>Inumber is a complex number for which you want to raise to a power. Number is the power to which you want to raise the complex number.", "engineering"],
			["IMPRODUCT", "IMPRODUCT(inumber1,inumber2...)", "<b>Syntax:</b> IMPRODUCT(inumber1,inumber2...)<br><br>Returns the product of 2 to 29 complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1,inumber2,... are 1 to 29 complex numbers to multiply.", "engineering"],
			["IMREAL", "IMREAL(inumber)", "<b>Syntax:</b> IMREAL(inumber)<br><br>Returns the real coefficient of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the real coefficient.", "engineering"],
			["IMSEC", "IMSEC(inumber)", "<b>Syntax:</b> IMSEC(inumber)<br><br>Returns the secant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the secant.", "engineering"],
			["IMSECH", "IMSECH(inumber)", "<b>Syntax:</b> IMSECH(inumber)<br><br>Returns the hyperbolic secant of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you hyperbolic secant.", "engineering"],
			["IMSIN", "IMSIN(inumber)", "<b>Syntax:</b> IMSIN(inumber)<br><br>Returns the sine of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the sine.", "engineering"],
			["IMSINH", "IMSINH(inumber)", "<b>Syntax:</b> IMSINH(inumber)<br><br>Returns the hyperbolic sine of a complex number in x+yi or x+yj text format. <br/><br/>Inumber is a complex number for which you want the hyperbolic sine.", "engineering"],
			["IMSQRT", "IMSQRT(inumber)", "<b>Syntax:</b> IMSQRT(inumber1)<br><br>Returns the square root of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the square root.", "engineering"],
			["IMSUM", "IMSUM(inumber1,inumber2...)", "<b>Syntax:</b> IMSUM(inumber1,inumber2...)<br><br>Returns the sum of two or more complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1,inumber2,... are 1 to 29 complex numbers to add.", "engineering"],
			["IMSUB", "IMSUB(inumber1,inumber2)", "<b>Syntax:</b> IMSUB(inumber1,inumber2)<br><br>Returns the difference of two complex numbers in x + yi or x + yj text format. <br/><br/>Inumber1,inumber2, the complex number from which to subtract.", "engineering"],
			["IMTAN", "IMTAN(inumber)", "<b>Syntax:</b> IMTAN(inumber)<br><br>Returns the tangent of a complex number in x + yi or x + yj text format. <br/><br/>Inumber is a complex number for which you want the tangent.", "engineering"],
			["INDEX", "INDEX(array, row_num, column_num)", "<b>Syntax:</b> INDEX(reference, row, column)<br><br>This function returns either the value or the reference to a value from a table or range.<br><br>array is a range of cells or table.<br><br>row is the row number in the array to use to return the value.<br><br>column is optional. It is the column number in the array to use to return the value.", "lookup"],
			["INDIRECT", "INDIRECT(string)", "<b>Syntax:</b> INDIRECT(string)<br><br>translate the passed string to a range reference", "info"],
			["INT", "INT(arg1)", "<b>Syntax:</b> INT(number)<br><br>Rounds a number down to the nearest integer", "numeric"],
			["IPMT", "IPMT(interest_rate, period, number_payments, PV, [FV], [Type])", "<b>Syntax:</b> IPMT(interest_rate, period, number_payments, PV, [FV], [type])<br><br>Returns the interest payment for an investment based on an interest rate and a constant payment schedule. <br><br>period is the period to calculate the interest rate. It must be a value between 1 and number_payments. <br><br>interest_rate is the interest rate for the loan. <br><br>number_payments is the number of payments for the loan. <br><br>PV is the present value or principal of the loan. <br><br>FV is optional. It is the future value or the loan amount outstanding after all payments have been made. If this parameter is omitted, the PMT function assumes a FV value of 0. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.", "finicial"],
			["IRR", "IRR(range, [estimated_irr])", "<b>Syntax:</b> IRR(range, [estimated_irr])<br><br>This function returns the internal rate of return for a series of cash flows represented by the numbers in values. The cash flows must occur at regular intervals, but do not have to be the same amounts for each interval. <br><br>range is a range of cells that represent the series of cash flows. <br><br>estimated_irr is optional. It is the your guess at the internal rate of return.", "finicial"],
			["ISBLANK", "ISBLANK(value)", "<b>Syntax:</b> ISBLANK(value)<br><br>This function is used to check for blank or null values.", "info"],
			["ISERROR", "ISERROR(value)", "<b>Syntax:</b> ISERROR(value)<br><br>Returns TRUE if value is an error value (#N/A, #VALUE!, #REF!, #DIV/0!, #NUM!, #NAME? or #NULL).", "info"],
			["ISERR", "ISERR(value)", "<b>Syntax:</b> ISERR(value)<br><br>Returns TRUE if value is an error value (except #N/A).", "info"],
			["ISEVEN", "ISEVEN(number)", "<b>Syntax:</b> ISEVEN(number)<br><br>Returns TRUE if number is even, or FALSE if number is odd.", "info"],
			["ISLOGICAL", "ISLOGICAL(value)", "<b>Syntax:</b> ISLOGICAL(value)<br><br>This function is used to check for a logical value (ie: TRUE or FALSE).", "info"],
			["ISNA", "ISNA(value)", "<b>Syntax:</b> ISNA(value)<br><br>Returns TRUE if value is not available.", "info"],
			["ISNUMBER", "ISNUMBER(value)", "<b>Syntax:</b> ISNUMBER(value)<br><br>Returns TRUE if value is number, or FALSE if value is not number.", "info"],
			["ISODD", "ISODD(number)", "<b>Syntax:</b> ISODD(number)<br><br>Returns TRUE if number is odd, or FALSE if number is even.", "info"],
			["ISOWEEKNUM", "ISOWEEKNUM(date)", "<b>Syntax:</b> ISOWEEKNUM(date)<br><br>Returns number of the ISO week number of the year for a given date.", "date"],
			["ISTEXT", "ISTEXT(value)", "<b>Syntax:</b> ISTEXT(value)<br><br>Returns TRUE if value is a text value, or FALSE if value is not a text value.", "info"],
			["LARGE", "LARGE(array, nth_position)", "<b>Syntax:</b> LARGE(array, nth_position)<br><br> Returns the nth largest value from a set of values.", "statistical"],
			["LCM", "LCM(number1, number2, ...)", "<b>Syntax:</b> LCM(number1, number2, ...)<br><br>Calculate the Least Common Multiple, which is the smallest number that can be divided by each of the given numbers", "numeric"],
			["LEFT", "LEFT(text, number)", "<b>Syntax:</b> LEFT(text, number)<br><br>Returns the first character or characters in a text string. Text is the text where the initial partial words are to be determined. Number (optional) is the number of characters for the start text. If this parameter is not defined, one character is returned.", "string"],
			["LEN", "LEN(text)", "<b>Syntax:</b> LEN(text)<br><br>Len function returns the length of the specified string.", "string"],
			["LN", "LN(number)", "<b>Syntax:</b> LN(number)<br><br>Returns the natural logarithm of a number. Natural logarithms are based on the constant e (2.71828182845904).", "numeric"],
			["LOG", "LOG(number, [base])", "<b>Syntax:</b> LOG(number, [base])<br><br>Returns the logarithm of a number to the base you specify.", "numeric"],
			["LOG10", "LOG10(number)", "<b>Syntax:</b> LOG10(number)<br><br>Returns the base-10 logarithm of a number.", "numeric"],
			["LOOKUP", "LOOKUP(lookup_value,  lookup_vector,  [result_vector])", "<b>Syntax:</b> LOOKUP(lookup_value,  lookup_vector,  [result_vector])<br><br>The LOOKUP function returns a value either from a one-row or one-column range or from an array. The LOOKUP function has two syntax forms: the vector form and the array form.", "lookup"],
			["LOWER", "LOWER(text)", "<b>Syntax:</b>  LOWER(text)<br><br>This function converts all letters in the specified string to lowercase. If there are characters in the string that are not letters, they are unaffected by this function.", "string"],
			["MATCH", "MATCH(lookup_value, lookup_array, [match_type])", "<b>Syntax:</b> MATCH(lookup_value, lookup_array, [match_type])<br><br>Search for a specified item in a range of cells, and then returns the relative position of that item in the range. The match_type can be 1 (default), 0, -1.", "lookup"],
			["MAX", "MAX(number1, number2, ...)", "<b>Syntax:</b> MAX(number1, number2, ...)<br><br>Returns the maximum value in a list of arguments. Ignores logic values and text.", "statistical"],
			["MEDIAN", "MEDIAN(number1, number2, ...)", "<b>Syntax:</b> MEDIAN(number1, number2, ...)<br><br>Median function returns the median of the numbers provided.", "statistical"],
			["MID", "MID(arg1,arg2,arg3)", "<b>Syntax:</b> MID(text, start_position, number_of_characters)<br><br>This function extracts a substring from a string (starting at any position)", "string"],
			["MIN", "MIN(number1, number2, ...)", "<b>Syntax:</b> MIN(number1, number2, ...)<br><br>Returns the minimum value in a list of arguments. Ignores logic values and text.", "statistical"],
			["MINUTE", "MINUTE(arg1)", "<b>Syntax:</b> MINUTE(serial_number)<br><br>This function returns the minute of a time value (from 0 to 59).", "date"],
			["MIRR", "MIRR(range, finance_rate, reinvestment_rate)", "<b>Syntax:</b> MIRR(range, finance_rate, reinvestment_rate)<br><br>This function returns the modified internal rate of return for a series of cash flows. The internal rate of return is calculated by using both the cost of the investment and the interest received by reinvesting the cash. <br><br>range is a range of cells that represent the series of cash flows. <br><br>finance_rate is the interest rate that you pay on the cash flow amounts. <br><br>reinvestment_rate is the interest rate that you receive on the cash flow amounts as they are reinvested.", "finicial"],
			["MOD", "MOD(number,divisor)", "<b>Syntax:</b> MOD(number,divisor)<br><br>Mode returns the remainder after number is divided by divisor. The result has the same sign as divisor.", "numeric"],
			["MODE", "MODE(number1, number2, ...)", "<b>Syntax:</b> MODE(number1, number2, ...)<br><br>Mode return the most frequently occurring value in a list of numbers.", "statistical"],
			["MODE.SNGL", "MODE.SNGL(number1, number2, ...)", "<b>Syntax:</b> MODE.SNGL(number1, number2, ...)<br><br>Mode return the most frequently occurring value in a list of numbers.", "statistical"],
			["MONTH", "MONTH(date_value)", "<b>Syntax:</b> MONTH(date_value)<br><br>This function returns the month (a number from 1 to 12) given a date value.", "date"],
			["MROUND", "MROUND(number,multiple)", "<b>Syntax:</b> MROUND(number,multiple)<br><br>Returns a number rounded to the desired multiple.<br/><br/>Number is the value to round. <br/><br/>Multiple is the multiple to which you want to round number.", "numeric"],
			["N", "N(value)", "<b>Syntax:</b> N(value)<br><br>This function converts a value to a number. <br><br>If value is a date, the N function returns the date as a serial number.<br><br>If value is boolean - true/false, the N function returns 1/0.", "info"],
			["NA", "NA()", "<b>Syntax:</b> NA()<br><br>This function returns the error value #N/A.", "info"],
			["NETWORKDAYS", "NETWORKDAYS(start_date,end_date,[holidays])", "<b>Syntax:</b> NETWORKDAYS(start_date,end_date,[holidays])<br><br>This function returns the number of whole working days between start_date and end_date. Working days exclude weekends and any dates identified in holidays.", "date"],
			["NETWORKDAYS.INTL", "NETWORKDAYS.INTL(start_date,end_date,[weekend],[holidays])", "<b>Syntax:</b> NETWORKDAYS.INTL(start_date,end_date,[weekend],[holidays])<br><br>This function returns the number of whole working days between start_date and end_date. Working days exclude weekends and any dates identified in holidays.", "date"],
			["NORMSDIST", "NORMSDIST(z)", "<b>Syntax:</b> NORMSDIST(z)<br><br>Returns the standard normal cumulative distribution function. The distribution has a mean of 0 (zero) and a standard deviation of one. Use this function in place of a table of standard normal curve areas.", "compatibility"],
			["NOT", "NOT(arg1)", "<b>Syntax:</b> NOT(logical)<br><br>Reverses the logic of its argument", "logic"],
			["NOW", "NOW()", "<b>Syntax:</b> NOW()<br><br>Returns the current computer system date time. NOW is a function without arguments.", "date"],
			["NPER", "NPER(interest_rate, payment, PV, [FV], [Type])", "<b>Syntax:</b> NPER(interest_rate, payment, PV, [FV], [Type])<br><br>This function returns the number of periods for an investment based on an interest rate and a constant payment schedule.<br><br>interest_rate is the interest rate for the investment.<br><br>payment is the amount of the payment for each period. This should be entered as a negative value.<br><br>PV is the present value of the payments.<br><br>FV is optional. It is the future value that you'd like the investment to be after all payments have been made. If this parameter is omitted, the NPER function will assume a FV of 0. <br><br>Type is optional. It indicates when the payments are due. Type can be one of the following values: 0 - Payments are due at the end of the period. (default), 1 - Payments are due at the beginning of the period.", "finicial"],
			["NPV", "NPV(discount_rate, value1, value2, ... value_n )", "<b>Syntax:</b> NPV(discount_rate, value1, value2, ... value_n)<br><br>This function returns the net present value of an investment.<br><br>discount_rate is the discount rate for the period.<br><br>value1, value2, ... value_n are the future payments and income for the investment (ie: cash flows).", "finicial"],
			["OCT2BIN", "OCT2BIN(number, [places])", "<b>Syntax:</b> OCT2BIN(number, [places]) <br><br>Converts an Octal (Base 8) number into a Binary (Base 2) number.", "engineering"],
			["OCT2DEC", "OCT2DEC(number)", "<b>Syntax:</b> OCT2DEC(number) <br><br>Converts an octal number to decimal.", "engineering"],
			["OCT2HEX", "OCT2HEX(number, [places])", "<b>Syntax:</b> OCT2HEX(number, [places]) <br><br>Converts an octal number to hexadecimal.", "engineering"],
			["ODD", "ODD(number)", "<b>Syntax:</b> ODD(number)<br><br>Returns number rounded up to the nearest odd integer.", "numeric"],
			["OFFSET", "OFFSET(reference, rows, cols, [height], [width])", "<b>Syntax:</b> OFFSET(reference, rows, cols, [height], [width])<br><br>Returns a reference to a range that is a specified number of rows and columns from a cell or range of cells. The reference that is returned can be a single cell or a range of cells. You can specify the number of rows and the number of columns to be returned.", "lookup"],
			["OR", "OR(arg1,arg2,...)", "<b>Syntax:</b> OR(logical1, logical2, ...)<br><br>Returns TRUE if any argument is TRUE", "logic"],
			["PERCENTILE.INC", "PERCENTILE.INC(array,k)", "<b>Syntax:</b> PERCENTILE.INC(array,k)<br><br>Returns the k-th percentile of values in a range, where k is in the range 0..1, inclusive.", "statistical"],
			["PERCENTILE.EXC", "PERCENTILE.EXC(array,k)", "<b>Syntax:</b> PERCENTILE.EXC(array,k)<br><br>Returns the k-th percentile of values in a range, where k is in the range 0..1, exclusive.", "statistical"],
			["PEARSON", "PEARSON(array1, array2)", "<b>Syntax:</b> PEARSON(array1, array2)<br><br>Returns the Pearson product moment correlation coefficient, r, a dimensionless index that ranges from -1.0 to 1.0 inclusive and reflects the extent of a linear relationship between two data sets.", "statistical"],
			["PI", "PI()", "<b>Syntax:</b> PI()<br><br>Returns the value of Pi, 3.14159265358979.", "numeric"],
			["PMT", "PMT(interest_rate, number_payments, PV, [FV], [type])", "<b>Syntax:</b> PMT(interest_rate, number_payments, PV, [FV], [type])<br><br>Returns the payment amount for a loan based on an interest rate and a constant payment schedule. <br><br>interest_rate is the interest rate for the loan. <br><br>number_payments is the number of payments for the loan. <br><br>PV is the present value or principal of the loan. <br><br>FV is optional. It is the future value or the loan amount outstanding after all payments have been made. If this parameter is omitted, the PMT function assumes a FV value of 0. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.", "finicial"],
			["PPMT", "PPMT(interest_rate, period, number_payments, PV, [FV], [type])", "<b>Syntax:</b> PPMT(interest_rate, period, number_payments, PV, [FV], [type])<br><br>Returns the payment on the principal for a particular payment based on an interest rate and a constant payment schedule. <br><br>interest_rate is the interest rate for the loan. <br><br>period is the period used to determine how much principal has been repaid. Period must be a value between 1 and number_payments. <br><br>number_payments is the number of payments for the loan. <br><br>PV is the present value or principal of the loan. <br><br>FV is optional. It is the future value or the loan amount outstanding after all payments have been made. If this parameter is omitted, the PPMT function assumes a FV value of 0. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.", "finicial"],
			["POWER", "POWER(base,power)", "<b>Syntax:</b> POWER(base, power)<br><br>Returns the result of a number raised to a power. Base is the number that is to be raised to the given power. Power is the exponent by which the base is to be raised.", "numeric"],
			["PRODUCT", "PRODUCT(number1, number2, ...)", "<b>Syntax:</b> PRODUCT(number1, number2, ...)<br><br>Multiplies its arguments", "numeric"],
			["PROPER", "PROPER(text)", "<b>Syntax:</b> PROPER(text)<br><br>This function sets the first character in each word to uppercase and the rest to lowercase. If there are characters in the string that are not letters, they are unaffected by this function.", "string"],
			["PV", "PV(interest_rate, number_payments, payment, [FV], [Type])", "<b>Syntax:</b> PV(interest_rate, number_payments, payment, [FV], [Type])<br><br>This function returns the present value of an investment based on an interest rate and a constant payment schedule. <br><br>interest_rate is the interest rate for the investment. <br><br>number_payments is the number of payments for the annuity. <br><br>payment is the amount of the payment made each period. <br><br>FV (optional) is the desired value (future value) to be reached at the end of the periodic payments. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period.", "finicial"],
			["QUARTILE.INC", "QUARTILE.INC(array,quart)", "<b>Syntax:</b> QUARTILE.INC(array,quart)<br><br>Returns the quartile of a data set, based on percentile values from 0..1, inclusive.", "statistical"],
			["QUARTILE.EXC", "QUARTILE.EXC(array,quart)", "<b>Syntax:</b> QUARTILE.EXC(array,quart)<br><br>Returns the quartile of a data set, based on percentile values from 0..1, exclusive.", "statistical"],
			["QUOTIENT", "QUOTIENT(numerator,denominator)", "<b>Syntax:</b> QUOTIENT(numerator,denominator)<br><br>Returns the integer portion of a division. Use this function when you want to discard the remainder of a division.", "numeric"],
			["RATE", "RATE(NPER, PMT, PV, [FV], [type], [guess])", "<b>Syntax:</b> RATE(NPER, PMT, PV, [FV], [type], [guess])<br><br>Returns the constant interest rate per period of an annuity. <br><br>NPER is the total number of periods, during which payments are made (payment period). <br><br>PMT is the constant payment (annuity) paid during each period. <br><br>PV is the cash value in the sequence of payments. <br><br>FV (optional) is the future value, which is reached at the end of the periodic payments. <br><br>Type (optional) defines whether the payment is due at the beginning (1) or the end (0) of a period. <br><br>Guess (optional) determines the estimated value of the interest with iterative calculation.", "finicial"],
			["RAND", "RAND()", "<b>Syntax:</b> RAND()<br><br>Returns a random number between 0 and 1.", "numeric"],
			["RADIANS", "RADIANS(angle)", "<b>Syntax:</b> RADIANS(angle)<br><br>Converts degrees to radians.", "numeric"],
			["RANDBETWEEN", "RANDBETWEEN(bottom,top)", "<b>Syntax:</b> RANDBETWEEN(bottom,top)<br><br>Returns a random number between the numbers you specify.", "numeric"],
			["RANK", "RANK(number,ref,[order])", "<b>Syntax:</b> RANK(number,ref, [order])<br><br>Returns the rank of a number in a list of numbers. The rank of a number is its size relative to other values in a list.", "compatibility"],
			["RANK.AVG", "RANK.AVG(number,ref,[order])", "<b>Syntax:</b> RANK.AVG(number,ref, [order])<br><br>Returns the rank of a number in a list of numbers: its size relative to other values in the list; if more than one value has the same rank, the average rank is returned.", "statistical"],
			["RANK.EQ", "RANK.EQ(number,ref,[order])", "<b>Syntax:</b> RANK.EQ(number,ref, [order])<br><br>Returns the rank of a number in a list of numbers. The rank of a number is its size relative to other values in a list.", "statistical"],
			["REPLACE", "REPLACE(text, start, number_of_chars, new_text)", "<b>Syntax:</b> REPLACE(text, start, number_of_chars, new_text)<br><br>This function replaces a sequence of characters in a string with another set of characters.", "string"],
			["REPT", "REPT(text, number)", "<b>Syntax:</b> REPT(text, number)<br><br>Repeats a character string by the given number of copies.", "string"],
			["RIGHT", "RIGHT(text, number)", "<b>Syntax:</b> RIGHT(text, number)<br><br>Defines the last character or characters in a text string. Text is the text of which the right part is to be determined. Number (optional) is the number of characters from the right part of the text.", "string"],
			["ROUND", "ROUND(number, count)", "<b>Syntax:</b> ROUND(number, count)<br><br>Rounds the given number to a certain number of decimal places according to valid mathematical criteria. Count (optional) is the number of the places to which the value is to be rounded. If the count parameter is negative, only the whole number portion is rounded. It is rounded to the place indicated by the count.", "numeric"],
			["ROUNDDOWN", "ROUNDDOWN(number, count)", "<b>Syntax:</b> ROUNDDOWN(number, count)<br><br>Rounds the given number to a certain number of decimal places according to valid mathematical criteria (toward zero). Count is the number of the places to which the value is to be rounded. ", "numeric"],
			["ROUNDUP", "ROUNDUP(number, count)", "<b>Syntax:</b> ROUNDUP(number, count)<br><br>Rounds the given number to a certain number of decimal places according to valid mathematical criteria (away zero). Count is the number of the places to which the value is to be rounded.", "numeric"],
			["ROW", "ROW(reference)", "<b>Syntax:</b> ROW(reference)<br><br>Row function returns the row number of a cell reference.", "lookup"],
			["ROWS", "ROWS(reference)", "<b>Syntax:</b> ROWS(reference)<br><br>Rows function returns the number of rows in a cell reference.", "lookup"],
			["RSQ", "RSQ(known_y's, known_x's)", "<b>Syntax:</b> RSQ(known_y's, known_x's)<br><br>Returns the square of the Pearson product moment correlation coefficient through data points in known_y's and known_x's.", "statistical"],
			["SEC", "SEC(number)", "<b>Syntax:</b> SEC(number)<br><br>Returns the secant of an angle. Number is a Double or any valid numeric expression that expresses an angle in radians.", "numeric"],
			["SECH", "SECH(number)", "<b>Syntax:</b> SECH(number)<br><br>Returns the hyperbolic secant of an angle.", "numeric"],
			["SECOND", "SECOND(number)", "<b>Syntax:</b>  SECOND(serial_number)<br><br>This function returns the second of a time value (from 0 to 59).", "date"],
			["SIGN", "SIGN(number)", "<b>Syntax:</b> SIGN(number)<br><br>Returns 1 if the number is positive, zero (0) if the number is 0, and -1 if the number is negative.", "numeric"],
			["SIN", "SIN(number)", "<b>Syntax:</b> SIN(number)<br><br>Returns a Double specifying the sine of an angle. Number is a Double or any valid numeric expression that expresses an angle in radians.", "numeric"],
			["SINH", "SINH(number)", "<b>Syntax:</b> SINH(number)<br><br>Returns the hyperbolic sine of a number.", "numeric"],
			["SLN", "SLN(cost, salvage, life)", "<b>Syntax:</b> SLN(cost, salvage, life)<br><br>This function returns the depreciation of an asset for a period based on the straight-line depreciation method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset.", "finicial"],
			["SLOPE", "SLOPE(known_y's, known_x's)", "<b>Syntax:</b> SLOPE(known_y's, known_x's)<br><br>Returns the slope of the linear regression line through data points in known_y's and known_x's. The slope is the vertical distance divided by the horizontal distance between any two points on the line, which is the rate of change along the regression line.", "statistical"],
			["SMALL", "SMALL(array, nth_position)", "<b>Syntax:</b> SMALL(array, nth_position)<br><br> Returns the nth smallest value from a set of values.", "statistical"],
			["SQRT", "SQRT(number)", "<b>Syntax:</b> SQRT(number)<br><br>Returns a positive square root", "numeric"],
			["SQRTPI", "SQRTPI(number)", "<b>Syntax:</b> SQRTPI(number)<br><br>Returns a positive square root of (number * pi).", "numeric"],
			["STDEV", "STDEV(number1,[number2],...])", "<b>Syntax:</b> STDEV(number1,[number2],...])<br><br>Estimates standard deviation based on a sample. The standard deviation is a measure of how widely values are dispersed from the average value (the mean).", "compatibility"],
			["STDEVP", "STDEVP(number1,[number2],...])", "<b>Syntax:</b> STDEVP(number1,[number2],...])<br><br>Calculates standard deviation based on the entire population given as arguments (ignores logical values and text).", "compatibility"],
			["STDEV.S", "STDEV.S(number1,[number2],...])", "<b>Syntax:</b> STDEV.S(number1,[number2],...])<br><br>Estimates standard deviation based on a sample. The standard deviation is a measure of how widely values are dispersed from the average value (the mean).", "statistical"],
			["STDEV.P", "STDEV.P(number1,[number2],...])", "<b>Syntax:</b> STDEV.P(number1,[number2],...])<br><br>Calculates standard deviation based on the entire population given as arguments (ignores logical values and text).", "statistical"],
			["STEYX", "STEYX(known_y's, known_x's)", "<b>Syntax:</b> STEYX(known_y's, known_x's)<br><br>Returns the standard error of the predicted y-value for each x in the regression. The standard error is a measure of the amount of error in the prediction of y for an individual x.", "statistical"],
			["SUBSTITUTE", "SUBSTITUTE(text, old_text, new_text, [nth_appearance])", "<b>Syntax:</b> SUBSTITUTE(text, old_text, new_text, [nth_appearance])<br><br>This function replaces a set of characters with another. Use SUBSTITUTE when you want to replace specific text in a text string.", "string"],
			["SUBTOTAL", "SUBTOTAL(function_num, ref1, ref2, ...)", "<b>Syntax:</b> SUBTOTAL(function_num, ref1, ref2, ...)<br><br>Returns a subtotal in a list or database. <BR/><BR/>Function_num is the number 1 to 11 (includes hidden values) that specifies which function to use in calculating subtotals within a list.", "numeric"],
			["SUM", "SUM(number1, number2, ...)", "<b>Syntax:</b> SUM(number1, number2, ...)<br><br>Returns the sum of corresponding array numbers", "numeric"],
			["SUMIF", "SUMIF(range, criteria, [sum_range])", "<b>Syntax:</b> SUMIF(range, criteria, [sum_range])<br><br>Adds all numbers in a range of cells, based on a given criteria. Range is the range of cells that you want to apply the criteria against. Criteria is used to determine which cells to add. Sum_range are the cells to sum.", "numeric"],
			["SUMIFS", "SUMIFS(range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)", "<b>Syntax:</b> SUMIFS(range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)<br><br>Adds the cells in a range that meet multiple criteria.", "numeric"],
			["SUMPRODUCT", "SUMPRODUCT(array1,array2, ...)", "<b>Syntax:</b> SUMPRODUCT(array1, array2, ...)<br><br>Returns the sum of the products of corresponding array components", "numeric"],
			["SUMSQ", "SUMSQ(number1, number2, ...)", "<b>Syntax:</b> SUMSQ(number1, number2, ...)<br><br>Calculates the sum of the squares of numbers.", "numeric"],
			["SUMXMY2", "SUMXMY2(array1, array2)", "<b>Syntax:</b> SUMXMY2(array1, array2)<br><br>This function calculates the sum of the squares of the differences between values in two arrays and returns the sum of the results. <br><br>array1 and array2 are two ranges or arrays.", "numeric"],
			["SUMX2PY2", "SUMX2PY2(array1, array2)", "<b>Syntax:</b> SUMX2PY2(array1, array2)<br><br>This function calculates the sum of the squares of corresponding values in two arrays and returns the sum of the results. <br><br>array1 and array2 are two ranges or arrays.", "numeric"],
			["SUMX2MY2", "SUMX2MY2(array1, array2)", "<b>Syntax:</b> SUMX2MY2(array1, array2)<br><br>This function calculates the difference of squares of corresponding values in two arrays and returns the sum of the results. <br><br>array1 and array2 are two ranges or arrays.", "numeric"],
			["SYD", "SYD(cost, salvage, life, period)", "<b>Syntax:</b> SYD(cost, salvage, life, period)<br><br>This function returns the depreciation of an asset for a given time period based on the sum-of-years digits depreciation method. <br><br>cost is the original cost of the asset. <br><br>salvage is the salvage value after the asset has been fully depreciated. <br><br>life is the useful life of the asset or the number of periods that you will be depreciating the asset. <br><br>period is the period that you wish to calculate the depreciation for. Use the same units as for the life.", "finicial"],
			["TAN", "TAN(number)", "<b>Syntax:</b> TAN(number)<br><br>Returns a Double specifying the tangent of an angle. The required number is a Double or any valid numeric expression that expresses an angle in radians.", "numeric"],
			["TANH", "TANH(number)", "<b>Syntax:</b> TANH(number)<br><br>Returns the hyperbolic tangent of a number.", "numeric"],
			["TEXT", "TEXT(value, format)", "<b>Syntax:</b> TEXT(value, format)<br><br>Text function returns a value converted to text with a specified format.", "string"],
			["TIME", "TIME(hour, minute, second)", "<b>Syntax:</b> TIME(hour, minute, second)<br><br>This function returns the decimal number for a particular time.", "date"],
			["TIMEVALUE", "TIMEVALUE(date_text)", "<b>Syntax:</b> TIMEVALUE(date_text)<br><br>Returns the decimal number of the time represented by a text string. The decimal number is a value ranging from 0 (zero) to 0.99988426, representing the times from 0:00:00 (12:00:00 AM) to 23:59:59 (11:59:59 P.M.).", "date"],
			["TODAY", "TODAY()", "<b>Syntax:</b> TODAY()<br><br>Returns the current computer system date. TODAY is a function without arguments.", "date"],
			["TRIM", "TRIM(text)", "<b>Syntax:</b> TRIM(text)<br><br>Returns a text value with the leading and trailing spaces removed.", "string"],
			["TRUE", "TRUE()", "<b>Syntax:</b> TRUE()<br><br>Returns the logical value TRUE", "logic"],
			["TRUNC", "TRUNC(number)", "<b>Syntax:</b> TRUNC(number)<br><br>Truncates a number to an integer", "numeric"],
			["TYPE", "TYPE(value)", "<b>Syntax:</b> TYPE(value)<br><br>Returns the type of value. Use TYPE when the behavior of another function depends on the type of value in a particular cell.", "info"],
			["UPPER", "UPPER(text)", "<b>Syntax:</b> UPPER(text)<br><br>This function allows you to convert text to all uppercase. If there are characters in the string that are not letters, they are unaffected by this function.", "string"],
			["VALUE", "VALUE(text)", "<b>Syntax:</b> VALUE(text)<br><br>Converts a text string into a number. Text is the text to be converted to a number.", "string"],
			["VAR", "VAR(number1,[number2],...])", "<b>Syntax:</b> VAR(number1,[number2],...])<br><br>Estimates variance based on a sample.", "compatibility"],
			["VARP", "VARP(number1,[number2],...])", "<b>Syntax:</b> VARP(number1,[number2],...])<br><br>Calculates variance based on the entire population.", "compatibility"],
			["VAR.S", "VAR.S(number1,[number2],...])", "<b>Syntax:</b> VAR.S(number1,[number2],...])<br><br>Estimates variance based on a sample (ignores logical values and text in the sample).", "statistical"],
			["VAR.P", "VAR.P(number1,[number2],...])", "<b>Syntax:</b> VAR.P(number1,[number2],...])<br><br>Calculates variance based on the entire population (ignores logical values and text in the population).", "statistical"],
			["WEEKDAY", "WEEKDAY(serial_number, [type])", "<b>Syntax:</b> WEEKDAY(serial_number, [type])<br><br>Returns the day of the week for the given serial_number (date value). The day is returned as an integer based on the type. <br><br>Type is option. It can be any of the following values: <br><br>type = 1 (default), the weekdays are counted starting from Sunday (Monday = 2). <br><br>type = 2, the weekdays are counted starting from Monday (Monday = 1). <br><br>type = 3, the weekdays are counted starting from Monday (Monday = 0).", "date"],
			["WEEKNUM", "WEEKNUM(serial_number, [type])", "<b>Syntax:</b> WEEKNUM(serial_number, [type])<br><br>Returns a number that indicates where the week falls numerically within a year. The WEEKNUM function considers the week containing January 1 to be the first week of the year. <br><br>Type is option. It can be any of the following values: <br><br>type = 1 (default), Week begins on Sunday. <br>type = 2, Week begins on Monday.", "date"],
			["WORKDAY", "WORKDAY(start_date, days, [holidays])", "<b>Syntax:</b> WORKDAY(start_date, days, [holidays])<br><br>Returns a number that represents a date that is the indicated number of working days before or after a date (the starting date). Working days exclude weekends and any dates identified as holidays. Holidays is optional.", "date"],
			["WORKDAY.INTL", "WORKDAY.INTL(start_date, days, [weekend], [holidays])", "<b>Syntax:</b> WORKDAY.INTL(start_date, days, [weekend], [holidays])<br><br>Returns a number that represents a date that is the indicated number of working days before or after a date (the starting date). Working days exclude weekends and any dates identified as holidays. Holidays and weekends are optional.", "date"],
			["YEAR", "YEAR(date_value)", "<b>Syntax:</b> YEAR(date_value)<br><br>This function returns a four-digit year (a number from 1900 to 9999) given a date value.", "date"],
			["YEARFRAC", "YEARFRAC(start_date, end_date, basis)", "<b>Syntax:</b> YEARFRAC(start_date, end_date, basis)<br><br>Calculates the fraction of the year represented by the number of whole days between two dates (the start_date and the end_date). Use the YEARFRAC worksheet function to identify the proportion of a whole year's benefits or obligations to assign to a specific term.", "date"],
			["VDB", "VDB(cost, salvage, life, start_period, end_period, [factor], [no_switch])", "<b>Syntax:</b> VDB(cost, salvage, life, start_period, end_period, [factor], [no_switch])<br><br>Returns the depreciation of an asset for any period you specify, including partial periods, using the double-declining balance method or some other method you specify. VDB stands for variable declining balance.<br/><br/>Cost: The initial cost of the asset.<br/><br/>Salvage: The value at the end of the depreciation. This value can be 0.<br/><br/>Life: the number of periods over which the asset is depreciated.<br/><br/>Start_period: The starting period for which you want to calculate the depreciation. Start_period must use the same units as life.<br/><br/>End_period: The ending period for which you want to calculate the depreciation. End_period must use the same units as life.<br/><br/>Factor: The rate at which the balance declines. If factor is omitted, it is assumed to be 2.<br/><br/>No_switch: A logical value specifying whether to switch to straight-line depreciation when depreciation is greater than the declining balance calculation.", "finicial"],
			["VLOOKUP", "VLOOKUP(lookup_value, tabe_array, col_index, [not_exact_match])", "<b>Syntax:</b> VLOOKUP(lookup_value, tabe_array, col_index, [not_exact_match])<br><br>Search for value in the left-most column of tabe_array and returns the value in the same row based on the col_index.", "lookup"]
		]
	}
}, function() {
	try {
		SLANG = SLANG || (Ext.create("EnterpriseSheet.pure.lang.Language")).content
	} catch(e) {
		SLANG = (Ext.create("EnterpriseSheet.pure.lang.Language")).content
	}
});
Ext.define("EnterpriseSheet.pure.common.CONST", {
	requires: [],
	constructor: function(config) {
		Ext.apply(this, config);
		var ml = this.ml || 4094267;
		Ext.apply(this, {
			version: "4.2.0.20170405",
			limitType: "3.0.5.20150201",
			RECONNECT_SERVER_INTERVAL: 30000,
			FORMAT_DATE: "date",
			FORMAT_TIME: "time",
			FORMAT_DATE_TIME: "datetime",
			DEFAULT_DATE_FORMAT: "Y-m-d",
			DEFAULT_TIME_FORMAT: "H:i:s",
			DEFAULT_DATE_TIME_FORMAT: "Y-m-d H:i",
			HIA_TIME_FORMAT: "h:i A",
			sortLimitRowCount: 2000,
			sortLimitCellCount: 20000,
			FORMAT_PERCENT: "percent",
			DEFAULT_PERCENT_FORMAT: "0.00%",
			NO_DECIMAL_PERCENT_FORMAT: "0%",
			FORMAT_COMMA: "comma",
			DEFAULT_COMMA_FORMAT: "#,000.00",
			FORMAT_SCIENCE: "science",
			DEFAULT_SCIENCE_FORMAT: "0.00E+00",
			FORMAT_NUMBER: "number",
			DEFAULT_NUMBER_FORMAT: "0.00",
			FORMAT_SPECIAL: "special",
			FORMAT_CURRENCY: "currency",
			DEFAULT_CURRENCY_FORMAT: "#,##0.00",
			FORMAT_LOCALE: "locale",
			FORMAT_FRACTION: "fraction",
			DEFAULT_FRACTION_FORMAT: "# ?/?",
			MARKER_SHAPES: ["circle", "cross", "diamond", "plus", "triangle", "line", "arrow", "square"],
			SSID: "ENTERPRISESHEET$r3BwrrtnWdRxfvfMUZKBtp8Z5nnRxfDvs2GhdZ96GgFKw8BBRkPfL4H4UCt45CQH$LIBOYANG",
			urlReg: /((((^https?)|(^ftp)|(^mailto)):\/\/)?([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i,
			strictUrlReg: /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/,
			urlProReg: /^(http|ftp|https|mailto):/i,
			emailReg: /^(")?(?:[^\."\s])(?:(?:[\.])?(?:[\w\-!#$%&'*+/=?^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/,
			jsDateFm: ["Y-m-d", "d-m-Y", "F d, Y", "M d, Y", "m/d/Y", "y-m-d", "d-m-y", "d-M-y", "l, M d, Y"],
			javaDateFm: ["yyyy-MM-dd", "dd-MM-yyyy", "MMMM dd, yyyy", "MMM dd, yyyy", "MM/dd/yyyy", "yy-MM-dd", "dd-MM-yy", "dd-MMM-yy", "EEEE, MMMM dd, yyyy"],
			jsTimeFm: ["H:i:s", "H:i", "g:i:s A", "g:i A", "G:i:s A"],
			javaTimeFm: ["HH:mm:ss", "HH:mm", "hh:mm:ss AM/PM", "hh:mm AM/PM", "HH:mm:ss AM/PM"],
			jsDateTimeFm: ["Y-m-d H:i:s", "Y-m-d H:i", "Y-m-d g:i:s A", "Y-m-d g:i A", "Y-m-d G:i:s A"],
			javaDateTimeFm: ["yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM-dd hh:mm:ss AM/PM", "yyyy-MM-dd hh:mm AM/PM", "yyyy-MM-dd HH:mm:ss AM/PM"],
			specialFormuals: ["=sum", "=sumproduct", "=sumx2py2", "=sumx2my2", "=sumxmy2", "=small", "=rows", "=index", "=large", "=lookup", "=type", "=match", "=networkdays", "=slope", "=workday", "=steyx", "=avedev", "=devsq", "=rsq"],
			ABSOLUTE_COORD: 1,
			RELATIVE_COORD: 2,
			ABSOLUTE_ROW_COORD: 3,
			ABSOLUTE_COL_COORD: 4,
			REPEAT_VALUE: 0,
			SOLE_VALUE: 1,
			YESTERDAY: 0,
			TODAY: 1,
			TOMORROW: 2,
			SEVEN_DAY: 3,
			LAST_WEEK: 4,
			THIS_WEEK: 5,
			NEXT_WEEK: 6,
			LAST_MONTH: 7,
			THIS_MONTH: 8,
			NEXT_MONTH: 9,
			OTHER_OPTION: 10,
			ABOVE_AVERAGE: 0,
			BELOW_AVERAGE: 1,
			PULLING_TIMEOUT: 300000,
			MAX_ROW_NUMBER: 1048576,
			MAX_COLUMN_NUMBER: 1024,
			azChars: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"],
			char2Num: {
				A: 0,
				B: 1,
				C: 2,
				D: 3,
				E: 4,
				F: 5,
				G: 6,
				H: 7,
				I: 8,
				J: 9,
				K: 10,
				L: 11,
				M: 12,
				N: 13,
				O: 14,
				P: 15,
				Q: 16,
				R: 17,
				S: 18,
				T: 19,
				U: 20,
				V: 21,
				W: 22,
				X: 23,
				Y: 24,
				Z: 25
			},
			letters: {
				'0': "A",
				'1': "B",
				'2': "C",
				'3': "D",
				'4': "E",
				'5': "F",
				'6': "G",
				'7': "H",
				'8': "I",
				'9': "J",
				a: "K",
				b: "L",
				c: "M",
				d: "N",
				e: "O",
				f: "P",
				g: "Q",
				h: "R",
				i: "S",
				j: "T",
				k: "U",
				l: "V",
				m: "W",
				n: "X",
				o: "Y",
				p: "Z",
				'10': "K",
				'11': "L",
				'12': "M",
				'13': "N",
				'14': "O",
				'15': "P",
				'16': "Q",
				'17': "R",
				'18': "S",
				'19': "T",
				'20': "U",
				'21': "V",
				'22': "W",
				'23': "X",
				'24': "Y",
				'25': "Z"
			},
			money_code: {
				usd: "$",
				rmb: String.fromCharCode(165),
				eur: String.fromCharCode(8364),
				all: "Lek",
				afn: String.fromCharCode(1547),
				ars: "$",
				aud: "A$",
				bob: "$b",
				brl: "R$",
				bgn: String.fromCharCode(1083) + String.fromCharCode(1074),
				cad: "C$",
				clp: "$",
				cop: "$",
				cup: String.fromCharCode(8369),
				czk: String.fromCharCode(75) + String.fromCharCode(269),
				dkk: "Kr",
				egp: String.fromCharCode(163),
				hkd: "$",
				huf: "Ft",
				isk: "Kr",
				irr: String.fromCharCode(65020),
				inr: String.fromCharCode(8377),
				idr: "Rp",
				ils: String.fromCharCode(8362),
				jmd: "J$",
				jpy: String.fromCharCode(165),
				kzt: String.fromCharCode(1083) + String.fromCharCode(1074),
				ltl: "Lt",
				won: String.fromCharCode(8361),
				lbp: String.fromCharCode(163),
				myr: "RM",
				mxn: "$",
				ngn: String.fromCharCode(8358),
				nzd: "$",
				nok: "Kr",
				pkr: String.fromCharCode(8360),
				pln: "z" + String.fromCharCode(322),
				ron: "lei",
				rub: "&#x20bd;",
				sar: String.fromCharCode(65020),
				sgd: "$",
				zar: "R",
				sek: "Kr",
				chf: "CHF",
				thb: String.fromCharCode(3647),
				twd: "NT$",
				'try': String.fromCharCode(8356),
				uah: String.fromCharCode(8372),
				gbp: String.fromCharCode(8356),
				vnd: String.fromCharCode(8363),
				zwd: "Z$"
			},
			locale_list_more: [{
				abbr: "de-DE",
				name: SLANG.locale_german_de
			}, {
				abbr: "en-US",
				name: SLANG.locale_english_us
			}, {
				abbr: "zh-Hans-CN",
				name: SLANG.locale_chinese
			}, {
				abbr: "en-IN",
				name: SLANG.locale_indian
			}, {
				abbr: "ar-EG",
				name: SLANG.locale_arabic
			}],
			money_list: [{
				abbr: "usd",
				name: SLANG.money_us_dollar
			}, {
				abbr: "rmb",
				name: SLANG.money_china_rmb
			}, {
				abbr: "eur",
				name: SLANG.money_european_euro
			}, {
				abbr: "all",
				name: SLANG.money_albania
			}, {
				abbr: "afn",
				name: SLANG.money_afghan
			}, {
				abbr: "ars",
				name: SLANG.money_argentina_peso
			}, {
				abbr: "aud",
				name: SLANG.money_australian_dollar
			}, {
				abbr: "bob",
				name: SLANG.money_bolivia
			}, {
				abbr: "brl",
				name: SLANG.money_brazil_real
			}, {
				abbr: "bgn",
				name: SLANG.money_bulgaria
			}, {
				abbr: "cad",
				name: SLANG.money_canada_dollar
			}, {
				abbr: "clp",
				name: SLANG.money_chile_peso
			}, {
				abbr: "cop",
				name: SLANG.money_columbia_peso
			}, {
				abbr: "cup",
				name: SLANG.money_cuba
			}, {
				abbr: "czk",
				name: SLANG.money_czech
			}, {
				abbr: "dkk",
				name: SLANG.money_denmark_krone
			}, {
				abbr: "egp",
				name: SLANG.money_egypt
			}, {
				abbr: "hkd",
				name: SLANG.money_hongkong
			}, {
				abbr: "huf",
				name: SLANG.money_hungary
			}, {
				abbr: "isk",
				name: SLANG.money_iceland
			}, {
				abbr: "irr",
				name: SLANG.money_iran
			}, {
				abbr: "inr",
				name: SLANG.money_indian_rupee
			}, {
				abbr: "idr",
				name: SLANG.money_indonsia_rupiah
			}, {
				abbr: "ils",
				name: SLANG.money_israel_shekel
			}, {
				abbr: "jmd",
				name: SLANG.money_jamaica
			}, {
				abbr: "jpy",
				name: SLANG.money_japanese_yen
			}, {
				abbr: "kzt",
				name: SLANG.money_kazakhstan
			}, {
				abbr: "won",
				name: SLANG.money_korean_won
			}, {
				abbr: "lbp",
				name: SLANG.money_lebanon
			}, {
				abbr: "ltl",
				name: SLANG.money_lithuania
			}, {
				abbr: "myr",
				name: SLANG.money_malaysia
			}, {
				abbr: "mxn",
				name: SLANG.money_mexico
			}, {
				abbr: "nzd",
				name: SLANG.money_newzealand
			}, {
				abbr: "ngn",
				name: SLANG.money_nigeria
			}, {
				abbr: "nok",
				name: SLANG.money_norway
			}, {
				abbr: "pkr",
				name: SLANG.money_pakistan
			}, {
				abbr: "pln",
				name: SLANG.money_poland
			}, {
				abbr: "ron",
				name: SLANG.money_romania
			}, {
				abbr: "rub",
				name: SLANG.money_russian_rouble
			}, {
				abbr: "sar",
				name: SLANG.money_saudi
			}, {
				abbr: "sgd",
				name: SLANG.money_sigapore
			}, {
				abbr: "zar",
				name: SLANG.money_southAf_rand
			}, {
				abbr: "sek",
				name: SLANG.money_sweden
			}, {
				abbr: "chf",
				name: SLANG.money_swit_franc
			}, {
				abbr: "twd",
				name: SLANG.money_taiwan_yen
			}, {
				abbr: "thb",
				name: SLANG.money_thailand
			}, {
				abbr: "try",
				name: SLANG.money_turky_lira
			}, {
				abbr: "uah",
				name: SLANG.money_ukraine
			}, {
				abbr: "gbp",
				name: SLANG.money_english_pound
			}, {
				abbr: "vnd",
				name: SLANG.money_viet
			}, {
				abbr: "zwd",
				name: SLANG.money_zimbabwe
			}],
			NUMBER_CUSTOM_FORMAT: {
				num1: "0",
				num2: "0.00",
				num3: "#,##0",
				num4: "#,##0.00",
				num5: "# ?/?",
				num6: "0.0e+00",
				num7: "#,##0.00;[Red]-#,##0.00",
				num8: "$#,##0.00;[Red]-$#,##0.00;[Red]ZERO",
				num9: "#,##0.0000",
				num10: "#,##0.000000"
			},
			NUMBER_CUSTOM_COLOR: ["red", "white", "blue", "magenta", "yellow", "black", "cyan", "green"],
			percent_list: [{
				name: "0%"
			}, {
				name: "0.0%"
			}, {
				name: "0.00%"
			}, {
				name: "0.000%"
			}, {
				name: "0.0000%"
			}, {
				name: "0.00000%"
			}],
			EXCEL_DB_NUM: ["dbnum1", "dbnum2", "dbnum3"],
			CHINESE_NUM_1_16UNI: ["\u96F6", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D"],
			CHINESE_NUM_2_16UNI: ["\u96F6", "\u58F9", "\u8D30", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D"],
			locale_list: [{
				id: "en_US",
				name: SLANG.locale_english_us
			}, {
				id: "zh_CN",
				name: SLANG.locale_chinese
			}],
			zh_CN_number_special: [{
				id: "rmb1",
				name: "\u4EBA\u6C11\u5E01\u5927\u5199\u8F6C\u5316"
			}, {
				id: "rmb2",
				name: "\u4EBA\u6C11\u5E01\u5C0F\u5199\u8F6C\u5316"
			}],
			en_US_number_special: [{
				id: "phoneus",
				name: SLANG.phoneNumber
			}, {
				id: "ssn",
				name: SLANG.ssn
			}],
			fill_pattern_style: {
				'625Gray': "url(js/EnterpriseSheet/resources/images/fill/6_25.png)",
				'125Gray': "url(js/EnterpriseSheet/resources/images/fill/12_5.png)",
				'25Gray': "url(js/EnterpriseSheet/resources/images/fill/25.png)",
				'50Gray': "url(js/EnterpriseSheet/resources/images/fill/50.png)",
				'75Gray': "url(js/EnterpriseSheet/resources/images/fill/75.png)",
				HS: "url(js/EnterpriseSheet/resources/images/fill/h_s.png)",
				thinHS: "url(js/EnterpriseSheet/resources/images/fill/t_h_s.png)",
				VS: "url(js/EnterpriseSheet/resources/images/fill/v_s.png)",
				thinVS: "url(js/EnterpriseSheet/resources/images/fill/t_v_s.png)",
				thinDS: "url(js/EnterpriseSheet/resources/images/fill/t_d_s.png)",
				thinRDS: "url(js/EnterpriseSheet/resources/images/fill/t_r_d_s.png)",
				thinDC: "url(js/EnterpriseSheet/resources/images/fill/t_d_c.png)",
				DC: "url(js/EnterpriseSheet/resources/images/fill/d_c.png)",
				thickDC: "url(js/EnterpriseSheet/resources/images/fill/tt_d_c.png)",
				thinHC: "url(js/EnterpriseSheet/resources/images/fill/t_h_c.png)"
			},
			fullWeekNames: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
			shortWeekNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
			fullMonthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			fullMonthNames_low: ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"],
			shortMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			shortMonthNames_low: ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"],
			dir: {
				xy: "overflow:auto;",
				x: "overflow-x:auto;",
				y: "overflow-y:auto;",
				none: "overflow:hidden;"
			},
			MAX_LENGTH: ml,
			dirbody: {
				xy: "width:110%;height:110%;",
				x: "width:110%;height:100%;",
				y: "width:100%;height:110%;",
				none: "width:" + ml + "px;height:" + ml + "px;"
			},
			jsSSDateFormat: {
				m: "m",
				mm: "m",
				mmm: "M",
				mmmm: "F",
				d: "j",
				dd: "d",
				ddd: "D",
				dddd: "l",
				yy: "y",
				yyyy: "Y"
			},
			exceptions: {
				CAL_INFINATE_LOOP: {}
			},
			validateDataType: {
				number: 0,
				text: 1,
				date: 2,
				list: 3,
				multi_options: 4,
				checkbox: 5,
				radio: 6,
				attachment: 7,
				phone: 8,
				email: 9,
				url: 10,
				currency: 11,
				percent: 12,
				single_select: 13,
				long_text: 14,
				remote_select: 15,
				ref_select: 16,
				html_text: 17,
				multi_checkbox: 21,
				display_text: 22,
				signature: 23,
				multi_radio: 24,
				customer: 100
			},
			weekend_types: [
				[],
				[6, 0],
				[0, 1],
				[1, 2],
				[2, 3],
				[3, 4],
				[4, 5],
				[5, 6],
				[],
				[],
				[],
				[0],
				[1],
				[2],
				[3],
				[4],
				[5],
				[6]
			],
			validateOption: {
				between: 0,
				not_between: 1,
				less: 2,
				less_equal: 3,
				greater: 4,
				greater_equal: 5,
				equal: 6,
				not_equal: 7,
				contain: 8,
				not_contain: 9,
				is_email: 10,
				is_url: 11,
				is_date: 12,
				date_before: 13,
				date_on_before: 14,
				date_after: 15,
				date_on_after: 16,
				any_number: 17,
				is_phone: 18
			}
		});
		Ext.apply(this, {
			MAX_COL_Z_INDEX: this.MAX_COLUMN_NUMBER + 1,
			SM_Z_INDEX: this.MAX_COLUMN_NUMBER + 2,
			RM_Z_INDEX: this.MAX_COLUMN_NUMBER + 3,
			INCELL_ITEM_Z_INDEX: this.MAX_COLUMN_NUMBER + 4,
			PB_Z_INDEX: this.MAX_COLUMN_NUMBER + 5,
			FLOAT_Z_INDEX: this.MAX_COLUMN_NUMBER + 14,
			ACTIVE_FLOAT_Z_INDEX: this.MAX_COLUMN_NUMBER + 15,
			TOP_Z_INDEX: this.MAX_COLUMN_NUMBER + 50000,
			CORNER_Z_INDEX: this.MAX_COLUMN_NUMBER + 50001
		});
	}
}, function() {
	SCONST = Ext.create("EnterpriseSheet.pure.common.CONST");
});
var kCSSColorTable = {
	transparent: [0, 0, 0, 0],
	aliceblue: [240, 248, 255, 1],
	antiquewhite: [250, 235, 215, 1],
	aqua: [0, 255, 255, 1],
	aquamarine: [127, 255, 212, 1],
	azure: [240, 255, 255, 1],
	beige: [245, 245, 220, 1],
	bisque: [255, 228, 196, 1],
	black: [0, 0, 0, 1],
	blanchedalmond: [255, 235, 205, 1],
	blue: [0, 0, 255, 1],
	blueviolet: [138, 43, 226, 1],
	brown: [165, 42, 42, 1],
	burlywood: [222, 184, 135, 1],
	cadetblue: [95, 158, 160, 1],
	chartreuse: [127, 255, 0, 1],
	chocolate: [210, 105, 30, 1],
	coral: [255, 127, 80, 1],
	cornflowerblue: [100, 149, 237, 1],
	cornsilk: [255, 248, 220, 1],
	crimson: [220, 20, 60, 1],
	cyan: [0, 255, 255, 1],
	darkblue: [0, 0, 139, 1],
	darkcyan: [0, 139, 139, 1],
	darkgoldenrod: [184, 134, 11, 1],
	darkgray: [169, 169, 169, 1],
	darkgreen: [0, 100, 0, 1],
	darkgrey: [169, 169, 169, 1],
	darkkhaki: [189, 183, 107, 1],
	darkmagenta: [139, 0, 139, 1],
	darkolivegreen: [85, 107, 47, 1],
	darkorange: [255, 140, 0, 1],
	darkorchid: [153, 50, 204, 1],
	darkred: [139, 0, 0, 1],
	darksalmon: [233, 150, 122, 1],
	darkseagreen: [143, 188, 143, 1],
	darkslateblue: [72, 61, 139, 1],
	darkslategray: [47, 79, 79, 1],
	darkslategrey: [47, 79, 79, 1],
	darkturquoise: [0, 206, 209, 1],
	darkviolet: [148, 0, 211, 1],
	deeppink: [255, 20, 147, 1],
	deepskyblue: [0, 191, 255, 1],
	dimgray: [105, 105, 105, 1],
	dimgrey: [105, 105, 105, 1],
	dodgerblue: [30, 144, 255, 1],
	firebrick: [178, 34, 34, 1],
	floralwhite: [255, 250, 240, 1],
	forestgreen: [34, 139, 34, 1],
	fuchsia: [255, 0, 255, 1],
	gainsboro: [220, 220, 220, 1],
	ghostwhite: [248, 248, 255, 1],
	gold: [255, 215, 0, 1],
	goldenrod: [218, 165, 32, 1],
	gray: [128, 128, 128, 1],
	green: [0, 128, 0, 1],
	greenyellow: [173, 255, 47, 1],
	grey: [128, 128, 128, 1],
	honeydew: [240, 255, 240, 1],
	hotpink: [255, 105, 180, 1],
	indianred: [205, 92, 92, 1],
	indigo: [75, 0, 130, 1],
	ivory: [255, 255, 240, 1],
	khaki: [240, 230, 140, 1],
	lavender: [230, 230, 250, 1],
	lavenderblush: [255, 240, 245, 1],
	lawngreen: [124, 252, 0, 1],
	lemonchiffon: [255, 250, 205, 1],
	lightblue: [173, 216, 230, 1],
	lightcoral: [240, 128, 128, 1],
	lightcyan: [224, 255, 255, 1],
	lightgoldenrodyellow: [250, 250, 210, 1],
	lightgray: [211, 211, 211, 1],
	lightgreen: [144, 238, 144, 1],
	lightgrey: [211, 211, 211, 1],
	lightpink: [255, 182, 193, 1],
	lightsalmon: [255, 160, 122, 1],
	lightseagreen: [32, 178, 170, 1],
	lightskyblue: [135, 206, 250, 1],
	lightslategray: [119, 136, 153, 1],
	lightslategrey: [119, 136, 153, 1],
	lightsteelblue: [176, 196, 222, 1],
	lightyellow: [255, 255, 224, 1],
	lime: [0, 255, 0, 1],
	limegreen: [50, 205, 50, 1],
	linen: [250, 240, 230, 1],
	magenta: [255, 0, 255, 1],
	maroon: [128, 0, 0, 1],
	mediumaquamarine: [102, 205, 170, 1],
	mediumblue: [0, 0, 205, 1],
	mediumorchid: [186, 85, 211, 1],
	mediumpurple: [147, 112, 219, 1],
	mediumseagreen: [60, 179, 113, 1],
	mediumslateblue: [123, 104, 238, 1],
	mediumspringgreen: [0, 250, 154, 1],
	mediumturquoise: [72, 209, 204, 1],
	mediumvioletred: [199, 21, 133, 1],
	midnightblue: [25, 25, 112, 1],
	mintcream: [245, 255, 250, 1],
	mistyrose: [255, 228, 225, 1],
	moccasin: [255, 228, 181, 1],
	navajowhite: [255, 222, 173, 1],
	navy: [0, 0, 128, 1],
	oldlace: [253, 245, 230, 1],
	olive: [128, 128, 0, 1],
	olivedrab: [107, 142, 35, 1],
	orange: [255, 165, 0, 1],
	orangered: [255, 69, 0, 1],
	orchid: [218, 112, 214, 1],
	palegoldenrod: [238, 232, 170, 1],
	palegreen: [152, 251, 152, 1],
	paleturquoise: [175, 238, 238, 1],
	palevioletred: [219, 112, 147, 1],
	papayawhip: [255, 239, 213, 1],
	peachpuff: [255, 218, 185, 1],
	peru: [205, 133, 63, 1],
	pink: [255, 192, 203, 1],
	plum: [221, 160, 221, 1],
	powderblue: [176, 224, 230, 1],
	purple: [128, 0, 128, 1],
	rebeccapurple: [102, 51, 153, 1],
	red: [255, 0, 0, 1],
	rosybrown: [188, 143, 143, 1],
	royalblue: [65, 105, 225, 1],
	saddlebrown: [139, 69, 19, 1],
	salmon: [250, 128, 114, 1],
	sandybrown: [244, 164, 96, 1],
	seagreen: [46, 139, 87, 1],
	seashell: [255, 245, 238, 1],
	sienna: [160, 82, 45, 1],
	silver: [192, 192, 192, 1],
	skyblue: [135, 206, 235, 1],
	slateblue: [106, 90, 205, 1],
	slategray: [112, 128, 144, 1],
	slategrey: [112, 128, 144, 1],
	snow: [255, 250, 250, 1],
	springgreen: [0, 255, 127, 1],
	steelblue: [70, 130, 180, 1],
	tan: [210, 180, 140, 1],
	teal: [0, 128, 128, 1],
	thistle: [216, 191, 216, 1],
	tomato: [255, 99, 71, 1],
	turquoise: [64, 224, 208, 1],
	violet: [238, 130, 238, 1],
	wheat: [245, 222, 179, 1],
	white: [255, 255, 255, 1],
	whitesmoke: [245, 245, 245, 1],
	yellow: [255, 255, 0, 1],
	yellowgreen: [154, 205, 50, 1]
};

function clamp_css_byte(i) {
	i = Math.round(i);
	return i < 0 ? 0 : i > 255 ? 255 : i
}

function clamp_css_float(f) {
	return f < 0 ? 0 : f > 1 ? 1 : f
}

function parse_css_int(str) {
	if(str[str.length - 1] === "%") {
		return clamp_css_byte(parseFloat(str) / 100 * 255)
	}
	return clamp_css_byte(parseInt(str))
}

function parse_css_float(str) {
	if(str[str.length - 1] === "%") {
		return clamp_css_float(parseFloat(str) / 100)
	}
	return clamp_css_float(parseFloat(str))
}

function css_hue_to_rgb(m1, m2, h) {
	if(h < 0) {
		h += 1
	} else {
		if(h > 1) {
			h -= 1
		}
	}
	if(h * 6 < 1) {
		return m1 + (m2 - m1) * h * 6
	}
	if(h * 2 < 1) {
		return m2
	}
	if(h * 3 < 2) {
		return m1 + (m2 - m1) * (2 / 3 - h) * 6
	}
	return m1
}

function parseCSSColor(css_str) {
	var str = css_str.replace(/ /g, "").toLowerCase();
	if(str in kCSSColorTable) {
		return kCSSColorTable[str].slice()
	}
	if(str[0] === "#") {
		if(str.length === 4) {
			var iv = parseInt(str.substr(1), 16);
			if(!(iv >= 0 && iv <= 4095)) {
				return null
			}
			return [((iv & 3840) >> 4) | ((iv & 3840) >> 8), (iv & 240) | ((iv & 240) >> 4), (iv & 15) | ((iv & 15) << 4), 1]
		} else {
			if(str.length === 7) {
				var iv = parseInt(str.substr(1), 16);
				if(!(iv >= 0 && iv <= 16777215)) {
					return null
				}
				return [(iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1]
			}
		}
		return null
	}
	var op = str.indexOf("("),
		ep = str.indexOf(")");
	if(op !== -1 && ep + 1 === str.length) {
		var fname = str.substr(0, op);
		var params = str.substr(op + 1, ep - (op + 1)).split(",");
		var alpha = 1;
		switch(fname) {
			case "rgba":
				if(params.length !== 4) {
					return null
				}
				alpha = parse_css_float(params.pop());
			case "rgb":
				if(params.length !== 3) {
					return null
				}
				return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];
			case "hsla":
				if(params.length !== 4) {
					return null
				}
				alpha = parse_css_float(params.pop());
			case "hsl":
				if(params.length !== 3) {
					return null
				}
				var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;
				var s = parse_css_float(params[1]);
				var l = parse_css_float(params[2]);
				var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
				var m1 = l * 2 - m2;
				return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
			default:
				return null
		}
	}
	return null
}
try {
	exports.parseCSSColor = parseCSSColor
} catch(e) {}
Ext.define("EnterpriseSheet.pure.common.Common", {
	requires: ["EnterpriseSheet.pure.common.CONST"],
	constructor: function() {
		var colors = ["rgb(148,174,10)", "rgb(17,95,166)", "rgb(166,17,32)", "rgb(255,136,9)", "rgb(255,209,62)", "rgb(166,17,135)", "rgb(36,173,154)", "rgb(124,116,116)", "rgb(166,97,17)"];
		var colorStrMap = {
			aliceblue: "f0f8ff",
			antiquewhite: "faebd7",
			aqua: "00ffff",
			aquamarine: "7fffd4",
			azure: "f0ffff",
			beige: "f5f5dc",
			bisque: "ffe4c4",
			black: "000000",
			blanchedalmond: "ffebcd",
			blue: "0000ff",
			blueviolet: "8a2be2",
			brown: "a52a2a",
			burlywood: "deb887",
			cadetblue: "5f9ea0",
			chartreuse: "7fff00",
			chocolate: "d2691e",
			coral: "ff7f50",
			cornflowerblue: "6495ed",
			cornsilk: "fff8dc",
			crimson: "dc143c",
			cyan: "00ffff",
			darkblue: "00008b",
			darkcyan: "008b8b",
			darkgoldenrod: "b8860b",
			darkgray: "a9a9a9",
			darkgreen: "006400",
			darkkhaki: "bdb76b",
			darkmagenta: "8b008b",
			darkolivegreen: "556b2f",
			darkorange: "ff8c00",
			darkorchid: "9932cc",
			darkred: "8b0000",
			darksalmon: "e9967a",
			darkseagreen: "8fbc8f",
			darkslateblue: "483d8b",
			darkslategray: "2f4f4f",
			darkturquoise: "00ced1",
			darkviolet: "9400d3",
			deeppink: "ff1493",
			deepskyblue: "00bfff",
			dimgray: "696969",
			dodgerblue: "1e90ff",
			feldspar: "d19275",
			firebrick: "b22222",
			floralwhite: "fffaf0",
			forestgreen: "228b22",
			fuchsia: "ff00ff",
			gainsboro: "dcdcdc",
			ghostwhite: "f8f8ff",
			gold: "ffd700",
			goldenrod: "daa520",
			gray: "808080",
			green: "008000",
			greenyellow: "adff2f",
			honeydew: "f0fff0",
			hotpink: "ff69b4",
			indianred: "cd5c5c",
			indigo: "4b0082",
			ivory: "fffff0",
			khaki: "f0e68c",
			lavender: "e6e6fa",
			lavenderblush: "fff0f5",
			lawngreen: "7cfc00",
			lemonchiffon: "fffacd",
			lightblue: "add8e6",
			lightcoral: "f08080",
			lightcyan: "e0ffff",
			lightgoldenrodyellow: "fafad2",
			lightgrey: "d3d3d3",
			lightgreen: "90ee90",
			lightpink: "ffb6c1",
			lightsalmon: "ffa07a",
			lightseagreen: "20b2aa",
			lightskyblue: "87cefa",
			lightslateblue: "8470ff",
			lightslategray: "778899",
			lightsteelblue: "b0c4de",
			lightyellow: "ffffe0",
			lime: "00ff00",
			limegreen: "32cd32",
			linen: "faf0e6",
			magenta: "ff00ff",
			maroon: "800000",
			mediumaquamarine: "66cdaa",
			mediumblue: "0000cd",
			mediumorchid: "ba55d3",
			mediumpurple: "9370d8",
			mediumseagreen: "3cb371",
			mediumslateblue: "7b68ee",
			mediumspringgreen: "00fa9a",
			mediumturquoise: "48d1cc",
			mediumvioletred: "c71585",
			midnightblue: "191970",
			mintcream: "f5fffa",
			mistyrose: "ffe4e1",
			moccasin: "ffe4b5",
			navajowhite: "ffdead",
			navy: "000080",
			oldlace: "fdf5e6",
			olive: "808000",
			olivedrab: "6b8e23",
			orange: "ffa500",
			orangered: "ff4500",
			orchid: "da70d6",
			palegoldenrod: "eee8aa",
			palegreen: "98fb98",
			paleturquoise: "afeeee",
			palevioletred: "d87093",
			papayawhip: "ffefd5",
			peachpuff: "ffdab9",
			peru: "cd853f",
			pink: "ffc0cb",
			plum: "dda0dd",
			powderblue: "b0e0e6",
			purple: "800080",
			red: "ff0000",
			rosybrown: "bc8f8f",
			royalblue: "4169e1",
			saddlebrown: "8b4513",
			salmon: "fa8072",
			sandybrown: "f4a460",
			seagreen: "2e8b57",
			seashell: "fff5ee",
			sienna: "a0522d",
			silver: "c0c0c0",
			skyblue: "87ceeb",
			slateblue: "6a5acd",
			slategray: "708090",
			snow: "fffafa",
			springgreen: "00ff7f",
			steelblue: "4682b4",
			tan: "d2b48c",
			teal: "008080",
			thistle: "d8bfd8",
			tomato: "ff6347",
			turquoise: "40e0d0",
			violet: "ee82ee",
			violetred: "d02090",
			wheat: "f5deb3",
			white: "ffffff",
			whitesmoke: "f5f5f5",
			yellow: "ffff00",
			yellowgreen: "9acd32"
		};
		var isNonAnsIIChar = function(charCode) {
			return 127 < charCode;
		};
		var findNoAnsIIChar = function(str) {
			for(var i = 0, len = str.length; i < len; i++) {
				var charCode = str.charCodeAt(i);
				if(isNonAnsIIChar(charCode)) {
					return i;
				}
			}
			return -1;
		};
		var nullOrUndefined = function(v) {
			return undefined === v || null === v;
		};
		var isEmptyValue = function(v) {
			return undefined === v || null === v || "" === v;
		};
		var isEmptyObj = function(o) {
			for(var p in o) {
				if(o.hasOwnProperty(p)) {
					return false;
				}
			}
			return true;
		};
		var deleteMembers = function(o, members) {
			for(var i = 0, len = members.length; i < len; i++) {
				delete o[members[i]];
			}
			return o;
		};
		var canbeNumber = function(v) {
			return null !== v && "" !== v && isFinite(Number(v));
		};
		var factorizeNum = function(num) {
			num = Math.abs(num);
			var factors = {};
			for(var i = 2; i <= num;) {
				if(0 == num % i) {
					factors[i] = factors[i] || 0;
					factors[i]++;
					num = num / i;
				} else {
					i++;
				}
			}
			if(1 != num) {
				factors[num] = factors[num] || 0;
				factors[num]++;
			}
			return factors;
		};
		var countObjMember = function(o) {
			if(o) {
				var count = 0;
				for(var p in o) {
					if(o.hasOwnProperty(p)) {
						count++;
					}
				}
				return count;
			}
		};
		var isEmptyStr = function(inStr) {
			var blankRE = /^[\s]+$/;
			if(inStr === "" || blankRE.test(inStr)) {
				return true;
			}
			return false;
		};
		var removeHTMLTag = function(str) {
			if("string" == SCOM.typeOf(str)) {
				str = str.replace(/<\/?.+?>/g, "");
				str = str.replace(/\\?/g, "");
				str = Ext.String.trim(str);
			}
			return str;
		};
		var number2Letter = function(num) {
			num--;
			var arr = [];
			var first = true;
			while(true) {
				var s, r, c = 27;
				if(first) {
					first = false;
					c = 26;
				}
				s = Math.floor(num / c);
				r = num % c;
				arr.unshift(r);
				num = s;
				if(0 === s) {
					break;
				}
			}
			var len = arr.length;
			if(1 < len) {
				arr[0]--;
			}
			for(var i = 0; i < len; i++) {
				arr[i] = SCONST.letters[arr[i]];
			}
			return arr.join("");
		};
		var letter2Number = function(str) {
			str = str.toUpperCase();
			var result = 0;
			var len = str.length,
				base = 1,
				first = true;
			for(var i = len - 1; 0 <= i; i--) {
				var temp = SCONST.char2Num[str.charAt(i)];
				if(0 === i) {
					temp++;
				}
				result = result + temp * base;
				var c = 27;
				if(first) {
					first = false;
					c = 26;
				}
				base *= c;
			}
			return 1 < len ? result + 1 : result;
		};
		var themeColors = ["FFFFFF", "000000", "EEECE1", "1F497D", "4F81BD", "C0504D", "9BBB59", "8064A2", "4BACC6", "F79646", "F2F2F2", "7F7F7F", "DDD9C3", "C6D9F0", "DBE5F1", "F2DCDB", "EBF1DD", "E5E0EC", "DBEEF3", "FDEADA", "D8D8D8", "595959", "C4BD97", "8DB3E2", "B8CCE4", "E5B9B7", "D7E3BC", "CCC1D9", "B7DDE8", "FBD5B5", "BFBFBF", "3F3F3F", "938953", "548DD4", "95B3D7", "D99694", "C3D69B", "B2A2C7", "92CDDC", "FAC08F", "A5A5A5", "262626", "494429", "17365D", "366092", "953734", "76923C", "5F497A", "31849B", "E36C09", "7F7F7F", "0C0C0C", "1D1B10", "0F243E", "244061", "632423", "4F6128", "3F3151", "205867", "984806"];
		var darkThemeColors = ["333333", "17365D", "366092", "76923C", "5F497A", "31849B", "0A6332", "0F243E", "244061", "632423", "4F6128", "3F3151", "205867", "984806", "993366", "FFCC00", "FF00FF", "800080", "30A0E5", "339966", "99CC00", "FF9900", "FF0000", "808080", "666699", "0F6E4C", "FF6600", "800000", "000080", "003300", "333399", "000000"];
		var copy = function(o) {
			if(Ext.clone) {
				return Ext.clone(o);
			}
			var type = SCOM.typeOf(o);
			if("array" == type) {
				var c = [];
				for(var i = 0, len = o.length; i < len; i++) {
					c.push(copy(o[i]));
				}
				return c;
			} else if("object" == type) {
				var c = {};
				for(var p in o) {
					if(o.hasOwnProperty(p)) {
						c[p] = copy(o[p]);
					}
				}
				return c;
			} else {
				return o;
			}
		};
		var typeOf = function(o) {
			var type = Ext.typeOf(o);
			if("null" == type || "undefined" == type) {
				return false;
			}
			return type;
		};
		var genTimeStamp = function() {
			return Ext.Date.format(new Date, "YmdHisu");
		};
		var genRegExp = function(exp, matchCase) {
			exp = exp.toString();
			var attributes = matchCase ? "g" : "gi";
			exp = exp.replace(/\*/gi, "[.]*");
			exp = exp.replace(/\?/gi, ".");
			var first = exp.charAt(0);
			var last = exp.charAt(exp.length - 1);
			if("[" != first) {
				exp = "^" + exp;
			}
			if("*" != last) {
				exp += "$";
			}
			var reg = new RegExp(exp, attributes);
			return reg;
		};
		var indexOfArray = function(arr, it, caseSensitive) {
			var isStr = Ext.isString(it);
			if(caseSensitive || !isStr) {
				return Ext.Array.indexOf(arr, it);
			} else {
				it = it.toLowerCase();
				for(var i = 0, len = arr.length; i < len; i++) {
					var o = arr[i];
					if(Ext.isString(o)) {
						var low = o.toLowerCase();
						if(low === it) {
							return i;
						}
					} else if(o === it) {
						return i;
					}
				}
				return -1;
			}
		};
		var mergeSpan = function(target, origin) {
			var oRowStart = origin[0],
				oRowEnd = origin[2],
				oColStart = origin[1],
				oColEnd = origin[3];
			var tRowStart = target[0],
				tRowEnd = target[2],
				tColStart = target[1],
				tColEnd = target[3];
			var minRow, maxRow, minCol, maxCol;
			if(oRowStart < tRowStart) {
				minRow = oRowStart;
			} else {
				minRow = tRowStart;
			}
			if(oColStart < tColStart) {
				minCol = oColStart;
			} else {
				minCol = tColStart;
			}
			if(oRowEnd > tRowEnd) {
				maxRow = oRowEnd;
			} else {
				maxRow = tRowEnd;
			}
			if(oColEnd > tColEnd) {
				maxCol = oColEnd;
			} else {
				maxCol = tColEnd;
			}
			return [minRow, minCol, maxRow, maxCol];
		};
		var config = {
			colors: colors,
			themeColors: themeColors,
			darkThemeColors: darkThemeColors,
			nullOrUndefined: nullOrUndefined,
			isNonAnsIIChar: isNonAnsIIChar,
			findNoAnsIIChar: findNoAnsIIChar,
			isEmptyObj: isEmptyObj,
			isEmptyValue: isEmptyValue,
			deleteMembers: deleteMembers,
			canbeNumber: canbeNumber,
			isEmptyStr: isEmptyStr,
			factorizeNum: factorizeNum,
			countObjMember: countObjMember,
			number2Letter: number2Letter,
			letter2Number: letter2Number,
			copy: copy,
			typeOf: typeOf,
			genTimeStamp: genTimeStamp,
			removeHTMLTag: removeHTMLTag,
			genRegExp: genRegExp,
			indexOfArray: indexOfArray,
			mergeSpan: mergeSpan,
			transferObj2Pairs: function(obj) {
				var arr = [];
				for(var p in obj) {
					if(obj.hasOwnProperty(p)) {
						arr.push(p);
					}
				}
				return SCOM.transferArr2Pairs(arr);
			},
			transferArr2Pairs: function(arr) {
				arr.sort(function(a, b) {
					return a - b;
				});
				var obj = [],
					start = false,
					end;
				for(var i = 0, len = arr.length; i < len; i++) {
					var v = Number(arr[i]);
					if(false === start) {
						start = v;
						end = start;
					} else {
						if(end + 1 === v) {
							end = v;
						} else {
							obj.push([start, end]);
							start = v;
							end = start;
						}
					}
				}
				if(false !== start) {
					obj.push([start, end]);
				}
				return obj;
			},
			transferObj2Arr: function(obj) {
				var arr = [];
				for(var p in obj) {
					if(obj.hasOwnProperty(p)) {
						arr.push(obj[p]);
					}
				}
				return arr;
			},
			eachLimitDefer: function(items, fn, fnScope, callback, cbScope, limitMS, interval) {
				var me = SCOM || window;
				me._eldClock = new Date;
				var index = 0,
					len = items.length;
				var loop = function() {
					var count = 0,
						flag = false;
					while(index < len) {
						fn.call(fnScope, items[index]);
						index++;
						var elapsed = Ext.Date.getElapsed(me._eldClock);
						if(limitMS <= elapsed) {
							me._eldClock = new Date;
							flag = true;
							break;
						}
					}
					if(flag) {
						Ext.Function.defer(loop, interval);
					} else {
						if(callback) {
							callback.call(cbScope);
						}
					}
				};
				loop();
			},
			kmpCompare: function(str, exp, matchCase) {
				var reg = genRegExp(exp, matchCase);
				reg.lastIndex = 0;
				var result = reg.test(str);
				return result;
			},
			getAMPM: function() {
				var am = Ext.Date.format(Ext.Date.parse("01:01", "H:i"), "A");
				var pm = Ext.Date.format(Ext.Date.parse("21:01", "H:i"), "A");
				return {
					am: am,
					pm: pm
				};
			},
			compareObjMember: function(a, b) {
				var count = 0;
				for(var p in a) {
					if(a.hasOwnProperty(p)) {
						count++;
						if(!b.hasOwnProperty(p)) {
							return false;
						}
					}
				}
				for(var p in b) {
					if(b.hasOwnProperty(p)) {
						count--;
					}
				}
				return 0 === count;
			},
			compareValue: function(a, b) {
				var nuA = this.isEmptyValue(a),
					nuB = this.isEmptyValue(b);
				if(nuA && nuB) {
					return true;
				} else if(nuA || nuB) {
					return false;
				}
				if(Ext.isObject(a) && Ext.isObject(b)) {
					var count = 0;
					for(var p in a) {
						if(a.hasOwnProperty(p)) {
							count++;
							if(!this.compareValue(a[p], b[p])) {
								return false;
							}
						}
					}
					for(var p in b) {
						if(b.hasOwnProperty(p)) {
							count--;
						}
					}
					return 0 === count;
				} else if(Ext.isArray(a) && Ext.isArray(b)) {
					var len = a.length;
					if(len === b.length) {
						for(var i = 0; i < len; i++) {
							if(!this.compareValue(a[i], b[i])) {
								return false;
							}
						}
						return true;
					} else {
						return false;
					}
				} else {
					return a.toString() === b.toString();
				}
			},
			skipBlankForCommaOrPercent: function(data) {
				if(Ext.isString(data)) {
					var reg = /^[0-9,.%\s]+$/gi;
					if(reg.test(data)) {
						data = data.replace(/([\s]+%)|(%[\s]+)|([\s]+,)|(,[\s]+)|([\s]+.)|(.[\s]+)/gi, function(w) {
							return w.trim();
						});
						return data;
					}
				}
				return data;
			},
			isSpecialKey: function(key) {
				var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
				return key == keyObj.LEFT || key == keyObj.RIGHT || key == keyObj.UP || key == keyObj.DOWN || key == keyObj.ENTER || key == keyObj.TAB;
			},
			getRGB: function(code) {
				if(code) {
					var len = code.length;
					if("#" === code.charAt(0) && 7 === len) {
						code = code.slice(1);
						var res = /^(\w{2})(\w{2})(\w{2})$/gi.exec(code);
						if(res) {
							return [parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16)];
						}
					} else if(colorStrMap[code]) {
						code = colorStrMap[code];
						var res = /^(\w{2})(\w{2})(\w{2})$/gi.exec(code);
						if(res) {
							return [parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16)];
						}
					} else {
						var res = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/gi.exec(code);
						if(res) {
							return [parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10)];
						}
					}
				}
			},
			antiRGB: function(code) {
				var res = this.getRGB(code);
				if(res) {
					return [255 - res[0], 255 - res[1], 255 - res[2]];
				}
			},
			whichColorDarker: function(color1, color2) {
				color1 = color1 || "";
				color2 = color2 || "";
				var ret1 = parseCSSColor(color1),
					ret2 = parseCSSColor(color2);
				if(!ret1 && !ret2) {
					return 0;
				} else if(!ret1) {
					return -1;
				} else if(!ret2) {
					return 1;
				} else {
					var v1 = (ret1[0] + ret1[1] + ret1[2]) * ret1[3],
						v2 = (ret2[0] + ret2[1] + ret2[2]) * ret2[3];
					if(v1 < v2) {
						return 1;
					} else if(v1 > v2) {
						return -1;
					} else {
						return 0;
					}
				}
			}
		};
		Ext.apply(this, config);
	}
}, function() {
	SCOM = Ext.create("EnterpriseSheet.pure.common.Common");
});
Ext.define("EnterpriseSheet.pure.common.FormulaHelper", {
	BesselI0: function(num) {
		var result, val;
		var absNum = Math.abs(num);
		if(absNum < 3.75) {
			val = num / 3.75;
			val == val * val;
			result = 1 + val * (3.5156229 + val * (3.0899424 + val * (1.2067492 + val * (0.2659732 + val * (0.0360768 + val * 0.0045813)))))
		} else {
			val = 3.75 / absNum;
			result = (Math.exp(absNum) / Math.sqrt(absNum)) * (0.39894228 + val * (0.01328592 + val * (0.00225319 + val * (-0.00157565 + val * (0.00916281 + val * (-0.02057706 + val * (0.02635537 + val * (-0.01647633 + val * 0.00392377))))))))
		}
		return result
	},
	BesselI1: function(num) {
		var result, val;
		var absNum = Math.abs(num);
		if(absNum < 3.75) {
			val = num / 3.75;
			val == val * val;
			var temp = 0.5 + val * (0.87890594 + val * (0.51498869 + val * (0.15084934 + val * (0.02658733 + val * (0.00301532 + val * 0.00032411)))));
			result = absNum * temp
		} else {
			val = 3.75 / absNum;
			result = 0.02282967 + val * (-0.02895312 + val * (0.01787654 - val * 0.00420059));
			result = 0.39894228 + val * (-0.03988024 + val * (-0.00362018 + val * (0.00163801 + val * (-0.01031555 + val * result))));
			result *= (Math.exp(absNum) / Math.sqrt(absNum))
		}
		if(num < 0) {
			result = 0 - result
		}
		return result
	},
	BesselJ0: function(num) {
		var remain, tempX, val, result, result1, result2;
		var absNum = Math.abs(num);
		if(absNum < 8) {
			val = num * num;
			result1 = 57568490574 + val * (-13362590354 + val * (651619640.7 + val * (-11214424.18 + val * (77392.33017 + val * (-184.9052456)))));
			result2 = 57568490411 + val * (1029532985 + val * (9494680.718 + val * (59272.64853 + val * (267.8532712 + val * 1))));
			result = result1 / result2
		} else {
			remain = 8 / absNum;
			val = remain * remain;
			tempX = absNum - 0.785398164;
			result1 = 1 + val * (-0.001098628627 + val * (0.00002734510407 + val * (-0.000002073370639 + val * 2.093887211e-7)));
			result2 = -0.01562499995 + val * (0.0001430488765 + val * (-0.000006911147651 + val * (7.621095161e-7 - val * 9.34935152e-8)));
			result = Math.sqrt(0.636619772 / absNum) * (Math.cos(tempX) * result1 - remain * Math.sin(tempX) * result2)
		}
		return result
	},
	BesselJ1: function(num) {
		var absNum, remain, tempX, val, result, result1, result2;
		absNum = Math.abs(num);
		if(absNum < 8) {
			val = num * num;
			result1 = num * (72362614232 + val * (-7895059235 + val * (242396853.1 + val * (-2972611.439 + val * (15704.4826 + val * (-30.16036606))))));
			result2 = 144725228442 + val * (2300535178 + val * (18583304.74 + val * (99447.43394 + val * (376.9991397 + val * 1))));
			result = result1 / result2
		} else {
			remain = 8 / absNum;
			val = remain * remain;
			tempX = absNum - 2.356194491;
			result1 = 1 + val * (0.00183105 + val * (-0.00003516396496 + val * (0.000002457520174 + val * (-2.40337019e-7))));
			result2 = 0.04687499995 + val * (-0.0002002690873 + val * (0.000008449199096 + val * (-8.8228987e-7 + val * 1.05787412e-7)));
			result = Math.sqrt(0.636619772 / absNum) * (Math.cos(tempX) * result1 - remain * Math.sin(tempX) * result2);
			if(num < 0) {
				result = 0 - result
			}
		}
		return result
	},
	besseli: function(val, n) {
		var accurateNum = 20;
		var BIGNO = 10000000000;
		var BIGNI = 1e-10;
		var j, bi, bim, bip, tox, result;
		if(val == 0) {
			return 0
		} else {
			tox = 2 / Math.abs(val);
			bip = result = 0;
			bi = 1;
			for(j = 2 * (n + Math.floor(Math.sqrt(accurateNum * n))); j > 0; j--) {
				bim = bip + j * tox * bi;
				bip = bi;
				bi = bim;
				if(Math.abs(bi) > BIGNO) {
					result *= BIGNI;
					bi *= BIGNI;
					bip *= BIGNI
				}
				if(j == n) {
					result = bip
				}
			}
			result *= FORMULA_HELPER.BesselI0(val) / bi;
			if(val < 0 && (n & 1)) {
				result = 0 - result
			}
			return result
		}
	},
	besselj: function(x, n) {
		var accurateNum = 20;
		var BIGNO = 10000000000;
		var BIGNI = 1e-10;
		var j, jsum, m, absNum, besselJ, besselJm, besselJp, sum, tox, result;
		absNum = Math.abs(x);
		if(absNum == 0) {
			return 0
		} else {
			if(absNum > n) {
				tox = 2 / absNum;
				besselJm = FORMULA_HELPER.BesselJ0(absNum);
				besselJ = FORMULA_HELPER.BesselJ1(absNum);
				for(j = 1; j < n; j++) {
					besselJp = j * tox * besselJ - besselJm;
					besselJm = besselJ;
					besselJ = besselJp
				}
				result = besselJ
			} else {
				tox = 2 / absNum;
				if(Math.sqrt(accurateNum * n) >= 0) {
					m = 2 * ((n + Math.floor(Math.sqrt(accurateNum * n))) / 2)
				} else {
					m = 2 * ((n + Math.ceil(Math.sqrt(accurateNum * n))) / 2)
				}
				jsum = 0;
				besselJp = result = sum = 0;
				besselJ = 1;
				for(j = m; j > 0; j--) {
					besselJm = j * tox * besselJ - besselJp;
					besselJp = besselJ;
					besselJ = besselJm;
					if(Math.abs(besselJ) > BIGNO) {
						besselJ *= BIGNI;
						besselJp *= BIGNI;
						result *= BIGNI;
						sum *= BIGNI
					}
					if(jsum) {
						sum += besselJ
					}
					jsum = !jsum;
					if(j == n) {
						result = besselJp
					}
				}
				sum = 2 * sum - besselJ;
				result /= sum
			}
		}
		if(x < 0 && (n & 1)) {
			result = 0 - result
		}
		return result
	},
	besselk: function(x, n) {
		var j, besselK, remain, bkp, tox;
		tox = 2 / x;
		remain = FORMULA_HELPER.BesselK0(x);
		besselK = FORMULA_HELPER.BesselK1(x);
		for(j = 1; j < n; j++) {
			bkp = remain + j * tox * besselK;
			remain = besselK;
			besselK = bkp
		}
		return besselK
	},
	BesselK0: function(numVal) {
		var val, result;
		if(numVal <= 2) {
			val = numVal * numVal / 4;
			result = (-Math.log(numVal / 2) * this.BesselI0(numVal)) - 0.57721566 + 0.4227842 * val + 0.23069756 * val * val + 0.0348859 * val * val * val + 0.00262698 * val * val * val * val + 0.0001075 * val * val * val * val * val + 0.0000074 * val * val * val * val * val * val
		} else {
			val = 2 / numVal;
			result = (Math.exp(-numVal) / Math.sqrt(numVal)) * (1.25331414 + val * (-0.07832358 + val * (0.02189568 + val * (-0.01062446 + val * (0.00587872 + val * (-0.0025154 + val * 0.00053208))))))
		}
		return result
	},
	BesselK1: function(numVal) {
		var val, result;
		if(numVal <= 2) {
			val = numVal * numVal / 4;
			result = (Math.log(numVal / 2) * this.BesselI1(numVal)) + (1 / numVal) * (1 + val * (0.15443144 + val * (-0.67278579 + val * (-0.18156897 + val * (-0.01919402 + val * (-0.00110404 + val * (-0.00004686)))))))
		} else {
			val = 2 / numVal;
			result = (Math.exp(-numVal) / Math.sqrt(numVal)) * (1.25331414 + val * (0.23498619 + val * (-0.0365562 + val * (0.01504268 + val * (-0.00780353 + val * (0.00325614 + val * (-0.00068245)))))))
		}
		return result
	},
	bessely: function(numVal, n) {
		var j, by, bym, bessYp, tox;
		tox = 2 / numVal;
		bessY = FORMULA_HELPER.BesselY1(numVal);
		bessYm = FORMULA_HELPER.BesselY0(numVal);
		for(j = 1; j < n; j++) {
			bessYp = j * tox * bessY - bessYm;
			bessYm = bessY;
			bessY = bessYp
		}
		return bessY
	},
	BesselY0: function(numVal) {
		var remain, tempX, squareNum, result, result1, result2;
		if(numVal < 8) {
			squareNum = numVal * numVal;
			result1 = -2957821389 + squareNum * (7062834065 + squareNum * (-512359803.6 + squareNum * (10879881.29 + squareNum * (-86327.92757 + squareNum * 228.4622733))));
			result2 = 40076544269 + squareNum * (745249964.8 + squareNum * (7189466.438 + squareNum * (47447.2647 + squareNum * (226.1030244 + squareNum * 1))));
			result = (result1 / result2) + 0.636619772 * this.BesselJ0(numVal) * Math.log(numVal)
		} else {
			remain = 8 / numVal;
			squareNum = remain * remain;
			tempX = numVal - 0.785398164;
			result1 = 1 + squareNum * (-0.001098628627 + squareNum * (0.00002734510407 + squareNum * (-0.000002073370639 + squareNum * 2.093887211e-7)));
			result2 = -0.01562499995 + squareNum * (0.0001430488765 + squareNum * (-0.000006911147651 + squareNum * (7.621095161e-7 + squareNum * (-9.34945152e-8))));
			result = Math.sqrt(0.636619772 / numVal) * (Math.sin(tempX) + result1 + remain * Math.cos(tempX) * result2)
		}
		return result
	},
	BesselY1: function(numVal) {
		var remain, tempX, squareNum, result, result1, result2;
		if(numVal < 8) {
			squareNum = numVal * numVal;
			result1 = numVal * (-4900604943000 + squareNum * (1275274390000 + squareNum * (-51534381390 + squareNum * (734926455.1 + squareNum * (-4237922.726 + squareNum * 8511.937935)))));
			result2 = 24995805700000 + squareNum * (424441966400 + squareNum * (3733650367 + squareNum * (22459040.02 + squareNum * (102042.605 + squareNum * (354.9632885 + squareNum)))));
			result = (result1 / result2) + 0.636619772 * (this.BesselJ1(numVal) * Math.log(numVal) - 1 / numVal)
		} else {
			remain = 8 / numVal;
			squareNum = remain * remain;
			tempX = numVal - 2.356194491;
			result1 = 1 + squareNum * (0.00183105 + squareNum * (-0.00003516396496 + squareNum * (0.000002457520174 + squareNum * (-2.40337019e-7))));
			result2 = 0.04687499995 + squareNum * (-0.000202690873 + squareNum * (0.000008449199096 + squareNum * (-8.8228987e-7 + squareNum * 1.0578e-7)));
			result = Math.sqrt(0.636619772 / numVal) * (Math.sin(tempX) * result1 + remain * Math.cos(tempX) * result2)
		}
		return result
	},
	gamma: function(x) {
		var gamma = 0.5772156649015329;
		if(x < 0.001) {
			return 1 / (x * (1 + gamma * x))
		}
		if(x < 12) {
			var y = x,
				n = 0;
			var arg_was_less_than_one = (y < 1);
			if(arg_was_less_than_one) {
				y += 1
			} else {
				n = Math.floor(y) - 1;
				y -= n
			}
			var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563, 629.3311553128184, 866.9662027904133, -31451.272968848367, -36144.413418691176, 66456.14382024054];
			var q = [-30.840230011973897, 315.35062697960416, -1015.1563674902192, -3107.771671572311, 22538.11842098015, 4755.846277527881, -134659.9598649693, -115132.25967555349];
			var num = 0;
			var den = 1;
			var z = y - 1;
			for(i = 0; i < 8; i++) {
				num = (num + p[i]) * z;
				den = den * z + q[i]
			}
			var result = num / den + 1;
			if(arg_was_less_than_one) {
				result /= (y - 1)
			} else {
				for(i = 0; i < n; i++) {
					result *= y++
				}
			}
			return result
		}
		var c = [1 / 12, -1 / 360, 1 / 1260, -1 / 1680, 1 / 1188, -691 / 360360, 1 / 156, -3617 / 122400];
		var z = 1 / (x * x);
		var sum = c[7];
		for(var i = 6; i >= 0; i--) {
			sum *= z;
			sum += c[i]
		}
		var series = sum / x;
		var halfLogTwoPi = 0.9189385332046728;
		var logGamma = (x - 0.5) * Math.log(x) - x + halfLogTwoPi + series;
		return Math.exp(logGamma)
	}
}, function() {
	FORMULA_HELPER = Ext.create("EnterpriseSheet.pure.common.FormulaHelper")
});

Ext.define("EnterpriseSheet.pure.common.Helper", {
	getNumFormat: function(digital) {
		var numFormat = "0,0";
		if(digital && Ext.isNumber(digital)) {
			numFormat += ".";
			for(var i = 0; i < digital; i++) {
				numFormat += "0";
			}
		}
		return numFormat;
	},
	getExpFractionDigits: function(format) {
		var format = format.toUpperCase().split("E+")[0];
		var commaSep = format.split(".");
		var result = 0;
		if(commaSep.length > 1) {
			result = commaSep[1].length;
		}
		return result;
	},
	includeComma: function(num) {
		var numStr = num.toString(),
			result = false;
		if(numStr.indexOf(".") > -1) {
			result = true;
		}
		return result;
	},
	formatMoneyWithPrecise: function(format, num) {
		var result = num,
			color = null;
		try {
			var moneyCombineFormat = format.split("|");
			var symbol = moneyCombineFormat[1];
			var formatReg = "#,##0",
				decimals = moneyCombineFormat[2],
				negativeNo = moneyCombineFormat[3];
			if(decimals > 0) {
				formatReg = "#,##0.";
				for(var i = 0; i < decimals; i++) {
					formatReg += "0";
				}
			}
			result = symbol + Ext.util.Format.number(num, formatReg);
			if(num < 0) {
				if(negativeNo == "negative2" || negativeNo == "negative3") {
					color = "red";
				}
				if(negativeNo == "negative2") {
					result = symbol + Ext.util.Format.number(-num, formatReg);
				} else {
					result = "-" + symbol + Ext.util.Format.number(-num, formatReg);
				}
			}
		} catch(e) {}
		return {
			data: result,
			color: color
		};
	},
	formatNumberWithLocale: function(num, format) {
		var result = num;
		try {
			var locale = format.locale;
			var options = format.options;
			result = num.toLocaleString(locale, options);
		} catch(e) {}
		return result;
	},
	formatNumberWithCustom: function(format, num) {
		var commaIndex = format.split(";"),
			result = num,
			formatPart1 = null;
		var positiveFm = commaIndex[0],
			negativeFm = null,
			zeroFm = null,
			textFm = null;
		if(commaIndex.length > 1) {
			negativeFm = commaIndex[1];
		}
		if(commaIndex.length > 2) {
			zeroFm = commaIndex[2];
		}
		if(commaIndex.length > 3) {
			textFm = commaIndex[3];
		}
		var myFm = positiveFm;
		if(num < 0) {
			if(negativeFm) {
				myFm = negativeFm;
				num = 0 - num;
			}
		} else if(num == 0) {
			if(zeroFm) {
				myFm = zeroFm;
			}
		}
		if(myFm.charAt(0) == "[") {
			var nextSepPos = 0,
				formatPart1 = "";
			for(var i = 1; i < myFm.length; i++) {
				var chartAtI = myFm.charAt(i);
				if(chartAtI == "]") {
					nextSepPos = i;
					break;
				}
				formatPart1 = formatPart1.concat(chartAtI);
			}
			if(nextSepPos > 0) {
				myFm = myFm.substring(nextSepPos + 1, myFm.length);
			}
			if(formatPart1 && HELPER.isArrayContain(SCONST.NUMBER_CUSTOM_COLOR, formatPart1.toLowerCase())) {
				formatPart1 = formatPart1.toLowerCase();
			} else {
				if(formatPart1) {
					if(HELPER.isArrayContain(SCONST.EXCEL_DB_NUM, formatPart1.toLowerCase())) {
						var result = HELPER.convertToJapaneseDBNum(formatPart1, myFm, num);
						return {
							result: result,
							color: null
						};
					}
				} else {
					formatPart1 = null;
				}
			}
		}
		var result = num;
		if(myFm.indexOf("e+0") > -1 || myFm.indexOf("E+0") > -1) {
			var fractionSize = HELPER.getExpFractionDigits(format);
			result = num.toExponential(fractionSize);
		} else if(myFm.indexOf("# ?") > -1 && myFm.indexOf("?/") > -1) {
			var digitals = myFm.split("/")[1];
			if(Ext.isNumber(Number(digitals))) {
				result = HELPER.getFractionWithFixedDenom(num, digitals);
			} else {
				result = HELPER.getFraction(num, digitals.length);
			}
		} else {
			result = Ext.util.Format.number(num, myFm);
		}
		return {
			result: result,
			color: formatPart1
		};
	},
	getFraction: function(num, digitals) {
		var min = 2,
			max = Math.pow(10, digitals) - 1;
		if(max < 2) {
			max = 2;
		}
		var intVal = 0,
			upVal = 0,
			downVal = 0,
			decimalsVal = 0;
		if(num > 0) {
			decimalsVal = num - Math.ceil(num) + 1;
			if(decimalsVal == 1) {
				decimalsVal = 0;
				intVal = num;
			} else {
				intVal = Math.ceil(num) - 1;
			}
		} else if(num < 0) {
			intVal = Math.ceil(num);
			decimalsVal = Math.ceil(num) - num;
		}
		var faultVal = 0.0005;
		if(digitals > 1) {
			faultVal = 0.0001;
		}
		if(digitals > 2) {
			faultVal = 0.00001;
		}
		var getResult = false,
			lastTriedValue = 0;
		for(var n = min; n <= max; n++) {
			var valueIntegerTemp = Math.round(n * decimalsVal);
			var guessVal = valueIntegerTemp / n;
			var deviation = Math.abs(guessVal - decimalsVal);
			if(getResult ? deviation < Math.abs(lastguessVal - decimalsVal) : true) {
				getResult = true;
				lastguessVal = guessVal;
				upVal = valueIntegerTemp;
				downVal = n;
				if(deviation < faultVal) {
					break;
				}
			}
		}
		var result = num;
		if(upVal == 0) {
			result = intVal;
		} else if(intVal == 0) {
			if(num < 0) {
				result = "- " + upVal + "/" + downVal;
			} else {
				result = upVal + "/" + downVal;
			}
		} else {
			result = intVal + " " + upVal + "/" + downVal;
		}
		return result;
	},
	convert2DollarFraction: function(num, digitals) {
		var numStr = num.toString();
		var numArr = numStr.split(".");
		if(numArr.length == 1) {
			return num;
		}
		var part1 = numArr[0],
			part2 = digitals * ("0." + numArr[1]);
		var digLen = digitals.toString().length;
		var result = parseInt(part1) + part2 / Math.pow(10, digLen);
		return result;
	},
	convert2DollarInt: function(num, digitals) {
		var numStr = num.toString();
		var numArr = numStr.split(".");
		if(numArr.length == 1) {
			return num;
		}
		var digLen = digitals.toString().length;
		var part1 = numArr[0],
			part2 = Math.pow(10, digLen) * ("0." + numArr[1]);
		var result = parseInt(part1) + part2 / digitals;
		return result;
	},
	convertToJapaneseDBNum: function(dbNum, remindFormat, num) {
		var fm = remindFormat,
			result = num;
		if(this.startWith(remindFormat, "[$-411]")) {
			fm = remindFormat.substring(7, fm.length);
			result = Ext.util.Format.number(num, fm);
			var convertResult = "";
			for(var i = 0; i < result.length; i++) {
				var chartAtI = result.charAt(i);
				if(Ext.isNumber(Number(chartAtI))) {
					chartAtI = SCONST.CHINESE_NUM_1_16UNI[chartAtI];
				}
				convertResult = convertResult.concat(chartAtI);
			}
			result = convertResult;
		} else {
			result = Ext.util.Format.number(num, fm);
		}
		return result;
	},
	applySpecialFormat: function(num, format) {
		if(format == "rmb1") {
			return this.applyRMBBigConvert(num);
		} else if(format == "rmb2") {
			return this.applyRMBBigConvert(num, "small");
		} else if(format == "phoneus") {
			return this.applyPhoneUSConvert(num);
		} else if(format == "ssn") {
			return this.applySSNConvert(num);
		}
		return format;
	},
	applyPhoneUSConvert: function(num) {
		var parts = num.toString().split(".");
		var integer = parts[0];
		return integer.replace(/(\d+)(\d\d\d)(\d\d\d\d)/, "($1) $2-$3");
	},
	applySSNConvert: function(num) {
		var parts = num.toString().split(".");
		var integer = parts[0];
		if(integer.length < 9) {
			for(var i = integer.length; i < 9; i++) {
				integer = "0".concat(integer);
			}
		}
		return integer.replace(/(\d+)(\d\d)(\d\d\d\d)/, "$1-$2-$3");
	},
	applyRMBBigConvert: function(num, type) {
		var MAXIMUM_NUMBER = 99999999999.99;
		var CN_ZERO = "\u96F6",
			CN_ONE = "\u58F9",
			CN_TWO = "\u8D30",
			CN_THREE = "\u53C1",
			CN_FOUR = "\u8086",
			CN_FIVE = "\u4F0D",
			CN_SIX = "\u9646",
			CN_SEVEN = "\u67D2",
			CN_EIGHT = "\u634C",
			CN_NINE = "\u7396",
			CN_TEN = "\u62FE",
			CN_HUNDRED = "\u4F70",
			CN_THOUSAND = "\u4EDF",
			CN_TEN_THOUSAND = "\u4E07",
			CN_HUNDRED_MILLION = "\u4EBF",
			CN_SYMBOL = "\u4EBA\u6C11\u5E01",
			CN_DOLLAR = "\u5706",
			CN_TEN_CENT = "\u89D2",
			CN_CENT = "\u5206",
			CN_INTEGER = "\u6574";
		if(type && type == "small") {
			CN_ZERO = "\u96F6", CN_ONE = "\u4E00", CN_TWO = "\u4E8C", CN_THREE = "\u4E09", CN_FOUR = "\u56DB", CN_FIVE = "\u4E94", CN_SIX = "\u516D", CN_SEVEN = "\u4E03", CN_EIGHT = "\u516B", CN_NINE = "\u4E5D", CN_TEN = "\u5341", CN_HUNDRED = "\u767E", CN_THOUSAND = "\u5343", CN_TEN_THOUSAND = "\u4E07", CN_HUNDRED_MILLION = "\u4EBF", CN_SYMBOL = "\u4EBA\u6C11\u5E01", CN_DOLLAR = "\u5143", CN_TEN_CENT = "\u89D2", CN_CENT = "\u5206", CN_INTEGER = "\u6574";
		}
		var integral, decimal, outputCharacters, parts, digits, radices, bigRadices, decimals, zeroCount, i, p, d, quotient, modulus;
		if(num > MAXIMUM_NUMBER) {
			return num;
		}
		parts = num.toString().split(".");
		if(parts.length > 1) {
			integral = parts[0];
			decimal = parts[1];
			decimal = decimal.substr(0, 2);
		} else {
			integral = parts[0];
			decimal = "";
		}
		digits = new Array(CN_ZERO, CN_ONE, CN_TWO, CN_THREE, CN_FOUR, CN_FIVE, CN_SIX, CN_SEVEN, CN_EIGHT, CN_NINE);
		radices = new Array("", CN_TEN, CN_HUNDRED, CN_THOUSAND);
		bigRadices = new Array("", CN_TEN_THOUSAND, CN_HUNDRED_MILLION);
		decimals = new Array(CN_TEN_CENT, CN_CENT);
		outputCharacters = "";
		if(Number(integral) > 0) {
			zeroCount = 0;
			for(i = 0; i < integral.length; i++) {
				p = integral.length - i - 1;
				d = integral.substr(i, 1);
				quotient = p / 4;
				modulus = p % 4;
				if(d == "0") {
					zeroCount++;
				} else {
					if(zeroCount > 0) {
						outputCharacters += digits[0];
					}
					zeroCount = 0;
					outputCharacters += digits[Number(d)] + radices[modulus];
				}
				if(modulus == 0 && zeroCount < 4) {
					outputCharacters += bigRadices[quotient];
					zeroCount = 0;
				}
			}
			outputCharacters += CN_DOLLAR;
		}
		if(decimal != "") {
			for(i = 0; i < decimal.length; i++) {
				d = decimal.substr(i, 1);
				if(d != "0") {
					outputCharacters += digits[Number(d)] + decimals[i];
				}
			}
		}
		if(outputCharacters == "") {
			outputCharacters = CN_ZERO + CN_DOLLAR;
		}
		if(decimal == "") {
			outputCharacters += CN_INTEGER;
		}
		return outputCharacters;
	},
	getFractionWithFixedDenom: function(num, fixedDenom) {
		var intVal = 0,
			decimalsVal = 0;
		if(num > 0) {
			decimalsVal = num - Math.ceil(num) + 1;
			if(decimalsVal == 1) {
				decimalsVal = 0;
				intVal = num;
			} else {
				intVal = Math.ceil(num) - 1;
			}
		} else if(num < 0) {
			intVal = Math.ceil(num);
			decimalsVal = Math.ceil(num) - num;
		}
		var nomVal = 0,
			preVal = 0,
			posDecimalVal = Math.abs(decimalsVal);
		for(var n = 1; n <= fixedDenom; n++) {
			var currentVal = n / fixedDenom;
			if(currentVal > posDecimalVal) {
				if(currentVal - posDecimalVal > posDecimalVal - preVal) {
					nomVal = n - 1;
				} else {
					nomVal = n;
				}
				break;
			}
			preVal = currentVal;
		}
		var result = num;
		if(nomVal == 0 || decimalsVal == 0) {
			result = intVal;
		} else if(intVal == 0) {
			if(num < 0) {
				if(nomVal == fixedDenom) {
					result = -1;
				} else {
					result = "- " + nomVal + "/" + fixedDenom;
				}
			} else {
				if(nomVal == fixedDenom) {
					result = 1;
				} else {
					result = nomVal + "/" + fixedDenom;
				}
			}
		} else {
			if(nomVal == fixedDenom) {
				if(num < 0) {
					result = intVal - 1;
				} else {
					result = intVal + 1;
				}
			} else {
				result = intVal + " " + nomVal + "/" + fixedDenom;
			}
		}
		return result;
	},
	parseNumberFm: function(fm) {
		var color = null;
		if(fm.charAt(0) == "[") {
			var nextSepPos = 0,
				color = "";
			for(var i = 1; i < fm.length; i++) {
				var chartAtI = fm.charAt(i);
				if(chartAtI == "]") {
					nextSepPos = i;
					break;
				}
				color = color.concat(chartAtI);
			}
			if(nextSepPos > 0) {
				fm = fm.substring(nextSepPos + 1, fm.length);
			}
			if(HELPER.isArrayContain(SCONST.NUMBER_CUSTOM_COLOR, color.toLowerCase())) {
				color = color.toLowerCase();
			} else {
				color = null;
			}
		}
		if(color) {
			fm = "<font color=" + color + ">" + fm + "</font>";
		}
		return fm;
	},
	isInt: function(n) {
		return typeof n === "number" && n % 1 == 0;
	},
	isMoneyFormat: function(format) {
		var result = false;
		if("money" == format || "dollar" == format || "rmb" == format || "pound" == format || "euro" == format || "japanese" == format || "spanish" == format) {
			result = true;
		}
		return result;
	},
	getMoneyFormat: function(data, format) {
		var numFormat = "0,000.00";
		var moneySymbol = "$";
		if(format == "rmb") {
			moneySymbol = String.fromCharCode(165);
		}
		if(format == "pound") {
			moneySymbol = String.fromCharCode(8356);
		}
		if(format == "euro") {
			moneySymbol = String.fromCharCode(8364);
		}
		if(format == "japanese") {
			moneySymbol = String.fromCharCode(165);
		}
		var result = moneySymbol + "  " + Ext.util.Format.number(data, numFormat);
		return result;
	},
	getValueFromMoneyData: function(data) {
		data = Ext.String.trim(data.toString());
		var moneyFormats = ["$", String.fromCharCode(165), String.fromCharCode(8356), String.fromCharCode(8364)];
		for(var i = 0; i < moneyFormats.length; i++) {
			var temp = moneyFormats[i];
			data = data.replace(temp, "");
		}
		data = data.replace(/,/gi, "");
		return data;
	},
	updateToolbarMoneyPress: function(fm, menu) {
		var dollarItem = 0,
			rmbItem = 1,
			euroItem = 2,
			poundItem = 3,
			jpItem = 4,
			spanishItem = 5,
			noneItem = 6;
		var moneyClearItem = menu.items.get(noneItem);
		moneyClearItem.setDisabled(false);
		if("dollar" == fm || "money" == fm) {
			var item = menu.items.get(dollarItem);
			item.setChecked(true, true);
		} else if("rmb" == fm) {
			var item = menu.items.get(rmbItem);
			item.setChecked(true, true);
		} else if("euro" == fm) {
			var item = menu.items.get(euroItem);
			item.setChecked(true, true);
		} else if("pound" == fm) {
			var item = menu.items.get(poundItem);
			item.setChecked(true, true);
		} else if("japanese" == fm) {
			var item = menu.items.get(jpItem);
			item.setChecked(true, true);
		} else if("spanish" == fm) {
			var item = menu.items.get(spanishItem);
			item.setChecked(true, true);
		} else {
			menu.items.each(function(it) {
				if(it.checked) {
					it.setChecked(false, true);
				}
			});
			moneyClearItem.setDisabled(true);
		}
	},
	getDigitalLen: function(num) {
		var str = num.toString();
		var parts = str.split(".");
		if(str.indexOf("e") == -1 && 2 == parts.length) {
			return parts[1].length;
		}
		return 0;
	},
	fmFormatWithQuote: function(inStr) {
		var formatOk = true;
		if(this.startEndWith(inStr, "'")) {
			return false;
		}
		var arrItems = this.getArrFromMathOper(inStr, "all");
		for(var j = 0; j < arrItems.length; j++) {
			if(this.startEndWith(arrItems[j], "'")) {
				return false;
			}
		}
		return formatOk;
	},
	parseDateTime: function(inStr) {
		if(inStr) {
			var inStr = inStr.trim();
			var meetColon = false;
			var separatePos = 0;
			for(var i = inStr.length; i > 0; i--) {
				var chartAtI = inStr.charAt(i);
				if(chartAtI == ":") {
					meetColon = true;
				}
				if(meetColon && chartAtI == " ") {
					separatePos = i;
					break;
				}
			}
			var date = inStr,
				time = null;
			if(separatePos > 0) {
				date = inStr.substring(0, separatePos);
				time = inStr.substring(separatePos + 1, inStr.length);
			}
			return {
				date: date,
				time: time
			};
		} else {
			return null;
		}
	},
	parseDateTimeFM: function(inStr) {
		var inStr = inStr.trim();
		var meetColon = false;
		var separatePos = 0;
		for(var i = inStr.length; i > 0; i--) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == ":") {
				meetColon = true;
			}
			if(meetColon && chartAtI == " ") {
				separatePos = i;
				break;
			}
		}
		var dateFm = inStr,
			timeFm = null;
		if(separatePos > 0) {
			dateFm = inStr.substring(0, separatePos);
			timeFm = inStr.substring(separatePos + 1, inStr.length);
		}
		return {
			dateFm: dateFm,
			timeFm: timeFm
		};
	},
	getArrFromMathOper: function(inStr, separator) {
		var arrItems = [];
		var tempStr = "";
		for(var i = 0; i < inStr.length; i++) {
			var chartAtI = inStr.charAt(i);
			if(separator == "plus") {
				if(chartAtI == "+") {
					arrItems.push(tempStr);
					tempStr = "";
				} else {
					tempStr = tempStr.concat(chartAtI);
				}
			} else {
				if(chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/") {
					arrItems.push(tempStr);
					tempStr = "";
				} else {
					tempStr = tempStr.concat(chartAtI);
				}
			}
		}
		if(tempStr.length > 0) {
			arrItems.push(tempStr);
		}
		return arrItems;
	},
	separatedByMathOperObj: function(inStr) {
		inStr = this.strTrim(inStr);
		var firstItem = "";
		var operator = null;
		var remindItem = null;
		var meetDoubleQuote = false;
		var countParenthese = 0;
		var ignoreCount = 0;
		for(var i = 0; i < inStr.length; i++) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			} else if(chartAtI == "[" || chartAtI == "{") {
				ignoreCount = ignoreCount + 1;
			} else if(chartAtI == "]" || chartAtI == "}") {
				ignoreCount = ignoreCount - 1;
			} else if(chartAtI == "(") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == ")") {
				countParenthese = countParenthese - 1;
			}
			if(!meetDoubleQuote && ignoreCount == 0 && countParenthese == 0) {
				if(chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/") {
					operator = chartAtI;
					remindItem = inStr.substring(i + 1);
					break;
				}
			}
			firstItem = firstItem.concat(chartAtI);
		}
		return {
			firstItem: firstItem,
			operator: operator,
			remindItem: remindItem
		};
	},
	startEndWith: function(inStr, startEndStr) {
		var result = false;
		inStr = this.strTrim(inStr);
		if(this.startWith(inStr, startEndStr) && this.endWith(inStr, startEndStr)) {
			result = true;
		}
		return result;
	},
	startWith: function(inStr, startStr) {
		return inStr.substring(0, startStr.length) === startStr;
	},
	endWith: function(inStr, endStr) {
		return inStr.substring(inStr.length - endStr.length, inStr.length) === endStr;
	},
	strTrim: function(inStr) {
		var result = inStr;
		if(inStr != null) {
			result = inStr.replace(/^\s+|\s+$/g, "");
		}
		return result;
	},
	isNumber: function(inStr) {
		if(inStr == null || inStr == undefined) {
			return false;
		}
		if(typeof inStr == "string") {
			if(inStr.trim().length == 0) {
				return false;
			}
		}
		var numPart1 = Number(inStr);
		if(Ext.isNumber(numPart1)) {
			return true;
		} else {
			return false;
		}
	},
	isBoolean: function(inStr) {
		if(typeof inStr == "boolean") {
			return true;
		}
		if(typeof inStr == "string") {
			if(inStr.toLowerCase() == "true" || inStr.toLowerCase() == "false") {
				return true;
			}
		}
		return false;
	},
	getBoolean: function(inStr) {
		if(HELPER.isBoolean(inStr)) {
			if(typeof inStr == "boolean") {
				return inStr;
			}
			if(typeof inStr == "string") {
				if(inStr.toLowerCase() == "true") {
					return true;
				} else if(inStr.toLowerCase() == "false") {
					return false;
				} else {
					throw "SS_ERROR_VALUE";
				}
			}
		} else {
			throw "SS_ERROR_VALUE";
		}
	},
	isArrayContain: function(inArray, inString) {
		for(var i = 0; i < inArray.length; i++) {
			if(inArray[i] == inString) {
				return true;
			}
		}
		return false;
	},
	isArrayIncludeDateObj: function(vendors, obj) {
		var found = false;
		for(var i = 0; i < vendors.length; i++) {
			if(HELPER.convertDateToNum(vendors[i]) === HELPER.convertDateToNum(obj)) {
				found = true;
				break;
			}
		}
		return found;
	},
	convertBoolean2Int: function(inStr) {
		if(HELPER.isBoolean(inStr)) {
			if(typeof inStr == "boolean") {
				if(inStr) {
					return 1;
				} else {
					return 0;
				}
			}
			if(typeof inStr == "string") {
				if(inStr.toLowerCase() == "true") {
					return 1;
				} else if(inStr.toLowerCase() == "false") {
					return 0;
				} else {
					throw "SS_ERROR_VALUE";
				}
			}
		} else {
			throw "SS_ERROR_VALUE";
		}
	},
	convertDateToNum: function(inDate) {
		var one_day = 86400000;
		var oneNine00 = new Date(1900, 0, 0);
		var escpaeDays = Math.ceil((Ext.Date.clearTime(inDate).getTime() - Ext.Date.clearTime(oneNine00).getTime()) / one_day) + 1;
		return escpaeDays;
	},
	convertDateToTimeVal: function(inDate) {
		var totalSeconds = (inDate.getHours() * 60 + inDate.getMinutes()) * 60 + inDate.getSeconds();
		var secondsADay = 86400;
		return totalSeconds / secondsADay;
	},
	isMdyDate: function(inStr) {
		if(inStr == null || inStr == "NaN" || inStr.length < 9) {
			return false;
		}
		var j = new RegExp("^[0-1][0-9]/[0-9]{2}/[0-9]{4}$");
		if(j.test(inStr)) {
			return true;
		} else {
			return false;
		}
	},
	isSSDefaultDate: function(inStr) {
		if(inStr == null || inStr == "NaN" || inStr.length < 9) {
			return false;
		}
		var j = new RegExp("^[0-9]{4}-[0-1][0-9]-[0-9]{2}$");
		if(j.test(inStr)) {
			return true;
		} else {
			return false;
		}
	},
	calculateDate: function(inStr, num, oper) {
		var inDate = this.parseDefaultDate(inStr);
		if(oper == "+") {
			inDate = this.addDate(inDate, num);
		} else if(oper == "-") {
			inDate = this.addDate(inDate, 0 - num);
		} else if(oper == "*") {
			var temp = HELPER.convertDateToNum(inDate);
			inDate = this.addDate(inDate, temp * (num - 1));
		} else {
			throw {
				code: "calculate date operator error"
			};
		}
		return Ext.Date.format(inDate, SCONST.DEFAULT_DATE_FORMAT);
	},
	calculateNetworkDays: function(startDate, endDate, holidays) {
		return HELPER.calculateNetworkDaysIntl(startDate, endDate, 1, holidays);
	},
	calculateNetworkDaysIntl: function(startDate, endDate, weekType, holidays) {
		var startInt = HELPER.convertDateToNum(startDate);
		var endInt = HELPER.convertDateToNum(endDate);
		var isNeg = false;
		if(endInt < startInt) {
			isNeg = true;
			var temp = startInt;
			startInt = endInt;
			endInt = temp;
			var tempDate = startDate;
			startDate = endDate;
			endDate = tempDate;
		}
		var days = endInt - startInt + 1;
		var weeks = Math.floor(days / 7),
			reminder = days % 7;
		var reduceTime = weekType > 10 ? 1 : 2;
		var days = days - weeks * reduceTime;
		var weekends = SCONST.weekend_types[weekType];
		var startDay = startDate.getDay(),
			endDay = endDate.getDay();
		if(reminder > 0) {
			if(endDay >= startDay && endDay >= weekends[0] && weekends[0] >= startDay || endDay < startDay && (endDay >= weekends[0] || weekends[0] >= startDay)) {
				days = days - 1;
			}
			if(weekends.length == 2) {
				if(endDay >= startDay && endDay >= weekends[1] && weekends[1] >= startDay || endDay < startDay && (endDay >= weekends[1] || weekends[1] >= startDay)) {
					days = days - 1;
				}
			}
		}
		if(holidays && holidays.length > 0) {
			for(var i = 0; i < holidays.length; i++) {
				var tempDate = holidays[i];
				var workday = tempDate.getDay();
				if(HELPER._compare2Date(tempDate, startDate) >= 0 && HELPER._compare2Date(endDate, tempDate) >= 0) {
					if(weekends.length == 1 && weekends[0] != workday) {
						days = days - 1;
					}
					if(weekends.length == 2 && weekends[0] != workday && weekends[1] != workday) {
						days = days - 1;
					}
				}
			}
			if(days < 0) {
				days = 0;
			}
		}
		return isNeg ? 0 - days : days;
	},
	calculateWorkDay: function(startDate, days, holidays) {
		return HELPER.calculateWorkDayIntl(startDate, days, 1, holidays);
	},
	calculateWorkDayIntl: function(startDate, days, weekend_type, holidays) {
		var nextDate = startDate;
		if(days > 0) {
			nextDate = HELPER.addDate(startDate, 1);
			if(HELPER.isHolidayOrWeekend(nextDate, holidays, weekend_type) == false) {
				days = days - 1;
			}
			nextDate = this.calculateWorkDayIntl(nextDate, days, weekend_type, holidays);
		}
		if(days < 0) {
			nextDate = HELPER.addDate(startDate, -1);
			if(HELPER.isHolidayOrWeekend(nextDate, holidays, weekend_type) == false) {
				days = days + 1;
			}
			nextDate = this.calculateWorkDayIntl(nextDate, days, weekend_type, holidays);
		}
		return nextDate;
	},
	isHolidayOrWeekend: function(inDate, holidays, weekend) {
		var workday = inDate.getDay();
		var weekends = SCONST.weekend_types[weekend];
		if(weekends.length == 2 && (workday == weekends[0] || workday == weekends[1])) {
			return true;
		}
		if(weekends.length == 1 && workday == weekends[0]) {
			return true;
		}
		if(holidays && holidays.length > 0) {
			for(var i = 0; i < holidays.length; i++) {
				var tempDate = holidays[i];
				if(HELPER._compare2Date(tempDate, inDate) == 0) {
					return true;
				}
			}
		}
		return false;
	},
	calculateDateByNum: function(inStr, num, oper) {
		var inDate = this.parseDefaultDate(inStr);
		if(oper == "*") {
			return this.convertDateToNum(inDate) * num;
		} else if(oper == "/") {
			return this.convertDateToNum(inDate) / num;
		} else {
			throw {
				code: "calculate date operator error"
			};
		}
	},
	calculateDateByNum2: function(num, inStr, oper) {
		var inDate = this.parseDefaultDate(inStr);
		if(oper == "*") {
			return this.convertDateToNum(inDate) * num;
		} else if(oper == "/") {
			return num / this.convertDateToNum(inDate);
		} else if(oper == "-") {
			return num - this.convertDateToNum(inDate);
		} else {
			throw {
				code: "calculate date operator error"
			};
		}
	},
	calculate2Date: function(inStr1, inStr2, oper) {
		var result = null;
		var inDate1 = this.parseDefaultDate(inStr1);
		var inDate2 = this.parseDefaultDate(inStr2);
		if(oper == "+") {
			result = this.convertDateToNum(inDate2) + this.convertDateToNum(inDate1);
		} else if(oper == "-") {
			result = this.convertDateToNum(inDate1) - this.convertDateToNum(inDate2);
		} else if(oper == "*") {
			result = this.convertDateToNum(inDate2) * this.convertDateToNum(inDate1);
		} else if(oper == "/") {
			result = this.convertDateToNum(inDate1) / this.convertDateToNum(inDate2);
		}
		return result;
	},
	addDate: function(inDate, num) {
		inDate.setDate(inDate.getDate() + num);
		return inDate;
	},
	_compare2Date: function(date1, date2) {
		return date1 - date2;
	},
	calDifferentDateByMethod: function(enddate, startdate, method) {
		var yearDiffDays = 0,
			monthDiffDays = 0,
			dayDiffDays = 0,
			startday = 0,
			endday = 0;
		yearDiffDays = (enddate.getYear() - startdate.getYear()) * 360;
		monthDiffDays = (enddate.getMonth() - startdate.getMonth()) * 30;
		if(method) {
			if(startdate.getDate() == 31) {
				startday = 30;
			} else {
				startday = startdate.getDate();
			}
			if(enddate.getDate() == 31) {
				endday = 30;
			} else {
				endday = enddate.getDate();
			}
			dayDiffDays = endday - startday;
		} else {
			if(startdate.getDate() == 31) {
				startday = 30;
			} else {
				startday = startdate.getDate();
			}
			if(enddate.getDate() == 31 && startday < 30) {
				monthDiffDays = monthDiffDays + 30;
				endday = 1;
			} else if(enddate.getDate() == 31 && startday >= 30) {
				endday = 30;
			} else {
				endday = enddate.getDate();
			}
			dayDiffDays = endday - startday;
		}
		return yearDiffDays + monthDiffDays + dayDiffDays;
	},
	calDiffDateByMethod: function(enddate, startdate, method, frequency) {
		var yearDiffDays = 0,
			monthDiffDays = 0,
			dayDiffDays = 0,
			startday = 0,
			endday = 0;
		yearDiffDays = (enddate.getYear() - startdate.getYear()) * 360;
		monthDiffDays = (enddate.getMonth() - startdate.getMonth()) * 30;
		var result = 0;
		if(method == 4) {
			if(startdate.getDate() == 31) {
				startday = 30;
			} else {
				startday = startdate.getDate();
			}
			if(enddate.getDate() == 31) {
				endday = 30;
			} else {
				endday = enddate.getDate();
			}
			dayDiffDays = endday - startday;
			result = yearDiffDays + monthDiffDays + dayDiffDays;
		} else if(method == 0 || method == 2) {
			if(startdate.getDate() == 31) {
				startday = 30;
			} else {
				startday = startdate.getDate();
			}
			if(enddate.getDate() == 31 && startday < 30) {
				monthDiffDays = monthDiffDays + 30;
				endday = 1;
			} else if(enddate.getDate() == 31 && startday >= 30) {
				endday = 30;
			} else {
				endday = enddate.getDate();
			}
			dayDiffDays = endday - startday;
			result = yearDiffDays + monthDiffDays + dayDiffDays;
		} else if(method == 1) {
			result = this.convertDateToNum(enddate) - this.convertDateToNum(startdate);
		} else if(method == 3) {
			return 365 / frequency;
		}
		return result;
	},
	_isLeapYear: function(year) {
		var result = (year % 400 === 0 || year % 4 === 0 && year % 100 !== 0) || year === 1900;
		return result;
	},
	_actualDaysPerYear: function(from, to) {
		var y1 = from.getFullYear();
		var y2 = to.getFullYear();
		var d1, d2;
		var feb29s, years;
		d1 = from;
		d1.setFullYear(d1.getFullYear() + 1);
		if(HELPER._compare2Date(to, d1) > 0) {
			years = y2 + 1 - y1;
			d1 = new Date(y1, 0, 1);
			d2 = new Date(y2 + 1, 0, 1);
			var diffDate = HELPER.convertDateToNum(d2) - HELPER.convertDateToNum(d1);
			feb29s = diffDate - 365 * (y2 + 1 - y1);
		} else {
			years = 1;
			if(HELPER._isLeapYear(y1) && from.getMonth() < 3 || HELPER._isLeapYear(y2) && to.getMonth() * 256 + to.getDate() >= 541) {
				feb29s = 1;
			} else {
				feb29s = 0;
			}
		}
		var d = feb29s / years;
		return 365 + d;
	},
	includeBasicMathOper: function(inStr) {
		var result = false;
		var j = new RegExp;
		j.compile("\\+|-|\\*|\\/");
		if(j.test(inStr)) {
			result = true;
		}
		return result;
	},
	removeParentheses: function(inStr) {
		var result = this.strTrim(inStr);
		if(this.startWith(result, "(") && this.endWith(result, ")")) {
			var temp = result.substring(1, result.length - 1);
			var leftPar = temp.indexOf("("),
				rightPar = temp.indexOf(")");
			if(leftPar == -1 || rightPar == -1) {
				result = temp;
			}
		}
		return result;
	},
	trimAndIncludeQuote: function(inStr) {
		var result = false;
		if(Ext.isString(inStr)) {
			inStr = inStr.replace(/^\s+|\s+$/g, "");
			if(inStr.charAt(inStr.length - 1) == "\"" && inStr.charAt(0) == "\"" || inStr.charAt(inStr.length - 1) == "'" && inStr.charAt(0) == "'") {
				result = true;
			}
		}
		return result;
	},
	trimAndRemoveQuote: function(inStr) {
		var result;
		if(Ext.isString(inStr)) {
			result = inStr.replace(/^\s+|\s+$/g, "");
			result = result.replace(/^"|"$/g, "");
			result = result.replace(/^'|'$/g, "");
		}
		return result;
	},
	whetherInQuote: function(str, index) {
		var sqNum = 0,
			dqNum = 0;
		for(var i = 0; i <= index; i++) {
			var chr = str.charCodeAt(i);
			if(34 === chr) {
				dqNum++;
			}
			if(39 === chr) {
				sqNum++;
			}
		}
		return 1 == sqNum % 2 || 1 == dqNum % 2;
	},
	whetherInFun: function(str, index) {
		var inFunFlg = false,
			emb = 0;
		for(var i = index - 1; 0 <= i; i--) {
			var chr = str.charAt(i);
			if("(" == chr) {
				emb++;
			} else if(")" == chr) {
				emb--;
			}
			if(0 < emb && "]" == str.charAt(i - 1)) {
				var fname = "";
				for(var j = i - 3; j >= 0; j--) {
					var ch = str.charAt(j);
					if("\"" == ch) {
						break;
					}
					fname = ch + fname;
				}
				if("condition" === fname) {
					inFunFlg = false;
				} else {
					inFunFlg = true;
				}
				break;
			}
		}
		return inFunFlg;
	},
	validateURL: function(url) {
		if(url) {
			url = url.toString();
			var myURL = url.trim();
			if(myURL.length != 0) {
				var j = new RegExp;
				j.compile(/^[a-z]+:\/\/[a-z0-9-]+\.[a-z0-9]+/gi);
				if(j.test(myURL)) {
					return true;
				}
			}
		}
		return false;
	},
	validateURLWithErrorMsg: function(url) {
		if(url) {
			var myURL = url.toString().trim();
			if(myURL.length > 0 && /\S+\.\S+$/i.test(myURL)) {
				var j = new RegExp("^(((ht|f)tp(s?))://)?(www.|[a-zA-Z0-9-.@]+)(com|edu|gov|mil|net|org|biz|info|name|museum|asia|[a-zA-Z]{2})(:[0-9]+)*(/($|[a-zA-Z0-9.,;?'\\+&amp;%$#=~_-]+))*$");
				if(j.test(myURL)) {
					return true;
				}
			}
		}
		return "URL should be in format: \"http://www.google.com\"";
	},
	generateHyperlink: function(html, obj) {
		if(Ext.ss.common.Helper.validateURLWithErrorMsg(html) == true) {
			var css = obj.css || "";
			obj.hyperlink = html;
			if(css && css.indexOf(SCONST.cssHash[4]) == -1 || !css) {
				css += " " + SCONST.cssHash[4];
				obj.css = css;
			}
		}
	},
	getlastday: function(date) {
		var tmpdate = new Date(date.getYear(), date.getMonth() + 1, 1);
		var tmpdate = new Date(tmpdate - 86400000);
		return tmpdate.getDate();
	},
	convertPercent2num: function(inStr) {
		var modeFlag = false;
		inStr = inStr.replace(/[0-9]+(\.)?[0-9]*%/g, function(w) {
			var matchPos = arguments[arguments.length - 2];
			if(Ext.ss.common.Helper.whetherInQuote(inStr, matchPos + w.length - 1)) {
				return w;
			}
			var next = inStr.charAt(matchPos + w.length);
			if(next && /[0-9]/gi.test(next)) {
				modeFlag = true;
				return w;
			}
			var r = w.replace("%", "");
			return Number(r) / 100;
		});
		if(modeFlag) {
			inStr += ";throw \"SS_ERROR_VALUE\";";
		}
		return inStr;
	},
	convertPercent2num2: function(inStr) {
		if(typeof inStr === "string" && inStr.substr(-1) === "%") {
			var result = parseFloat(inStr) / 100;
			return result;
		} else {
			return inStr;
		}
	},
	unwrapLink: function(url) {
		var flag = false;
		if(url) {
			var myURL = url.toString().trim();
			if(Ext.ss.common.Mask.isLink(myURL)) {
				flag = true;
				var parts = myURL.split(">", 1);
				url = parts[0].slice(9, -1);
			}
		}
		return {
			url: url,
			flag: flag
		};
	},
	wrapLink: function(url) {
		return "<a href=\"" + url + "\">" + url + "</a>";
	},
	isEmptyValue: function(val) {
		if(val == null || false == Ext.typeOf(val)) {
			return true;
		}
		var s = val.toString().trim();
		if("" === s) {
			return true;
		}
		return false;
	},
	updateCompareCondition: function(val) {
		val = val.toString().trim();
		var compareFlag = /^\s*[!<>=]/gi.test(val);
		if(compareFlag) {
			val = val.toString().trim();
			if(val.length > 1) {
				if(val.substring(0, 1) == "=" && val.substring(1, 2) != "=") {
					val = "=" + val;
				}
				var firstPart = val.substring(0, 1);
				var secondPart = val.slice(1);
				var first2ndPart = secondPart.substring(0, 1);
				if(first2ndPart == "=" || first2ndPart == ">" || first2ndPart == "<") {
					firstPart = val.substring(0, 2);
					secondPart = val.slice(2);
					if(firstPart == "<>") {
						firstPart = "!=";
					}
				}
				secondPart = HELPER.convertPercent2num2(secondPart.trim());
				if(Ext.isNumber(Number(secondPart))) {
					return firstPart.concat(secondPart);
				} else {
					return firstPart.concat("\"").concat(secondPart).concat("\"");
				}
			}
		}
		return val;
	},
	roundUpNonZero: function(val) {
		var numFormat = "0.00000000000";
		var result = Ext.util.Format.number(val, numFormat);
		var str = result.toString();
		for(var i = str.length; i > 0; i--) {
			var tempChar = str.charAt(i - 1);
			if(tempChar != "0") {
				if(tempChar == ".") {
					return str.substr(0, i - 1);
				} else {
					return str.substr(0, i);
				}
			}
		}
		return val;
	},
	valRoundUpNonZero: function(val) {
		var val = Number(val);
		if(Ext.isNumber(val)) {
			var digitalLen = Ext.ss.common.Helper.getDigitalLen(val);
			if(digitalLen > 14) {
				val = Ext.ss.common.Helper.roundUpNonZero(val);
			}
		}
		return val;
	},
	getPercentNumPart: function(str) {
		if(str) {
			str = str.toString();
			var last = str.charAt(str.length - 1);
			if("%" == last) {
				str = str.slice(0, str.length - 1);
				str = str.replace(/,/g, "");
				var num = Number(str);
				if(Ext.isNumber(num)) {
					var parts = str.split("."),
						d = 0;
					if(2 == parts.length) {
						d = parts[1].length;
					}
					d += 2;
					num = num / 100;
					str = num.toString();
					parts = str.split(".");
					var dot;
					if(2 == parts.length) {
						dot = parts[1];
						var m = Number(dot.slice(d, d + 1));
						dot = dot.slice(0, d);
						if(5 <= m) {
							m = Number(dot.charAt(dot.length - 1)) + 1;
							dot = dot.slice(0, d - 1) + m;
						}
					}
					if(dot) {
						num = parts[0] + "." + dot;
					}
					return Number(num);
				}
			}
		}
	},
	checkDataFormat: function(str, origFormat) {},
	parseDefaultDate: function(input) {
		var parts = input.split("-");
		return new Date(parts[0], parts[1] - 1, parts[2]);
	},
	stringEndsWith: function(str, suffix) {},
	isPercent: function(str) {
		var result = false;
		if(str) {
			str = str.toString();
			var last = str.charAt(str.length - 1);
			if("%" != last) {
				return false;
			}
			str = str.slice(0, str.length - 1);
			str = str.replace(/,/g, "");
			var num = Number(str);
			if(Ext.isNumber(num)) {
				result = true;
			}
		}
		return result;
	},
	isScienceFormat: function(inStr) {
		inStr = inStr.toLowerCase();
		var parts = inStr.split("e+");
		if(2 == parts.length) {
			var ePart1 = Ext.util.Format.trim(parts[0]);
			var ePart2 = Ext.util.Format.trim(parts[1]);
			if(/^[0-9.]+$/gi.test(ePart1) && /^[0-9]+$/gi.test(ePart2)) {
				return true;
			}
		}
		parts = inStr.split("e-");
		if(2 == parts.length) {
			var ePart1 = Ext.util.Format.trim(parts[0]);
			var ePart2 = Ext.util.Format.trim(parts[1]);
			if(/^[0-9.]+$/gi.test(ePart1) && /^[0-9]+$/gi.test(ePart2)) {
				return true;
			}
		}
		return false;
	},
	isCommaFormat: function(inStr) {
		if(inStr.indexOf(",") !== -1) {
			inStr = inStr.replace(/,/g, "");
			var num = Number(inStr);
			if(Ext.isNumber(num)) {
				return true;
			}
		}
		return false;
	},
	checkNumFormat: function(value) {
		if(value == null || value === undefined) {
			return null;
		}
		var str = value.toString();
		if(Ext.ss.common.Helper.isScienceFormat(str)) {
			return SCONST.FORMAT_SCIENCE;
		}
		var num = Number(str);
		if(Ext.isNumber(num)) {
			return null;
		}
		if(Ext.ss.common.Helper.isPercent(str)) {
			return SCONST.FORMAT_PERCENT;
		}
		if(Ext.ss.common.Helper.isCommaFormat(str)) {
			str = str.replace(/,/g, "");
			return SCONST.FORMAT_COMMA;
		}
		return null;
	},
	includeMathOperator: function(inStr) {
		if(inStr.indexOf("+") !== -1 || inStr.indexOf("*") !== -1 || inStr.indexOf("-") !== -1 || inStr.indexOf("/") !== -1) {
			return true;
		}
		return false;
	},
	changeCondSpecialCase: function(inStr) {
		var str = inStr.toString().trim();
		if(str != null && str.length > 2) {
			if(str.substring(0, 2) === "=*" || str.charAt(0) === "=" && str.slice(str.length - 1) === "*") {
				str = str.slice(1);
			}
		}
		return str;
	},
	repeat: function(txt, times) {
		times = Number(times);
		if(Ext.isNumber(times)) {
			if(0 > times) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "repeat"
				};
			} else if(0 == times) {
				return "";
			}
		} else {
			throw {
				code: "CAL_NO_VALUE",
				cal: "repeat"
			};
		}
		if(Ext.isNumber(txt) || Ext.isString(txt)) {
			txt = txt.toString();
			var arr = [];
			for(var i = 0; i < times; i++) {
				arr.push(txt);
			}
			return arr.join("");
		} else {
			throw {
				code: "CAL_NO_VALUE",
				cal: "repeat"
			};
		}
	},
	setBottombarStatusInSaving: function(ss) {
		ss.setStatus({
			text: feyaSoft.ss.lang.saveChanges,
			iconCls: "x-status-busy"
		});
		ss.file.inSaving = true;
		if(ss.toolbar.get(0)) {
			ss.toolbar.get(0).setDisabled(true);
		}
		if(ss.toolbar.get(1)) {
			ss.toolbar.get(1).setDisabled(true);
		}
		if(ss.toolbar.get(2)) {
			ss.toolbar.get(2).setDisabled(true);
		}
	},
	setBottombarStatusInDone: function(ss, isTemporary) {
		if(isTemporary == null || isTemporary == false) {
			ss.setStatus({
				text: feyaSoft.lang.common.saved + " " + feyaSoft.lang.common.at + " " + (new Date).format("H:i:s d/m Y"),
				iconCls: "x-status-valid"
			});
		} else {
			ss.setStatus({
				text: feyaSoft.ss.lang.newSpreadsheet,
				iconCls: "x-status-valid"
			});
		}
		delete ss.file.inSaving;
		if(ss.toolbar.get(0)) {
			ss.toolbar.get(0).setDisabled(false);
		}
		if(ss.toolbar.get(1)) {
			ss.toolbar.get(1).setDisabled(false);
		}
		if(ss.toolbar.get(2)) {
			ss.toolbar.get(2).setDisabled(false);
		}
	},
	setBottombarStatusInFailed: function(ss) {
		ss.setStatus({
			text: feyaSoft.ss.lang.fail2Save,
			iconCls: "x-status-error"
		});
		delete ss.file.inSaving;
		if(ss.toolbar.get(0)) {
			ss.toolbar.get(0).setDisabled(false);
		}
		if(ss.toolbar.get(1)) {
			ss.toolbar.get(1).setDisabled(false);
		}
		if(ss.toolbar.get(2)) {
			ss.toolbar.get(2).setDisabled(false);
		}
	},
	setBottombarStatusInProcessISIF: function(ss) {
		ss.setStatus({
			text: "Updating ISIF, please wait ...",
			iconCls: "x-status-busy"
		});
		ss.file.inSaving = true;
		if(ss.toolbar.get(0)) {
			ss.toolbar.get(0).setDisabled(true);
		}
		if(ss.toolbar.get(1)) {
			ss.toolbar.get(1).setDisabled(true);
		}
		if(ss.toolbar.get(2)) {
			ss.toolbar.get(2).setDisabled(true);
		}
	},
	setBottombarStatusEndISIF: function(ss) {
		ss.setStatus({
			text: "ISIF Changed",
			iconCls: "x-status-valid"
		});
		delete ss.file.inSaving;
		if(ss.toolbar.get(0)) {
			ss.toolbar.get(0).setDisabled(false);
		}
		if(ss.toolbar.get(1)) {
			ss.toolbar.get(1).setDisabled(false);
		}
		if(ss.toolbar.get(2)) {
			ss.toolbar.get(2).setDisabled(false);
		}
	},
	reCheckDoubleQuote: function(inStr) {
		if(this.startWith(inStr, "=+")) {
			inStr = "=" + inStr.substring(2);
		}
		var needReCal = false;
		var arrItems = HELPER.getArrFromMathOper(inStr, "plus");
		for(var j = 0; j < arrItems.length; j++) {
			var temp = HELPER.strTrim(arrItems[j]);
			if(HELPER.startEndWith(temp, "\"")) {
				var tempNumStr = temp.substring(1, temp.length - 1);
				var tempNum = Number(tempNumStr);
				if(Ext.isNumber(tempNum)) {
					arrItems[j] = tempNum;
					needReCal = true;
				}
			}
		}
		if(needReCal) {
			inStr = arrItems.join("+");
		}
		return inStr;
	},
	convertSpecialFormulaName: function(inStr) {
		var lowCalStr = inStr.toLowerCase();
		if(lowCalStr.indexOf("stdev.s(") != -1) {
			inStr = inStr.replace(/stdev.s\(/gi, "stdev_s(");
		}
		if(lowCalStr.indexOf("stdev.p(") != -1) {
			inStr = inStr.replace(/stdev.p\(/gi, "stdev_p(");
		}
		if(lowCalStr.indexOf("var.p(") != -1) {
			inStr = inStr.replace(/var.p\(/gi, "var_p(");
		}
		if(lowCalStr.indexOf("=var(") != -1) {
			inStr = inStr.replace(/=var\(/gi, "=var_orig(");
		}
		if(lowCalStr.indexOf("var.s(") != -1) {
			inStr = inStr.replace(/var.s\(/gi, "var_s(");
		}
		if(lowCalStr.indexOf("percentile.inc(") != -1) {
			inStr = inStr.replace(/percentile.inc\(/gi, "percentile_inc(");
		}
		if(lowCalStr.indexOf("percentile.exc(") != -1) {
			inStr = inStr.replace(/percentile.exc\(/gi, "percentile_exc(");
		}
		if(lowCalStr.indexOf("quartile.inc(") != -1) {
			inStr = inStr.replace(/quartile.inc\(/gi, "quartile_inc(");
		}
		if(lowCalStr.indexOf("quartile.exc(") != -1) {
			inStr = inStr.replace(/quartile.exc\(/gi, "quartile_exc(");
		}
		if(lowCalStr.indexOf("mode.sngl(") != -1) {
			inStr = inStr.replace(/mode.sngl\(/gi, "mode(");
		}
		if(lowCalStr.indexOf("expon.dist(") != -1) {
			inStr = inStr.replace(/expon.dist\(/gi, "expon_dist(");
		}
		if(lowCalStr.indexOf("rank.avg(") != -1) {
			inStr = inStr.replace(/rank.avg\(/gi, "rank_avg(");
		}
		if(lowCalStr.indexOf("rank.eq(") != -1) {
			inStr = inStr.replace(/rank.eq\(/gi, "rank_eq(");
		}
		if(lowCalStr.indexOf("binom.dist(") != -1) {
			inStr = inStr.replace(/binom.dist\(/gi, "binomdist(");
		}
		if(lowCalStr.indexOf("networkdays.intl(") != -1) {
			inStr = inStr.replace(/networkdays.intl\(/gi, "networkdays_intl(");
		}
		if(lowCalStr.indexOf("workday.intl(") != -1) {
			inStr = inStr.replace(/workday.intl\(/gi, "workday_intl(");
		}
		return inStr;
	},
	isIncludeSpecialFormulas: function(lowStr) {
		var listSpecialFormulas = SCONST.specialFormuals;
		for(var i = 0; i < listSpecialFormulas.length; i++) {
			if(lowStr.indexOf(listSpecialFormulas[i]) != -1) {
				return true;
			}
		}
		return false;
	},
	replaceBraces: function(str) {
		var newStr;
		while(true) {
			newStr = str.replace(/("[^\"]*")|('[^\']*')|({[^{}]+})/gi, function(w) {
				if(arguments[3]) {
					var match = arguments[3];
					match = match.slice(1, -1);
					var parts = match.split(";"),
						len = parts.length;
					if(1 < len) {
						for(var i = 0; i < len; i++) {
							parts[i] = "([" + parts[i] + "])";
						}
						match = parts.join(",");
					}
					return "([" + match + "])";
				} else {
					return w;
				}
			});
			if(newStr === str) {
				break;
			}
			str = newStr;
		}
		return newStr;
	},
	reCheckBracesAndExtraComma: function(str) {
		var lowStr = str.toLowerCase();
		if(HELPER.isIncludeSpecialFormulas(lowStr)) {
			str = str.replace(/\'([^ \']+)\'|\"([^ \"]+)\"|(\{)|(\})/g, function(v, m) {
				var start = arguments[5];
				if(v == "{") {
					var itm = str.substring(start + 1, start + 20);
					itm = itm.trim();
					if(itm.indexOf("{") == 0 || itm.indexOf("{") != -1 || itm.indexOf("sheetIndex:") == -1) {
						v = "[";
					}
				} else if(v == "}") {
					var itm = str.substring(start - 20, start);
					if(itm.indexOf("ab:") == -1 || itm.indexOf("}") != -1 && itm.indexOf("ab:") != -1) {
						v = "]";
					}
				}
				return v;
			});
			if(lowStr.indexOf("=type") != -1 || lowStr.indexOf("=rows") != -1 || lowStr.indexOf("=index") != -1 || lowStr.indexOf("=lookup") != -1) {
				str = str.replace(/\'([^ \']+)\'|\"([^ \"]+)\"|(\;)/g, function(v, m) {
					if(v == ";") {
						v = "],[";
					}
					return v;
				});
			} else {
				str = str.replace(/\'([^ \']+)\'|\"([^ \"]+)\"|(\;)/g, function(v, m) {
					if(v == ";") {
						v = ",";
					}
					return v;
				});
			}
		}
		if(lowStr.indexOf("=areas") != -1) {
			str = str.replace("((", "(").replace("))", ")");
		}
		if(lowStr.indexOf("=rate") != -1 || lowStr.indexOf("=sum") != -1 || lowStr.indexOf("=pv") != -1) {
			str = str.replace(/,\s*,/g, ",0,");
		}
		str = str.replace(/\(\s*,/g, "(").replace(/,\s*\)/g, ")");
		return str;
	},
	isEmptyStr: function(inStr) {
		var blankRE = /^[\s]+$/;
		if(inStr === "" || blankRE.test(inStr)) {
			return true;
		}
		return false;
	},
	formatNumber: function(num, fm) {
		if(typeof fm != "string") {
			throw {
				code: "CAL_PARAM_MISS",
				cal: "formatNumber"
			};
		}
		if(fm === "%") {
			return "%";
		}
		var finalFm = fm;
		var formatType = "decimal";
		if(fm.substr(-1) === "%") {
			formatType = "percent";
			finalFm = finalFm.slice(0, finalFm.length - 1);
			num = parseFloat(num) * 100;
		}
		finalFm = finalFm.replace(/#/g, "0").replace(/\?/g, "0");
		if(HELPER.isScienceFormat(finalFm)) {
			var value = Number(num).toExponential(2);
			return value;
		}
		var result = Ext.util.Format.number(num, finalFm);
		if(formatType === "percent") {
			result = result + "%";
		}
		return result;
	},
	replaceDateFm: function(fm) {
		if(fm && Ext.isString(fm) && fm.length > 1) {
			fm = fm.replace(/yyyy/gi, "Y").replace(/yy/gi, "y").replace(/mmmm/gi, "F").replace(/mmm/gi, "M").replace(/mm/g, "m").replace(/dddd/gi, "l").replace(/ddd/g, "D").replace(/dd/gi, "d").replace(/D/gi, "d").replace(/hh/g, "h");
			if(fm.indexOf(":m") != -1) {
				fm = fm.replace(/:m/i, ":i");
			}
			fm = fm.replace(/am\/pm/i, "A");
			fm = fm.replace(/aaaaa/i, "l").replace(/aaaa/i, "l").replace(/aaa/i, "D");
		}
		return fm;
	},
	calculateErf: function(value) {
		var a1 = 0.254829592;
		var a2 = -0.284496736;
		var a3 = 1.421413741;
		var a4 = -1.453152027;
		var a5 = 1.061405429;
		var p = 0.3275911;
		var sign = 1;
		if(value < 0) {
			sign = -1;
		}
		var x = Math.abs(value);
		var t = 1 / (1 + p * x);
		var y = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
		return sign * y;
	},
	sortNumberArray: function(inArr, order) {
		if(order == "asc") {
			return inArr.sort(function(a, b) {
				return a - b;
			});
		} else {
			return inArr.sort(function(a, b) {
				return b - a;
			});
		}
	},
	recursiveMathOpers: function(str, arrObj) {
		var separatedObj = HELPER.seperatedByMathOper(str);
		if(separatedObj) {
			arrObj.push(separatedObj);
			if(separatedObj.remindItem) {
				this.recursiveMathOpers(separatedObj.remindItem, arrObj);
			}
		}
	},
	seperatedByMathOper: function(str) {
		str = HELPER.removeParentheses(str);
		var separatedObj = HELPER.separatedByMathOperObj(str);
		if(separatedObj.firstItem == null) {
			return null;
		}
		return separatedObj;
	},
	calculateByOper: function(part1, part2, oper) {
		if(part1 == "#REF!" || part1 == "#REF!") {
			throw "SS_ERROR_REF";
		}
		if(part1 == null) {
			return part2;
		}
		if(oper == null) {
			return part1;
		}
		var numPart1 = Number(part1);
		var numPart2 = Number(part2);
		var result = null;
		if(Ext.ss.common.Helper.isSSDefaultDate(part1)) {
			if(Ext.isNumber(numPart2)) {
				if(oper == "-" || oper == "+") {
					result = Ext.ss.common.Helper.calculateDate(part1, numPart2, oper);
				} else {
					result = Ext.ss.common.Helper.calculateDateByNum(part1, numPart2, oper);
				}
			} else if(Ext.ss.common.Helper.isSSDefaultDate(part2)) {
				result = Ext.ss.common.Helper.calculate2Date(part1, part2, oper);
			} else {
				throw "SS_ERROR_VALUE";
			}
			return result;
		}
		if(Ext.ss.common.Helper.isSSDefaultDate(part2)) {
			if(Ext.isNumber(numPart1)) {
				if(oper == "+") {
					result = Ext.ss.common.Helper.calculateDate(part2, numPart1, oper);
				} else {
					result = Ext.ss.common.Helper.calculateDateByNum2(numPart1, part2, oper);
				}
			} else {
				throw "SS_ERROR_VALUE";
			}
			return result;
		}
		if(Ext.isNumber(numPart1) && Ext.isNumber(numPart2)) {
			return eval(part1 + oper + part2);
		}
		throw "SS_ERROR_VALUE";
	},
	convertPlusMinus: function(inStr, checkParenthese) {
		var result = inStr;
		if(this.startWith(inStr, "=")) {
			inStr = inStr.substring(1, inStr.length);
		}
		if(checkParenthese) {
			inStr = HELPER.removeParentheses(inStr);
		}
		var firstItem = "";
		var operator = null;
		var remindItem = null;
		var operatorPart1 = "";
		var operatorPart2 = "";
		var meetDoubleQuote = false;
		var meetSingleQuote = false;
		var ignoreCount = 0,
			preChar = null;
		for(var i = 0; i < inStr.length; i++) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			}
			if(chartAtI == "'") {
				meetSingleQuote = !meetSingleQuote;
			} else if(chartAtI == "[" || chartAtI == "{") {
				ignoreCount = ignoreCount + 1;
			} else if(chartAtI == "]" || chartAtI == "}") {
				ignoreCount = ignoreCount - 1;
			}
			if(!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0 && (chartAtI == "+" || chartAtI == "-") && "*" != preChar && "/" != preChar) {
				operator = chartAtI;
				remindItem = inStr.substring(i + 1);
				break;
			}
			firstItem = firstItem.concat(chartAtI);
			preChar = chartAtI;
		}
		if(remindItem == null) {
			return result;
		}
		if(firstItem == "" && operator == "-") {
			firstItem = "0";
		}
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for(var i = firstItem.length; i > 0; i--) {
			var chartAtI = firstItem.charAt(i - 1);
			if(chartAtI == "(" && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<") && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if(chartAtI == ")") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == "(") {
				countParenthese = countParenthese - 1;
			}
			operatorPart1 = chartAtI + operatorPart1;
		}
		if(firstPartSepPos == 0) {
			firstItem = "";
		} else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		operatorPart1 = this.strTrim(operatorPart1);
		if(operatorPart1.length == 0) {
			operatorPart1 = "0";
		}
		countParenthese = 0;
		var secondPartSepPos = 0;
		for(var i = 0; i < remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			if(chartAtI == ")" && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<") && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if((chartAtI == "+" || chartAtI == "-") && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(chartAtI == "(") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == ")") {
				countParenthese = countParenthese - 1;
			}
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		if(secondPartSepPos == 0) {
			remindItem = "";
		} else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
		operatorPart2 = this.strTrim(operatorPart2);
		if(operatorPart2.length > 0) {
			if(Ext.isNumber(Number(operatorPart1)) && Ext.isNumber(Number(operatorPart2))) {
				return result;
			}
			if(/[0-9.]+e$/i.test(operatorPart1) && Ext.isNumber(Number(operatorPart2))) {
				return result;
			}
			if(operator == "+") {
				result = "=" + firstItem + "overwriteplus(" + operatorPart1 + "," + operatorPart2 + ")" + remindItem;
			} else if(operator == "-") {
				result = "=" + firstItem + "overwriteminus(" + operatorPart1 + "," + operatorPart2 + ")" + remindItem;
			}
			return this.convertPlusMinus(result, false);
		}
		return result;
	},
	convertMulDiv: function(inStr) {
		var result = inStr;
		if(this.startWith(inStr, "=")) {
			inStr = inStr.substring(1, inStr.length);
		}
		var firstItem = "";
		var operator = null;
		var remindItem = null;
		var operatorPart1 = "";
		var operatorPart2 = "";
		var meetDoubleQuote = false;
		var meetSingleQuote = false;
		var ignoreCount = 0;
		for(var i = 0; i < inStr.length; i++) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			}
			if(chartAtI == "'") {
				meetSingleQuote = !meetSingleQuote;
			} else if(chartAtI == "[" || chartAtI == "{") {
				ignoreCount = ignoreCount + 1;
			} else if(chartAtI == "]" || chartAtI == "}") {
				ignoreCount = ignoreCount - 1;
			}
			if(!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0 && (chartAtI == "*" || chartAtI == "/")) {
				operator = chartAtI;
				remindItem = inStr.substring(i + 1);
				break;
			}
			firstItem = firstItem.concat(chartAtI);
		}
		if(remindItem == null) {
			return result;
		}
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for(var i = firstItem.length; i > 0; i--) {
			var chartAtI = firstItem.charAt(i - 1);
			if(chartAtI == "(" && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<" || chartAtI == "+" || chartAtI == "-") && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if(chartAtI == ")") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == "(") {
				countParenthese = countParenthese - 1;
			}
			operatorPart1 = chartAtI + operatorPart1;
		}
		if(firstPartSepPos == 0) {
			firstItem = "";
		} else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		operatorPart1 = this.strTrim(operatorPart1);
		if(operatorPart1.length == 0) {
			return result;
		}
		countParenthese = 0;
		var secondPartSepPos = 0;
		for(var i = 0; i < remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			if(chartAtI == ")" && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<" || chartAtI == "+" || chartAtI == "-") && countParenthese == 0) {
				if(i == 0 && (chartAtI == "-" || chartAtI == "+")) {
					operatorPart2 = operatorPart2.concat(chartAtI);
					continue;
				} else {
					secondPartSepPos = i;
					break;
				}
			}
			if((chartAtI == "*" || chartAtI == "/") && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(chartAtI == "(") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == ")") {
				countParenthese = countParenthese - 1;
			}
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		if(secondPartSepPos == 0) {
			remindItem = "";
		} else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
		operatorPart2 = this.strTrim(operatorPart2);
		if(operatorPart2.length > 0) {
			if(Ext.isNumber(Number(operatorPart1)) && Ext.isNumber(Number(operatorPart2))) {
				return result;
			}
			if(operator == "*") {
				result = "=" + firstItem + "overwritemultiple(" + operatorPart1 + "," + operatorPart2 + ")" + remindItem;
			} else if(operator == "/") {
				result = "=" + firstItem + "overwritedivide(" + operatorPart1 + "," + operatorPart2 + ")" + remindItem;
			}
			return this.convertMulDiv(result);
		}
		return result;
	},
	convertPower: function(inStr) {
		var result = inStr;
		if(this.startWith(inStr, "=")) {
			inStr = inStr.substring(1, inStr.length);
		}
		var firstItem = "";
		var operator = null;
		var remindItem = null;
		var operatorPart1 = "";
		var operatorPart2 = "";
		var meetDoubleQuote = false;
		var meetSingleQuote = false;
		var ignoreCount = 0;
		for(var i = 0; i < inStr.length; i++) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			}
			if(chartAtI == "'") {
				meetSingleQuote = !meetSingleQuote;
			} else if(chartAtI == "[" || chartAtI == "{") {
				ignoreCount = ignoreCount + 1;
			} else if(chartAtI == "]" || chartAtI == "}") {
				ignoreCount = ignoreCount - 1;
			}
			if(!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0 && chartAtI == "^") {
				operator = chartAtI;
				remindItem = inStr.substring(i + 1);
				break;
			}
			firstItem = firstItem.concat(chartAtI);
		}
		if(remindItem == null) {
			return result;
		}
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for(var i = firstItem.length; i > 0; i--) {
			var chartAtI = firstItem.charAt(i - 1);
			if(chartAtI == "(" && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<" || chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/") && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if(chartAtI == ")") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == "(") {
				countParenthese = countParenthese - 1;
			}
			operatorPart1 = chartAtI + operatorPart1;
		}
		if(firstPartSepPos == 0) {
			firstItem = "";
		} else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		operatorPart1 = this.strTrim(operatorPart1);
		if(operatorPart1.length == 0) {
			return result;
		}
		countParenthese = 0;
		var secondPartSepPos = 0;
		for(var i = 0; i < remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			if(chartAtI == ")" && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if((chartAtI == "," || chartAtI == "=" || chartAtI == ">" || chartAtI == "<" || chartAtI == "+" || chartAtI == "-" || chartAtI == "*" || chartAtI == "/") && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(chartAtI == "^" && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(chartAtI == "(") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == ")") {
				countParenthese = countParenthese - 1;
			}
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		if(secondPartSepPos == 0) {
			remindItem = "";
		} else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
		operatorPart2 = this.strTrim(operatorPart2);
		if(operatorPart2.length > 0) {
			if(operator == "^") {
				result = "=" + firstItem + "power(" + operatorPart1 + "," + operatorPart2 + ")" + remindItem;
			}
			return this.convertPower(result);
		}
		return result;
	},
	__checkFirstPart: function() {},
	__checkSecondPart: function() {},
	convertCondition: function(inStr, overwriteFnName, needRemoveParenthese) {
		var result = inStr;
		var firstChar = "";
		if(this.startWith(inStr, "=")) {
			inStr = inStr.substring(1, inStr.length);
			firstChar = "=";
		}
		var firstItem = "";
		var operator = null;
		var remindItem = null;
		var operatorPart1 = "";
		var operatorPart2 = "";
		var meetDoubleQuote = false;
		var meetSingleQuote = false;
		var ignoreCount = 0,
			strLen = inStr.length;
		for(var i = 0; i < strLen; i++) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			}
			if(chartAtI == "'") {
				meetSingleQuote = !meetSingleQuote;
			} else if(chartAtI == "[" || chartAtI == "{") {
				ignoreCount = ignoreCount + 1;
			} else if(chartAtI == "]" || chartAtI == "}") {
				ignoreCount = ignoreCount - 1;
			}
			if(!meetDoubleQuote && !meetSingleQuote && ignoreCount == 0 && (chartAtI == ">" || chartAtI == "<" || chartAtI == "=")) {
				operator = chartAtI;
				if(strLen > i) {
					var nextChart = inStr.charAt(i + 1);
					if(nextChart == ">" || nextChart == "<" || nextChart == "=") {
						operator += nextChart;
						i += 1;
					}
				}
				remindItem = inStr.substring(i + 1);
				break;
			}
			firstItem = firstItem.concat(chartAtI);
		}
		if(remindItem == null) {
			return result;
		}
		var firstPartSepPos = 0;
		var countParenthese = 0;
		for(var i = firstItem.length; i > 0; i--) {
			var chartAtI = firstItem.charAt(i - 1);
			if(chartAtI == "(" && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if(chartAtI == "," && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if(chartAtI == ")") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == "(") {
				countParenthese = countParenthese - 1;
			}
			operatorPart1 = chartAtI + operatorPart1;
		}
		if(firstPartSepPos == 0) {
			firstItem = "";
		} else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		operatorPart1 = this.strTrim(operatorPart1);
		if(operatorPart1.length == 0) {
			return result;
		}
		countParenthese = 0;
		var secondPartSepPos = 0;
		for(var i = 0; i < remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			if(chartAtI == ")" && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(chartAtI == "," && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if((chartAtI == ">" || chartAtI == "<" || chartAtI == "=") && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(chartAtI == "(") {
				countParenthese = countParenthese + 1;
			} else if(chartAtI == ")") {
				countParenthese = countParenthese - 1;
			}
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		if(secondPartSepPos == 0) {
			remindItem = "";
		} else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
		operatorPart2 = this.strTrim(operatorPart2);
		if(operatorPart2.length > 0) {
			if(operator) {
				if(needRemoveParenthese && remindItem.charAt(0) == ")" && firstItem.slice(-1) == "(") {
					remindItem = remindItem.substr(1);
					firstItem = firstItem.slice(0, -1);
					if(firstItem.slice(-1) == "*") {
						firstItem = firstItem.slice(0, -1) + ",";
					}
				}
				result = firstChar + firstItem + overwriteFnName + "(" + operatorPart1 + ",'" + operator + "'," + operatorPart2 + ")" + remindItem;
			} else {
				return inStr;
			}
			return this.convertCondition(result, overwriteFnName, needRemoveParenthese);
		}
		return result;
	},
	convertAndSymbol: function(inStr, checkParenthese) {
		var result = inStr;
		if(this.startWith(inStr, "=")) {
			inStr = inStr.substring(1, inStr.length);
		}
		if(checkParenthese) {
			inStr = HELPER.removeParentheses(inStr);
		}
		var firstItem = "";
		var remindItem = null;
		var operatorPart1 = "";
		var operatorPart2 = "";
		var meetDoubleQuote = false;
		var meetSingleQuote = false;
		var ignoreCount = 0;
		for(var i = 0; i < inStr.length; i++) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			} else if(!meetDoubleQuote && (chartAtI == "[" || chartAtI == "{")) {
				ignoreCount = ignoreCount + 1;
			} else if(!meetDoubleQuote && (chartAtI == "]" || chartAtI == "}")) {
				ignoreCount = ignoreCount - 1;
			}
			if(!meetDoubleQuote && ignoreCount == 0 && chartAtI == "&") {
				remindItem = inStr.substring(i + 1);
				break;
			}
			firstItem = firstItem.concat(chartAtI);
		}
		if(remindItem == null) {
			return result;
		}
		var firstPartSepPos = 0,
			countParenthese = 0;
		meetDoubleQuote = false;
		for(var i = firstItem.length; i > 0; i--) {
			var chartAtI = firstItem.charAt(i - 1);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			} else if(!meetDoubleQuote && chartAtI == "(" && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if(!meetDoubleQuote && chartAtI == "," && countParenthese == 0) {
				firstPartSepPos = i;
				break;
			}
			if(!meetDoubleQuote && chartAtI == ")") {
				countParenthese = countParenthese + 1;
			} else if(!meetDoubleQuote && chartAtI == "(") {
				countParenthese = countParenthese - 1;
			}
			operatorPart1 = chartAtI + operatorPart1;
		}
		if(firstPartSepPos == 0) {
			firstItem = "";
		} else {
			firstItem = firstItem.substring(0, firstPartSepPos);
		}
		operatorPart1 = this.strTrim(operatorPart1);
		if(operatorPart1.length == 0) {
			return result;
		}
		countParenthese = 0;
		var secondPartSepPos = 0;
		for(var i = 0; i < remindItem.length; i++) {
			var chartAtI = remindItem.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			} else if(!meetDoubleQuote && chartAtI == ")" && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(!meetDoubleQuote && chartAtI == "," && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(!meetDoubleQuote && chartAtI == "&" && countParenthese == 0) {
				secondPartSepPos = i;
				break;
			}
			if(!meetDoubleQuote && chartAtI == "(") {
				countParenthese = countParenthese + 1;
			} else if(!meetDoubleQuote && chartAtI == ")") {
				countParenthese = countParenthese - 1;
			}
			operatorPart2 = operatorPart2.concat(chartAtI);
		}
		if(secondPartSepPos == 0) {
			remindItem = "";
		} else {
			remindItem = remindItem.substring(secondPartSepPos);
		}
		operatorPart2 = this.strTrim(operatorPart2);
		if(operatorPart2.length > 0) {
			result = "=" + firstItem + "overwriteAnd(" + operatorPart1 + "," + operatorPart2 + ")" + remindItem;
			if(remindItem && remindItem.indexOf("&") != -1) {
				return this.convertAndSymbol(result, false);
			}
		}
		return result;
	},
	fromToUnitData: [
		["g", "weightAndMass", 1],
		["sg", "weightAndMass", 14593.90294],
		["lbm", "weightAndMass", 453.59237],
		["u", "weightAndMass", 1.66053e-24],
		["ozm", "weightAndMass", 28.349523125],
		["m", "distance", 1],
		["mi", "distance", 1609.344],
		["Nmi", "distance", 1852],
		["in", "distance", 0.0254],
		["ft", "distance", 0.3048],
		["yd", "distance", 0.9144],
		["ang", "distance", 1e-10],
		["Pica", "distance", 0.000352778],
		["yr", "time", 31557600],
		["day", "time", 86400],
		["hr", "time", 3600],
		["mn", "time", 60],
		["sec", "time", 1],
		["Pa", "pressure", 1],
		["p", "pressure", 1],
		["at", "pressure", 101325],
		["atm", "pressure", 101325],
		["mmHg", "pressure", 133.3223684],
		["N", "force", 1],
		["dyn", "force", 0.00001],
		["dy", "force", 0.00001],
		["lbf", "force", 4.448221615],
		["J", "energy", 1],
		["e", "energy", 1e-7],
		["c", "energy", 4.184],
		["cal", "energy", 4.1868],
		["ev", "energy", 1.60219e-19],
		["eV", "energy", 1.60219e-19],
		["HPh", "energy", 2684519.5368856],
		["hh", "energy", 2684519.538],
		["Wh", "energy", 3600],
		["wh", "energy", 3600],
		["flb", "energy", 1.355817948],
		["btu", "energy", 1055.055853],
		["BTU", "energy", 1055.055853],
		["HP", "power", 745.6998716],
		["h", "power", 745.6998716],
		["W", "power", 1],
		["w", "power", 1],
		["T", "magnetism", 10000],
		["ga", "magnetism", 1],
		["C", "temperature", 1],
		["cel", "temperature", 1],
		["F", "temperature", 33.8],
		["fah", "temperature", 33.8],
		["K", "temperature", 274.15],
		["kel", "temperature", 274.15],
		["tsp", "liquidMeasure", 1],
		["tbs", "liquidMeasure", 3],
		["oz", "liquidMeasure", 6],
		["cup", "liquidMeasure", 48],
		["pt", "liquidMeasure", 96],
		["us_pt", "liquidMeasure", 96],
		["uk_pt", "liquidMeasure", 96],
		["qt", "liquidMeasure", 192],
		["gal", "liquidMeasure", 768],
		["l", "liquidMeasure", 202.8841362],
		["lt", "liquidMeasure", 202.8841362]
	],
	getGDA: function(cost, remindVal, endVal, period, factor) {
		var result, costVal, startVal, tempVal = factor / endVal;
		if(tempVal >= 1) {
			tempVal = 1;
			if(period === 1) {
				costVal = cost;
			} else {
				costVal = 0;
			}
		} else {
			costVal = cost * Math.pow(1 - tempVal, period - 1);
		}
		startVal = cost * Math.pow(1 - tempVal, period);
		if(startVal < remindVal) {
			result = costVal - remindVal;
		} else {
			result = costVal - startVal;
		}
		if(result < 0) {
			result = 0;
		}
		return result;
	},
	getVDB: function(cost, salvage, life, life1, period, factor) {
		var result = 0,
			endPeriod = Math.ceil(period);
		var termVal, tempVal = 0,
			iCost = cost - salvage,
			judge = false,
			gdaVal = 0;
		for(var i = 1; i <= endPeriod; i++) {
			if(!judge) {
				gdaVal = HELPER.getGDA(cost, salvage, life, i, factor);
				tempVal = iCost / (life1 - (i - 1));
				if(tempVal > gdaVal) {
					termVal = tempVal;
					judge = true;
				} else {
					termVal = gdaVal;
					iCost -= gdaVal;
				}
			} else {
				termVal = tempVal;
			}
			if(i === endPeriod) {
				termVal *= period + 1 - endPeriod;
			}
			result += termVal;
		}
		return result;
	},
	IMREAL: function(inumber) {
		if(inumber === 0 || inumber === "0") {
			return 0;
		}
		if(["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(inumber) >= 0) {
			return 0;
		}
		var plus = inumber.indexOf("+");
		var minus = inumber.indexOf("-");
		if(plus === 0) {
			plus = inumber.indexOf("+", 1);
		}
		if(minus === 0) {
			minus = inumber.indexOf("-", 1);
		}
		var last = inumber.substring(inumber.length - 1, inumber.length);
		var unit = last === "i" || last === "j";
		if(plus >= 0 || minus >= 0) {
			if(!unit) {}
			if(plus >= 0) {
				return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? "#NUM!" : Number(inumber.substring(0, plus));
			} else {
				return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? "#NUM!" : Number(inumber.substring(0, minus));
			}
		} else {
			if(unit) {
				return isNaN(inumber.substring(0, inumber.length - 1)) ? "#NUM!" : 0;
			} else {
				return isNaN(inumber) ? "#NUM!" : Number(inumber);
			}
		}
	},
	IMAGINARY: function(inumber) {
		if(inumber === 0 || inumber === "0") {
			return 0;
		}
		if(["i", "j"].indexOf(inumber) >= 0) {
			return 1;
		}
		inumber = inumber.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
		var plus = inumber.indexOf("+");
		var minus = inumber.indexOf("-");
		if(plus === 0) {
			plus = inumber.indexOf("+", 1);
		}
		if(minus === 0) {
			minus = inumber.indexOf("-", 1);
		}
		var last = inumber.substring(inumber.length - 1, inumber.length);
		var unit = last === "i" || last === "j";
		if(plus >= 0 || minus >= 0) {
			if(!unit) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "IMAGINARY"
				};
			}
			if(plus >= 0) {
				return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? "#NUM!" : Number(inumber.substring(plus + 1, inumber.length - 1));
			} else {
				return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? "#NUM!" : -Number(inumber.substring(minus + 1, inumber.length - 1));
			}
		} else {
			if(unit) {
				return isNaN(inumber.substring(0, inumber.length - 1)) ? "#NUM!" : inumber.substring(0, inumber.length - 1);
			} else {
				return isNaN(inumber) ? "#NUM!" : 0;
			}
		}
	},
	IMARGUMENT: function(inumber) {
		var x = HELPER.IMREAL(inumber);
		var y = HELPER.IMAGINARY(inumber);
		if(x === "#NUM!" || y === "#NUM!") {
			return "#NUM!";
		}
		if(x === 0 && y === 0) {
			throw {
				code: "SS_ERROR_INFINITY",
				cal: "IMARGUMENT"
			};
		}
		if(x === 0 && y > 0) {
			return Math.PI / 2;
		}
		if(x === 0 && y < 0) {
			return -Math.PI / 2;
		}
		if(y === 0 && x > 0) {
			return 0;
		}
		if(y === 0 && x < 0) {
			return -Math.PI;
		}
		if(x > 0) {
			return Math.atan(y / x);
		} else if(x < 0 && y >= 0) {
			return Math.atan(y / x) + Math.PI;
		} else {
			return Math.atan(y / x) - Math.PI;
		}
	},
	IMDIV: function(inumber1, inumber2) {
		var a = HELPER.IMREAL(inumber1);
		var b = HELPER.IMAGINARY(inumber1);
		var c = HELPER.IMREAL(inumber2);
		var d = HELPER.IMAGINARY(inumber2);
		var unit1 = inumber1.substring(inumber1.length - 1);
		var unit2 = inumber1.substring(inumber1.length - 1);
		var unit = "i";
		if(unit1 === "j") {
			unit = "j";
		} else if(unit2 === "j") {
			unit = "j";
		}
		if(a === "#NUM!" || b === "#NUM!" || c === "#NUM!" || d === "#NUM!") {
			return "#NUM!";
		}
		if(c === 0 && d === 0) {
			return "#NUM!";
		}
		var den = c * c + d * d;
		return HELPER.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
	},
	COMPLEX: function(real, imaginary, suffix) {
		if(isNaN(real) || isNaN(imaginary)) {
			throw {
				code: "VALUE_NOT_AVAILABLE",
				cal: "COMPLEX"
			};
		}
		var suffix = typeof suffix === "undefined" ? "i" : suffix;
		if(suffix !== "i" && suffix !== "j") {
			throw {
				code: "VALUE_NOT_AVAILABLE",
				cal: "COMPLEX"
			};
		}
		if(real === 0 && imaginary === 0) {
			return 0;
		} else if(real === 0) {
			var digitalLen = HELPER.getDigitalLen(imaginary);
			if(digitalLen > 13) {
				imaginary = HELPER.roundUpNonZero(imaginary);
			}
			return imaginary === 1 ? suffix : imaginary.toString() + suffix;
		} else if(imaginary === 0) {
			var digitalLen = HELPER.getDigitalLen(real);
			if(digitalLen > 13) {
				real = HELPER.roundUpNonZero(real);
			}
			return real.toString();
		} else {
			var digitalLen = HELPER.getDigitalLen(real);
			if(digitalLen > 13) {
				real = HELPER.roundUpNonZero(real);
			}
			digitalLen = HELPER.getDigitalLen(imaginary);
			if(digitalLen > 13) {
				imaginary = HELPER.roundUpNonZero(imaginary);
			}
			var sign = imaginary > 0 ? "+" : "";
			return real.toString() + sign + (imaginary === 1 ? suffix : imaginary.toString() + suffix);
		}
	},
	convertIftruefalseCdt: function(inputFormula) {
		var paras = HELPER.getFormulaParas(inputFormula, "if");
		var itemPart1 = null,
			itemPart2 = null,
			itemPart3 = null,
			temp = "",
			totalComma = 0;
		var meetDoubleQuote = false,
			meetSingleQuote = false;
		var ignoreCount = 0,
			strLen = paras.length;
		for(var i = 0; i < strLen; i++) {
			var chartAtI = paras.charAt(i);
			if(chartAtI == "\"") {
				meetDoubleQuote = !meetDoubleQuote;
			} else if(chartAtI == "'") {
				meetSingleQuote = !meetSingleQuote;
			} else if(chartAtI == "[" || chartAtI == "{" || chartAtI == "(") {
				ignoreCount = ignoreCount + 1;
			} else if(chartAtI == "]" || chartAtI == "}" || chartAtI == ")") {
				ignoreCount = ignoreCount - 1;
			}
			if(ignoreCount == 0 && !meetDoubleQuote && !meetSingleQuote && chartAtI == ",") {
				if(itemPart1 == null) {
					itemPart1 = temp;
				} else if(itemPart2 == null) {
					itemPart2 = temp;
				} else if(itemPart3 == null) {
					itemPart3 = temp;
				}
				temp = "";
				totalComma++;
			} else {
				temp = temp.concat(chartAtI);
			}
		}
		if(totalComma > 2) {
			return inputFormula;
		}
		if(itemPart2 == null) {
			itemPart2 = temp;
		} else if(itemPart3 == null) {
			itemPart3 = temp;
		}
		if(itemPart2 != null && !Ext.isNumber(itemPart2)) {
			itemPart2 = "function() {return (" + itemPart2 + ")}";
		}
		if(itemPart3 != null && !Ext.isNumber(itemPart3)) {
			itemPart3 = "function() {return (" + itemPart3 + ")}";
		}
		var replacedParas = itemPart1 + "," + itemPart2 + "," + itemPart3;
		return inputFormula.replace(paras, replacedParas);
	},
	convertFormulaCondition: function(inStr, formulaname) {
		var paras = HELPER.getFormulaParas(inStr, formulaname);
		var newParas = HELPER.convertCondition(paras, "overwriteArrCompareCond", true);
		return inStr.replace(paras, newParas);
	},
	getFormulaParas: function(inStr, formulaName) {
		var result = "";
		var parts = inStr.toLowerCase().split(formulaName + "(");
		var len = parts[0].length + formulaName.length + 1;
		var countParenthese = 0;
		for(var i = len; i < inStr.length; i++) {
			var chartAtI = inStr.charAt(i);
			if(chartAtI == ")") {
				if(countParenthese == 0) {
					return result;
				} else {
					countParenthese -= 1;
				}
			} else if(chartAtI == "(") {
				countParenthese += 1;
			}
			result = result + chartAtI;
		}
		return null;
	},
	checkConditionForArr: function(conditionAllowedColumns, conditionArr, condition) {
		if(conditionAllowedColumns == null) {
			conditionAllowedColumns = [];
		}
		return conditionAllowedColumns;
	},
	getSumProduct: function(list2DimArr, formulaName) {
		var basicLen = list2DimArr[0].length,
			maxColumn = list2DimArr[0][0].length;
		var columnArrayLength = [maxColumn];
		for(var m = 1; m < list2DimArr.length; m++) {
			if(list2DimArr[m].length != basicLen) {
				list2DimArr = [];
				throw {
					code: "CAL_NO_VALUE",
					cal: formulaName
				};
			}
			var temp = list2DimArr[m][0].length;
			if(maxColumn < temp) {
				maxColumn = temp;
			}
			columnArrayLength.push(temp);
		}
		var total = 0;
		for(var k = 0; k < maxColumn; k++) {
			for(var i = 0; i < list2DimArr[0].length; i++) {
				var result = 1;
				for(var j = 0; j < list2DimArr.length; j++) {
					var tempVal, maxItemLen = columnArrayLength[j];
					if(k < maxItemLen) {
						tempVal = list2DimArr[j][i][k];
					} else {
						tempVal = list2DimArr[j][i][maxItemLen - 1];
					}
					if(HELPER.isBoolean(tempVal)) {
						tempVal = 0;
					}
					var num = Number(tempVal);
					if(tempVal === undefined) {
						result = 0;
						break;
					} else {
						if(!Ext.isNumber(num)) {
							throw {
								code: "CAL_NO_VALUE",
								cal: formulaName
							};
						}
						result *= num;
					}
				}
				total += result;
			}
		}
		return total;
	},
	singleArr2ToArr1: function(arr2) {
		var flag = true,
			arr1 = [];
		for(var i = 0, len = arr2.length; i < len; i++) {
			var it = arr2[i];
			if(1 !== it.length || Ext.isArray(it[0])) {
				flag = false;
				break;
			} else {
				arr1.push(it[0]);
			}
		}
		if(flag) {
			return arr1;
		} else {
			return arr2;
		}
	},
	cal2ArrsAs1Arr: function(arr1, arr2, calculateMethod) {
		if(arr1.length == 0 || arr2.length == 0 || arr1.length != arr2.length) {
			throw {
				code: "CAL_NO_VALUE",
				cal: "cal2ArrsAs1Arr"
			};
		}
		var megArr = [];
		for(var len = 0; len < arr1.length; len++) {
			var val1 = arr1[len],
				val2 = arr2[len];
			if(val1 === undefined || val2 === undefined) {
				megArr.push(undefined);
				continue;
			}
			if(HELPER.isBoolean(val1)) {
				val1 = 0;
			}
			if(HELPER.isBoolean(val2)) {
				val2 = 0;
			}
			var num1 = Number(val1),
				num2 = Number(val2);
			if(!Ext.isNumber(num1) || !Ext.isNumber(num2)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "cal2ArrsAs1Arr"
				};
			}
			var result = num1 + num2;
			if(calculateMethod == "multiple") {
				result = num1 * num2;
			}
			if(calculateMethod == "divide") {
				result = num1 / num2;
			}
			megArr.push(result);
		}
		arr1 = [], arr2 = [];
		return megArr;
	},
	combine2ArrsAs1Arr: function(arr1, arr2, calculateMethod) {
		if(arr1.length == 0 || arr2.length == 0 || arr1.length != arr2.length) {
			throw {
				code: "CAL_NO_VALUE",
				cal: "combine2ArrsAs1Arr"
			};
		}
		var meg2DimArr = [];
		var arr1SubLen = arr1[0].length,
			arr2SubLen = arr2[0].length;
		if(!Ext.isNumber(arr1SubLen) && !Ext.isNumber(arr2SubLen)) {}
		var subArrLen = arr1SubLen > arr2SubLen ? arr1SubLen : arr2SubLen;
		for(var x = 0, arr1Len = arr1.length; x < arr1Len; x++) {
			var subArray = [];
			for(var y = 0; y < subArrLen; y++) {
				var val1, val2;
				if(arr1SubLen > y) {
					val1 = arr1[x][y];
				} else {
					val1 = arr1[x][arr1SubLen - 1];
				}
				if(arr2SubLen > y) {
					val2 = arr2[x][y];
				} else {
					val2 = arr2[x][arr2SubLen - 1];
				}
				if(val1 === undefined || val2 === undefined) {
					subArray.push(undefined);
					continue;
				}
				if(HELPER.isBoolean(val1)) {
					val1 = 0;
				}
				if(HELPER.isBoolean(val2)) {
					val2 = 0;
				}
				var num1 = Number(val1),
					num2 = Number(val2);
				if(!Ext.isNumber(num1) || !Ext.isNumber(num2)) {
					if(HELPER.isSSDefaultDate(val1)) {
						var inDate = this.parseDefaultDate(val1);
						num1 = this.convertDateToNum(inDate);
					}
					if(HELPER.isSSDefaultDate(val2)) {
						var inDate = this.parseDefaultDate(val2);
						num2 = this.convertDateToNum(inDate);
					}
					if(!Ext.isNumber(num1) || !Ext.isNumber(num2)) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "combine2ArrsAs1Arr"
						};
					}
				}
				var result;
				if(calculateMethod == "multiple") {
					result = num1 * num2;
				} else if(calculateMethod == "divide") {
					result = num1 / num2;
				} else {
					result = num1 + num2;
				}
				subArray.push(result);
			}
			meg2DimArr.push(subArray);
		}
		arr1 = [], arr2 = [];
		if(1 === meg2DimArr.length) {
			var it = meg2DimArr[0];
			if(1 === it.length && Ext.isPrimitive(it[0])) {
				return it[0];
			}
		}
		return meg2DimArr;
	},
	compare2String: function(str1, symbol, str2) {
		var result = str1.localeCompare(str2);
		if(result > 0 && (symbol == ">" || symbol == ">=" || symbol == "!=")) {
			return true;
		} else if(result == 0 && (symbol == "=" || symbol == "==")) {
			return true;
		} else if(result < 0 && (symbol == "<" || symbol == "<=" || symbol == "!=")) {
			return true;
		}
		return false;
	},
	calculateBinom: function(x, n, p) {
		var sum1 = 1,
			sum2 = 1;
		for(var i = Math.floor(n); i > Math.floor(n) - Math.floor(x); i--) {
			sum1 = sum1 * i;
		}
		for(var i = 1; i <= Math.floor(x); i++) {
			sum2 = sum2 * i;
		}
		var combin = Math.floor(sum1 / sum2);
		return combin * Math.pow(p, x) * Math.pow(1 - p, n - x);
	},
	addBracket2ScienceData: function(inStr) {
		var result = inStr.replace(/[0-9.]+e[\+\-][0-9]+/gi, function(w) {
			return "(" + w + ")";
		});
		return result;
	},
	isExpress: function(str) {
		return /^\s*[\!\<\>\=]/gi.test(str);
	},
	isExpressFn: function(str) {
		return /[\<\>\=]/gi.test(str);
	},
	getMedianfromArr: function(arr) {
		var alen = arr.length;
		if(2 >= alen) {
			var sum = 0;
			for(var i = 0; i < alen; i++) {
				sum += arr[i];
			}
			return sum / alen;
		} else {
			arr.sort(function(a, b) {
				return a - b;
			});
			if(0 != alen % 2) {
				var mid = Math.floor(alen / 2);
				return arr[mid];
			} else {
				var mid = Math.floor(alen / 2);
				var sum = (arr[mid] + arr[mid - 1]) / 2;
				return sum;
			}
		}
	}
}, function() {
	HELPER = Ext.create("EnterpriseSheet.pure.common.Helper");
});

Ext.define("EnterpriseSheet.pure.common.SortedArray", {
	constructor: function(config) {
		Ext.apply(this, config);
		this.empty();
	},
	empty: function() {
		this.arr = [];
	},
	compare: function(a, b) {
		return a - b;
	},
	add: function(a, allowRepeat) {
		var res = this.find(a),
			i = res.index;
		if(0 !== res.flag || allowRepeat) {
			this.arr.splice(i, 0, a);
		}
	},
	find: function(a, start, end) {
		var arr = this.arr;
		var len = arr.length;
		if(0 === len) {
			return {
				flag: -1,
				index: 0
			};
		}
		if(!Ext.isDefined(start)) {
			start = 0;
		}
		if(!Ext.isDefined(end)) {
			end = len - 1;
		}
		var i = Math.floor((end + start) / 2),
			flag;
		while(end >= start) {
			var b = arr[i];
			flag = this.compare(a, b);
			if(0 === flag) {
				return {
					flag: 0,
					index: i
				};
			} else if(0 > flag) {
				end = i - 1;
				if(end < start) {
					break;
				}
				i = Math.floor((start + end) / 2);
			} else {
				start = i + 1;
				if(end < start) {
					break;
				}
				i = Math.floor((start + end) / 2);
			}
		}
		if(0 > flag) {
			return {
				flag: flag,
				index: i
			};
		} else {
			return {
				flag: flag,
				index: i + 1
			};
		}
	}
}, function() {});

Ext.define("EnterpriseSheet.pure.sheet.data.reader.CellReader", {
	constructor: function(config) {
		Ext.apply(this, config);
		this.borderRankingMap = {
			clear: 0,
			hair: 1,
			dashed: 2,
			thin: 3,
			dotted: 4,
			mediumDashed: 5,
			medium: 6,
			"double": 8,
			thick: 7
		};
		this.widthMap = {
			clear: 1,
			thin: 1,
			hair: 1,
			dashed: 1,
			medium: 2,
			dotted: 2,
			mediumDashed: 2,
			"double": 3,
			thick: 3
		};
		this.styleMap = {
			thin: "solid",
			hair: "dotted",
			dashed: "dashed",
			medium: "solid",
			dotted: "dotted",
			mediumDashed: "dashed",
			"double": "double",
			thick: "solid"
		}
	},
	prepareJson: function(o) {
		if(Ext.isArray(o)) {
			if(!o[3]) {
				o[3] = {}
			}
			var json = o[3];
			delete(json.timestamp);
			delete(json.value);
			delete(json.cdtVal);
			if(Ext.isNumber(json.afrow)) {
				var row = json.afrow + o[1],
					col = json.afcol + o[2];
				if(row !== o[1] || col !== o[2]) {
					json.data = "=" + SCOM.number2Letter(col) + row
				}
			}
		} else {
			var json = o.json;
			delete(json.timestamp);
			delete(json.value);
			delete(json.cdtVal);
			if(Ext.isNumber(json.afrow)) {
				var row = json.afrow + o.row,
					col = json.afcol + o.col;
				if(row !== o.row || col !== o.col) {
					json.data = "=" + SCOM.number2Letter(col) + row
				}
			}
		}
		return o
	},
	reverseBorderConfig: function(json, config) {
		var dir = ["l", "t", "b", "r"];
		config = config || {};
		if(json.wrap) {
			for(var i = 0; i < 4; i++) {
				var j = dir[i];
				var t = "b" + j + "t",
					x = "xb" + j + "s",
					c = "b" + j + "c",
					y = "x" + c;
				var btype = json[t];
				if("double" === btype) {
					config[x] = "double";
					config[y] = json[c]
				} else {
					if("solid" === btype) {
						config[x] = "thick";
						config[y] = json[c]
					}
				}
			}
		} else {
			for(var i = 0; i < 4; i++) {
				var j = dir[i];
				var s = "b" + j + "s",
					x = "x" + s,
					w = "b" + j + "w",
					c = "b" + j + "c",
					y = "x" + c,
					f = "b" + j + "f";
				var bt = json[s],
					bw = json[w],
					bf = json[f];
				if(1 === bw || 1 === bf) {
					if("dashed" === bt) {
						config[x] = "dashed";
						config[y] = json[c]
					} else {
						if("dotted" === bt) {
							config[x] = "hair";
							config[y] = json[c]
						} else {
							if(json[c]) {
								config[x] = "thin";
								config[y] = json[c]
							}
						}
					}
				} else {
					if(2 === bf || 2 === bw) {
						if("solid" === bt) {
							config[x] = "medium";
							config[y] = json[c]
						} else {
							if("dashed" === bt) {
								config[x] = "mediumDashed";
								config[y] = json[c]
							} else {
								if("dotted" === bt) {
									config[x] = "dotted";
									config[y] = json[c]
								}
							}
						}
					}
				}
			}
		}
		return config
	},
	presetBorderProperty: function(json, keepXBorderProperty) {
		var dir = ["l", "r", "t", "b"],
			store = this.store;
		for(var i = 0; i < 4; i++) {
			var d = dir[i],
				s = "xb" + d + "s",
				style = json[s],
				c = "xb" + d + "c";
			if(style) {
				Ext.apply(json, store.getBorderConfig(d, this.widthMap[style], this.styleMap[style], json[c], true));
				if(!keepXBorderProperty) {
					delete(json[s]);
					delete(json[c])
				}
			}
		}
	},
	readData: function(root) {
		if(root) {
			for(var i = 0, len = root.length; i < len; i++) {
				var it = root[i];
				if(Ext.isArray(it)) {
					var json = {
						data: it[3]
					};
					if(5 == it.length) {
						json.cal = true
					}
					root[i] = [it[0], it[1], it[2], json]
				}
			}
		}
		return root
	},
	read: function(root) {
		if(root) {
			for(var i = 0, len = root.length; i < len; i++) {
				var it = root[i];
				if(Ext.isArray(it)) {
					var obj;
					var json = it[3] || {};
					if(Ext.isString(json)) {
						json = Ext.decode(json)
					}
					obj = [it[0], it[1], it[2], json];
					this.prepareJson(obj);
					root[i] = obj
				} else {
					if(Ext.isString(it.json)) {
						it.json = Ext.decode(it.json)
					}
					this.prepareJson(it);
					root[i] = [it.sheet, it.row, it.col, it.json]
				}
			}
		}
		return root
	},
	readSingle: function(it) {
		var json = it[3] || {};
		if(Ext.isString(json)) {
			json = Ext.decode(json)
		}
		it[3] = json;
		this.prepareJson(it);
		return it
	},
	readStyle: function(results) {
		if(results) {
			for(var i = 0, len = results.length; i < len; i++) {
				var it = results[i];
				var json = it[3] || {};
				if(Ext.isString(json)) {
					json = Ext.decode(json)
				}
				it[3] = json;
				this.prepareJson(it);
				results[i] = it
			}
		}
		return results
	}
}, function() {
	Ext.apply(EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype, {
		separateChar: "$",
		getIdBasedData: function(data) {
			var separateChar = this.separateChar;
			return data.sheet + separateChar + data.row + separateChar + data.col
		}
	})
});

Ext.define("EnterpriseSheet.pure.sheet.calculate.Coordinate", {
	requires: ["EnterpriseSheet.pure.common.Common"],
	transfer2Absolute: function(sheetId, row, col, args) {
		var arr = [];
		var lineup = function(bus) {
			for(var k = 0, count = bus.length; k < count; k++) {
				var it = bus[k];
				if(Ext.isArray(it)) {
					lineup(it);
				} else {
					arr.push(it);
				}
			}
		};
		lineup(args);
		args = arr;
		arr = [];
		for(var i = 0, len = args.length; i < len; i++) {
			var arg = args[i];
			if(Ext.isObject(arg)) {
				var span = arg.span || arg.SPAN,
					type = arg.type || arg.TYPE;
				var range = this.transferCoord2MinMax(span, sheetId);
				var min = range.min,
					max = range.max;
				if(SCONST.ABSOLUTE_COORD == type) {
					row = col = 0;
				} else if(SCONST.ABSOLUTE_COL_COORD == type) {
					col = 0;
				} else if(SCONST.ABSOLUTE_ROW_COORD == type) {
					row = 0;
				}
				var minrow = "" === min[1] ? 0 : row + min[1],
					mincol = "" === min[2] ? 0 : col + min[2],
					maxrow = "" === max[1] ? 0 : row + max[1],
					maxcol = "" === max[2] ? 0 : col + max[2];
				arr.push([min[0], minrow, mincol, maxrow, maxcol]);
			} else {
				arr.push(arg);
			}
		}
		return arr;
	}
}, function() {
	Ext.apply(EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype, {
		dot: "!",
		separator: "$",
		sheetNameReg: /^[^\=\)\(\+\*\/\^\>\<\!\[\]]+$/i,
		spanReg: /("[^\"]*"([^!\"\']|$))|('[^\']*'([^!\'\"]|$))|((((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+):(\$)?([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+)(\$)?([0-9]+)(:(\$)?([a-zA-Z]+)(\$)?([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([0-9]+):(\$)?([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$)))/g,
		spanReg1: /("[^\"]*"([^!\"\']|$))|('[^\']*'([^!\'\"]|$))|((((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+):(\$)?([a-zA-Z]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([a-zA-Z]+)(\$)?([0-9]+)(:(\$)?([a-zA-Z]+)(\$)?([0-9]+))?([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$))|(((("[^\"]+")|('[^\']+')|([^\=\)\(\+\-\*\/\^\>\<\,\!]+))!)?(\$)?([0-9]+):(\$)?([0-9]+)([\s,\}\]\)\+\-\*\/\>\<\=\&]|!=|$)))/g,
		refNameReg: /[\'\"\w]+/g,
		transferReg: /\{[^\{\}]+\}/g,
		transferCoordInStr: function(str, fn, scope) {
			if(fn) {
				return str.replace(this.transferReg, function(w) {
					var coord = Ext.decode(w);
					var ret = fn.call(scope, coord);
					if(undefined !== ret) {
						return ret;
					}
				});
			}
		},
		absoluteSpan2Relative: function(sheetId, row, col, span) {
			var arr = [].concat(span);
			if(sheetId == arr[0]) {
				arr[0] = "";
			}
			arr[1] = 0 === arr[1] ? "" : arr[1] - row;
			arr[2] = 0 === arr[2] ? "" : arr[2] - col;
			arr[3] = 0 === arr[3] ? "" : arr[3] - row;
			arr[4] = 0 === arr[4] ? "" : arr[4] - col;
			return arr;
		},
		relativeSpan2Absolute: function(sheetId, row, col, span) {
			var arr = [].concat(span);
			if("" == arr[0]) {
				arr[0] = sheetId;
			}
			arr[1] = "" === arr[1] ? 0 : arr[1] + row;
			arr[2] = "" === arr[2] ? 0 : arr[2] + col;
			arr[3] = "" === arr[3] ? 0 : arr[3] + row;
			arr[4] = "" === arr[4] ? 0 : arr[4] + col;
			return arr;
		},
		normalizeCoord: function(arg, defaultSheetId) {
			if(false == SCOM.typeOf(defaultSheetId)) {
				defaultSheetId = "";
			}
			var arr = [];
			var len = arg.length;
			if(2 == len) {
				arr = [defaultSheetId].concat(arg).concat(arg);
			} else if(3 == len) {
				arr = [].concat(arg);
				arr.push(arg[1]);
				arr.push(arg[2]);
			} else if(4 == len) {
				arr = [defaultSheetId].concat(arg);
			} else if(5 == len) {
				arr = [].concat(arg);
				if("" === arg[0]) {
					arr[0] = defaultSheetId;
				}
			}
			return arr;
		},
		transferCoord2MinMax: function(arg, defaultSheetId) {
			var min, max;
			arg = this.normalizeCoord(arg, defaultSheetId);
			min = [arg[0], arg[1], arg[2]];
			max = [arg[0], arg[3], arg[4]];
			return {
				min: min,
				max: max
			};
		},
		coord2String: function(coord, separator, withSheet) {
			try {
				var ret = "";
				if(false == SCOM.typeOf(separator)) {
					separator = this.separator;
				}
				for(var i = 0, len = coord.length; i < len; i++) {
					var it = coord[i];
					var span, ctype;
					if(Ext.isArray(it)) {
						span = it;
						ctype = SCONST.ABSOLUTE_COORD;
					} else {
						span = it.span;
						ctype = it.type;
					}
					var mm = this.transferCoord2MinMax(span),
						min = mm.min,
						max = mm.max;
					var str = "";
					if(min[1] == max[1] && min[2] == max[2]) {
						var arr = [];
						if("" !== min[2] && 0 !== min[2]) {
							arr.push(SCOM.number2Letter(min[2]));
						}
						if("" !== min[1] && 0 !== min[1]) {
							arr.push(min[1]);
						}
						if(0 === arr.length) {
							str = "";
						} else {
							if(SCONST.ABSOLUTE_COORD == ctype) {
								str = separator + arr.join(separator);
							} else if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
								str = arr.join(separator);
							} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
								str = separator + arr.join("");
							} else {
								str = arr.join("");
							}
							if("" === min[1] || 0 === min[1] || "" === min[2] || 0 === min[2]) {
								str = str + ":" + str;
							}
						}
					} else {
						var arr = [],
							arr2 = [];
						if("" !== min[2] && 0 !== min[2] || "" !== max[2] && 0 !== max[2]) {
							arr.push(SCOM.number2Letter(min[2]));
							if(0 === max[2] || "" === max[2]) {
								arr2.push(SCOM.number2Letter(SCONST.MAX_COLUMN_NUMBER));
							} else {
								arr2.push(SCOM.number2Letter(max[2]));
							}
						}
						if("" !== min[1] && 0 !== min[1] || "" !== max[1] && 0 !== max[1]) {
							arr.push(min[1]);
							if(0 === max[1] || "" === max[1]) {
								arr2.push(SCONST.MAX_ROW_NUMBER);
							} else {
								arr2.push(max[1]);
							}
						}
						if(SCONST.ABSOLUTE_COORD == ctype) {
							str = separator + arr.join(separator) + ":" + separator + arr2.join(separator);
						} else if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
							str = arr.join(separator) + ":" + arr2.join(separator);
						} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
							str = separator + arr.join("") + ":" + separator + arr2.join("");
						} else {
							str = arr.join("") + ":" + arr2.join("");
						}
					}
					if(withSheet && false != SCOM.typeOf(min[0]) && false !== min[0] && "" !== min[0]) {
						min[0] = this.quoteStr(min[0]);
						str = min[0] + this.dot + str;
					}
					if(i != len - 1) {
						str += ",";
					}
					ret += str;
				}
				return ret;
			} catch(e) {
				return "";
			}
		},
		quoteStr: function(str) {
			if(str) {
				str = str.toString();
				var firstChr = str.charAt(0),
					lastChr = str.charAt(str.length - 1);
				if("[" == firstChr) {
					var arr = str.split("]");
					if(2 === arr.length) {
						var after = arr[1];
						firstChr = after.charAt(0);
						lastChr = after.charAt(after.length - 1);
						if(!(firstChr == lastChr && ("\"" == firstChr || "'" == firstChr))) {
							if(-1 !== after.indexOf("\"")) {
								after = "\"" + after + "\"";
							} else {
								after = "'" + after + "'";
							}
							str = arr[0] + "]" + after;
						}
					}
				} else if(!(firstChr == lastChr && ("\"" == firstChr || "'" == firstChr))) {
					if(-1 !== str.indexOf("\"")) {
						str = "\"" + str + "\"";
					} else {
						str = "'" + str + "'";
					}
				}
			}
			return str;
		},
		assembleCoordByRegResult: function(result) {
			var sheet, mincol, minrow, maxcol, maxrow, next, type, flag;
			if(result[17]) {
				flag = true;
				sheet = result[19], mincol = result[24], minrow = result[26], maxcol = result[29], maxrow = result[31], next = result[32];
				var minColSep = result[23],
					minRowSep = result[25],
					maxColSep = result[28],
					maxRowSep = result[30];
				if(Ext.isDefined(maxcol)) {
					if(minColSep && maxColSep && minRowSep && maxRowSep) {
						type = SCONST.ABSOLUTE_COORD;
					} else if(minColSep && maxColSep && !minRowSep && !maxRowSep) {
						type = SCONST.ABSOLUTE_COL_COORD;
					} else if(!minColSep && !maxColSep && minRowSep && maxRowSep) {
						type = SCONST.ABSOLUTE_ROW_COORD;
					} else {
						type = SCONST.RELATIVE_COORD;
					}
				} else {
					if(minColSep && minRowSep) {
						type = SCONST.ABSOLUTE_COORD;
					} else if(minColSep) {
						type = SCONST.ABSOLUTE_COL_COORD;
					} else if(minRowSep) {
						type = SCONST.ABSOLUTE_ROW_COORD;
					} else {
						type = SCONST.RELATIVE_COORD;
					}
				}
			} else if(result[6]) {
				flag = true;
				sheet = result[8], mincol = result[13], maxcol = result[15], next = result[16];
				var minColSep = result[12],
					maxColSep = result[14];
				if(minColSep && maxColSep) {
					type = SCONST.ABSOLUTE_COORD;
				} else {
					type = SCONST.RELATIVE_COORD;
				}
			} else if(result[33]) {
				flag = true;
				sheet = result[35], minrow = result[40], maxrow = result[42], next = result[43];
				var minRowSep = result[39],
					maxRowSep = result[41];
				if(minRowSep && maxRowSep) {
					type = SCONST.ABSOLUTE_COORD;
				} else {
					type = SCONST.RELATIVE_COORD;
				}
			}
			if(!flag) {
				return;
			}
			if(minrow) {
				minrow = Number(minrow);
			} else {
				minrow = 0;
			}
			if(maxrow) {
				maxrow = Number(maxrow);
			} else {
				maxrow = 0;
			}
			if(mincol) {
				mincol = SCOM.letter2Number(mincol);
			} else {
				mincol = 0;
			}
			if(maxcol) {
				maxcol = SCOM.letter2Number(maxcol);
			} else {
				maxcol = 0;
			}
			if(0 == maxrow && 0 == maxcol) {
				maxrow = minrow;
				maxcol = mincol;
			}
			if(0 === minrow || minrow > maxrow && 0 !== maxrow) {
				var tmp = minrow;
				minrow = maxrow;
				maxrow = tmp;
			}
			if(0 === mincol || mincol > maxcol && 0 !== maxcol) {
				var tmp = mincol;
				mincol = maxcol;
				maxcol = tmp;
			}
			if(maxcol == SCONST.MAX_COLUMN_NUMBER) {
				maxcol = 0;
				if(1 == mincol) {
					mincol = 0;
				}
			}
			if(maxrow == SCONST.MAX_ROW_NUMBER) {
				maxrow = 0;
				if(1 == minrow) {
					minrow = 0;
				}
			}
			if(sheet) {
				return {
					span: [sheet, minrow, mincol, maxrow, maxcol],
					next: next,
					type: type
				};
			} else {
				return {
					span: ["", minrow, mincol, maxrow, maxcol],
					next: next,
					type: type
				};
			}
		},
		isCoordSpan: function(val) {
			this.spanReg.lastIndex = 0;
			var result = this.spanReg.exec(val);
			if(result) {
				var obj = this.assembleCoordByRegResult(result);
				if(obj) {
					return true;
				}
			}
		},
		string2Coord: function(str, sheetId, forceCoordType) {
			var coord = [];
			var ps = str.split(",");
			for(var i = 0, len = ps.length; i < len; i++) {
				var single = ps[i];
				this.spanReg.lastIndex = 0;
				var result = this.spanReg.exec(single);
				if(result) {
					var obj = this.assembleCoordByRegResult(result);
					if(obj) {
						if(SCOM.isEmptyValue(obj.span[0]) && Ext.isDefined(sheetId)) {
							obj.span[0] = sheetId;
						}
						coord.push({
							span: obj.span,
							type: Ext.isDefined(forceCoordType) ? forceCoordType : obj.type
						});
					}
				}
			}
			return coord;
		},
		normalizeCoordStr: function(str, separator) {
			separator = separator || "";
			var coord = this.string2Coord(str);
			return this.coord2String(coord, separator, true);
		},
		transferCoord2CellLookup: function(coord) {
			var lookup = {},
				visited = {};
			try {
				var separateChar = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar;
				for(var i = 0, len = coord.length; i < len; i++) {
					var span = coord[i];
					var cid = span.join(separateChar);
					if(!visited[cid]) {
						visited[cid] = true;
						var sheetId = span[0],
							minrow = span[1],
							maxrow = span[3],
							mincol = span[2],
							maxcol = span[4];
						if(0 === maxrow) {
							minrow = 0;
						}
						if(0 === maxcol) {
							mincol = maxcol;
						}
						for(var j = minrow; j <= maxrow; j++) {
							for(var k = mincol; k <= maxcol; k++) {
								var arr = [sheetId, j, k];
								var id = arr.join(separateChar);
								lookup[id] = arr;
							}
						}
					}
				}
			} catch(e) {}
			return lookup;
		},
		transferCoord2CellMap: function(coord) {
			var lookup = {},
				visited = {};
			var separateChar = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar;
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				var cid = span.join(separateChar);
				if(!visited[cid]) {
					visited[cid] = true;
					var sheetId = span[0],
						minrow = span[1],
						maxrow = span[3],
						mincol = span[2],
						maxcol = span[4];
					for(var j = minrow; j <= maxrow; j++) {
						for(var k = mincol; k <= maxcol; k++) {
							var id = [sheetId, j, k].join(separateChar);
							lookup[id] = true;
						}
					}
				}
			}
			return lookup;
		},
		toCoordArr: function(coord) {
			var arr = [];
			for(var i = 0, len = coord.length; i < len; i++) {
				var it = coord[i];
				if(Ext.isObject(it)) {
					var span = it.span || it.SPAN;
					arr.push(span);
				} else {
					arr.push(it);
				}
			}
			return arr;
		},
		isOverlappedSpan: function(span1, span2) {
			if(span1[0] === span2[0]) {
				if((span1[1] <= span2[1] && (span2[1] <= span1[3] || 0 === span1[3]) || span1[1] <= span2[3] && (span2[3] <= span1[3] || 0 === span1[3])) && (span1[2] <= span2[2] && (span2[2] <= span1[4] || 0 === span1[4]) || span1[2] <= span2[4] && (span2[4] <= span1[4] || 0 === span1[4]))) {
					return true;
				} else if((span2[1] <= span1[1] && (span1[1] <= span2[3] || 0 === span2[3]) || span2[1] <= span1[3] && (span1[3] <= span2[3] || 0 === span2[3])) && (span2[2] <= span1[2] && (span1[2] <= span2[4] || 0 === span2[4]) || span2[2] <= span1[4] && (span1[4] <= span2[4] || 0 === span2[4]))) {
					return true;
				}
			}
			return false;
		},
		isOverlappedCoord: function(coord1, coord2) {
			for(var i = 0, len = coord1.length; i < len; i++) {
				var span1 = coord1[i];
				for(var j = 0, count = coord2.length; j < count; j++) {
					if(this.isOverlappedSpan(span1, coord2[j])) {
						return true;
					}
				}
			}
		},
		isIncludedSpan: function(span1, span2) {
			if(span1[0] === span2[0]) {
				if(span1[1] <= span2[1] && (span2[3] <= span1[3] || 0 === span1[3]) && span1[2] <= span2[2] && (span2[4] <= span1[4] || 0 === span1[4])) {
					return true;
				}
			}
			return false;
		},
		isCellInSpan: function(cell, span) {
			if(cell[0] === span[0]) {
				if((0 === span[3] || cell[1] >= span[1] && cell[1] <= span[3]) && (0 === span[4] || cell[2] >= span[2] && cell[2] <= span[4])) {
					return true;
				}
			}
			return false;
		},
		isCellInCoord: function(cell, coord) {
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				if(this.isCellInSpan(cell, span)) {
					return true;
				}
			}
			return false;
		},
		isFactorSpan: function(factor, mother) {
			var mRowSpan = mother[3] - mother[1] + 1,
				mColSpan = mother[4] - mother[2] + 1;
			var fRowSpan = factor[3] - factor[1] + 1,
				fColSpan = factor[4] - factor[2] + 1;
			if(mRowSpan && mColSpan && fRowSpan && fColSpan) {
				var flag = 0 == mRowSpan % fRowSpan && 0 == mColSpan % fColSpan;
				if(flag) {
					var rowProp = Math.floor(mRowSpan / fRowSpan);
					var colProp = Math.floor(mColSpan / fColSpan);
					return {
						rowProp: rowProp,
						colProp: colProp
					};
				}
			}
		},
		expand2Around: function(coord) {
			var newCoord = [];
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				if(0 === span[3] || 4 === span[4]) {
					return null;
				} else {
					var row = span[3] + 1;
					newCoord.push([span[0], row, span[2], row, span[4] + 1]);
					if(1 < span[1]) {
						row = span[1] - 1;
						newCoord.push([span[0], row, 1 < span[2] ? span[2] - 1 : span[2], row, span[4] + 1]);
					}
					var col = span[4] + 1;
					newCoord.push([span[0], span[1], col, span[3], col]);
					if(1 < span[2]) {
						col = span[2] - 1;
						newCoord.push([span[0], span[1], col, span[3] + 1, col]);
					}
				}
			}
			return newCoord.concat(coord);
		},
		pairArr2Obj: function(arr) {
			var obj = {};
			for(var i = 0, len = arr.length; i < len; i++) {
				var pair = arr[i];
				obj[pair[0]] = pair[1];
			}
			return obj;
		}
	});
});

Ext.define("EnterpriseSheet.pure.sheet.calculate.Exception", {
	getExceptionInfo: function(e) {
		var title, msg, code = e.code;
		var found = this.exceptionInfo[code];
		if(found) {
			var info = found(e);
			if(info) {
				title = info.title;
				msg = info.msg;
				code = info.code;
			}
		} else {
			title = SLANG.error;
			if(Ext.isObject(e)) {
				msg = e.code;
			} else {
				msg = e.toString();
			}
			if(-1 != msg.indexOf("ReferenceError")) {
				title = SLANG.invalid_refer;
				code = "#REF!";
			} else {
				code = "#ERROR!";
			}
		}
		return {
			e: e,
			code: code,
			title: title,
			msg: msg
		};
	},
	addExceptionInfo: function(expName, expFun) {
		if(!this.exceptionInfo[expName]) {
			this.exceptionInfo[expName] = expFun;
			return true;
		} else {
			return false;
		}
	},
	exceptionInfo: {
		CAL_INCORRECT_COORD: function(e) {
			return {
				title: SLANG.invalid_refer,
				msg: Ext.String.format(SLANG.invalid_refer_display, e.span[0]),
				code: "#REF!"
			};
		},
		CAL_INFINATE_LOOP: function(e) {
			return {
				title: SLANG.circle_refer,
				msg: SLANG.circle_refer_display,
				code: "#LOOP!"
			};
		},
		CAL_PARAM_MISS: function(e) {
			var cal = e.cal || "UNKNOWN";
			cal = cal.toUpperCase();
			return {
				title: SLANG.param_miss,
				msg: Ext.String.format(SLANG.param_number_wrong, cal, "http://www.enterprisesheet.com/api/docs/formula/index.html#" + cal),
				code: "#PARAM!"
			};
		},
		CAL_NO_VALUE: function(e) {
			var cal = e.cal,
				msg;
			if(cal) {
				cal = cal.toUpperCase();
				msg = Ext.String.format(SLANG.cannot_calculate_value, cal);
			} else {
				msg = SLANG.value_of_calculate_invalid;
			}
			return {
				title: SLANG.value_invalid,
				msg: msg,
				code: "#VALUE!"
			};
		},
		CAL_INDEX_OUT_PARAM_RANG: function(e) {
			var msg = Ext.String.format(SLANG.index_out_param_range, e.cal.toUpperCase());
			return {
				title: SLANG.index_out_range,
				msg: msg,
				code: "#PARAM!"
			};
		},
		CAL_PARAM_NEED_BE_NUM: function(e) {
			var msg = Ext.String.format(SLANG.param_need_be_num, e.cal.toUpperCase());
			return {
				title: SLANG.param_type_wrong,
				msg: msg,
				code: "#NUM!"
			};
		},
		NUM_IS_NOT_RIGHT: function(e) {
			var msg = Ext.String.format(SLANG.number_not_right, e.cal.toUpperCase());
			return {
				title: SLANG.param_type_wrong,
				msg: msg,
				code: "#NUM!"
			};
		},
		CAL_PARAM_NOT_MATCH: function(e) {
			var msg = Ext.String.format(SLANG.param_should_be_same, e.cal.toUpperCase());
			return {
				title: SLANG.param_not_match,
				msg: msg,
				code: "#PARAM!"
			};
		},
		VALUE_NOT_AVAILABLE: function(e) {
			return {
				title: SLANG.error,
				msg: SLANG.value_not_available,
				code: "#N/A"
			};
		},
		SS_ERROR_INFINITY: function(e) {
			return {
				title: SLANG.error,
				msg: SLANG.result_infinity,
				code: "#DIV/0!"
			};
		},
		CAL_INVALID_NAME: function(e) {
			return {
				title: SLANG.invalid_name,
				msg: SLANG.invalid_name_in_cal,
				code: "#NAME!"
			};
		}
	}
}, function() {
	SCALEXP = Ext.create("EnterpriseSheet.pure.sheet.calculate.Exception");
});

Ext.define("EnterpriseSheet.pure.sheet.calculate.CalCacheMap", {
	requires: ["EnterpriseSheet.pure.common.SortedArray"],
	constructor: function(config) {
		Ext.apply(this, config);
		this.caches = {};
	},
	getMap: function(name) {
		var map = this.caches[name];
		if(!map) {
			map = this.caches[name] = Ext.create("EnterpriseSheet.pure.common.SortedArray", {
				compare: this.compare
			});
		}
		return map;
	},
	compare: function(a, b) {
		var len = 5;
		for(var i = 0; i < len; i++) {
			var ai = a[i],
				bi = b[i];
			if(ai < bi) {
				return -1;
			} else if(ai > bi) {
				return 1;
			}
		}
		return 0;
	},
	add: function(map, span, value) {
		var res = map.find(span),
			i = res.index;
		if(0 === res.flag) {
			var it = map.arr[i];
			it[5] = value;
		} else {
			span = span.concat([value]);
			map.arr.splice(i, 0, span);
		}
	},
	empty: function() {
		for(var p in this.caches) {
			if(this.caches.hasOwnProperty(p)) {
				var map = this.caches[p];
				map.empty();
			}
		}
	},
	clearRelatedInMap: function(map, s, r, c) {
		var span = [s, r, c, r, c];
		var start = map.find(span).index;
		span[2]++;
		span[4]++;
		var end = map.find(span).index,
			arr = map.arr;
		arr.splice(start, end - start);
		for(var i = start - 1; 0 <= i; i--) {
			var it = arr[i];
			if(it[0] === s) {
				if((0 === it[1] || r <= it[3]) && (0 === it[2] || c <= it[4])) {
					arr.splice(i, 1);
				} else {
					if(0 < i) {
						var pre = arr[i - 1];
						if(pre[0] === s && pre[1] === it[1] && pre[2] === it[2]) {
							var tmp = [s, it[1], it[2], it[1], it[2]];
							var res = map.find(tmp, 0, i - 1);
							i = res.index;
						}
					}
				}
			} else {
				break;
			}
		}
	},
	clearRelated: function(sheetId, row, col) {
		for(var p in this.caches) {
			if(this.caches.hasOwnProperty(p)) {
				var map = this.caches[p];
				this.clearRelatedInMap(map, sheetId, row, col);
			}
		}
	},
	getValueFromCache: function(span, cacheName) {
		cacheName = cacheName || "d2";
		var map = this.getMap(cacheName);
		var res = map.find(span);
		if(0 === res.flag) {
			return Ext.decode(map.arr[res.index][5]);
		}
		return null;
	},
	addValueToCache: function(span, items, cacheName) {
		if(50 < items.length) {
			cacheName = cacheName || "d2";
			var map = this.getMap(cacheName);
			this.add(map, span, Ext.encode(items));
		}
	}
});

Ext.define("EnterpriseSheet.pure.sheet.calculate.Calculate", {
	extend: "EnterpriseSheet.pure.sheet.calculate.Coordinate",
	requires: ["EnterpriseSheet.pure.common.Helper", "EnterpriseSheet.pure.common.FormulaHelper", "EnterpriseSheet.pure.sheet.calculate.Exception", "EnterpriseSheet.pure.sheet.calculate.CalCacheMap", "EnterpriseSheet.pure.sheet.data.reader.CellReader"],
	lookup: {},
	_exposeFns: {},
	_exposeScope: {},
	_exposeEnv: {},
	formulaAliasReg: /([a-zA-Z0-9_]+)\(/gi,
	constructor: function() {
		EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.superclass.constructor.apply(this, arguments);
		this.calCacheMap = Ext.create("EnterpriseSheet.pure.sheet.calculate.CalCacheMap", {});
		this.bindListeners();
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.bindListeners();
	},
	bindListeners: function() {
		if(this.sheet) {
			var store = this.sheet.getStore();
			store.on({
				scope: this,
				aftersetupcalmap: function() {
					this.calCacheMap.empty();
				},
				valuechange: function(sheetId, row, col) {
					this.calCacheMap.clearRelated(sheetId, row, col);
				}
			});
		}
	},
	adjustCalForRemoveRow: function(config) {
		var json = config.json,
			osheetId = config.osheetId,
			sheetId = config.sheetId,
			preChanged = config.preChanged,
			changed = config.changed,
			minrow = config.minrow,
			maxrow = config.maxrow,
			dspan = config.dspan,
			related = config.related;
		var me = this,
			store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type,
				separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype) {
				separator = "";
				if(preChanged) {
					changed = true;
				}
			}
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = "" !== arr[0] && "string" == SCOM.typeOf(arr[0]),
				sheetName = arr[0];
			if(withSheetName) {
				arr[0] = store.getSheetIdByName(sheetName);
			}
			if(sheetId === arr[0] || "" === arr[0] && osheetId == sheetId) {
				var oldEndRow = arr[3];
				if(minrow < arr[1]) {
					if(maxrow >= arr[1]) {
						arr[1] = minrow;
					} else {
						arr[1] -= dspan;
					}
					if(0 !== arr[3]) {
						arr[3] -= dspan;
					}
					changed = true;
				} else if(minrow <= arr[3]) {
					if(maxrow > arr[3]) {
						arr[3] = minrow - 1;
					} else {
						arr[3] -= dspan;
					}
					changed = true;
				}
				if(changed) {
					if(arr[1] > arr[3] && 0 !== oldEndRow) {
						return "0" + next;
					} else {
						arr[0] = sheetName;
						str = me.coord2String([{
							span: arr,
							type: ctype
						}], separator, withSheetName);
						return str + next;
					}
				} else if(0 === arr[1]) {
					related = true;
				}
			}
			return w;
		});
		return {
			text: arg,
			changed: changed,
			related: related
		};
	},
	beforeRemoveRow: function(sheetId, minrow, maxrow) {
		var me = this;
		var dspan = maxrow - minrow + 1,
			coord = [
				[sheetId, minrow, 0, maxrow, 0]
			];
		var store = this.sheet.getStore(),
			oldCalCache = {},
			curCalCache = {},
			needCheckNamedFunc = {};
		store.eachCalAndNamedFunc(function(rd) {
			var osheetId = rd.data.sheet,
				orow = row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json,
				changed = false,
				related = false,
				preChanged = false;
			if(json.cal) {
				flag = true;
				if(row >= minrow && osheetId === sheetId) {
					row += dspan;
					preChanged = true;
				}
				if(row < minrow || row > maxrow || osheetId !== sheetId) {
					var ret = me.adjustCalForRemoveRow({
						json: json,
						osheetId: osheetId,
						sheetId: sheetId,
						preChanged: preChanged,
						changed: changed,
						minrow: minrow,
						maxrow: maxrow,
						dspan: dspan,
						related: related
					});
					var arg = ret.text;
					changed = ret.changed;
					related = ret.related;
					if(changed) {
						var isNamedFunc = rd.hasOwnProperty("named_func") ? "named_func" : undefined;
						var o = this.transferCalculate({
							data: arg
						}, store, osheetId, orow, col, isNamedFunc);
						var curId, oldId;
						if(isNamedFunc) {
							oldId = curId = rd.named_func;
							if(!oldCalCache[oldId]) {
								oldCalCache[oldId] = SCOM.copy(store.getNamedFuncConfigByName(oldId));
							}
							needCheckNamedFunc[oldId] = true;
							curCalCache[curId] = curCalCache[curId] || {
								ctype: "named_func",
								jsonArr: []
							};
							curCalCache[curId].jsonArr.push({
								cal: arg,
								arg: o.arg,
								refs: o.refs,
								scope: json.scope
							});
						} else {
							curId = store.getIdBasedData({
								sheet: osheetId,
								row: orow,
								col: col
							});
							oldId = curId;
							if(row !== orow) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col,
								json: {
									data: json.data,
									arg: json.arg,
									refs: json.refs
								}
							};
							store.setCell(osheetId, orow, col, {
								data: arg,
								arg: o.arg,
								refs: o.refs
							}, null, true);
							curCalCache[curId] = {
								sheet: osheetId,
								row: orow,
								col: col,
								json: {
									data: arg,
									arg: o.arg,
									refs: o.refs
								}
							};
						}
					} else if(related) {
						if(rd.named_func) {
							var oldId = curId = rd.named_func;
							oldCalCache[oldId] = oldCalCache[oldId] || true;
							curCalCache[curId] = curCalCache[curId] || true;
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: orow,
									col: col
								}),
								oldId = curId;
							if(row !== orow) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col
							};
							curCalCache[curId] = {
								sheet: osheetId,
								row: orow,
								col: col
							};
						}
					}
				}
			}
		}, this);
		var needRefreshCal;
		if(!SCOM.isEmptyObj(needCheckNamedFunc)) {
			for(var p in needCheckNamedFunc) {
				if(needCheckNamedFunc.hasOwnProperty(p)) {
					var nfConfig = store.mergeNamedFuncConfig(p, curCalCache[p]);
					store.setNamedFuncConfig(p, nfConfig, undefined, true);
				}
			}
			store.checkReferenceString();
		}
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)) {
			needRefreshCal = true;
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	adjustCalForRemoveColumn: function(config) {
		var json = config.json,
			osheetId = config.osheetId,
			sheetId = config.sheetId,
			preChanged = config.preChanged,
			changed = config.changed,
			mincol = config.mincol,
			maxcol = config.maxcol,
			dspan = config.dspan,
			related = config.related;
		var me = this,
			store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type,
				separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype) {
				separator = "";
				if(preChanged) {
					changed = true;
				}
			}
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = "" !== arr[0] && "string" == SCOM.typeOf(arr[0]),
				sheetName = arr[0];
			if(withSheetName) {
				arr[0] = store.getSheetIdByName(sheetName);
			}
			if(sheetId === arr[0] || "" === arr[0] && osheetId == sheetId) {
				var oldEndCol = arr[4];
				if(mincol < arr[2]) {
					if(maxcol >= arr[2]) {
						arr[2] = mincol;
					} else {
						arr[2] -= dspan;
					}
					if(0 !== arr[4]) {
						arr[4] -= dspan;
					}
					changed = true;
				} else if(mincol <= arr[4]) {
					if(maxcol > arr[4]) {
						arr[4] = mincol - 1;
					} else {
						arr[4] -= dspan;
					}
					changed = true;
				}
				if(changed) {
					if(arr[2] > arr[4] && 0 !== oldEndCol) {
						return "";
					} else {
						arr[0] = sheetName;
						str = me.coord2String([{
							span: arr,
							type: ctype
						}], separator, withSheetName);
						return str + next;
					}
				} else if(0 === arr[2]) {
					related = true;
				}
			}
			return w;
		});
		return {
			text: arg,
			changed: changed,
			related: related
		};
	},
	beforeRemoveColumn: function(sheetId, mincol, maxcol) {
		var me = this;
		var dspan = maxcol - mincol + 1;
		var store = this.sheet.getStore(),
			oldCalCache = {},
			curCalCache = {},
			needCheckNamedFunc = {};
		store.eachCalAndNamedFunc(function(rd) {
			var osheetId = rd.data.sheet,
				row = rd.data.row,
				ocol = col = rd.data.col,
				json = rd.data.json,
				changed = false,
				preChanged = false,
				related;
			if(json.cal) {
				if(col >= mincol && osheetId === sheetId) {
					col += dspan;
					preChanged = true;
				}
				if(col < mincol || col > maxcol || osheetId !== sheetId) {
					var ret = me.adjustCalForRemoveColumn({
						json: json,
						osheetId: osheetId,
						sheetId: sheetId,
						preChanged: preChanged,
						changed: changed,
						mincol: mincol,
						maxcol: maxcol,
						dspan: dspan,
						related: related
					});
					var arg = ret.text;
					changed = ret.changed;
					related = ret.related;
					if(changed) {
						var isNamedFunc = rd.hasOwnProperty("named_func") ? "named_func" : undefined;
						var o = this.transferCalculate({
							data: arg
						}, store, osheetId, row, ocol, isNamedFunc);
						if(isNamedFunc) {
							var oldId = curId = rd.named_func;
							if(!oldCalCache[oldId]) {
								oldCalCache[oldId] = SCOM.copy(store.getNamedFuncConfigByName(oldId));
							}
							needCheckNamedFunc[oldId] = true;
							curCalCache[curId] = curCalCache[curId] || {
								ctype: "named_func",
								jsonArr: []
							};
							curCalCache[curId].jsonArr.push({
								cal: arg,
								arg: o.arg,
								refs: o.refs,
								scope: json.scope
							});
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: ocol
								}),
								oldId = curId;
							if(col !== ocol) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col,
								json: {
									data: json.data,
									arg: json.arg,
									refs: json.refs
								}
							};
							store.setCell(osheetId, row, ocol, {
								data: arg,
								arg: o.arg,
								refs: o.refs
							}, null, true);
							curCalCache[curId] = {
								sheet: osheetId,
								row: row,
								col: ocol,
								json: {
									data: arg,
									arg: o.arg,
									refs: o.refs
								}
							};
						}
					} else if(related) {
						if(rd.named_func) {
							var oldId = curId = rd.named_func;
							oldCalCache[oldId] = oldCalCache[oldId] || true;
							curCalCache[curId] = curCalCache[curId] || true;
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: ocol
								}),
								oldId = curId;
							if(col !== ocol) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col
							};
							curCalCache[curId] = {
								sheet: osheetId,
								row: row,
								col: ocol
							};
						}
					}
				}
			}
		}, this);
		var needRefreshCal;
		if(!SCOM.isEmptyObj(needCheckNamedFunc)) {
			for(var p in needCheckNamedFunc) {
				if(needCheckNamedFunc.hasOwnProperty(p)) {
					var nfConfig = store.mergeNamedFuncConfig(p, curCalCache[p]);
					store.setNamedFuncConfig(p, nfConfig, undefined, true);
				}
			}
			store.checkReferenceString();
		}
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)) {
			needRefreshCal = true;
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	adjustCalForRemoveCell: function(config) {
		var json = config.json,
			osheetId = config.osheetId,
			sheetId = config.sheetId,
			preChanged = config.preChanged,
			changed = config.changed,
			related = config.related,
			moveDir = config.moveDir,
			minrow = config.minrow,
			maxrow = config.maxrow,
			mincol = config.mincol,
			maxcol = config.maxcol,
			rowSpan = config.rowSpan,
			colSpan = config.colSpan;
		var me = this,
			store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type,
				separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype) {
				separator = "";
				if(preChanged) {
					changed = true;
				}
			}
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = "" !== arr[0] && "string" == SCOM.typeOf(arr[0]),
				sheetName = arr[0];
			if(withSheetName) {
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			if(sheetId === arr[0] || "" === arr[0] && osheetId == sheetId) {
				var oldEndRow = arr[3],
					oldEndCol = arr[4];
				if(minrow <= arr[1] && arr[3] <= maxrow) {
					if(mincol < arr[2]) {
						if("left" == moveDir) {
							if(maxcol >= arr[2]) {
								arr[2] = mincol;
							} else {
								arr[2] -= colSpan;
							}
							if(0 !== arr[4]) {
								arr[4] -= colSpan;
							}
							changed = true;
						} else {
							if(maxcol >= arr[2] && 0 !== arr[2]) {
								arr[2] = maxcol + 1;
								changed = true;
							}
						}
					} else if(mincol <= arr[4]) {
						if("left" == moveDir) {
							if(maxcol > arr[4]) {
								arr[4] = mincol - 1;
							} else {
								arr[4] -= colSpan;
							}
							changed = true;
						} else {
							if(maxcol > arr[4]) {
								arr[4] = mincol - 1;
								changed = true;
							} else if(mincol == arr[2]) {
								arr[2] = maxcol + 1;
								changed = true;
							}
						}
					}
				} else if(mincol <= arr[2] && arr[4] <= maxcol) {
					if(minrow < arr[1]) {
						if("up" == moveDir) {
							if(maxrow >= arr[1]) {
								arr[1] = minrow;
							} else {
								arr[1] -= rowSpan;
							}
							if(0 !== arr[3]) {
								arr[3] -= rowSpan;
							}
							changed = true;
						} else {
							if(maxrow >= arr[1] && 0 !== arr[1]) {
								arr[1] = maxrow + 1;
								changed = true;
							}
						}
					} else if(minrow <= arr[3]) {
						if("up" == moveDir) {
							if(maxrow > arr[3]) {
								arr[3] = minrow - 1;
							} else {
								arr[3] -= rowSpan;
							}
							changed = true;
						} else {
							if(maxrow > arr[3]) {
								arr[3] = minrow - 1;
								changed = true;
							} else if(minrow == arr[1]) {
								arr[1] = maxrow + 1;
								changed = true;
							}
						}
					}
				}
				if(changed) {
					if(arr[2] > arr[4] && 0 !== oldEndCol || arr[1] > arr[3] && 0 !== oldEndRow) {
						return next;
					} else {
						arr[0] = sheetName;
						str = me.coord2String([{
							span: arr,
							type: ctype
						}], separator, withSheetName);
						return str + next;
					}
				} else {
					if("up" == moveDir) {
						if(arr[1] > maxrow && (arr[2] <= mincol && mincol <= arr[4] || arr[2] <= maxcol && maxcol <= arr[4] || mincol <= arr[2] && arr[4] <= maxcol)) {
							related = true;
						}
					} else {
						if(arr[2] > maxcol && (arr[1] <= minrow && minrow <= arr[3] || arr[1] <= maxrow && maxrow <= arr[3] || minrow <= arr[1] && arr[3] <= maxrow)) {
							related = true;
						}
					}
				}
			}
			return w;
		});
		return {
			text: arg,
			changed: changed,
			related: related
		};
	},
	beforeRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir) {
		var me = this;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		var store = this.sheet.getStore(),
			oldCalCache = {},
			curCalCache = {},
			needCheckNamedFunc = {};
		store.eachCalAndNamedFunc(function(rd) {
			var osheetId = rd.data.sheet,
				orow = row = rd.data.row,
				ocol = col = rd.data.col,
				json = rd.data.json;
			if(json.cal) {
				var changed = false,
					preChanged = false,
					related;
				if("up" == moveDir && osheetId === sheetId && row >= minrow && ocol >= mincol && ocol <= maxcol) {
					row += rowSpan;
					preChanged = true;
				}
				if("left" == moveDir && osheetId === sheetId && col >= mincol && orow >= minrow && orow <= maxrow) {
					col += colSpan;
					preChanged = true;
				}
				if(col < mincol || col > maxcol || row < minrow || row > maxrow || osheetId !== sheetId) {
					var ret = me.adjustCalForRemoveCell({
						json: json,
						osheetId: osheetId,
						sheetId: sheetId,
						preChanged: preChanged,
						changed: changed,
						minrow: minrow,
						maxrow: maxrow,
						mincol: mincol,
						maxcol: maxcol,
						rowSpan: rowSpan,
						colSpan: colSpan,
						moveDir: moveDir,
						related: related
					});
					var arg = ret.text;
					changed = ret.changed;
					related = ret.related;
					if(changed) {
						var isNamedFunc = rd.hasOwnProperty("named_func") ? "named_func" : undefined;
						var o = this.transferCalculate({
							data: arg
						}, store, osheetId, orow, ocol, isNamedFunc);
						if(isNamedFunc) {
							var oldId = curId = rd.named_func;
							if(!oldCalCache[oldId]) {
								oldCalCache[oldId] = SCOM.copy(store.getNamedFuncConfigByName(oldId));
							}
							needCheckNamedFunc[oldId] = true;
							curCalCache[curId] = curCalCache[curId] || {
								ctype: "named_func",
								jsonArr: []
							};
							curCalCache[curId].jsonArr.push({
								cal: arg,
								arg: o.arg,
								refs: o.refs,
								scope: json.scope
							});
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: orow,
									col: ocol
								}),
								oldId = curId;
							if(col !== ocol || row !== orow) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col,
								json: {
									data: json.data,
									arg: json.arg,
									refs: json.refs
								}
							};
							store.setCell(osheetId, orow, ocol, {
								data: arg,
								arg: o.arg,
								refs: o.refs
							}, null, true);
							curCalCache[curId] = {
								sheet: osheetId,
								row: orow,
								col: ocol,
								json: {
									data: arg,
									arg: o.arg,
									refs: o.refs
								}
							};
						}
					} else if(related) {
						if(rd.named_func) {
							var oldId = curId = rd.named_func;
							oldCalCache[oldId] = oldCalCache[oldId] || true;
							curCalCache[curId] = curCalCache[curId] || true;
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: orow,
									col: ocol
								}),
								oldId = curId;
							if(col !== ocol || row !== orow) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col
							};
							curCalCache[curId] = {
								sheet: osheetId,
								row: orow,
								col: ocol
							};
						}
					}
				}
			}
		}, this);
		var needRefreshCal;
		if(!SCOM.isEmptyObj(needCheckNamedFunc)) {
			for(var p in needCheckNamedFunc) {
				if(needCheckNamedFunc.hasOwnProperty(p)) {
					var nfConfig = store.mergeNamedFuncConfig(p, curCalCache[p]);
					store.setNamedFuncConfig(p, nfConfig, undefined, true);
				}
			}
			store.checkReferenceString();
		}
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)) {
			needRefreshCal = true;
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	adjustCalForInsertRow: function(config) {
		var json = config.json,
			osheetId = config.osheetId,
			sheetId = config.sheetId,
			preChanged = config.preChanged,
			changed = config.changed,
			minrow = config.minrow,
			rowSpan = config.rowSpan,
			expandCalInNext = config.expandCalInNext;
		var me = this,
			store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type,
				separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype) {
				separator = "";
				if(preChanged) {
					changed = true;
				}
			}
			var inFun = me.isInFun(str, pos);
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = "" !== arr[0] && "string" == SCOM.typeOf(arr[0]),
				sheetName = arr[0];
			if(withSheetName) {
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			if(sheetId === arr[0] || "" === arr[0] && osheetId == sheetId) {
				if(minrow <= arr[1]) {
					arr[1] += rowSpan;
					if(0 !== arr[3]) {
						arr[3] += rowSpan;
					}
					changed = true;
				} else if(minrow <= arr[3] || expandCalInNext && minrow <= arr[3] + 1) {
					if(arr[1] == arr[3] && !inFun) {
						arr[1] += rowSpan;
					}
					arr[3] += rowSpan;
					changed = true;
				}
				if(changed) {
					arr[0] = sheetName;
					str = me.coord2String([{
						span: arr,
						type: ctype
					}], separator, withSheetName);
					return str + next;
				}
			}
			return w;
		});
		return {
			text: arg,
			changed: changed
		};
	},
	beforeInsertRow: function(sheetId, minrow, rowSpan, mincol, maxcol, expandCalInNext) {
		var me = this;
		var maxrow = minrow + rowSpan - 1;
		var store = this.sheet.getStore(),
			oldCalCache = {},
			curCalCache = {},
			needCheckNamedFunc = {};
		store.eachCalAndNamedFunc(function(rd) {
			var osheetId = rd.data.sheet,
				orow = row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			if(json.cal) {
				var changed = false,
					preChanged = false;
				if(row > maxrow && osheetId === sheetId) {
					row -= rowSpan;
					preChanged = true;
				}
				if(orow < minrow || orow >= maxrow || osheetId !== sheetId) {
					var ret = me.adjustCalForInsertRow({
						json: json,
						osheetId: osheetId,
						sheetId: sheetId,
						preChanged: preChanged,
						changed: changed,
						minrow: minrow,
						rowSpan: rowSpan,
						expandCalInNext: expandCalInNext
					});
					var arg = ret.text;
					changed = ret.changed;
					if(changed) {
						var isNamedFunc = rd.hasOwnProperty("named_func") ? "named_func" : undefined;
						var o = this.transferCalculate({
							data: arg
						}, store, osheetId, orow, col, isNamedFunc);
						if(isNamedFunc) {
							var oldId = curId = rd.named_func;
							if(!oldCalCache[oldId]) {
								oldCalCache[oldId] = SCOM.copy(store.getNamedFuncConfigByName(oldId));
							}
							needCheckNamedFunc[oldId] = true;
							curCalCache[curId] = curCalCache[curId] || {
								ctype: "named_func",
								jsonArr: []
							};
							curCalCache[curId].jsonArr.push({
								cal: arg,
								arg: o.arg,
								refs: o.refs,
								scope: json.scope
							});
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: orow,
									col: col
								}),
								oldId = curId;
							if(row !== orow) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col,
								json: {
									data: json.data,
									arg: json.arg,
									refs: json.refs
								}
							};
							store.setCell(osheetId, orow, col, {
								data: arg,
								arg: o.arg,
								refs: o.refs
							}, null, true);
							curCalCache[curId] = {
								sheet: osheetId,
								row: orow,
								col: col,
								json: {
									data: arg,
									arg: o.arg,
									refs: o.refs
								}
							};
						}
					}
				}
			}
		}, this);
		var needRefreshCal;
		if(!SCOM.isEmptyObj(needCheckNamedFunc)) {
			for(var p in needCheckNamedFunc) {
				if(needCheckNamedFunc.hasOwnProperty(p)) {
					var nfConfig = store.mergeNamedFuncConfig(p, curCalCache[p]);
					store.setNamedFuncConfig(p, nfConfig, undefined, true);
				}
			}
			store.checkReferenceString();
		}
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)) {
			needRefreshCal = true;
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	adjustCalForInsertColumn: function(config) {
		var json = config.json,
			osheetId = config.osheetId,
			sheetId = config.sheetId,
			preChanged = config.preChanged,
			changed = config.changed,
			mincol = config.mincol,
			colSpan = config.colSpan,
			expandCalInNext = config.expandCalInNext;
		var me = this,
			store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type,
				separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype) {
				separator = "";
				if(preChanged) {
					changed = true;
				}
			}
			var inFun = me.isInFun(str, pos);
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = "" !== arr[0] && "string" == SCOM.typeOf(arr[0]),
				sheetName = arr[0];
			if(withSheetName) {
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			if(sheetId === arr[0] || "" === arr[0] && osheetId == sheetId) {
				if(mincol <= arr[2]) {
					arr[2] += colSpan;
					if(0 !== arr[4]) {
						arr[4] += colSpan;
					}
					changed = true;
				} else if(mincol <= arr[4] || expandCalInNext && mincol <= arr[4] + 1) {
					if(arr[2] == arr[4] && !inFun) {
						arr[2] += colSpan;
					}
					arr[4] += colSpan;
					changed = true;
				}
				if(changed) {
					arr[0] = sheetName;
					str = me.coord2String([{
						span: arr,
						type: ctype
					}], separator, withSheetName);
					return str + next;
				}
			}
			return w;
		});
		return {
			text: arg,
			changed: changed
		};
	},
	beforeInsertColumn: function(sheetId, mincol, colSpan, minrow, maxrow, expandCalInNext) {
		var me = this;
		var maxcol = mincol + colSpan - 1;
		var store = this.sheet.getStore(),
			oldCalCache = {},
			curCalCache = {},
			needCheckNamedFunc = {};
		store.eachCalAndNamedFunc(function(rd) {
			var osheetId = rd.data.sheet,
				row = rd.data.row,
				ocol = col = rd.data.col,
				json = rd.data.json;
			if(json.cal) {
				var changed = false,
					preChanged = false;
				if(col > maxcol && osheetId === sheetId) {
					col -= colSpan;
					preChanged = true;
				}
				if(ocol < mincol || ocol >= maxcol || osheetId !== sheetId) {
					var ret = me.adjustCalForInsertColumn({
						json: json,
						osheetId: osheetId,
						sheetId: sheetId,
						preChanged: preChanged,
						changed: changed,
						mincol: mincol,
						colSpan: colSpan,
						expandCalInNext: expandCalInNext
					});
					var arg = ret.text;
					changed = ret.changed;
					if(changed) {
						var isNamedFunc = rd.hasOwnProperty("named_func") ? "named_func" : undefined;
						var o = this.transferCalculate({
							data: arg
						}, store, osheetId, row, ocol, isNamedFunc);
						if(isNamedFunc) {
							var oldId = curId = rd.named_func;
							if(!oldCalCache[oldId]) {
								oldCalCache[oldId] = SCOM.copy(store.getNamedFuncConfigByName(oldId));
							}
							needCheckNamedFunc[oldId] = true;
							curCalCache[curId] = curCalCache[curId] || {
								ctype: "named_func",
								jsonArr: []
							};
							curCalCache[curId].jsonArr.push({
								cal: arg,
								arg: o.arg,
								refs: o.refs,
								scope: json.scope
							});
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: ocol
								}),
								oldId = curId;
							if(col !== ocol) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col,
								json: {
									data: json.data,
									arg: json.arg,
									refs: json.refs
								}
							};
							store.setCell(osheetId, row, ocol, {
								data: arg,
								arg: o.arg,
								refs: o.refs
							}, null, true);
							curCalCache[curId] = {
								sheet: osheetId,
								row: row,
								col: ocol,
								json: {
									data: arg,
									arg: o.arg,
									refs: o.refs
								}
							};
						}
					}
				}
			}
		}, this);
		var needRefreshCal;
		if(!SCOM.isEmptyObj(needCheckNamedFunc)) {
			for(var p in needCheckNamedFunc) {
				if(needCheckNamedFunc.hasOwnProperty(p)) {
					var nfConfig = store.mergeNamedFuncConfig(p, curCalCache[p]);
					store.setNamedFuncConfig(p, nfConfig, undefined, true);
				}
			}
			store.checkReferenceString();
		}
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)) {
			needRefreshCal = true;
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	adjustCalForInsertCell: function(config) {
		var json = config.json,
			osheetId = config.osheetId,
			sheetId = config.sheetId,
			preChanged = config.preChanged,
			changed = config.changed,
			related = config.related,
			minrow = config.minrow,
			rowSpan = config.rowSpan,
			mincol = config.mincol,
			colSpan = config.colSpan,
			moveDir = config.moveDir,
			expandCalInNext = config.expandCalInNext,
			maxrow = minrow + rowSpan - 1,
			maxcol = mincol + colSpan - 1;
		var me = this,
			store = me.sheet.getStore();
		this.spanReg.lastIndex = 0;
		var arg = json.data.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type,
				separator = me.separator;
			if(SCONST.RELATIVE_COORD == ctype) {
				separator = "";
				if(preChanged) {
					changed = true;
				}
			}
			var inFun = me.isInFun(str, pos);
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			var withSheetName = "" !== arr[0] && "string" == SCOM.typeOf(arr[0]),
				sheetName = arr[0];
			if(withSheetName) {
				arr[0] = store.getSheetIdByName(arr[0]);
			}
			if(sheetId === arr[0] || "" === arr[0] && osheetId == sheetId) {
				if(minrow <= arr[1] && arr[3] <= maxrow) {
					if(mincol <= arr[2]) {
						if("right" == moveDir) {
							arr[2] += colSpan;
							if(0 !== arr[4]) {
								arr[4] += colSpan;
							}
							changed = true;
						} else if(maxcol >= arr[4] && 0 !== arr[4]) {
							arr[1] += rowSpan;
							arr[3] += rowSpan;
							changed = true;
						}
					} else if(mincol <= arr[4] || expandCalInNext && mincol <= arr[4] + 1) {
						if("right" == moveDir) {
							if(arr[2] == arr[4] && !inFun) {
								arr[2] += colSpan;
							}
							arr[4] += colSpan;
							changed = true;
						}
					}
				} else if(mincol <= arr[2] && arr[4] <= maxcol) {
					if(minrow <= arr[1]) {
						if("down" == moveDir) {
							arr[1] += rowSpan;
							if(0 !== arr[3]) {
								arr[3] += rowSpan;
							}
							changed = true;
						} else if(maxrow >= arr[3] && 0 !== arr[3]) {
							arr[1] += colSpan;
							arr[3] += colSpan;
							changed = true;
						}
					} else if(minrow <= arr[3] || expandCalInNext && minrow <= arr[3] + 1) {
						if("down" == moveDir) {
							if(arr[1] == arr[3] && !inFun) {
								arr[1] += rowSpan;
							}
							arr[3] += rowSpan;
							changed = true;
						}
					}
				}
				if(changed) {
					arr[0] = sheetName;
					str = me.coord2String([{
						span: arr,
						type: ctype
					}], separator, withSheetName);
					return str + next;
				} else {
					if("down" == moveDir) {
						if(arr[1] >= maxrow && (arr[2] <= mincol && mincol <= arr[4] || arr[2] <= maxcol && maxcol <= arr[4] || mincol <= arr[2] && arr[4] <= maxcol)) {
							related = true;
						}
					} else {
						if(arr[2] >= maxcol && (arr[1] <= minrow && minrow <= arr[3] || arr[1] <= maxrow && maxrow <= arr[3] || minrow <= arr[1] && arr[3] <= maxrow)) {
							related = true;
						}
					}
				}
			}
			return w;
		});
		return {
			text: arg,
			changed: changed,
			related: related
		};
	},
	beforeInsertCell: function(sheetId, minrow, mincol, rowSpan, colSpan, moveDir, expandCalInNext) {
		var me = this;
		var maxrow = minrow + rowSpan - 1,
			maxcol = mincol + colSpan - 1;
		var store = this.sheet.getStore(),
			oldCalCache = {},
			curCalCache = {},
			needCheckNamedFunc = {};
		store.eachCalAndNamedFunc(function(rd) {
			var osheetId = rd.data.sheet,
				orow = row = rd.data.row,
				ocol = col = rd.data.col,
				json = rd.data.json;
			if(json.cal) {
				var changed = false,
					preChanged = false,
					related;
				flag = true;
				if("down" == moveDir && osheetId === sheetId && row > maxrow && ocol >= mincol && maxcol >= ocol) {
					row -= rowSpan;
					preChanged = true;
				}
				if("right" == moveDir && osheetId === sheetId && col > maxcol && orow >= minrow && maxrow >= orow) {
					col -= colSpan;
					preChanged = true;
				}
				if(ocol < mincol || ocol >= maxcol || orow < minrow || orow >= maxrow || osheetId !== sheetId) {
					var ret = me.adjustCalForInsertCell({
						json: json,
						osheetId: osheetId,
						sheetId: sheetId,
						preChanged: preChanged,
						changed: changed,
						minrow: minrow,
						rowSpan: rowSpan,
						mincol: mincol,
						colSpan: colSpan,
						moveDir: moveDir,
						related: related,
						expandCalInNext: expandCalInNext
					});
					var arg = ret.text;
					changed = ret.changed;
					related = ret.related;
					if(changed) {
						var isNamedFunc = rd.hasOwnProperty("named_func") ? "named_func" : undefined;
						var o = this.transferCalculate({
							data: arg
						}, store, osheetId, orow, ocol, isNamedFunc);
						if(isNamedFunc) {
							var oldId = curId = rd.named_func;
							if(!oldCalCache[oldId]) {
								oldCalCache[oldId] = SCOM.copy(store.getNamedFuncConfigByName(oldId));
							}
							needCheckNamedFunc[oldId] = true;
							curCalCache[curId] = curCalCache[curId] || {
								ctype: "named_func",
								jsonArr: []
							};
							curCalCache[curId].jsonArr.push({
								cal: arg,
								arg: o.arg,
								refs: o.refs,
								scope: json.scope
							});
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: orow,
									col: ocol
								}),
								oldId = curId;
							if(col !== ocol || row != orow) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col,
								json: {
									data: json.data,
									arg: json.arg,
									refs: json.refs
								}
							};
							store.setCell(osheetId, orow, ocol, {
								data: arg,
								arg: o.arg,
								refs: o.refs
							}, null, true);
							curCalCache[curId] = {
								sheet: osheetId,
								row: orow,
								col: ocol,
								json: {
									data: arg,
									arg: o.arg,
									refs: o.refs
								}
							};
						}
					} else if(related) {
						if(rd.named_func) {
							var oldId = curId = rd.named_func;
							oldCalCache[oldId] = oldCalCache[oldId] || true;
							curCalCache[curId] = curCalCache[curId] || true;
						} else {
							var curId = store.getIdBasedData({
									sheet: osheetId,
									row: orow,
									col: ocol
								}),
								oldId = curId;
							if(col !== ocol || row != orow) {
								oldId = store.getIdBasedData({
									sheet: osheetId,
									row: row,
									col: col
								});
							}
							oldCalCache[oldId] = {
								sheet: osheetId,
								row: row,
								col: col
							};
							curCalCache[curId] = {
								sheet: osheetId,
								row: orow,
								col: ocol
							};
						}
					}
				}
			}
		}, this);
		var needRefreshCal;
		if(!SCOM.isEmptyObj(needCheckNamedFunc)) {
			for(var p in needCheckNamedFunc) {
				if(needCheckNamedFunc.hasOwnProperty(p)) {
					var nfConfig = store.mergeNamedFuncConfig(p, curCalCache[p]);
					store.setNamedFuncConfig(p, nfConfig, undefined, true);
				}
			}
			store.checkReferenceString();
		}
		if(SCOM.countObjMember(oldCalCache) && SCOM.countObjMember(curCalCache)) {
			needRefreshCal = true;
		}
		return {
			oldCal: oldCalCache,
			curCal: curCalCache,
			needRefreshCal: needRefreshCal
		};
	},
	holdChange: function(e) {
		e.calCdt = true;
	},
	each: function(sheetId, row, col, args, fn, scope, skipEmpty) {
		var me = this;
		var store = this.sheet.getStore();
		var cacheRow = row,
			cacheCol = col;
		var index = 0;
		var processCoordObj = function(coord) {
			var span = coord.span || coord.SPAN,
				type = coord.type || coord.TYPE;
			var range = me.transferCoord2MinMax(span, sheetId);
			var min = range.min,
				max = range.max;
			if(SCONST.ABSOLUTE_COORD == type) {
				row = col = 0;
			} else if(SCONST.ABSOLUTE_ROW_COORD == type) {
				row = 0;
				col = cacheCol;
			} else if(SCONST.ABSOLUTE_COL_COORD == type) {
				col = 0;
				row = cacheRow;
			} else {
				row = cacheRow;
				col = cacheCol;
			}
			var minrow = "" === min[1] ? 0 : row + min[1],
				mincol = "" === min[2] ? 0 : col + min[2],
				maxrow = "" === max[1] ? 0 : row + max[1],
				maxcol = "" === max[2] ? 0 : col + max[2];
			var span = [min[0], minrow, mincol, maxrow, maxcol];
			store.walkRange([span], function(rd) {
				if(fn) {
					return fn.call(scope, [rd.data.sheet, rd.data.row, rd.data.col, rd.data.json], "span", index++, argIndex++, span);
				}
			}, this, skipEmpty);
		};
		if(!Ext.isArray(args) && !args.callee) {
			args = [args];
		}
		for(var i = 0, len = args.length; i < len; i++) {
			var arg = args[i];
			var argIndex = 0;
			if(me.isSingleCoordObj(arg)) {
				processCoordObj(arg);
			} else if(Ext.isArray(arg)) {
				var argIndex = 0;
				for(var j = 0, alen = arg.length; j < alen; j++) {
					var it = arg[j];
					if(me.isSingleCoordObj(it)) {
						processCoordObj(it);
					} else {
						fn.call(scope, arg[j], "array", index++, argIndex++, arg);
					}
				}
			} else {
				var argIndex = 0;
				fn.call(scope, arg, "value", index++, argIndex++, arg);
			}
		}
	},
	resetData: function(obj, store, sheetId, row, col, oldSheetId, oldRow, oldCol, reverse, changedTabName) {
		var calStr = obj.data,
			arg = obj.arg,
			refs = obj.refs;
		calStr = calStr.toString();
		var me = this;
		var rowOffset = row - oldRow,
			colOffset = col - oldCol;
		var index = 0,
			changed = false;
		this.spanReg.lastIndex = 0;
		var newCalStr = calStr.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type,
				separator = me.separator;
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			if(SCONST.ABSOLUTE_COORD == ctype) {
				if("" !== arr[0] && "string" == SCOM.typeOf(arr[0])) {
					var oldSheetName = arr[0];
					var relatedSheetId = store.getSheetIdByName(arr[0], undefined, true);
					if(!Ext.isDefined(relatedSheetId)) {
						arr[0] = "\"#REF\"";
					} else {
						arr[0] = store.getSheetNameById(relatedSheetId);
					}
					if(arr[0] !== oldSheetName) {
						changed = true;
					}
				}
				if(arr[0] === changedTabName) {
					changed = true;
				}
				if(changed) {
					str = me.coord2String([{
						span: arr,
						type: ctype
					}], separator, true);
					return str + next;
				} else {
					return w;
				}
			} else {
				if(SCONST.RELATIVE_COORD == ctype) {
					if(0 !== arr[1]) {
						arr[1] += rowOffset;
					} else {
						changed = true;
					}
					if(0 !== arr[2]) {
						arr[2] += colOffset;
					} else {
						changed = true;
					}
					if(0 !== arr[3]) {
						arr[3] += rowOffset;
					} else {
						changed = true;
					}
					if(0 !== arr[4]) {
						arr[4] += colOffset;
					} else {
						changed = true;
					}
					if(reverse) {
						var rowMinOff = arr[1] - row,
							rowMaxOff = arr[3] - row,
							colMinOff = arr[2] - col,
							colMaxOff = arr[4] - col;
						arr[1] = row + colMinOff;
						arr[3] = row + colMaxOff;
						arr[2] = col + rowMinOff;
						arr[4] = col + rowMaxOff;
						changed = true;
					}
					separator = "";
				} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
					arr[1] += rowOffset;
					arr[3] += rowOffset;
				} else if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
					arr[2] += colOffset;
					arr[4] += colOffset;
				}
				if(arr[1] == arr[3]) {
					if(0 > arr[1]) {
						arr[1] = arr[3] = 0;
						changed = true;
					}
				} else {
					if(0 >= arr[1]) {
						arr[1] = 1;
						changed = true;
					}
					if(0 >= arr[3]) {
						arr[3] = 1;
						changed = true;
					}
				}
				if(arr[2] == arr[4]) {
					if(0 > arr[2]) {
						arr[2] = arr[4] = 0;
						changed = true;
					}
				} else {
					if(0 >= arr[2]) {
						arr[2] = 1;
						changed = true;
					}
					if(0 >= arr[4]) {
						arr[4] = 1;
						changed = true;
					}
				}
				if("" !== arr[0] && "string" == SCOM.typeOf(arr[0])) {
					var oldSheetName = arr[0];
					var relatedSheetId = store.getSheetIdByName(arr[0], undefined, true);
					if(!Ext.isDefined(relatedSheetId)) {
						arr[0] = "\"#REF\"";
					} else {
						arr[0] = store.getSheetNameById(relatedSheetId);
					}
					if(arr[0] !== oldSheetName) {
						changed = true;
					}
				}
				if(arr[0] === changedTabName) {
					changed = true;
				}
				str = me.coord2String([{
					span: arr,
					type: ctype
				}], separator, true);
				return str + next;
			}
		});
		if(changed || newCalStr !== calStr) {
			var tmp = Ext.apply({}, obj);
			tmp.data = newCalStr;
			var trObj = this.transferCalculate(tmp, store, sheetId, row, col);
			return {
				data: newCalStr,
				arg: trObj.arg,
				refs: trObj.refs
			};
		} else {
			return {
				data: newCalStr,
				arg: arg,
				refs: refs
			};
		}
	},
	addQuoteForSheetName: function(o, store) {
		var me = this;
		this.spanReg.lastIndex = 0;
		var data = o.data.replace(this.spanReg, function(w) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = me.assembleCoordByRegResult(arguments);
			if(!ret) {
				return w;
			}
			var arr = ret.span,
				next = ret.next,
				ctype = ret.type;
			arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
			if(arr[0]) {
				var sheetId = store.getSheetIdByName(arr[0]);
				if(Ext.isDefined(sheetId)) {
					arr[0] = store.getSheetNameById(sheetId);
				}
				arr[0] = me.quoteStr(arr[0]);
			}
			separator = SCONST.RELATIVE_COORD == ctype ? "" : me.separator;
			var str = me.coord2String([{
				span: arr,
				type: ctype
			}], separator, true);
			return str + next;
		});
		o.data = data;
	},
	isInQuote: function(str, pos, startPos) {
		startPos = startPos || 0;
		var s = 0,
			d = 0;
		for(var i = startPos; i < pos; i++) {
			var chr = str.charAt(i);
			if("\"" == chr) {
				s++;
			}
			if("'" == chr) {
				d++;
			}
		}
		if(0 !== s % 2 || 0 !== d % 2) {
			return true;
		}
		return false;
	},
	specialCaseForCalculateStr: function(calStr, ignoreQuote) {
		var me = this;
		var arg = calStr.replace(/[=]+/gi, function(w) {
			var index = arguments[arguments.length - 2];
			if("=" == w && (ignoreQuote || !me.isInQuote(calStr, index))) {
				var lastChr = 0 < index ? calStr.charAt(index - 1) : "";
				if("!" != lastChr && "<" != lastChr && ">" != lastChr) {
					return "==";
				}
			}
			return w;
		});
		calStr = arg.replace(/\<\>/gi, function(w) {
			var index = arguments[arguments.length - 2];
			if(ignoreQuote || !me.isInQuote(arg, index)) {
				return "!=";
			}
			return w;
		});
		calStr = arg.replace(/[-.0-9]+%/gi, function(w) {
			var index = arguments[arguments.length - 2];
			if(ignoreQuote || !me.isInQuote(arg, index)) {
				var num = w.slice(0, w.length - 1);
				num = Number(num);
				if(Ext.isNumber(num)) {
					return num / 100;
				}
			}
			return w;
		});
		return calStr;
	},
	processCalculate: function(o, scope, skipUpdateValue, callerId) {
		var store = scope.store,
			sheetId = scope.sheet,
			row = scope.row,
			col = scope.col,
			timestamp = scope.timestamp;
		var separateChar = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar;
		store.getSheetIdLookup();
		callerId = callerId || store.getIdBasedData({
			sheet: store.idCrossMap[sheetId] || sheetId,
			row: row,
			col: col
		});
		if(0 === row || 0 === col) {
			return {};
		}
		if(!o.data) {
			return o;
		}
		var args = o.arg;
		if(o.cal) {
			if(!this.lookup[callerId]) {
				this.lookup[callerId] = [sheetId, row, col];
				if(store.isLoadingCells() || false != SCOM.typeOf(o.value)) {
					o.data = o.value;
				} else {
					scope = Ext.applyIf({
						me: this,
						isArrayFormula: Ext.isNumber(o.afrow)
					}, scope);
					var oldVal = o.value;
					Ext.apply(o, this.evalCal(args, scope, o));
					if("named_func" !== skipUpdateValue && (!skipUpdateValue || oldVal !== o.data)) {
						var val = o.data;
						var modified = {
							value: val
						};
						store.setCell(sheetId, row, col, modified, null, true);
					}
					o.value = o.data;
				}
			} else {
				var arr = this.lookup[callerId];
				this.lookup = {};
				o.data = o.value = {
					code: "CAL_INFINATE_LOOP",
					span: [arr[0], arr[1], arr[2], arr[1], arr[2]]
				};
				throw o.value;
			}
			delete this.lookup[callerId];
		}
		return o;
	},
	getCellData: function(sheetId, row, col, scope) {
		var store = scope.store;
		var separateChar = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar;
		store.getSheetIdLookup();
		var fullSheetId = store.idCrossMap[sheetId];
		var cid = store.getIdBasedData({
			sheet: fullSheetId || sheetId,
			row: row,
			col: col
		});
		var cd = {},
			rec = store.getRecord(sheetId, row, col);
		if(rec) {
			var json = rec.data.json;
			if(!SCOM.isEmptyValue(json.data)) {
				cd = Ext.apply({}, json);
			}
		}
		if(store.isMergedCell(cd, sheetId, row, col) && !(0 == cd.minrow && 0 == cd.mincol)) {
			if(Ext.isObject(cd.data) && cd.data._isExp) {
				throw cd.data;
			}
			cd.value = 0;
			cd.data = 0;
			return cd;
		}
		var newScope = {
			store: store,
			sheet: sheetId,
			row: row,
			col: col,
			timestamp: scope.timestamp,
			originScope: Ext.apply({}, scope)
		};
		cd = this.processCalculate(cd, newScope, undefined, cid);
		if(Ext.isObject(cd.data) && cd.data._isExp) {
			throw cd.data;
		}
		if(Ext.isNumber(cd.aerow)) {
			var afrow = cd.afrow + row,
				afcol = cd.afcol + col,
				aerow = cd.aerow + row,
				aecol = cd.aecol + col;
			if(scope.row >= afrow && scope.row <= aerow && scope.col >= afcol && scope.col <= aecol) {
				return cd;
			}
		}
		cd = this.processArrayFormulaResult(cd, row, col);
		return cd;
	},
	processArrayFormulaResult: function(cell, row, col) {
		if(Ext.isArray(cell.data) && Ext.isNumber(cell.afrow)) {
			var afrow = cell.afrow + row,
				afcol = cell.afcol + col;
			var rowIndex = row - afrow,
				colIndex = col - afcol;
			var data = cell.data;
			if(!Ext.isArray(data)) {
				data = [data];
			}
			var colLen = data.length,
				rowLen = false;
			if(Ext.isArray(data[0])) {
				rowLen = data[0].length;
			}
			colIndex = colIndex % colLen;
			if(false === rowLen) {
				cell.data = data[colIndex];
			} else if(rowIndex < rowLen) {
				cell.data = data[colIndex][rowIndex];
			} else {
				cell.data = "#N/A";
			}
		}
		return cell;
	},
	evalCal: function(calStr, scope, cellObj) {
		try {
			var me = this,
				calculates = me.calculates;
			var exposeFns = me._exposeFns,
				exposeScope = me._exposeScope;
			var scopeCache = Ext.apply({}, exposeScope);
			for(var p in exposeScope) {
				if(exposeScope.hasOwnProperty(p)) {
					delete exposeScope[p];
				}
			}
			Ext.apply(exposeScope, scope);
			var store = me.sheet.getStore();
			var upperCaseReserved = this.upperCaseReserved;
			return(function() {
				var nfv = Ext.bind(store.getNamedFuncValue, store);
				calStr = upperCaseReserved(calStr);
				var sheetStr = Ext.isNumber(scope.sheet) ? scope.sheet : "\"" + scope.sheet + "\"";
				var envStr = "\"use strict\";var window={}," + store.exposeNamedFuncVar + "=nfv,_curSheetId=" + sheetStr + ";" + me.prepareEnv();
				var refStr = store.prepareFileConfigReference();
				calStr = envStr + refStr + calStr;
				var v = (function() {
					return eval(calStr);
				})();
				var valOfFlag = false;
				if(Ext.isFunction(v)) {
					v = v.call(exposeScope);
				}
				if(Ext.isObject(v)) {
					if(!v.code && "named_func" !== scope.from) {
						valOfFlag = true;
					}
				} else if(Ext.isArray(v) && 1 == v.length && !scope.isArrayFormula) {
					v = v[0];
					if(me.isSingleCoordObj(v)) {
						valOfFlag = true;
					}
				}
				if(valOfFlag) {
					calStr = envStr + " VALOF(" + Ext.encode(v) + ");";
					v = (function() {
						return eval(calStr);
					})();
				}
				for(var p in exposeScope) {
					if(exposeScope.hasOwnProperty(p)) {
						delete exposeScope[p];
					}
				}
				Ext.apply(exposeScope, scopeCache);
				if(Ext.isFunction(v) || Ext.isArray(v) || Ext.isObject(v)) {
					if(v.code) {
						throw v;
					} else {
						if(Ext.isArray(v) && cellObj && Ext.isNumber(cellObj.afrow)) {
							if(Ext.isNumber(cellObj.aerow)) {
								v = HELPER.singleArr2ToArr1(v);
								if(cellObj.afcol === cellObj.aecol && !Ext.isArray(v[0])) {
									v = [v];
								}
							}
						} else if("named_func" !== scope.from) {
							throw {
								code: "CAL_NO_VALUE"
							};
						}
					}
				}
				try {
					if(v.toString() == "Infinity") {
						throw {
							code: "SS_ERROR_INFINITY"
						};
					}
				} catch(e) {
					throw {
						code: "CAL_INVALID_NAME"
					};
				}
				return {
					data: v
				};
			})();
		} catch(e) {
			if(Ext.isObject(e)) {
				e._isExp = true;
			} else {
				e = {
					code: e.toString(),
					_isExp: true
				};
			}
			return {
				data: e
			};
		}
	},
	upperCaseReserved: function(calStr) {
		calStr = calStr.replace(/[a-z0-9]+/gi, function(w) {
			var lw = w.toLowerCase();
			if("true" == lw || "false" == lw) {
				return lw;
			}
			return w;
		});
		calStr = calStr.replace(/[a-z0-9]+\s*\(/gi, function(w) {
			var lw = w.toLowerCase().slice(0, w.length - 1);
			if("false" == lw || "true" == lw || "if" == lw || "and" == lw || "or" == lw || "not" == lw || "int" == lw || "date" == lw || "text" == lw) {
				return w.toUpperCase();
			}
			return w;
		});
		return calStr;
	},
	escapeErrorResult: function(calStr) {
		var marks = [];
		calStr.replace(/(("[^\"]+")|('[^\']+')|((^|[,\s\+\-\*\/\>\<\=\(\)])(iferror|iserror|isna|ifna|iserr|IF)))/gi, function(w) {
			if(arguments[4]) {
				var index = arguments[arguments.length - 2] + w.length;
				if("(" === calStr.charAt(index)) {
					marks.push(index + 1);
				}
			}
		});
		if(0 < marks.length) {
			for(var i = marks.length - 1; 0 <= i; i--) {
				var pos = marks[i],
					match = 0;
				var strLen = calStr.length;
				var pts = [];
				pts.push(pos);
				var j = pos;
				for(; j < strLen; j++) {
					var ch = calStr[j];
					if("(" == ch) {
						match++;
					} else if(")" == ch) {
						match--;
					}
					if(0 > match) {
						break;
					} else if(0 == match && "," == ch) {
						pts.push(j);
						var k = j + 1;
						while(k < strLen) {
							if(!calStr[k]) {
								k++;
							} else {
								pts.push(k);
								break;
							}
						}
					}
				}
				if(j < strLen) {
					pts.push(j);
				}
				var len = pts.length;
				if(0 < len) {
					var parts = [];
					for(var k = 0; k < len; k++) {
						if(0 == k) {
							parts.push(calStr.slice(0, pts[k]));
						}
						if(0 == k % 2) {
							parts.push("function(){return (");
						} else {
							parts.push(")}");
						}
						if(k < len - 1) {
							parts.push(calStr.slice(pts[k], pts[k + 1]));
						} else {
							parts.push(calStr.slice(pts[k], strLen));
						}
						if(1 === len) {
							parts.push(")}");
						}
					}
					calStr = parts.join("");
				}
			}
		}
		return calStr;
	},
	isExpress: function(str) {
		return /^\s*[\!\<\>\=]/gi.test(str);
	},
	prepareEnv: function() {
		var me = this,
			pro = EnterpriseSheet.pure.sheet.calculate.Calculate.prototype,
			escapeErrorFuncs = pro.escapeErrorFuncs;
		if(!me._exposeEnv.envStr) {
			var calculates = me.calculates,
				exposeFns = me._exposeFns,
				exposeScope = me._exposeScope;
			var expose = [];
			for(var p in calculates) {
				if(calculates.hasOwnProperty(p) && "function" == Ext.typeOf(calculates[p])) {
					var name = p.toString(),
						lowName = name.toLowerCase();
					var NAME = name.toUpperCase();
					var fn = calculates[name];
					if(escapeErrorFuncs[lowName]) {
						exposeFns[name] = Ext.Function.bind(fn, exposeScope);
					} else {
						exposeFns[name] = Ext.Function.bind(function() {
							for(var i = 0, len = arguments.length; i < len; i++) {
								var it = arguments[i];
								if(Ext.isFunction(it)) {
									arguments[i] = it.call(this.scope);
								}
							}
							return this.func.apply(this.scope, arguments);
						}, {
							func: fn,
							scope: exposeScope
						});
					}
					expose.push("var " + name + " = exposeFns." + name + ";var " + NAME + " = " + name + ";");
				}
			}
			me._exposeEnv.envStr = expose.join("");
		}
		return me._exposeEnv.envStr;
	},
	fakeEnv: function() {
		var me = this,
			pro = EnterpriseSheet.pure.sheet.calculate.Calculate.prototype;
		if(!me._exposeEnv.fakeEnvStr) {
			var calculates = me.calculates;
			var expose = [];
			for(var p in calculates) {
				if(calculates.hasOwnProperty(p) && "function" == Ext.typeOf(calculates[p])) {
					var name = p.toString();
					var fn = calculates[name];
					var NAME = name.toUpperCase();
					expose.push("var " + name + " = function(){};var " + NAME + " = function(){};");
				}
			}
			me._exposeEnv.fakeEnvStr = expose.join("");
		}
		return me._exposeEnv.fakeEnvStr;
	},
	absolute2Relative: function(span, row, col, coordType) {
		if(SCONST.RELATIVE_COORD == coordType) {
			span[1] -= row;
			span[2] -= col;
			span[3] -= row;
			span[4] -= col;
		} else if(SCONST.ABSOLUTE_ROW_COORD == coordType) {
			span[2] -= col;
			span[4] -= col;
		} else if(SCONST.ABSOLUTE_COL_COORD == coordType) {
			span[1] -= row;
			span[3] -= row;
		}
		return span;
	},
	resetCache: function() {
		this.cache = {};
	},
	keep2Cache: function(arg, timestamp, data) {
		this.cache = this.cache || {};
		this.cache[arg] = {
			timestamp: timestamp,
			data: Ext.apply({}, data)
		};
	},
	getFromCache: function(arg, timestamp) {
		if(this.cache) {
			var o = this.cache[arg];
			if(o && o.timestamp == timestamp) {
				return o.data;
			}
		}
	},
	walkRange: function(store, sheet, row, col, range, fn) {
		store.walkRange(range, function(rd, span) {
			fn.call(this, rd.data.sheet, rd.data.row, rd.data.col, rd.data.json);
		}, this);
	},
	findMinMaxInCondition: function(timestamp, store, sheet, row, col, range, addOnScope) {
		var tmp = {
			min: false,
			max: false
		};
		var fn = function(s, r, c, json) {
			if(!Ext.isDefined(json.minrow) || 0 === json.minrow && 0 === json.mincol) {
				var cell = this.getCellData(s, r, c, Ext.apply({
					store: store,
					sheet: sheet,
					row: row,
					col: col,
					timestamp: timestamp
				}, addOnScope));
				if(SCOM.canbeNumber(cell.data)) {
					var n = Number(cell.data);
					if(false === tmp.min || tmp.min > n) {
						tmp.min = n;
					}
					if(false === tmp.max || tmp.max < n) {
						tmp.max = n;
					}
				}
			}
		};
		this.walkRange(store, sheet, row, col, range, fn);
		return tmp;
	},
	minMaxVal: function(range, scope) {
		var me = scope.me,
			calculates = me.calculates;
		var min = false,
			max = false,
			minOrigData = 0,
			maxOrigData = 0;
		var rangeObjs = calculates.rangeObjsOf.call(scope, range);
		for(var i = 0, len = rangeObjs.length; i < len; i++) {
			var data = rangeObjs[i];
			if(data === undefined || data === "" || data === null) {
				continue;
			}
			if(HELPER.isBoolean(data)) {
				data = HELPER.convertBoolean2Int(data);
			}
			var num = Number(data);
			if(Ext.isNumber(num)) {} else {
				var checkDate = SFORMAT.checkingDate(data);
				if(checkDate) {
					num = HELPER.convertDateToNum(checkDate);
				} else {
					continue;
				}
			}
			if(false === min || min > num) {
				min = num;
				minOrigData = data;
			}
			if(false === max || max < num) {
				max = num;
				maxOrigData = data;
			}
		}
		return {
			min: minOrigData,
			max: maxOrigData
		};
	},
	getMinMax: function(range, scope, addOnScope) {
		var store = scope.store,
			timestamp = scope.timestamp,
			sheet = scope.sheet,
			row = scope.row,
			col = scope.col;
		var coord = [],
			min = false,
			max = false;
		for(var i = 0, len = range.length; i < len; i++) {
			var it = range[i];
			if(Ext.isObject(it) && it.span) {
				coord.push(it);
			} else {
				if(it === undefined || it === "" || it === null) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "min/max"
					};
				}
				var num = Number(it);
				if(Ext.isNumber(num)) {
					if(false === min || min > num) {
						min = num;
					}
					if(false === max || max < num) {
						max = num;
					}
				} else {
					throw {
						code: "CAL_NO_VALUE",
						cal: "min/max"
					};
				}
			}
		}
		coord = this.transfer2Absolute(sheet, row, col, coord);
		var str = Ext.encode(coord);
		var data = this.getFromCache(str, timestamp);
		if(!data || false == SCOM.typeOf(data.min) || false == SCOM.typeOf(data.max)) {
			data = this.findMinMaxInCondition(timestamp, store, sheet, row, col, coord, addOnScope);
			this.keep2Cache(str, timestamp, {
				min: data.min,
				max: data.max
			});
		}
		if(false === min || Ext.isNumber(data.min) && min > data.min) {
			min = data.min;
		}
		if(false === max || Ext.isNumber(data.max) && max < data.max) {
			max = data.max;
		}
		return {
			min: min,
			max: max
		};
	},
	findCountInCondition: function(timestamp, store, sheet, row, col, range, addOnScope) {
		var tmp = {
			count: 0
		};
		var fn = function(s, r, c, json) {
			if(!Ext.isDefined(json.minrow) || 0 === json.minrow && 0 === json.mincol) {
				var cell = this.getCellData(s, r, c, Ext.apply({
					store: store,
					sheet: sheet,
					row: row,
					col: col,
					timestamp: timestamp
				}, addOnScope));
				if(false != SCOM.typeOf(cell.data) && SCOM.canbeNumber(cell.data)) {
					tmp.count++;
				}
			}
		};
		this.walkRange(store, sheet, row, col, range, fn);
		return tmp.count;
	},
	getCount: function(range, scope, addOnScope) {
		var store = scope.store,
			timestamp = scope.timestamp,
			sheet = scope.sheet,
			row = scope.row,
			col = scope.col;
		var coord = [],
			count = 0;
		for(var i = 0, len = range.length; i < len; i++) {
			var it = range[i];
			if(Ext.isObject(it) && it.span) {
				coord.push(it);
			} else {
				count++;
			}
		}
		coord = this.transfer2Absolute(sheet, row, col, coord);
		var str = Ext.encode(coord);
		var data = this.getFromCache(str, timestamp);
		if(!data || false == SCOM.typeOf(data.count)) {
			var c = this.findCountInCondition(timestamp, store, sheet, row, col, coord, addOnScope);
			count += c;
			this.keep2Cache(str, timestamp, {
				count: c
			});
		} else {
			count += data.count;
		}
		return count;
	},
	findAverageInCondition: function(timestamp, store, sheet, row, col, range, addOnScope) {
		var tmp = {
			sum: 0,
			count: 0
		};
		var fn = function(s, r, c) {
			var cell = this.getCellData(s, r, c, Ext.apply({
				store: store,
				sheet: sheet,
				row: row,
				col: col,
				timestamp: timestamp
			}, addOnScope));
			if(SCOM.canbeNumber(cell.data)) {
				tmp.sum += Number(cell.data);
				tmp.count++;
			}
		};
		this.walkRange(store, sheet, row, col, range, fn);
		if(0 < tmp.count) {
			return {
				sum: tmp.sum,
				count: tmp.count,
				average: tmp.sum / tmp.count
			};
		} else {
			return {
				sum: 0,
				count: 0,
				average: 0
			};
		}
	},
	getAverage: function(range, scope, addOnScope) {
		var store = scope.store,
			timestamp = scope.timestamp,
			sheet = scope.sheet,
			row = scope.row,
			col = scope.col;
		var coord = [],
			sum = 0,
			count = 0;
		for(var i = 0, len = range.length; i < len; i++) {
			var it = range[i];
			if(Ext.isObject(it) && it.span) {
				coord.push(it);
			} else {
				var num = Number(it);
				if(Ext.isNumber(num)) {
					sum += num;
					count++;
				}
			}
		}
		coord = this.transfer2Absolute(sheet, row, col, coord);
		var str = Ext.encode(coord);
		var data = this.getFromCache(str, timestamp),
			average;
		if(!data || false == SCOM.typeOf(data.average)) {
			var res = this.findAverageInCondition(timestamp, store, sheet, row, col, coord, addOnScope);
			sum += res.sum;
			count += res.count;
			var average = 0 === count ? 0 : sum / count;
			this.keep2Cache(str, timestamp, res);
		} else {
			sum += data.sum;
			count += data.count;
			average = 0 === count ? 0 : sum / count;
		}
		return average;
	},
	checkCoordValid: function(args) {
		var coord = [];
		if(Ext.isArray(args)) {
			for(var i = 0, len = args.length; i < len; i++) {
				var arg = args[i];
				if(this.isCoordObj(arg)) {
					coord.push(arg);
				} else if(Ext.isArray(arg)) {
					for(var j = 0, count = arg.length; j < count; j++) {
						var it = arg[j];
						if(this.isCoordObj(it)) {
							coord.push(it);
						}
					}
				}
			}
		} else {
			coord.push(args);
		}
		if(0 === coord.length) {
			return args;
		}
		for(var i = 0, len = coord.length; i < len; i++) {
			var span = coord[i].span;
			if(Ext.isArray(span)) {
				if(!Ext.isDefined(span[0] || "" === span[0])) {
					return span;
				}
			}
		}
		return true;
	},
	transferAll2Absolute: function(args, sheet, row, col) {
		var me = this;
		for(var i = 0, len = args.length; i < len; i++) {
			var arg = args[i];
			if(this.isCoordObj(arg)) {
				arg.span = me.transfer2Absolute(sheet, row, col, [arg])[0];
				arg.type = SCONST.ABSOLUTE_COORD;
			} else if(Ext.isArray(arg)) {
				for(var j = 0, count = arg.length; j < count; j++) {
					var it = arg[j];
					if(this.isCoordObj(it)) {
						it.span = me.transfer2Absolute(sheet, row, col, [it])[0];
						it.type = SCONST.ABSOLUTE_COORD;
					}
				}
			}
		}
		return args;
	},
	checkRangeMatch: function(params, rangeLen, isRow, isCol) {
		var rowLen, colLen;
		for(var i = 0, len = params.length; i < len; i++) {
			var it = params[i];
			if(this.isCoordObj(it)) {
				var span = it.span;
				var rlen = span[3] - span[1] + 1,
					clen = span[4] - span[2] + 1;
				if(!Ext.isDefined(isRow)) {
					isRow = 0 == span[1];
				} else if(isRow != (0 == span[1])) {
					return false;
				}
				if(!Ext.isDefined(isCol)) {
					isCol = 0 == span[2];
				} else if(isCol != (0 == span[2])) {
					return false;
				}
				if(!Ext.isDefined(rowLen)) {
					rowLen = rlen;
				} else if(rowLen != rlen) {
					return false;
				}
				if(!Ext.isDefined(colLen)) {
					colLen = clen;
				} else if(colLen != clen) {
					return false;
				}
				if(!Ext.isDefined(rangeLen)) {
					rangeLen = rlen * clen;
				} else if(rangeLen != rlen * clen) {
					return false;
				}
			} else if(Ext.isArray(it)) {
				if(isRow || isCol) {
					return false;
				}
				var ilen = it.length;
				if(!Ext.isDefined(rangeLen)) {
					rangeLen = ilen;
				} else if(rangeLen != ilen) {
					return false;
				}
			} else {
				if(isRow || isCol) {
					return false;
				}
				if(!Ext.isDefined(rangeLen)) {
					rangeLen = 1;
				} else if(rangeLen != 1) {
					return false;
				}
			}
		}
		return true;
	},
	isCoordObj: function(obj) {
		if(Ext.isArray(obj)) {
			if(1 === obj.length) {
				obj = obj[0];
			}
		}
		if(Ext.isObject(obj)) {
			var span = obj.span || obj.SPAN;
			if(Ext.isArray(span) && 5 == span.length) {
				return true;
			}
		}
		return false;
	},
	isSingleCoordObj: function(obj) {
		if(Ext.isObject(obj)) {
			var span = obj.span || obj.SPAN;
			if(Ext.isArray(span) && 5 == span.length) {
				return true;
			}
		}
		return false;
	},
	sumxmyCommon: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(len != 2) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var xArrary = arguments[0],
			yArrary = arguments[1];
		if(Ext.isArray(xArrary)) {} else if(Ext.isString(xArrary) || Ext.isNumber(Number(xArrary))) {
			xArrary = [xArrary];
		} else {
			xArrary = calculates.rangeObjsOf.call(myScope, [xArrary]);
		}
		if(Ext.isArray(yArrary)) {} else if(Ext.isString(yArrary) || Ext.isNumber(Number(yArrary))) {
			yArrary = [yArrary];
		} else {
			yArrary = calculates.rangeObjsOf.call(myScope, [yArrary]);
		}
		if(yArrary.length != yArrary.length) {
			throw {
				code: "CAL_PARAM_NOT_MATCH",
				cal: option
			};
		}
		if(xArrary.length == yArrary.length && xArrary.length > 0) {
			var result = 0;
			for(var i = 0; i < xArrary.length; i++) {
				var xVal = Number(xArrary[i]);
				if(HELPER.isBoolean(xArrary[i])) {
					xVal = 1;
				} else if(!Ext.isNumber(xVal)) {
					continue;
				}
				var yVal = Number(yArrary[i]);
				if(HELPER.isBoolean(yArrary[i])) {
					yVal = 1;
				} else if(!Ext.isNumber(yVal)) {
					continue;
				}
				if(option == "sumxmy2") {
					result += Math.pow(xVal - yVal, 2);
				}
				if(option == "sumx2py2") {
					result += Math.pow(xVal, 2) + Math.pow(yVal, 2);
				}
				if(option == "sumx2my2") {
					result += Math.pow(xVal, 2) - Math.pow(yVal, 2);
				}
			}
			xArrary = [];
			yArrary = [];
			return result;
		}
		xArrary = [];
		yArrary = [];
		throw {
			code: "VALUE_NOT_AVAILABLE",
			cal: option
		};
	},
	mathCommonFunction2: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col;
		var len = arguments.length;
		if(len != 1) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var val = arguments[0];
		if(this.isCoordObj(val)) {
			var args = this.transferAll2Absolute(arguments, isheet, irow, icol);
			var arg = args[0];
			if(this.checkRangeMatch(args, 1, false, false)) {
				var span = arg.span;
				if(span) {
					var cell = me.getCellData(span[0], span[1], span[2], myScope);
					val = cell.data;
					if(val && val == "#N/A") {
						throw {
							code: "VALUE_NOT_AVAILABLE",
							cal: option
						};
					}
					var checkDate = SFORMAT.checkingDate(val);
					if(checkDate) {
						val = HELPER.convertDateToNum(checkDate);
					}
				}
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: option
				};
			}
		} else {
			if(val === undefined || val === "" || SCOM.isEmptyStr(val)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: option
				};
				return false;
			}
		}
		if(val === undefined || val === "" || SCOM.isEmptyStr(val)) {
			if(option == "isodd") {
				return false;
			}
		}
		if(SCOM.canbeNumber(val)) {
			if(HELPER.isBoolean(val) && (option == "iseven" || option == "isodd" || option == "sqrtpi")) {
				throw {
					code: "CAL_NO_VALUE",
					cal: option
				};
			}
			var num = Number(val);
			if(option == "even") {
				if(num < 0) {
					num = Math.ceil(Math.abs(num));
					if(num % 2 > 0) {
						num = num + (2 - num % 2);
					}
					num = -num;
				} else {
					num = Math.ceil(num);
					if(num % 2 > 0) {
						num = num + (2 - num % 2);
					}
				}
			} else if(option == "odd") {
				if(num < 0) {
					num = Math.ceil(Math.abs(num));
					if(num % 2 == 0) {
						num = num + 1;
					}
					num = -num;
				} else {
					num = Math.ceil(num);
					if(num % 2 == 0) {
						num = num + 1;
					}
				}
			} else if(option == "fact") {
				if(num < 0) {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: option
					};
				}
				var fact = 1;
				num = Math.floor(num);
				for(var i = 1; i <= num; i++) {
					fact = fact * i;
				}
				num = fact;
			} else if(option == "factdouble") {
				if(num < 0) {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: option
					};
				}
				var fact = 1;
				num = Math.floor(num);
				for(var i = num; i > 1; i = i - 2) {
					if(i > 1) {
						fact = fact * i;
					}
				}
				num = fact;
			} else if(option == "iseven") {
				num = num > 0 ? Math.floor(num) : Math.ceil(num);
				if(num % 2 == 0) {
					return true;
				} else {
					return false;
				}
			} else if(option == "isodd") {
				num = num > 0 ? Math.floor(num) : Math.ceil(num);
				if(num % 2 == 0) {
					return false;
				} else {
					return true;
				}
			} else if(option == "sign") {
				if(num > 0) {
					num = 1;
				} else if(num < 0) {
					num = -1;
				} else {
					num = 0;
				}
			} else if(option == "sqrtpi") {
				if(num < 0) {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: option
					};
				}
				num = Math.sqrt(num * Math.PI);
			} else if(option == "sqrt") {
				if(num < 0) {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: option
					};
				}
				num = Math.sqrt(num);
			} else if(option == "degrees") {
				num = 180 * (num / Math.PI);
			} else if(option == "exp") {
				num = Math.exp(num);
			} else if(option == "abs") {
				num = Math.abs(num);
			} else if(option == "int") {
				num = Math.floor(num);
			} else if(option == "radians") {
				num = Math.PI * (num / 180);
			}
			return num;
		}
		throw {
			code: "CAL_NO_VALUE",
			cal: option
		};
	},
	mathCommonFunction4: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(len != 2) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var val1 = arguments[0],
			val2 = arguments[1];
		if(me.isCoordObj(val1)) {
			val1 = calculates.valof.call(myScope, val1);
		}
		if(me.isCoordObj(val2)) {
			val2 = calculates.valof.call(myScope, val2);
		}
		if(HELPER.isBoolean(val1)) {
			if(option == "quotient") {
				throw {
					code: "CAL_NO_VALUE",
					cal: option
				};
			}
			val1 = HELPER.convertBoolean2Int(val1);
		}
		if(HELPER.isBoolean(val2)) {
			if(option == "quotient") {
				throw {
					code: "CAL_NO_VALUE",
					cal: option
				};
			}
			val2 = HELPER.convertBoolean2Int(val2);
		}
		var num = Number(val1);
		var num2 = Number(val2);
		if(!Ext.isNumber(num)) {
			throw {
				code: "CAL_NO_VALUE",
				cal: option
			};
		}
		if(!Ext.isNumber(num2)) {
			throw {
				code: "CAL_NO_VALUE",
				cal: option
			};
		}
		if(option != "mod") {
			if(HELPER.isBoolean(val1)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: option
				};
			}
			if(HELPER.isBoolean(val2)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: option
				};
			}
		}
		if(option == "ceiling") {
			if(num2 == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: option
				};
			}
			if(num2 < 0 && num * num2 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: option
				};
			}
			var snum2 = num2 + "";
			var times = 1;
			if(snum2.indexOf(".") > 0) {
				snum2 = snum2.substring(snum2.indexOf(".") + 1, snum2.length);
				times = Math.pow(10, snum2.length);
			}
			if(num2 < 0 && num < 0) {
				num = Math.ceil(Math.abs(num * times));
				num2 = Math.abs(num2 * times);
				if(num % num2 != 0) {
					num = num + (num2 - num % num2);
				}
				num = -num;
			} else if(num < 0) {
				num2 = Math.abs(num2 * times);
				num = Math.abs(Math.ceil(num * times));
				if(num % num2 == 0) {
					num = -num;
				} else {
					num = -(num - num % num2);
				}
			} else {
				num2 = Math.abs(num2 * times);
				num = Math.abs(Math.ceil(num * times));
				if(num % num2 != 0) {
					num = num + (num2 - num % num2);
				}
			}
			num = num / times;
		} else if(option == "floor") {
			if(num2 == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: option
				};
			}
			if(num2 < 0 && num * num2 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: option
				};
			}
			var snum2 = num2 + "";
			var times = 1;
			if(snum2.indexOf(".") > 0) {
				snum2 = snum2.substring(snum2.indexOf(".") + 1, snum2.length);
				times = Math.pow(10, snum2.length);
			}
			if(num2 < 0 && num < 0) {
				num = Math.floor(Math.abs(num)) * times;
				num2 = Math.abs(num2 * times);
				if(num % num2 != 0) {
					num = num - num % num2;
				}
				num = -num;
			} else if(num < 0) {
				num = Math.abs(Math.floor(num) * times);
				num2 = Math.abs(num2 * times);
				if(num % num2 == 0) {
					num = -num;
				} else {
					num = -(num + (num2 - num % num2));
				}
			} else {
				num = num * times;
				num2 = Math.abs(num2 * times);
				num = num - num % num2;
			}
			num = num / times;
		} else if(option == "mod") {
			if(num2 == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: option
				};
			}
			num = num - num2 * -Math.ceil(-(num / num2));
		} else if(option == "randbetween") {
			if(num > num2) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: option
				};
			}
			num = Math.floor(Math.random() * (num2 - num + 1) + num);
		} else if(option == "quotient") {
			if(num2 == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: option
				};
			}
			num = num / num2;
			num = num > 0 ? Math.floor(num) : Math.ceil(num);
		} else if(option == "atan2") {
			if(num2 == 0 && num == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: option
				};
			}
			num = Math.atan2(num2, num);
		}
		var digitalLen = HELPER.getDigitalLen(num);
		if(digitalLen > 13) {
			num = HELPER.roundUpNonZero(num);
		}
		return num;
	},
	mathCommonRound: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(len != 2 && len != 1) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var digital = 0;
		if(2 == len) {
			digital = arguments[1];
		}
		if(me.isCoordObj(digital)) {
			digital = calculates.valof.call(myScope, digital);
		}
		if(digital === undefined || digital === "") {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		digital = Number(digital);
		if(Ext.isNumber(digital)) {
			if(option != "mround") {
				if(digital >= 0) {
					digital = Math.floor(digital);
				} else {
					digital = Math.ceil(digital);
				}
			}
		} else {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var posOffset = arguments[0];
		if(me.isCoordObj(posOffset)) {
			posOffset = calculates.valof.call(myScope, posOffset);
		}
		if(posOffset === undefined || posOffset === "") {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var num = Number(posOffset);
		if(Ext.isNumber(num)) {
			var base = Math.pow(10, digital);
			var result = num;
			if(option == "round") {
				result = Math.round(Math.abs(num) * base) / base;
				if(num < 0) {
					result = -result;
				}
			} else if(option == "rounddown") {
				if(num > 0) {
					result = Math.floor(num * base) / base;
				} else {
					result = -Math.floor(Math.abs(num) * base) / base;
				}
			} else if(option == "roundup") {
				if(num > 0) {
					result = Math.ceil(num * base) / base;
				} else {
					result = Math.floor(num * base) / base;
				}
			} else if(option == "mround") {
				if(num === 0 || digital === 0) {
					return 0;
				}
				if(num < 0 && 0 < digital || digital < 0 && 0 < num) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: option
					};
				}
				result = Math.floor(num / digital + 0.5) * digital;
				var digitalLen = HELPER.getDigitalLen(result);
				if(digitalLen > 13) {
					result = HELPER.roundUpNonZero(result);
				}
			}
			return result;
		} else {
			throw {
				code: "CAL_NO_VALUE",
				cal: option
			};
		}
	},
	mathCommonFunction5: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		if(1 != arguments.length) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var num = arguments[0];
		if(me.isCoordObj(num)) {
			num = calculates.valof.call(myScope, num);
		}
		if(num === undefined || num == null) {
			num = 0;
		} else if(Ext.isNumber(Number(num))) {
			num = Number(num);
		} else {
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: option
			};
		}
		if(option == "LOG10" || option == "LN") {
			if(num <= 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: option
				};
			}
		}
		if(option == "ACOSH") {
			if(num < 1) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: option
				};
			}
		}
		if(option == "ATANH" || option == "ACOS" || option == "ATANH" || option == "ASIN") {
			if(num < -1 || num > 1) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: option
				};
			}
		}
		if(option == "COT" && num == 0) {
			throw {
				code: "SS_ERROR_INFINITY",
				cal: option
			};
		}
		var result = 0;
		if(option == "LOG10") {
			result = Math.log(num);
		} else if(option == "LN") {
			result = Math.log(num) / Math.log(2.71828182845904);
		} else if(option == "TANH") {
			result = (Math.exp(num) - Math.exp(-num)) / (Math.exp(num) + Math.exp(-num));
		} else if(option == "ACOS") {
			result = Math.acos(num);
		} else if(option == "ASIN") {
			result = Math.asin(num);
		} else if(option == "ATAN") {
			result = Math.atan(num);
		} else if(option == "ATANH") {
			result = 0.5 * Math.log((1 + num) / (1 - num));
		} else if(option == "CSC") {
			result = 1 / Math.sin(num);
		} else if(option == "CSCH") {
			result = 2 / (Math.exp(num) - Math.exp(-num));
		} else if(option == "SIN") {
			result = Math.sin(num);
		} else if(option == "SINH") {
			result = (Math.exp(num) - Math.exp(-num)) / 2;
		} else if(option == "COS") {
			result = Math.cos(num);
		} else if(option == "SEC") {
			result = 1 / Math.cos(num);
		} else if(option == "SECH") {
			result = 2 / (Math.exp(num) + Math.exp(-num));
		} else if(option == "COSH") {
			result = (Math.exp(num) + Math.exp(-num)) / 2;
		} else if(option == "TAN") {
			result = Math.tan(num);
		} else if(option == "ACOSH") {
			result = Math.log(num + Math.sqrt(num * num - 1));
		} else if(option == "ASINH") {
			result = Math.log(num + Math.sqrt(num * num + 1));
		} else if(option == "COT") {
			result = Math.tan(Math.PI / 2 - num);
		} else if(option == "COTH") {
			result = (Math.exp(num) + Math.exp(-num)) / (Math.exp(num) - Math.exp(-num));
		} else if(option == "ACOT") {
			result = Math.PI / 2 - Math.atan(num);
		}
		if(result == "Infinity" || result == "-Infinity") {
			throw {
				code: "SS_ERROR_INFINITY",
				cal: option
			};
		}
		var digitalLen = HELPER.getDigitalLen(result);
		if(digitalLen > 13) {
			result = HELPER.roundUpNonZero(result);
		}
		return result;
	},
	stringCommon1: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(len != 1) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var val = arguments[0];
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		if(me.isCoordObj(val)) {
			val = calculates.valof.call(myScope, val);
		}
		if(val == "#DIV/0!") {
			throw {
				code: "SS_ERROR_INFINITY"
			};
		} else if(val == "#N/A") {
			throw {
				code: "VALUE_NOT_AVAILABLE",
				cal: option
			};
		} else if(val == "#VALUE!") {
			throw {
				code: "CAL_NO_VALUE",
				cal: option
			};
		} else if(val == "#NUM!") {
			throw {
				code: "NUM_IS_NOT_RIGHT",
				cal: option
			};
		} else if(val == "#ERROR") {
			throw {
				code: "SS_ERROR",
				cal: option
			};
		}
		if(option == "upper") {
			if(Ext.isBoolean(val) || Ext.isNumber(val)) {
				return val;
			}
			return val.toUpperCase();
		} else if(option == "lower") {
			if(Ext.isBoolean(val) || Ext.isNumber(val)) {
				return val;
			}
			return val.toLowerCase();
		} else if(option == "proper") {
			if(Ext.isBoolean(val) || Ext.isNumber(val)) {
				return val;
			}
			return val.replace(/\w\S*/g, function(txt) {
				return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
			});
		} else if(option == "len") {
			return val.toString().length;
		}
	},
	imMathCommonFunction: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		if(1 != arguments.length) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var inumber = arguments[0];
		if(me.isCoordObj(inumber)) {
			inumber = calculates.valof.call(myScope, inumber);
		}
		if(option == "IMSIN" || option == "IMCOS" || option == "IMCOSH" || option == "IMCOT" || option == "IMCSC" || option == "IMCSCH" || option == "IMSINH" || option == "IMSEC" || option == "IMSECH") {
			if(inumber === true || inumber === false) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: option
				};
			}
		}
		inumber = inumber.toString();
		if(option == "IMARGUMENT") {
			return HELPER.IMARGUMENT(inumber);
		} else if(option == "IMAGINARY") {
			return HELPER.IMAGINARY(inumber);
		} else if(option == "IMREAL") {
			return HELPER.IMREAL(inumber);
		}
		var x = HELPER.IMREAL(inumber);
		var y = HELPER.IMAGINARY(inumber);
		var unit = inumber.substring(inumber.length - 1);
		unit = unit === "i" || unit === "j" ? unit : "i";
		if(x === "#NUM!" || y === "#NUM!") {
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: option
			};
		}
		var result;
		if(option == "IMSIN") {
			result = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
		} else if(option == "IMCOS") {
			result = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
		} else if(option == "IMLOG10") {
			result = HELPER.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
		} else if(option == "IMLOG2") {
			result = HELPER.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
		} else if(option == "IMABS") {
			result = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
		} else if(option == "IMLN") {
			result = HELPER.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
		} else if(option == "IMEXP") {
			var e = Math.exp(x);
			result = HELPER.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
		} else if(option == "IMCONJUGATE") {
			return y !== 0 ? HELPER.COMPLEX(x, -y, unit) : inumber;
		} else if(option == "IMCOSH") {
			return HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
		} else if(option == "IMCOT") {
			var val1 = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			var val2 = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV(val1, val2);
		} else if(option == "IMCSC") {
			var val2 = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV("1", val2);
		} else if(option == "IMCSCH") {
			var val2 = HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
			return HELPER.IMDIV("1", val2);
		} else if(option == "IMSINH") {
			return HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
		} else if(option == "IMSEC") {
			var val2 = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV("1", val2);
		} else if(option == "IMSECH") {
			var val2 = HELPER.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
			return HELPER.IMDIV("1", val2);
		} else if(option == "IMSQRT") {
			var absVal = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
			var s = Math.sqrt(absVal);
			var t = HELPER.IMARGUMENT(inumber);
			return HELPER.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
		} else if(option == "IMTAN") {
			var val1 = HELPER.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			var val2 = HELPER.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
			return HELPER.IMDIV(val1, val2);
		}
		return result;
	},
	imMathCommonFunction2: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		if(2 > arguments.length) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = arguments[0];
		if(me.isCoordObj(result)) {
			result = calculates.valof.call(myScope, result);
		}
		result = result.toString();
		for(var i = 1; i < arguments.length; i++) {
			var a = HELPER.IMREAL(result);
			var b = HELPER.IMAGINARY(result);
			var inumber2 = arguments[i];
			if(me.isCoordObj(inumber2)) {
				inumber2 = calculates.valof.call(myScope, inumber2);
			}
			inumber2 = inumber2.toString();
			var c = HELPER.IMREAL(inumber2);
			var d = HELPER.IMAGINARY(inumber2);
			if(a === "#NUM!" || b === "#NUM!" || c === "#NUM!" || d === "#NUM!") {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: option
				};
			}
			if(option == "IMSUM") {
				result = HELPER.COMPLEX(a + c, b + d);
			} else if(option == "IMPRODUCT") {
				result = HELPER.COMPLEX(a * c - b * d, a * d + b * c);
			}
		}
		return result;
	},
	statisticalCommon: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(len != 1) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var val = arguments[0];
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		if(me.isCoordObj(val)) {
			val = calculates.valof.call(myScope, val);
		}
		if(val === undefined || val === "" || SCOM.isEmptyStr(val)) {
			if(option == "istext" || option == "isnumber" || option == "islogical") {
				return false;
			} else if(option == "isblank") {
				return true;
			} else if(option == "n") {
				return 0;
			}
		}
		if(option == "isblank") {
			return false;
		}
		if(HELPER.isBoolean(val)) {
			if(option == "islogical") {
				return true;
			} else if(option == "istext" || option == "isnumber") {
				return false;
			} else if(option == "n") {
				var result = HELPER.getBoolean(val);
				if(result) {
					return 1;
				} else {
					return 0;
				}
			}
		}
		if(option == "n" && Ext.isString(val)) {
			return 0;
		}
		if(option == "istext" && Ext.isString(val)) {
			return true;
		}
		var num = Number(val);
		if(!Ext.isNumber(num)) {
			if(option == "n") {
				if(val == "#DIV/0!") {
					throw {
						code: "SS_ERROR_INFINITY",
						cal: option
					};
				} else if(val == "#N/A") {
					throw {
						code: "VALUE_NOT_AVAILABLE",
						cal: option
					};
				} else if(val == "#VALUE!") {
					throw {
						code: "CAL_NO_VALUE",
						cal: option
					};
				} else if(val == "#NUM!") {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: option
					};
				} else {
					return 0;
				}
			}
			if(option == "istext") {
				return true;
			}
		} else {
			if(option == "n") {
				return num;
			}
			if(option == "isnumber") {
				return true;
			}
		}
		return false;
	},
	stdevCommonFunction: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(0 == len) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var arrObj = calculates.rangeNumsOf2.call(myScope, arguments, option);
		if(arrObj.length == 0 || arrObj.length == 1) {
			throw {
				code: "SS_ERROR_INFINITY",
				cal: option
			};
		}
		var mean = 0,
			sum = 0,
			sumdev = 0;
		for(var i = 0; i < arrObj.length; i++) {
			sum += arrObj[i];
		}
		mean = sum / arrObj.length;
		for(var i = 0; i < arrObj.length; i++) {
			sumdev += (arrObj[i] - mean) * (arrObj[i] - mean);
		}
		var baseVal = arrObj.length - 1;
		if(option == "stdev.p" || option == "var.p") {
			baseVal = arrObj.length;
		}
		var result = sumdev / baseVal;
		if(option == "stdev.p" || option == "stdev.s" || option == "stdev") {
			return Math.sqrt(result);
		}
		if(option == "var.p" || option == "var.s" || option == "var") {
			return result;
		}
	},
	rankCommonFunction: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(0 == len) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = this.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		if(2 != len && 3 != len) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var inumber = arguments[0];
		if(me.isCoordObj(inumber)) {
			inumber = calculates.numberof.call(myScope, inumber);
		}
		var iorder = 0;
		if(len == 3) {
			iorder = arguments[2];
			if(me.isCoordObj(iorder)) {
				iorder = calculates.valof.call(myScope, iorder);
			}
			if(iorder && iorder != 0 && iorder != "0") {
				iorder = 1;
			}
		}
		var posOffset = arguments[1],
			arrObj = [];
		if(Ext.isArray(posOffset)) {
			arrObj = posOffset;
		} else {
			var tmpSpan = posOffset.span;
			if("" === tmpSpan[0]) {
				tmpSpan[0] = isheet;
			}
			arrObj = me.calCacheMap.getValueFromCache(tmpSpan, "d1");
			if(!arrObj) {
				arrObj = calculates.rangeNumsOf2.call(myScope, [posOffset], option);
				me.calCacheMap.addValueToCache(tmpSpan, arrObj, "d1");
			}
		}
		if(arrObj.length == 0) {
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: option
			};
		}
		if(iorder == 0) {
			arrObj = HELPER.sortNumberArray(arrObj, "desc");
		} else {
			arrObj = HELPER.sortNumberArray(arrObj, "asc");
		}
		var result = 0,
			total = 0;
		for(var i = 0; i < arrObj.length; i++) {
			if(arrObj[i] == inumber) {
				if(option == "rank.eq") {
					return i + 1;
				} else {
					result = result + i + 1;
					total = total + 1;
				}
			}
		}
		if(total > 0) {
			return result / total;
		}
		throw {
			code: "VALUE_NOT_AVAILABLE",
			cal: "RANK"
		};
	},
	coupCommonFn: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		var len = arguments.length;
		if(3 != len && 4 != len) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = me.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var settlement = arguments[0],
			maturity = arguments[1],
			frequency = arguments[2],
			basis = 0;
		if(me.isCoordObj(frequency)) {
			frequency = calculates.numberof.call(myScope, frequency);
		}
		if(len == 4) {
			basis = arguments[3];
			if(me.isCoordObj(basis)) {
				basis = calculates.numberof.call(myScope, arguments[3]);
			}
		}
		if(frequency != 1 && frequency != 2 && frequency != 4) {
			throw {
				code: "NUM_IS_NOT_RIGHT",
				cal: "frequency"
			};
		}
		if(basis > 4 || basis < 0) {
			throw {
				code: "NUM_IS_NOT_RIGHT",
				cal: "basis"
			};
		}
		if(me.isCoordObj(settlement)) {
			settlement = calculates.valof.call(myScope, settlement);
		}
		settlement = SFORMAT.checkingDate(settlement);
		if(settlement == null) {
			throw {
				code: "CAL_NO_VALUE",
				cal: option
			};
		}
		if(me.isCoordObj(maturity)) {
			maturity = calculates.valof.call(myScope, maturity);
		}
		maturity = SFORMAT.checkingDate(maturity);
		if(maturity == null) {
			throw {
				code: "CAL_NO_VALUE",
				cal: option
			};
		}
		if(HELPER._compare2Date(settlement, maturity) > 0) {
			throw {
				code: "NUM_IS_NOT_RIGHT",
				cal: option
			};
		}
		var months = 12 / frequency,
			preSettleDate = maturity,
			nextSettleDate = maturity,
			count = 0;
		while(HELPER._compare2Date(settlement, preSettleDate) < 0) {
			nextSettleDate = preSettleDate;
			preSettleDate = Ext.Date.add(preSettleDate, Ext.Date.MONTH, 0 - months);
			count++;
		}
		if(option == "couppcd") {
			result = preSettleDate;
		} else if(option == "coupncd") {
			result = nextSettleDate;
		} else if(option == "coupnum") {
			return count;
		} else if(option == "coupdays") {
			return HELPER.calDiffDateByMethod(nextSettleDate, preSettleDate, basis, frequency);
		} else if(option == "coupdaysnc") {
			return HELPER.calDiffDateByMethod(nextSettleDate, settlement, basis, frequency);
		}
		return Ext.Date.format(result, SCONST.DEFAULT_DATE_FORMAT);
	},
	addCalculate: function(calName, calFun) {
		if(!this.calculates[calName]) {
			this.calculates[calName] = calFun;
			delete this._exposeEnv.envStr;
			return true;
		} else {
			return false;
		}
	},
	sumCommonFn: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		if(0 == arguments.length) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = me.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var sum = 0;
		var maxDigNum = 0;
		var rangeObjs = calculates.rangeNumsOf.call(myScope, arguments);
		if(this.isArrayFormula && 1 === arguments.length && Ext.isArray(arguments[0])) {
			return rangeObjs;
		}
		for(var i = 0, len = rangeObjs.length; i < len; i++) {
			var data = rangeObjs[i];
			if(HELPER.isBoolean(data)) {
				data = HELPER.convertBoolean2Int(data);
			}
			var dn = HELPER.getDigitalLen(data);
			if(dn > maxDigNum) {
				maxDigNum = dn;
			}
			sum += data;
		}
		var dn = HELPER.getDigitalLen(sum);
		if(dn > maxDigNum) {
			sum = Ext.util.Format.round(sum, maxDigNum);
		}
		return sum;
	},
	concatenateCommonFn: function(arguments, option, myScope) {
		var me = myScope.me,
			isheet = myScope.sheet,
			irow = myScope.row,
			icol = myScope.col,
			calculates = me.calculates;
		if(0 == arguments.length) {
			throw {
				code: "CAL_PARAM_MISS",
				cal: option
			};
		}
		var result = me.checkCoordValid(arguments);
		if(true !== result) {
			throw {
				code: "CAL_INCORRECT_COORD",
				span: result
			};
		}
		var arr = [];
		me.each(myScope.sheet, myScope.row, myScope.col, arguments, function(obj, itemType, index, insideIndex, item) {
			var data;
			if("span" == itemType) {
				var sheet = obj[0],
					row = obj[1],
					col = obj[2];
				if(Ext.isDefined(sheet)) {
					var cell = me.getCellData(sheet, row, col, myScope);
					data = cell.data;
				}
			} else {
				data = obj;
			}
			if(Ext.isArray(data)) {
				arr = arr.concat(data);
			} else if(!Ext.isObject(data) && !SCOM.nullOrUndefined(data)) {
				var str = data.toString();
				if(str) {
					arr.push(str);
				}
			}
		}, myScope);
		return arr.join("");
	},
	calculates: {
		beval: function(coord) {
			return coord;
		},
		valof: function(coord, notThrowFlag) {
			if(0 === arguments.length) {
				if(!notThrowFlag) {
					throw {
						code: "CAL_PARAM_MISS",
						cal: "valof"
					};
				}
				return;
			}
			var me = this.me;
			var store = this.store;
			if(Ext.isArray(coord)) {
				coord = coord[0];
			}
			var span = coord.SPAN || coord.span,
				type = coord.TYPE || coord.type;
			var result = me.checkCoordValid(coord);
			if(true !== result) {
				if(!notThrowFlag) {
					throw {
						code: "CAL_INCORRECT_COORD",
						span: result
					};
				}
				return;
			}
			var sheet = "" === span[0] ? this.sheet : span[0],
				row = span[1],
				col = span[2],
				erow = span[3],
				ecol = span[4];
			if(SCONST.RELATIVE_COORD == type) {
				row += this.row;
				erow += this.row;
				col += this.col;
				ecol += this.col;
			} else if(SCONST.ABSOLUTE_ROW_COORD == type) {
				col += this.col;
				ecol += this.col;
			} else if(SCONST.ABSOLUTE_COL_COORD == type) {
				row += this.row;
				erow += this.row;
			}
			var cell = store.getCell(sheet, row, col);
			if(false != SCOM.typeOf(cell.minrow)) {
				var abMinRow = row + cell.minrow,
					abMaxRow = row + cell.maxrow,
					abMinCol = col + cell.mincol,
					abMaxCol = col + cell.maxcol;
				if(abMinRow === row && abMaxRow === erow && abMinCol === col && abMaxCol === ecol) {
					erow = abMinRow;
					ecol = abMinCol;
				}
			}
			if(row == erow && col == ecol) {
				if(0 != row && 0 != col) {
					var cell = me.getCellData(sheet, row, col, this);
					var data;
					if(SCOM.nullOrUndefined(cell.data)) {
						data = "";
					} else {
						data = cell.data;
					}
					return data;
				}
			}
			if(!notThrowFlag) {
				throw {
					code: "CAL_NO_VALUE",
					span: span
				};
			}
		},
		cellof: function(coord, getWay) {
			var me = this.me,
				store = this.store;
			if(Ext.isArray(coord)) {
				coord = coord[0];
			}
			var span = coord.SPAN || coord.span,
				type = coord.TYPE || coord.type;
			var result = me.checkCoordValid(coord);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var sheet = "" === span[0] ? this.sheet : span[0],
				row = span[1],
				col = span[2],
				erow = span[3],
				ecol = span[4];
			if(SCONST.RELATIVE_COORD == type) {
				row += this.row;
				erow += this.row;
				col += this.col;
				ecol += this.col;
			} else if(SCONST.ABSOLUTE_ROW_COORD == type) {
				col += this.col;
				ecol += this.col;
			} else if(SCONST.ABSOLUTE_COL_COORD == type) {
				row += this.row;
				erow += this.row;
			}
			var cell = "getCellData" === getWay ? store.getCellData(sheet, row, col) : store.getCell(sheet, row, col);
			return cell;
		},
		numberof: function(coord, booleanIsNotNum) {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "numberof"
				};
			}
			var me = this.me;
			if(Ext.isArray(coord)) {
				coord = coord[0];
			}
			var span = coord.SPAN || coord.span,
				type = coord.TYPE || coord.type;
			if(true !== me.isCoordObj(coord)) {
				return Number(coord);
			}
			if(span[1] == span[3] && span[2] == span[4]) {
				var sheet = "" === span[0] ? this.sheet : span[0],
					row = span[1],
					col = span[2];
				if(SCONST.RELATIVE_COORD == type) {
					row += this.row;
					col += this.col;
				} else if(SCONST.ABSOLUTE_ROW_COORD == type) {
					col += this.col;
				} else if(SCONST.ABSOLUTE_COL_COORD == type) {
					row += this.row;
				}
				if(0 != row && 0 != col) {
					var cell = me.getCellData(sheet, row, col, this);
					var data = cell.data;
					if(SCOM.nullOrUndefined(data)) {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: "numberof"
						};
					}
					if(HELPER.isBoolean(data)) {
						if(booleanIsNotNum) {
							throw {
								code: "CAL_PARAM_NEED_BE_NUM",
								cal: "numberof"
							};
						}
						data = HELPER.convertBoolean2Int(data);
					}
					data = HELPER.convertPercent2num2(data);
					var numberObj = Number(data);
					if(!Ext.isNumber(numberObj)) {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: "numberof"
						};
					}
					return numberObj;
				}
			}
			throw {
				code: "CAL_NO_VALUE",
				span: span
			};
		},
		rangeObjsOf: function(coord) {
			var arrObj = new Array;
			var me = this.me;
			var result = me.checkCoordValid(coord);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				arrObj.push(data);
			}, this);
			return arrObj;
		},
		rangeNumsOf2: function(coord, formulaName) {
			var me = this.me;
			var result = me.checkCoordValid(coord);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arrObj = new Array;
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
						data = Number(data);
						if(Ext.isNumber(data)) {
							arrObj.push(data);
						}
					}
				} else {
					data = obj;
					data = Number(data);
					if(Ext.isNumber(data)) {
						arrObj.push(data);
					} else {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: formulaName
						};
					}
				}
			}, this);
			return arrObj;
		},
		rangeNumsOf: function(coord) {
			var arrObj = new Array;
			var me = this.me;
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				data = Number(data);
				if(Ext.isNumber(data)) {
					arrObj.push(data);
				} else {
					arrObj.push(0);
				}
			}, this);
			return arrObj;
		},
		rangeNumsOf3: function(coord) {
			var arrObj = new Array;
			var me = this.me;
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				data = Number(data);
				if(Ext.isNumber(data)) {
					arrObj.push(data);
				}
			}, this);
			return arrObj;
		},
		rangeVal2Dimension: function(coord) {
			var me = this.me;
			var result = me.checkCoordValid(coord);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var dimensionArray = [];
			var preRow = null;
			var subArray = [];
			me.each(this.sheet, this.row, this.col, coord, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
					if(preRow != null && preRow != row) {
						dimensionArray.push(subArray);
						subArray = [];
						preRow = row;
					}
					if(preRow == null) {
						preRow = row;
					}
					subArray.push(data);
				}
			}, this);
			dimensionArray.push(subArray);
			return dimensionArray;
		},
		odd: function() {
			return this.me.mathCommonFunction2(arguments, "odd", this);
		},
		even: function() {
			return this.me.mathCommonFunction2(arguments, "even", this);
		},
		abs: function() {
			return this.me.mathCommonFunction2(arguments, "abs", this);
		},
		sqrt: function() {
			return this.me.mathCommonFunction2(arguments, "sqrt", this);
		},
		sqrtpi: function() {
			return this.me.mathCommonFunction2(arguments, "sqrtpi", this);
		},
		degrees: function() {
			return this.me.mathCommonFunction2(arguments, "degrees", this);
		},
		exp: function() {
			return this.me.mathCommonFunction2(arguments, "exp", this);
		},
		fact: function() {
			return this.me.mathCommonFunction2(arguments, "fact", this);
		},
		factdouble: function() {
			return this.me.mathCommonFunction2(arguments, "factdouble", this);
		},
		'int': function() {
			return this.me.mathCommonFunction2(arguments, "int", this);
		},
		radians: function() {
			return this.me.mathCommonFunction2(arguments, "radians", this);
		},
		sign: function() {
			return this.me.mathCommonFunction2(arguments, "sign", this);
		},
		floor: function() {
			return this.me.mathCommonFunction4(arguments, "floor", this);
		},
		ceiling: function() {
			return this.me.mathCommonFunction4(arguments, "ceiling", this);
		},
		mod: function() {
			return this.me.mathCommonFunction4(arguments, "mod", this);
		},
		randbetween: function() {
			return this.me.mathCommonFunction4(arguments, "randbetween", this);
		},
		quotient: function() {
			return this.me.mathCommonFunction4(arguments, "quotient", this);
		},
		atan2: function() {
			return this.me.mathCommonFunction4(arguments, "atan2", this);
		},
		round: function() {
			return this.me.mathCommonRound(arguments, "round", this);
		},
		rounddown: function() {
			return this.me.mathCommonRound(arguments, "rounddown", this);
		},
		roundup: function() {
			return this.me.mathCommonRound(arguments, "roundup", this);
		},
		mround: function() {
			return this.me.mathCommonRound(arguments, "mround", this);
		},
		pi: function() {
			if(arguments.length != 0) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "pi"
				};
			}
			return Math.PI;
		},
		rand: function() {
			if(arguments.length != 0) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "RAND"
				};
			}
			return Math.random();
		},
		combin: function() {
			var me = this.me,
				calculates = me.calculates;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "combin"
				};
			}
			var number = calculates.numberof.call(this, arguments[0]);
			var choose = calculates.numberof.call(this, arguments[1]);
			if(number === undefined || number === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "combin"
				};
			}
			if(choose === undefined || choose === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "combin"
				};
			}
			if(number < 0 || choose < 0 || number < choose) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "combin"
				};
			}
			var sum1 = 1,
				sum2 = 1;
			for(var i = Math.floor(number); i > Math.floor(number) - Math.floor(choose); i--) {
				sum1 = sum1 * i;
			}
			for(var i = 1; i <= Math.floor(choose); i++) {
				sum2 = sum2 * i;
			}
			return Math.floor(sum1 / sum2);
		},
		combina: function() {
			var me = this.me,
				calculates = me.calculates;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "combina"
				};
			}
			var number = calculates.numberof.call(this, arguments[0]);
			var choose = calculates.numberof.call(this, arguments[1]);
			if(number === undefined || number === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "combina"
				};
			}
			if(choose === undefined || choose === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "combina"
				};
			}
			if(number < 0 || choose < 0 || number < choose) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "combina"
				};
			}
			var sum1 = 1,
				sum2 = 1,
				sum3 = 1;
			var nADDrMIN1 = Math.floor(number + choose - 1),
				nMIN1 = Math.floor(number - 1);
			for(var i = 1; i <= nADDrMIN1; i++) {
				sum1 = sum1 * i;
			}
			for(var i = 1; i <= nMIN1; i++) {
				sum2 = sum2 * i;
			}
			for(var i = 1; i <= Math.floor(choose); i++) {
				sum3 = sum3 * i;
			}
			return Math.floor(sum1 / (sum2 * sum3));
		},
		power: function() {
			var me = this.me,
				calculates = me.calculates;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "power"
				};
			}
			var mi = arguments[1];
			if(mi === undefined || mi === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "power"
				};
			}
			mi = calculates.numberof.call(this, mi);
			var base = calculates.numberof.call(this, arguments[0]);
			if(base === 0) {
				return 0;
			}
			var result = 0;
			if(HELPER.isBoolean(base)) {
				base = HELPER.getBoolean(base);
			}
			if(Ext.isNumber(base) && Ext.isNumber(mi)) {
				result = Math.pow(base, mi);
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "power"
				};
			}
			var digitalLen = HELPER.getDigitalLen(result);
			if(digitalLen > 14) {
				result = HELPER.roundUpNonZero(result);
			}
			return result;
		},
		product: function() {
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "PRODUCT"
				};
			}
			var me = this.me,
				store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var res = 1;
			var allArgsNaN = true;
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				num = Number(data);
				if(Ext.isNumber(num) && "" != data) {
					res *= num;
					allArgsNaN = false;
				}
			}, this);
			if(allArgsNaN) {
				res = 0;
			}
			var digitalLen = HELPER.getDigitalLen(res);
			if(digitalLen > 14) {
				res = HELPER.roundUpNonZero(res);
			}
			return res;
		},
		log: function() {
			var len = arguments.length,
				me = this.me,
				calculates = me.calculates;
			if(0 == len || len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "LOG"
				};
			}
			var me = this.me;
			var logNum = calculates.numberof.call(this, arguments[0]);
			if(logNum === undefined || logNum === "" || logNum <= 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "LOG"
				};
			}
			var base = 10;
			if(len == 2) {
				var base = calculates.numberof.call(this, arguments[1]);
			}
			var result = Math.log(logNum) / Math.log(base);
			var digitalLen = HELPER.getDigitalLen(result);
			if(digitalLen > 14) {
				result = HELPER.roundUpNonZero(result);
			}
			return result;
		},
		log10: function() {
			return this.me.mathCommonFunction5(arguments, "LOG10", this);
		},
		ln: function() {
			return this.me.mathCommonFunction5(arguments, "LN", this);
		},
		tanh: function() {
			return this.me.mathCommonFunction5(arguments, "TANH", this);
		},
		acos: function() {
			return this.me.mathCommonFunction5(arguments, "ACOS", this);
		},
		asin: function() {
			return this.me.mathCommonFunction5(arguments, "ASIN", this);
		},
		atan: function() {
			return this.me.mathCommonFunction5(arguments, "ATAN", this);
		},
		atanh: function() {
			return this.me.mathCommonFunction5(arguments, "ATANH", this);
		},
		sin: function() {
			return this.me.mathCommonFunction5(arguments, "SIN", this);
		},
		sinh: function() {
			return this.me.mathCommonFunction5(arguments, "SINH", this);
		},
		cos: function() {
			return this.me.mathCommonFunction5(arguments, "COS", this);
		},
		cosh: function() {
			return this.me.mathCommonFunction5(arguments, "COSH", this);
		},
		csc: function() {
			return this.me.mathCommonFunction5(arguments, "CSC", this);
		},
		csch: function() {
			return this.me.mathCommonFunction5(arguments, "CSCH", this);
		},
		sec: function() {
			return this.me.mathCommonFunction5(arguments, "SEC", this);
		},
		sech: function() {
			return this.me.mathCommonFunction5(arguments, "SECH", this);
		},
		acosh: function() {
			return this.me.mathCommonFunction5(arguments, "ACOSH", this);
		},
		tan: function() {
			return this.me.mathCommonFunction5(arguments, "TAN", this);
		},
		cot: function() {
			return this.me.mathCommonFunction5(arguments, "COT", this);
		},
		coth: function() {
			return this.me.mathCommonFunction5(arguments, "COTH", this);
		},
		acot: function() {
			return this.me.mathCommonFunction5(arguments, "ACOT", this);
		},
		asinh: function() {
			return this.me.mathCommonFunction5(arguments, "ASINH", this);
		},
		sum: function() {
			return this.me.sumCommonFn(arguments, "SUM", this);
		},
		sumsq: function() {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "SUMSQ"
				};
			}
			var me = this.me;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var sum = 0;
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				data = Number(data);
				if(Ext.isNumber(data)) {
					sum += Math.pow(data, 2);
				}
			}, this);
			var digitalLen = HELPER.getDigitalLen(sum);
			if(digitalLen > 14) {
				sum = HELPER.roundUpNonZero(sum);
			}
			return sum;
		},
		sumif: function() {
			var alen = arguments.length;
			if(2 > alen || alen > 3) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "SUMIF"
				};
			}
			var me = this.me,
				sheetId = this.sheet,
				row = this.row,
				col = this.col,
				timestamp = this.timestamp;
			var store = this.store;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var args = me.transferAll2Absolute(arguments, sheetId, row, col);
			var checkSpan = args[0],
				standSpan = args[1],
				resultSpan = args[2];
			var stand, standData, standVal;
			if(me.isCoordObj(standSpan)) {
				stand = standSpan.span;
				standData = me.getCellData(stand[0], stand[1], stand[2], this);
				standVal = standData.data;
			} else {
				standVal = standSpan;
			}
			if(!Ext.isDefined(standVal)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "SUMIF"
				};
			}
			var isExpress = false;
			if(Ext.isString(standVal)) {
				isExpress = me.isExpress(standVal);
				if(isExpress) {
					standVal = me.specialCaseForCalculateStr(standVal, true);
				}
			}
			var check = checkSpan.span;
			var result;
			if(resultSpan) {
				result = resultSpan.span;
			} else {
				result = [].concat(check);
			}
			var rowOffset = result[1] - check[1],
				colOffset = result[2] - check[2];
			var sum = 0;
			store.walkRange([check], function(rd, span, store) {
				var cell = me.getCellData(rd.data.sheet, rd.data.row, rd.data.col, this);
				var match = false;
				if(isExpress) {
					var num = Number(cell.data);
					if(Ext.isNumber(num)) {
						match = eval(num + standVal);
					} else {
						match = eval("\"" + cell.data + "\"" + standVal);
					}
				} else {
					if(cell.data == standVal || SCOM.kmpCompare(cell.data, standVal)) {
						match = true;
					}
				}
				if(match) {
					var rsRow = rd.data.row + rowOffset,
						rsCol = rd.data.col + colOffset;
					var rsCell = me.getCellData(result[0], rsRow, rsCol, this);
					if(SCOM.canbeNumber(rsCell.data)) {
						sum += Number(rsCell.data);
					}
				}
			}, this);
			return sum;
		},
		sumifs: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len < 3 || len % 2 == 0) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "sumifs"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var sumRange = arguments[0];
			if(Ext.isObject(sumRange)) {
				sumRange = calculates.rangeVal2Dimension.call(this, [sumRange]);
			}
			if(sumRange == null || sumRange.length == 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "sumifs"
				};
			}
			var sumRangeXlength = sumRange.length;
			var sumRangeYlength = sumRange[0].length;
			var criteriaRangeArr = [],
				criteriaArr = [];
			var i = 1;
			while(i < len) {
				var criteraRange = arguments[i];
				if(Ext.isObject(arguments[i])) {
					criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[i]]);
				}
				if(criteraRange == null || criteraRange.length == 0) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "sumifs"
					};
				}
				var criteraRangeXlength = criteraRange.length;
				var criteraRangeYlength = criteraRange[0].length;
				if(sumRangeXlength != criteraRangeXlength || sumRangeYlength != criteraRangeYlength) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "sumifs"
					};
				}
				criteriaRangeArr[criteriaRangeArr.length] = criteraRange;
				i = i + 1;
				var cond = arguments[i];
				if(me.isCoordObj(cond)) {
					cond = calculates.valof.call(this, cond);
				}
				if(Ext.isString(cond)) {
					cond = Ext.util.Format.htmlDecode(cond);
					cond = HELPER.changeCondSpecialCase(cond);
					if(HELPER.isExpress(cond)) {
						cond = HELPER.updateCompareCondition(cond);
					}
				}
				criteriaArr[criteriaArr.length] = cond;
				i = i + 1;
			}
			var result = 0;
			for(var i = 0; i < sumRangeXlength; i++) {
				for(var j = 0; j < sumRangeYlength; j++) {
					var flag = true;
					for(var k = 0; k < criteriaRangeArr.length; k++) {
						var criteraRange = criteriaRangeArr[k];
						var data = criteraRange[i][j];
						data = HELPER.convertPercent2num2(data);
						var cond = criteriaArr[k];
						var condflag = false;
						if(HELPER.isExpress(cond)) {
							if(Ext.isNumber(Number(data))) {
								condflag = eval(data + cond);
							} else {
								condflag = eval("\"" + data + "\"" + cond);
							}
						} else if(SCOM.kmpCompare(data.toString(), cond.toString())) {
							condflag = true;
						}
						flag = flag && condflag;
					}
					if(flag) {
						var sumData = sumRange[i][j];
						sumData = Number(sumData);
						if(Ext.isNumber(sumData)) {
							result += sumData;
						}
					}
				}
			}
			return result;
		},
		sumproduct: function() {
			var me = this.me,
				calculates = me.calculates,
				sheetId = this.sheet;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "sumproduct"
				};
			}
			var varArrs = [];
			for(var k = 0; k < len; k++) {
				var posOffset = arguments[k];
				if(Ext.isArray(posOffset)) {
					if(Ext.isArray(posOffset[0])) {
						varArrs.push(posOffset);
					} else {
						varArrs.push([posOffset]);
					}
				} else if(Ext.isString(posOffset) || Ext.isNumber(Number(posOffset))) {
					if(HELPER.isBoolean(posOffset)) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "sumproduct"
						};
					}
					var tempArr = [
						[posOffset]
					];
					varArrs.push(tempArr);
				} else {
					var tmpSpan = posOffset.span;
					if("" === tmpSpan[0]) {
						tmpSpan[0] = sheetId;
					}
					var tempArr = me.calCacheMap.getValueFromCache(tmpSpan);
					if(!tempArr) {
						tempArr = calculates.rangeVal2Dimension.call(this, [posOffset]);
						me.calCacheMap.addValueToCache(tmpSpan, tempArr);
					}
					if(tempArr && tempArr.length == 1 && tempArr[0].length == 1 && HELPER.isBoolean(tempArr[0][0])) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "sumproduct"
						};
					}
					varArrs.push(tempArr);
				}
			}
			if(varArrs.length == 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "sumproduct"
				};
			}
			var total = HELPER.getSumProduct(varArrs, "sumproduct");
			varArrs = [];
			return total;
		},
		sumxmy2: function() {
			return this.me.sumxmyCommon(arguments, "sumxmy2", this);
		},
		sumx2py2: function() {
			return this.me.sumxmyCommon(arguments, "sumx2py2", this);
		},
		sumx2my2: function() {
			return this.me.sumxmyCommon(arguments, "sumx2my2", this);
		},
		mmult: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "mmult"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var twoDimensionArray1 = calculates.rangeVal2Dimension.call(this, [arguments[0]]);
			var twoDimensionArray2 = calculates.rangeVal2Dimension.call(this, [arguments[1]]);
			if(twoDimensionArray1 == null || twoDimensionArray1.length == 0 || twoDimensionArray2 == null || twoDimensionArray2.length == 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "mmult"
				};
			}
			var array1ColCount = twoDimensionArray1[0].length;
			var array1RowCount = twoDimensionArray1.length;
			var array2ColCount = twoDimensionArray2[0].length;
			var array2RowCount = twoDimensionArray2.length;
			if(array1ColCount !== array2RowCount) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "mmult"
				};
			}
			var result = [];
			for(var i = 0; i < array1RowCount; i++) {
				for(var j = 0; j < array1ColCount; j++) {
					var value = twoDimensionArray1[i][j];
					var num = Number(value);
					if(!Ext.isNumber(num)) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "mmult"
						};
					}
				}
			}
			for(var i = 0; i < array2RowCount; i++) {
				for(var j = 0; j < array2ColCount; j++) {
					var value = twoDimensionArray2[i][j];
					var num = Number(value);
					if(!Ext.isNumber(num)) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "mmult"
						};
					}
				}
			}
			for(var i2 = 0; i2 < array1RowCount; i2++) {
				result[i2] = [array2ColCount];
				for(var j2 = 0; j2 < array2ColCount; j2++) {
					var sum = 0;
					for(var k = 0; k < array2RowCount; k++) {
						sum += twoDimensionArray1[i2][k] * twoDimensionArray2[k][j2];
					}
					result[i2][j2] = sum;
				}
			}
			return result;
		},
		subtotal: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(2 > len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "subtotal"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var function_num = calculates.numberof.call(this, arguments[0]);
			if(function_num < 1 || function_num > 11) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "subtotal"
				};
			}
			var params = Array.prototype.slice.call(arguments);
			params.shift();
			if(function_num == 1) {
				return calculates.average.call(this, params);
			} else if(function_num == 2) {
				return calculates.count.call(this, params);
			} else if(function_num == 3) {
				return calculates.counta.call(this, params);
			} else if(function_num == 4) {
				return me.minMaxVal(params, this).max;
			} else if(function_num == 5) {
				return me.minMaxVal(params, this).min;
			} else if(function_num == 6) {
				return calculates.product.call(this, params);
			} else if(function_num == 7) {
				return calculates.stdev.call(this, params);
			} else if(function_num == 8) {
				return calculates.stdevp.call(this, params);
			} else if(function_num == 9) {
				return calculates.sum.call(this, params);
			} else if(function_num == 10) {
				return calculates.var_orig.call(this, params);
			} else if(function_num == 11) {
				return calculates.varp.call(this, params);
			}
		},
		aggregate: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col,
				len = arguments.length;
			if(2 > len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "need"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var function_num = calculates.numberof.call(this, arguments[0]);
			if(function_num < 1 || function_num > 19) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "aggregate"
				};
			}
			var options = calculates.numberof.call(this, arguments[1]);
			if(options < 1 || options > 6) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "aggregate"
				};
			}
			var params = Array.prototype.slice.call(arguments);
			params.shift();
			params.shift();
			if(function_num == 1) {
				return calculates.average.call(this, params);
			} else if(function_num == 2) {
				return calculates.count.call(this, params);
			} else if(function_num == 3) {
				return calculates.counta.call(this, params);
			} else if(function_num == 4) {
				return me.minMaxVal(params, this).max;
			} else if(function_num == 5) {
				return me.minMaxVal(params, this).min;
			} else if(function_num == 6) {
				return calculates.product.call(this, params);
			} else if(function_num == 7) {
				return calculates.stdev.call(this, params);
			} else if(function_num == 8) {
				return calculates.stdevp.call(this, params);
			} else if(function_num == 9) {
				return calculates.sum.call(this, params);
			} else if(function_num == 10) {
				return calculates.var_orig.call(this, params);
			} else if(function_num == 11) {
				return calculates.varp.call(this, params);
			} else if(function_num == 12) {
				return calculates.median.call(this, params);
			} else if(function_num == 13) {
				return calculates.mode.call(this, params);
			} else if(function_num == 14) {
				return calculates.large.call(this, params);
			} else if(function_num == 15) {
				return calculates.small.call(this, params);
			} else if(function_num == 16) {
				return calculates.percentile_inc.call(this, params);
			} else if(function_num == 17) {
				return calculates.quartile_inc.call(this, params);
			} else if(function_num == 18) {
				return calculates.percentile_exc.call(this, params);
			} else if(function_num == 19) {
				return calculates.quartile_exc.call(this, params);
			}
		},
		average: function() {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "average"
				};
			}
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var sum = 0,
				count = 0,
				argsAllNaN = true;
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				data = Number(data);
				if(Ext.isNumber(data)) {
					sum += data;
					argsAllNaN = false;
					count++;
				}
			}, this);
			if(argsAllNaN) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "average"
				};
			}
			return sum / count * 100 / 100;
		},
		averageif: function() {
			if(2 > arguments.length || arguments.length > 3) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "averageif"
				};
			}
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var sheetId = this.sheet,
				row = this.row,
				col = this.col,
				timestamp = this.timestamp;
			var args = me.transferAll2Absolute(arguments, sheetId, row, col);
			var checkSpan = args[0],
				standSpan = args[1],
				resultSpan = args[2];
			var stand, standData, standVal;
			if(me.isCoordObj(standSpan)) {
				stand = standSpan.span;
				standData = me.getCellData(stand[0], stand[1], stand[2], this);
				standVal = standData.data;
			} else {
				standVal = standSpan;
			}
			if(!Ext.isDefined(standVal)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "averageif"
				};
			}
			var isExpress = false;
			if(Ext.isString(standVal)) {
				standVal = Ext.util.Format.htmlDecode(standVal);
				standVal = HELPER.changeCondSpecialCase(standVal);
				isExpress = me.isExpress(standVal);
				if(HELPER.isExpress(standVal)) {
					standVal = me.specialCaseForCalculateStr(standVal, true);
					standVal = HELPER.updateCompareCondition(standVal);
				}
			}
			var check = checkSpan.span;
			var result;
			if(resultSpan) {
				result = resultSpan.span;
			} else {
				result = [].concat(check);
			}
			var rowOffset = result[1] - check[1],
				colOffset = result[2] - check[2];
			var sum = 0,
				count = 0;
			store.walkRange([check], function(rd, span, store) {
				var cell = me.getCellData(rd.data.sheet, rd.data.row, rd.data.col, this);
				var match = false;
				if(isExpress) {
					var data = HELPER.convertPercent2num2(cell.data);
					var num = Number(data);
					if(Ext.isNumber(num)) {
						match = eval(num + standVal);
					} else {
						match = eval("\"" + cell.data + "\"" + standVal);
					}
				} else {
					if(cell.data == standVal || SCOM.kmpCompare(cell.data, standVal)) {
						match = true;
					}
				}
				if(match) {
					var rsRow = rd.data.row + rowOffset,
						rsCol = rd.data.col + colOffset;
					var rsCell = me.getCellData(result[0], rsRow, rsCol, this);
					if(SCOM.canbeNumber(rsCell.data)) {
						sum += Number(rsCell.data);
						count += 1;
					}
				}
			}, this);
			if(count == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "averageif"
				};
			}
			return sum / count * 100 / 100;
		},
		averageifs: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len < 3 || len % 2 == 0) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "averageifs"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var averageRange = arguments[0];
			if(Ext.isObject(averageRange)) {
				averageRange = calculates.rangeVal2Dimension.call(this, [averageRange]);
			}
			if(averageRange == null || averageRange.length == 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "averageifs"
				};
			}
			var averageRangeXlength = averageRange.length;
			var averageRangeYlength = averageRange[0].length;
			var criteriaRangeArr = [],
				criteriaArr = [];
			var i = 1;
			while(i < len) {
				var criteraRange = arguments[i],
					tmpSpan = criteraRange.span;
				if(Ext.isObject(arguments[i])) {
					if("" === tmpSpan[0]) {
						tmpSpan[0] = isheet;
					}
					criteraRange = me.calCacheMap.getValueFromCache(tmpSpan);
					if(!criteraRange) {
						criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[i]]);
						me.calCacheMap.addValueToCache(tmpSpan, criteraRange);
					}
				}
				if(criteraRange == null || criteraRange.length == 0) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "averageifs"
					};
				}
				var criteraRangeXlength = criteraRange.length;
				var criteraRangeYlength = criteraRange[0].length;
				if(averageRangeXlength != criteraRangeXlength || averageRangeYlength != criteraRangeYlength) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "averageifs"
					};
				}
				criteriaRangeArr[criteriaRangeArr.length] = criteraRange;
				i = i + 1;
				var cond = arguments[i];
				if(me.isCoordObj(cond)) {
					cond = calculates.valof.call(this, cond);
				}
				if(Ext.isString(cond)) {
					cond = Ext.util.Format.htmlDecode(cond);
					cond = HELPER.changeCondSpecialCase(cond);
					if(HELPER.isExpress(cond)) {
						cond = HELPER.updateCompareCondition(cond);
					}
				}
				criteriaArr[criteriaArr.length] = cond;
				i = i + 1;
			}
			var result = 0,
				totalCount = 0;
			for(var i = 0; i < averageRangeXlength; i++) {
				for(var j = 0; j < averageRangeYlength; j++) {
					var flag = true;
					for(var k = 0; k < criteriaRangeArr.length; k++) {
						var criteraRange = criteriaRangeArr[k];
						var data = criteraRange[i][j];
						if(data === undefined || data == null || data == "") {
							flag = false;
							break;
						}
						var cond = criteriaArr[k];
						var condflag = false;
						var compareFlag = /^\s*[!<>=]/gi.test(cond);
						if(compareFlag) {
							data = HELPER.convertPercent2num2(data);
							if(Ext.isNumber(Number(data))) {
								condflag = eval(data + cond);
							} else {
								condflag = eval("\"" + data + "\"" + cond);
							}
						} else if(SCOM.kmpCompare(data.toString(), cond.toString())) {
							condflag = true;
						}
						if(condflag == false) {
							flag = false;
							break;
						}
					}
					if(flag) {
						var sumData = averageRange[i][j];
						sumData = Number(sumData);
						if(Ext.isNumber(sumData)) {
							result += sumData;
							totalCount += 1;
						}
					}
				}
			}
			criteriaRangeArr = [], criteriaArr = [];
			if(totalCount == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "averageifs"
				};
			}
			return result / totalCount * 100 / 100;
		},
		count: function() {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "COUNTA"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeObjs = calculates.rangeObjsOf.call(this, arguments);
			var res = 0;
			for(var i = 0, len = rangeObjs.length; i < len; i++) {
				var data = Number(rangeObjs[i]);
				if(Ext.isNumber(data)) {
					res++;
				}
			}
			return res;
		},
		counta: function() {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "COUNTA"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeObjs = calculates.rangeObjsOf.call(this, arguments);
			var res = 0;
			for(var i = 0, len = rangeObjs.length; i < len; i++) {
				var cell = rangeObjs[i];
				if(cell != undefined && cell != "") {
					res++;
				}
			}
			return res;
		},
		countblank: function() {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "COUNTA"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeObjs = calculates.rangeObjsOf.call(this, arguments);
			var res = 0;
			for(var i = 0, len = rangeObjs.length; i < len; i++) {
				var cell = rangeObjs[i];
				if(cell == undefined || cell == "") {
					res++;
				}
			}
			return res;
		},
		max: function() {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "MAX"
				};
			}
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			return me.minMaxVal(arguments, this).max;
		},
		min: function() {
			if(0 == arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "MIN"
				};
			}
			var me = this.me;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			return me.minMaxVal(arguments, this).min;
		},
		median: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "median"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = calculates.rangeNumsOf2.call(this, arguments, "median");
			if(0 == arr.length) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "median"
				};
			}
			return HELPER.getMedianfromArr(arr);
		},
		small: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "small"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var range = [];
			var posOffset = arguments[0];
			if(Ext.isObject(posOffset)) {
				range = calculates.rangeObjsOf.call(this, [posOffset]);
			} else {
				if(Ext.isArray(posOffset)) {
					range = posOffset;
				} else {
					if(HELPER.isEmptyStr(posOffset)) {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: "small"
						};
					}
					var num = Number(posOffset);
					range.push(num);
				}
			}
			var position = calculates.numberof.call(this, arguments[1]);
			if(0 >= position || position > range.length) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "small"
				};
			}
			var tmp = [];
			for(var i = 0; i < range.length; i++) {
				var val = range[i];
				if(val === undefined || val === "" || HELPER.isEmptyStr(val) || HELPER.isBoolean(val)) {
					continue;
				}
				var numberObj = Number(val);
				if(Ext.isNumber(numberObj)) {
					tmp.push(numberObj);
				}
			}
			if(tmp.length == 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "small"
				};
			}
			HELPER.sortNumberArray(tmp, "asc");
			if(position > tmp.length) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "small"
				};
			}
			return tmp[position - 1];
		},
		large: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "large"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var range = [];
			var posOffset = arguments[0];
			if(Ext.isObject(posOffset)) {
				range = calculates.rangeObjsOf.call(this, [posOffset]);
			} else {
				if(Ext.isArray(posOffset)) {
					range = posOffset;
				} else {
					if(HELPER.isEmptyStr(posOffset)) {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: "large"
						};
					}
					var num = Number(posOffset);
					range.push(num);
				}
			}
			var position = calculates.numberof.call(this, arguments[1]);
			if(0 >= position || position > range.length) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "large"
				};
			}
			var tmp = [];
			for(var i = 0; i < range.length; i++) {
				var val = range[i];
				if(val === undefined || val === "" || HELPER.isEmptyStr(val) || HELPER.isBoolean(val)) {
					continue;
				}
				var numberObj = Number(val);
				if(Ext.isNumber(numberObj)) {
					tmp.push(numberObj);
				}
			}
			if(tmp.length == 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "large"
				};
			}
			HELPER.sortNumberArray(tmp, "desc");
			if(position > tmp.length) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "large"
				};
			}
			return tmp[position - 1];
		},
		geomean: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "geomean"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
						if(Ext.isNumber(Number(data))) {
							arr.push(Number(data));
						}
					}
				} else {
					data = Number(obj);
					if(Ext.isNumber(data)) {
						arr.push(data);
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "geomean"
						};
					}
				}
			}, this);
			var alen = arr.length;
			if(0 == alen) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "geomean"
				};
			} else {
				var sumProduct = 1;
				for(var i = 0; i < alen; i++) {
					if(arr[i] < 0) {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: "geomean"
						};
					}
					sumProduct *= arr[i];
				}
				return Math.pow(sumProduct, 1 / alen);
			}
		},
		harmean: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "harmean"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
						if(Ext.isNumber(Number(data))) {
							arr.push(Number(data));
						}
					}
				} else {
					data = Number(obj);
					if(Ext.isNumber(data)) {
						arr.push(data);
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "harmean"
						};
					}
				}
			}, this);
			var alen = arr.length;
			if(0 == alen) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "harmean"
				};
			} else {
				var sum = 1;
				for(var i = 0; i < alen; i++) {
					if(arr[i] <= 0) {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: "harmean"
						};
					}
					sum += 1 / arr[i];
				}
				return alen / sum;
			}
		},
		slope: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "slope"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeY = [],
				posOffset = arguments[0];
			if(Ext.isObject(posOffset)) {
				rangeY = calculates.rangeObjsOf.call(this, [posOffset]);
			} else {
				if(Ext.isArray(posOffset)) {
					rangeY = posOffset;
				} else {
					rangeY.push(Number(posOffset));
				}
			}
			var rangeX = [],
				posOffset = arguments[1];
			if(Ext.isObject(posOffset)) {
				rangeX = calculates.rangeObjsOf.call(this, [posOffset]);
			} else {
				if(Ext.isArray(posOffset)) {
					rangeX = posOffset;
				} else {
					rangeX.push(Number(posOffset));
				}
			}
			var lengthY = rangeY.length,
				lengthX = rangeX.length;
			if(lengthY !== lengthX) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "slope"
				};
			}
			var sumy = 0,
				sumx = 0,
				sumxx = 0,
				sumxy = 0,
				total = 0;
			for(var i = 0; i < lengthY; i++) {
				var y = Number(rangeY[i]),
					x = Number(rangeX[i]);
				if(Ext.isNumber(y) && Ext.isNumber(x)) {
					sumy += y;
					sumx += x;
					sumxx += x * x;
					sumxy += x * y;
					total++;
				}
			}
			if(total * sumxx - sumx * sumx === 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "slope"
				};
			}
			return(total * sumxy - sumx * sumy) / (total * sumxx - sumx * sumx);
		},
		steyx: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "steyx"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeY = [],
				posOffset = arguments[0];
			if(Ext.isObject(posOffset)) {
				rangeY = calculates.rangeObjsOf.call(this, [posOffset]);
			} else {
				if(Ext.isArray(posOffset)) {
					rangeY = posOffset;
				} else {
					rangeY.push(Number(posOffset));
				}
			}
			var rangeX = [],
				posOffset = arguments[1];
			if(Ext.isObject(posOffset)) {
				rangeX = calculates.rangeObjsOf.call(this, [posOffset]);
			} else {
				if(Ext.isArray(posOffset)) {
					rangeX = posOffset;
				} else {
					rangeX.push(Number(posOffset));
				}
			}
			var lengthY = rangeY.length,
				lengthX = rangeX.length;
			if(lengthY !== lengthX) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "steyx"
				};
			}
			var sumy = 0,
				sumyy = 0,
				sumx = 0,
				sumxx = 0,
				sumxy = 0,
				total = 0;
			for(var i = 0; i < lengthY; i++) {
				var y = Number(rangeY[i]),
					x = Number(rangeX[i]);
				if(Ext.isNumber(y) && Ext.isNumber(x)) {
					sumy += y;
					sumyy += y * y;
					sumx += x;
					sumxx += x * x;
					sumxy += x * y;
					total++;
				}
			}
			if(total < 3 || total * sumxx - sumx * sumx === 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "steyx"
				};
			}
			if(total * sumxx - sumx * sumx === 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "steyx"
				};
			}
			return Math.sqrt((total * sumyy - sumy * sumy - (total * sumxy - sumx * sumy) * (total * sumxy - sumx * sumy) / (total * sumxx - sumx * sumx)) / (total * (total - 2)));
		},
		avedev: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "avedev"
				};
			}
			var arrObj = calculates.rangeNumsOf2.call(this, arguments, "avedev");
			if(arrObj.length == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "avedev"
				};
			}
			var mean = 0,
				sum = 0,
				sumdev = 0;
			for(var i = 0; i < arrObj.length; i++) {
				sum += arrObj[i];
			}
			mean = sum / arrObj.length;
			for(var i = 0; i < arrObj.length; i++) {
				sumdev += Math.abs(mean - arrObj[i]);
			}
			return sumdev / arrObj.length;
		},
		devsq: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "devsq"
				};
			}
			var arrObj = calculates.rangeNumsOf2.call(this, arguments, "devsq");
			if(arrObj.length == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "devsq"
				};
			}
			var mean = 0,
				sum = 0,
				sumdevsq = 0;
			for(var i = 0; i < arrObj.length; i++) {
				sum += arrObj[i];
			}
			mean = sum / arrObj.length;
			for(var i = 0; i < arrObj.length; i++) {
				sumdevsq += (arrObj[i] - mean) * (arrObj[i] - mean);
			}
			return sumdevsq;
		},
		fisher: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(1 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "fisher"
				};
			}
			var num = calculates.numberof.call(this, arguments[0]);
			if(num === undefined || num === "" || num <= -1 || num >= 1) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "fisher"
				};
			}
			var result = Math.log((1 + num) / (1 - num)) / 2;
			return result;
		},
		fisherinv: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(1 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "fisherinv"
				};
			}
			var num = calculates.numberof.call(this, arguments[0]);
			if(num === undefined || num === "") {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "fisherinv"
				};
			}
			var p1 = Math.exp(2 * num) - 1;
			var p2 = Math.exp(2 * num) + 1;
			var result = p1 / p2;
			var digitalLen = HELPER.getDigitalLen(result);
			if(digitalLen > 14) {
				result = HELPER.roundUpNonZero(result);
			}
			return result;
		},
		correl: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "correl"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], "correl");
			if(rangeX.length == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "correl"
				};
			}
			var rangeY = calculates.rangeNumsOf2.call(this, [arguments[1]], "correl");
			if(rangeY.length == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "correl"
				};
			}
			var lengthY = rangeY.length,
				lengthX = rangeX.length;
			if(lengthY !== lengthX) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "correl"
				};
			}
			var meanX = 0,
				sumX = 0;
			for(var i = 0; i < lengthX; i++) {
				sumX += rangeX[i];
			}
			meanX = sumX / lengthX;
			var meanY = 0,
				sumY = 0;
			for(var i = 0; i < lengthY; i++) {
				sumY += rangeY[i];
			}
			meanY = sumY / lengthY;
			var sumxy = 0,
				sumxx = 0;
			sumyy = 0;
			for(var i = 0; i < lengthX; i++) {
				var tempX = rangeX[i] - meanX,
					tempY = rangeY[i] - meanY;
				sumxy += tempX * tempY;
				sumxx += tempX * tempX;
				sumyy += tempY * tempY;
			}
			if(sumxx == 0 || sumyy == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "correl"
				};
			}
			var result = sumxy / Math.sqrt(sumxx * sumyy);
			return result;
		},
		rsq: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "rsq"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], "rsq");
			if(rangeX.length == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "rsq"
				};
			}
			var rangeY = calculates.rangeNumsOf2.call(this, [arguments[1]], "rsq");
			if(rangeY.length == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "rsq"
				};
			}
			var lengthY = rangeY.length,
				lengthX = rangeX.length;
			if(lengthY !== lengthX) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "rsq"
				};
			}
			if(lengthY == 1) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "rsq"
				};
			}
			var meanX = 0,
				sumX = 0;
			for(var i = 0; i < lengthX; i++) {
				sumX += rangeX[i];
			}
			meanX = sumX / lengthX;
			var meanY = 0,
				sumY = 0;
			for(var i = 0; i < lengthY; i++) {
				sumY += rangeY[i];
			}
			meanY = sumY / lengthY;
			var sumxy = 0,
				sumxx = 0;
			sumyy = 0;
			for(var i = 0; i < lengthX; i++) {
				var tempX = rangeX[i] - meanX,
					tempY = rangeY[i] - meanY;
				sumxy += tempX * tempY;
				sumxx += tempX * tempX;
				sumyy += tempY * tempY;
			}
			if(sumxx == 0 || sumyy == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "rsq"
				};
			}
			var result = sumxy / Math.sqrt(sumxx * sumyy);
			return result * result;
		},
		gamma: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(1 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "gamma"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var x = calculates.numberof.call(this, arguments[0]);
			if(x <= 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "gamma"
				};
			}
			if(x > 171) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "gamma"
				};
			}
			return FORMULA_HELPER.gamma(x);
		},
		gammaln: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(1 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "gammaln"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var x = calculates.numberof.call(this, arguments[0]);
			if(x <= 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "gammaln"
				};
			}
			var result = FORMULA_HELPER.gamma(x);
			return Math.log(result) / Math.log(2.71828182845904);
		},
		stdev_s: function() {
			return this.me.stdevCommonFunction(arguments, "stdev.s", this);
		},
		stdev_p: function() {
			return this.me.stdevCommonFunction(arguments, "stdev.p", this);
		},
		var_s: function() {
			return this.me.stdevCommonFunction(arguments, "var.s", this);
		},
		var_p: function() {
			return this.me.stdevCommonFunction(arguments, "var.p", this);
		},
		percentile_inc: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "percentile.inc"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], "percentile.inc");
			if(rangeX.length == 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "percentile.inc"
				};
			}
			var k = calculates.numberof.call(this, arguments[1]);
			if(k < 0 || k > 1) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "percentile.inc"
				};
			}
			rangeX = HELPER.sortNumberArray(rangeX, "asc");
			var index = k * (rangeX.length - 1);
			var reminder = index % 1;
			var index = parseInt(index.toString(), 10);
			if(reminder === 0) {
				return rangeX[index];
			}
			return rangeX[index] + reminder * (rangeX[index + 1] - rangeX[index]);
		},
		percentile_exc: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "percentile.exc"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], "percentile.exc");
			if(rangeX.length == 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "percentile.exc"
				};
			}
			var n = rangeX.length;
			var k = calculates.numberof.call(this, arguments[1]);
			if(k <= 1 / n || k >= 1 - 1 / n) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "percentile.exc"
				};
			}
			rangeX = HELPER.sortNumberArray(rangeX, "asc");
			var index = k * (rangeX.length + 1);
			var reminder = index % 1;
			var index = parseInt(index.toString(), 10);
			if(reminder === 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "percentile.exc"
				};
			}
			return rangeX[index - 1] + reminder * (rangeX[index] - rangeX[index - 1]);
		},
		quartile_inc: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "quartile.inc"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var quart = calculates.numberof.call(this, arguments[1]);
			if(quart < 0 || quart > 4) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "quartile.inc"
				};
			}
			quart = parseInt(quart);
			if(quart == 2) {
				return calculates.median.call(this, arguments[0]);
			}
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], "quartile.inc");
			if(rangeX.length == 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "quartile.inc"
				};
			}
			if(rangeX.length == 1) {
				return rangeX[0];
			}
			rangeX = HELPER.sortNumberArray(rangeX, "asc");
			var total = rangeX.length;
			if(quart == 0) {
				return rangeX[0];
			}
			if(quart == 4) {
				return rangeX[total - 1];
			}
			var position = (total - 1) * 0.75;
			if(quart == 1) {
				position = (total - 1) * 0.25;
			}
			var part1 = parseInt(position),
				part2 = position - part1;
			var val1 = 0,
				val2 = 0;
			if(part1 >= 0 && part1 < total) {
				val1 = rangeX[part1];
				val2 = rangeX[part1 + 1];
			} else if(part1 > total) {
				val1 = rangeX[part1];
			} else {
				val2 = rangeX[part1 + 1];
			}
			return val1 * (1 - part2) + val2 * part2;
		},
		quartile_exc: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "quartile.exc"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var quart = calculates.numberof.call(this, arguments[1]);
			if(quart < 1 || quart >= 4) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "quartile.exc"
				};
			}
			quart = parseInt(quart);
			if(quart == 2) {
				return calculates.median.call(this, arguments[0]);
			}
			var rangeX = calculates.rangeNumsOf2.call(this, [arguments[0]], "quartile.exc");
			if(rangeX.length == 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "quartile.exc"
				};
			}
			if(rangeX.length == 1) {
				return rangeX[0];
			}
			rangeX = HELPER.sortNumberArray(rangeX, "asc");
			var total = rangeX.length;
			var position = (total + 1) * 0.75;
			if(quart == 1) {
				position = (total + 1) * 0.25;
			}
			var part1 = parseInt(position),
				part2 = position - part1;
			var val1 = 0,
				val2 = 0;
			if(part1 >= 0 && part1 < total) {
				val1 = rangeX[part1 - 1];
				val2 = rangeX[part1];
			} else if(part1 > total) {
				val1 = rangeX[part1 - 1];
			} else {
				val2 = rangeX[part1];
			}
			return val1 * (1 - part2) + val2 * part2;
		},
		expon_dist: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(3 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "expon.dist"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var x = calculates.numberof.call(this, arguments[0]);
			if(x < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "expon.dist"
				};
			}
			var lambda = calculates.numberof.call(this, arguments[1]);
			if(0 >= lambda) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "expon.dist"
				};
			}
			var cumulative = arguments[2];
			if(me.isCoordObj(cumulative)) {
				cumulative = calculates.valof.call(this, cumulative);
			}
			var result;
			if(HELPER.isBoolean(cumulative)) {
				cumulative = HELPER.getBoolean(cumulative);
				if(cumulative) {
					result = 1 - Math.exp(-lambda * x);
				} else {
					result = lambda * Math.exp(-lambda * x);
				}
				return result;
			}
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: "expon.dist"
			};
		},
		binomdist: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(4 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "binom.dist"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number_s = calculates.numberof.call(this, arguments[0]);
			if(number_s < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "binom.dist"
				};
			}
			var trials = calculates.numberof.call(this, arguments[1]);
			trials = parseInt(trials);
			var probability_s = calculates.numberof.call(this, arguments[2]);
			if(probability_s < 0 || probability_s > 1) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "binom.dist"
				};
			}
			var cumulative = arguments[3];
			if(me.isCoordObj(cumulative)) {
				cumulative = calculates.valof.call(this, cumulative);
			}
			if(!HELPER.isBoolean(cumulative)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "binom.dist"
				};
			}
			cumulative = HELPER.getBoolean(cumulative);
			if(cumulative == false) {
				return HELPER.calculateBinom(number_s, trials, probability_s);
			} else {
				var sum = 0;
				for(var loop = 0; loop <= number_s; loop++) {
					sum = sum + HELPER.calculateBinom(loop, trials, probability_s);
				}
				return sum;
			}
		},
		pearson: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				len = arguments.length;
			if(2 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "pearson"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr1 = calculates.rangeNumsOf3.call(this, [arguments[0]], "pearson");
			if(0 == arr1.length) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "pearson"
				};
			}
			var arr2 = calculates.rangeNumsOf3.call(this, [arguments[1]], "pearson");
			if(0 == arr2.length) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "pearson"
				};
			}
			var lengthX = arr1.length,
				lengthY = arr2.length;
			if(lengthX !== lengthY) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "pearson"
				};
			}
			var meanX = 0,
				sumX = 0;
			for(var i = 0; i < lengthX; i++) {
				sumX += arr1[i];
			}
			meanX = sumX / lengthX;
			var meanY = 0,
				sumY = 0;
			for(var i = 0; i < lengthY; i++) {
				sumY += arr2[i];
			}
			meanY = sumY / lengthY;
			var num = 0,
				den1 = 0,
				den2 = 0;
			for(var i = 0; i < lengthX; i++) {
				num += (arr1[i] - meanX) * (arr2[i] - meanY);
				den1 += Math.pow(arr1[i] - meanX, 2);
				den2 += Math.pow(arr2[i] - meanY, 2);
			}
			return num / Math.sqrt(den1 * den2);
		},
		isblank: function() {
			return this.me.statisticalCommon(arguments, "isblank", this);
		},
		isnumber: function() {
			return this.me.statisticalCommon(arguments, "isnumber", this);
		},
		istext: function() {
			return this.me.statisticalCommon(arguments, "istext", this);
		},
		islogical: function() {
			return this.me.statisticalCommon(arguments, "islogical", this);
		},
		n: function() {
			return this.me.statisticalCommon(arguments, "n", this);
		},
		iseven: function() {
			return this.me.mathCommonFunction2(arguments, "iseven", this);
		},
		isodd: function() {
			return this.me.mathCommonFunction2(arguments, "isodd", this);
		},
		na: function() {
			var len = arguments.length;
			if(0 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "NA"
				};
			}
			throw {
				code: "VALUE_NOT_AVAILABLE",
				cal: "NA"
			};
		},
		iserror: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "ISERROR"
				};
			}
			var expressFn = arguments[0],
				val;
			if(Ext.isFunction(expressFn)) {
				try {
					val = expressFn.call(this);
					if(val == "Infinity" || val == "#NUM!" || val == "#N/A" || val == "#PARAM!" || val == "#LOOP!" || val == "#DIV/0!" || val == "#VALUE!" || val == "#ERROR!" || val == "#REF!") {
						return true;
					}
				} catch(e) {
					return true;
				}
			} else {
				val = expressFn;
			}
			if(val === undefined || val === "") {
				return false;
			}
			if(val == "Infinity") {
				return true;
			}
			return false;
		},
		iserr: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "ISERR"
				};
			}
			var expressFn = arguments[0],
				val;
			if(Ext.isFunction(expressFn)) {
				try {
					val = expressFn.call(this);
					if(val == "Infinity" || val == "#NUM!" || val == "#PARAM!" || val == "#LOOP!" || val == "#DIV/0!" || val == "#VALUE!" || val == "#ERROR!" || val == "#REF!") {
						return true;
					}
				} catch(e) {
					if(e.code && e.code == "VALUE_NOT_AVAILABLE") {
						return false;
					}
					return true;
				}
			} else {
				val = expressFn;
			}
			if(val === undefined || val === "") {
				return false;
			}
			if(val == "Infinity") {
				return true;
			}
			return false;
		},
		isna: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "ISNA"
				};
			}
			var expressFn = arguments[0],
				val;
			if(Ext.isFunction(expressFn)) {
				try {
					val = expressFn.call(this);
					if(val == "#N/A") {
						return true;
					}
				} catch(e) {
					if(e.code && e.code == "VALUE_NOT_AVAILABLE") {
						return true;
					}
					return false;
				}
			}
			if(expressFn == "#N/A") {
				return true;
			}
			return false;
		},
		type: function() {
			var errorVal = 16,
				arrayVal = 64,
				logicalVal = 4,
				textVal = 2,
				numVal = 1;
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				if(Ext.isArray(arguments[0])) {
					return arrayVal;
				}
				throw {
					code: "CAL_PARAM_MISS",
					cal: "TYPE"
				};
			}
			var val = arguments[0];
			try {
				if(Ext.isArray(val)) {
					return arrayVal;
				} else if(me.isCoordObj(val)) {
					val = calculates.valof.call(this, val);
				} else if(Ext.isFunction(val)) {
					val = val.call(this);
					if(val == "Infinity" || val == "#NUM!" || val == "#N/A" || val == "#PARAM!" || val == "#LOOP!" || val == "#DIV/0!" || val == "#VALUE!" || val == "#ERROR!" || val == "#REF!") {
						return errorVal;
					}
				}
			} catch(e) {
				return errorVal;
			}
			try {
				if(val === undefined || val === "" || SCOM.isEmptyStr(val)) {
					return numVal;
				}
				if(HELPER.isBoolean(val)) {
					return logicalVal;
				}
				if(Ext.isString(val)) {
					return textVal;
				}
				if(Ext.isNumber(val)) {
					return numVal;
				}
			} catch(e) {
				return errorVal;
			}
			return errorVal;
		},
		countif: function() {
			if(2 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "COUNTIF"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var criteraRange = arguments[0];
			if(Ext.isObject(arguments[0])) {
				var tmpSpan = criteraRange.span;
				if("" === tmpSpan[0]) {
					tmpSpan[0] = isheet;
				}
				criteraRange = me.calCacheMap.getValueFromCache(tmpSpan);
				if(!criteraRange) {
					criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[0]]);
					me.calCacheMap.addValueToCache(tmpSpan, criteraRange);
				}
			}
			var cond = arguments[1];
			if(me.isCoordObj(cond)) {
				cond = calculates.valof.call(this, cond);
			}
			if(Ext.isString(cond)) {
				cond = Ext.util.Format.htmlDecode(cond);
				cond = HELPER.changeCondSpecialCase(cond);
				if(HELPER.isExpress(cond)) {
					cond = HELPER.updateCompareCondition(cond);
				}
			}
			var result = 0,
				sumRangeXlength = criteraRange.length,
				sumRangeYlength = criteraRange[0].length;
			for(var i = 0; i < sumRangeXlength; i++) {
				for(var j = 0; j < sumRangeYlength; j++) {
					var data = criteraRange[i][j],
						flag = false;
					if(data === undefined || data == null || Ext.String.trim(data.toString()) == "") {
						continue;
					}
					if(HELPER.isExpress(cond)) {
						data = HELPER.convertPercent2num2(data);
						if(Ext.isNumber(Number(data))) {
							flag = eval(data + cond);
						} else {
							flag = eval("\"" + data + "\"" + cond);
						}
					} else if(SCOM.kmpCompare(data.toString(), cond.toString())) {
						flag = true;
					}
					if(flag) {
						result++;
					}
				}
			}
			criteraRange = [];
			return result;
		},
		countifs: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len < 2 || len % 2 == 1) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "countifs"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var criteriaRangeArr = [],
				criteriaArr = [];
			var sumRangeXlength = 0,
				sumRangeYlength = 0;
			var i = 0;
			while(i < len) {
				var criteraRange = arguments[i];
				if(Ext.isObject(arguments[i])) {
					var tmpSpan = criteraRange.span;
					if("" === tmpSpan[0]) {
						tmpSpan[0] = isheet;
					}
					criteraRange = me.calCacheMap.getValueFromCache(tmpSpan);
					if(!criteraRange) {
						criteraRange = calculates.rangeVal2Dimension.call(this, [arguments[i]]);
						me.calCacheMap.addValueToCache(tmpSpan, criteraRange);
					}
				}
				if(criteraRange == null || criteraRange.length == 0) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "countifs"
					};
				}
				var criteraRangeXlength = criteraRange.length;
				var criteraRangeYlength = criteraRange[0].length;
				if(i == 0) {
					sumRangeXlength = criteraRangeXlength;
					sumRangeYlength = criteraRangeYlength;
				}
				if(sumRangeXlength != criteraRangeXlength || sumRangeYlength != criteraRangeYlength) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "countifs"
					};
				}
				criteriaRangeArr[criteriaRangeArr.length] = criteraRange;
				i = i + 1;
				var cond = arguments[i];
				if(me.isCoordObj(cond)) {
					cond = calculates.valof.call(this, cond);
				}
				if(Ext.isString(cond)) {
					cond = Ext.util.Format.htmlDecode(cond);
					cond = HELPER.changeCondSpecialCase(cond);
					if(HELPER.isExpress(cond)) {
						cond = HELPER.updateCompareCondition(cond);
					}
				}
				criteriaArr[criteriaArr.length] = cond;
				i = i + 1;
			}
			var result = 0;
			for(var i = 0; i < sumRangeXlength; i++) {
				for(var j = 0; j < sumRangeYlength; j++) {
					var flag = true;
					for(var k = 0; k < criteriaRangeArr.length; k++) {
						var criteraRange = criteriaRangeArr[k];
						var data = criteraRange[i][j];
						if(data === undefined || data == null || Ext.String.trim(data.toString()) == "") {
							flag = false;
							break;
						}
						var cond = criteriaArr[k];
						var condflag = false;
						if(HELPER.isExpress(cond)) {
							data = HELPER.convertPercent2num2(data);
							if(Ext.isNumber(Number(data))) {
								condflag = eval(data + cond);
							} else {
								condflag = eval("\"" + data + "\"" + cond);
							}
						} else if(SCOM.kmpCompare(data.toString(), cond.toString())) {
							condflag = true;
						}
						if(condflag == false) {
							flag = false;
							break;
						}
					}
					if(flag) {
						result++;
					}
				}
			}
			criteriaRangeArr = [], criteriaArr = [];
			return result;
		},
		mode: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "mode"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				if(HELPER.isBoolean(data)) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "mode"
					};
				}
				var pos = Number(data);
				if(Ext.isNumber(pos)) {
					arr.push(pos);
				}
			}, this);
			var alen = arr.length;
			if(0 == alen) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "mode"
				};
			}
			if(2 > alen) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "mode"
				};
			}
			if(2 == alen) {
				if(arr[0] == arr[1]) {
					return arr[0];
				}
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "mode"
				};
			} else {
				var lookup = {};
				for(var i = 0; i < alen; i++) {
					var v = arr[i];
					lookup[v] = lookup[v] || 0;
					lookup[v]++;
				}
				var max = -1,
					found;
				for(var p in lookup) {
					if(max < lookup[p]) {
						found = p;
						max = lookup[p];
					}
				}
				if(1 >= max) {
					throw {
						code: "VALUE_NOT_AVAILABLE",
						cal: "mode"
					};
				}
				return found;
			}
		},
		lcm: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "lcm"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				if(HELPER.isBoolean(data)) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "lcm"
					};
				}
				data = Number(data);
				if(Ext.isNumber(data)) {
					arr.push(Math.floor(data));
				}
			}, this);
			var alen = arr.length;
			if(0 == alen) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "lcm"
				};
			}
			for(var i = 0; i < alen; i++) {
				if(arr[i] < 0 || arr[i] == null) {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: "lcm"
					};
				}
			}
			if(1 == alen) {
				return arr[0];
			}
			var lookup = {};
			for(var i = 0; i < alen; i++) {
				var v = arr[i];
				lookup[v] = true;
			}
			var fset = {};
			for(var num in lookup) {
				var factors = SCOM.factorizeNum(num);
				for(var f in factors) {
					fset[f] = fset[f] || 0;
					if(fset[f] < factors[f]) {
						fset[f] = factors[f];
					}
				}
			}
			var mut = 1;
			for(var p in fset) {
				mut *= Math.pow(p, fset[p]);
			}
			return mut;
		},
		gcd: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "gcd"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				if(HELPER.isBoolean(data)) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "lcm"
					};
				}
				data = Number(data);
				if(data < 0) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "lcm"
					};
				}
				if(Ext.isNumber(data)) {
					var roundNum = Math.floor(data);
					if(roundNum > 0) {
						arr.push(Math.floor(data));
					}
				}
			}, this);
			var alen = arr.length;
			if(0 == alen) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "lcm"
				};
			}
			for(var i = 0; i < alen; i++) {
				if(arr[i] < 0 || arr[i] == null) {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: "lcm"
					};
				}
			}
			if(arr == null || arr.length == 0) {
				return 0;
			}
			if(1 == alen) {
				return arr[0];
			}
			arr.sort(function(a, b) {
				return a - b;
			});
			res = arr[0];
			while(res > 0) {
				var counts = 0;
				for(i = 0; i < arr.length; i++) {
					if(arr[i] % res == 0) {
						counts++;
					}
				}
				if(counts == arr.length) {
					break;
				}
				res--;
			}
			return res;
		},
		year: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "YEAR"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var myDate = arguments[0];
			if(me.isCoordObj(myDate)) {
				myDate = calculates.valof.call(this, myDate);
			}
			if(SCOM.canbeNumber(myDate)) {
				if(Number(myDate) < 0) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "YEAR"
					};
				}
				if(myDate == 0) {
					myDate = 1;
				}
				var newDate = new Date;
				newDate.setFullYear(1900, 0, myDate);
				if(newDate.getFullYear() > 9999) {
					throw {
						code: "CAL_PARAM_NEED_BE_NUM",
						cal: "YEAR"
					};
				}
				return newDate.getFullYear();
			}
			var date = SFORMAT.checkingDate(myDate);
			if(date) {
				return Ext.Date.format(date, "Y");
			}
			date = new Date(myDate);
			if(date) {
				return Ext.Date.format(date, "Y");
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "YEAR"
			};
		},
		month: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "MONTH"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			if(HELPER.isBoolean(val)) {
				return 1;
			}
			if(SCOM.canbeNumber(val)) {
				if(val === 0) {
					return 1;
				}
				if(Number(val) < 0) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "MONTH"
					};
				}
				var myDate = new Date;
				myDate.setFullYear(1900, 0, val);
				if(myDate.getFullYear() > 9999) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "MONTH"
					};
				}
				return myDate.getMonth() + 1;
			}
			var date = SFORMAT.checkingDate(val);
			if(date) {
				return date.getMonth() + 1;
			}
			date = new Date(val);
			if(date) {
				return date.getMonth() + 1;
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "MONTH"
			};
		},
		date: function() {
			if(3 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "date"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var year = arguments[0],
				month = arguments[1],
				day = arguments[2];
			if(me.isCoordObj(year)) {
				year = calculates.numberof.call(this, year);
			}
			if(me.isCoordObj(month)) {
				month = calculates.numberof.call(this, month);
			}
			if(me.isCoordObj(day)) {
				day = calculates.numberof.call(this, day);
			}
			try {
				if(HELPER.isBoolean(year)) {
					year = HELPER.convertBoolean2Int(year);
				}
				if(HELPER.isBoolean(month)) {
					month = HELPER.convertBoolean2Int(month);
				}
				if(HELPER.isBoolean(day)) {
					day = HELPER.convertBoolean2Int(day);
				}
				if(year < 0) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "date"
					};
				}
				var date = new Date(year, month - 1, day);
				return Ext.Date.format(date, SCONST.DEFAULT_DATE_FORMAT);
			} catch(e) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "date"
				};
			}
		},
		datedif: function() {
			if(3 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "date"
				};
			}
			var start_date = arguments[0],
				end_date = arguments[1],
				unit = arguments[2];
			var me = this.me,
				calculates = me.calculates;
			var startValue, endValue, result;
			if(me.isCoordObj(start_date)) {
				start_date = calculates.valof.call(this, start_date);
			}
			if(me.isCoordObj(end_date)) {
				end_date = calculates.valof.call(this, end_date);
			}
			if(me.isCoordObj(unit)) {
				unit = calculates.valof.call(this, unit).toUpperCase();
			}
			start_date = new Date(start_date);
			end_date = new Date(end_date);
			if(start_date == "Invalid Date") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "datedif.start_date"
				};
			}
			if(end_date == "Invalid Date") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "datedif.end_date"
				};
			}
			var unitArray = ["Y", "M", "D", "MD", "YM", "YD"];
			var unitIndex = unitArray.indexOf(unit);
			if(unitIndex == -1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "datedif.unit"
				};
			}
			switch(unitIndex) {
				case 0:
					startValue = start_date.getYear();
					endValue = end_date.getYear();
					result = endValue - startValue;
					break;
				case 1:
					startValue = start_date.getYear();
					endValue = end_date.getYear();
					result = (endValue - startValue) * 12;
					startValue = start_date.getMonth();
					endValue = end_date.getMonth();
					result += endValue - startValue;
					break;
				case 2:
					startValue = start_date;
					endValue = end_date;
					result = (endValue - startValue) / 86400000;
					break;
				case 3:
					startValue = start_date.getDate();
					endValue = end_date.getDate();
					result = endValue - startValue;
					break;
				case 4:
					startValue = start_date.getMonth();
					endValue = end_date.getMonth();
					result = endValue - startValue;
					break;
				case 5:
					startValue = new Date(0, start_date.getMonth(), start_date.getDate());
					endValue = new Date(0, end_date.getMonth(), end_date.getDate());
					result = (endValue - startValue) / 86400000;
				default:
					;
			}
			return result;
		},
		today: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "TODAY"
				};
			}
			var today = new Date;
			return Ext.Date.format(today, SCONST.DEFAULT_DATE_FORMAT);
		},
		now: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "NOW"
				};
			}
			var today = new Date;
			return Ext.Date.format(today, SCONST.DEFAULT_DATE_TIME_FORMAT);
		},
		weeknum: function() {
			if(1 != arguments.length && 2 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "weeknum"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var returnType = 1;
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			val = SFORMAT.checkingDate(val);
			if(!val) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "weeknum"
				};
			}
			if(arguments.length == 2) {
				returnType = arguments[1];
				if(me.isCoordObj(returnType)) {
					returnType = calculates.valof.call(this, returnType);
				}
			}
			if(returnType === undefined) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "weeknum"
				};
			}
			if(returnType != 1 && returnType != 2) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "weeknum"
				};
			}
			var janOne = new Date(val.getFullYear(), 0, 1);
			var offsetVal = 0;
			if(returnType === 1) {
				offsetVal = 1;
			}
			return Math.ceil(((val - janOne) / 86400000 + janOne.getDay() + offsetVal) / 7);
		},
		isoweeknum: function() {
			if(1 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "isoweeknum"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			val = SFORMAT.checkingDate(val);
			if(!val) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "isoweeknum"
				};
			}
			var janOne = new Date(val.getFullYear(), 0, 1);
			var offsetVal = 0;
			return Math.ceil(((val - janOne) / 86400000 + janOne.getDay() + offsetVal) / 7);
		},
		day: function() {
			if(1 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "DAY"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var returnType = 1;
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			if(val == "0" || val == 0) {
				return 0;
			}
			var dateObj = SFORMAT.checkingDate(val);
			if(dateObj) {
				return dateObj.getDate();
			} else if(Ext.isNumber(Number(val))) {
				var baseDate = new Date("1904-01-02");
				if(val == "" || Number(val) < 0) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "DAY"
					};
				}
				baseDate.setDate(baseDate.getDate() + (Number(val) - 1));
				return baseDate.getDate();
			}
			var date = new Date(val);
			if(date) {
				return date.getDate();
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "day"
			};
		},
		days: function() {
			if(2 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "days"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var startDate = arguments[1],
				startDateNum = 0;
			if(me.isCoordObj(startDate)) {
				startDate = calculates.valof.call(this, startDate);
			}
			var dateObj = SFORMAT.checkingDate(startDate);
			if(dateObj) {
				startDateNum = HELPER.convertDateToNum(dateObj);
			} else if(Ext.isNumber(Number(startDate))) {
				startDateNum = startDate;
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: "days"
				};
			}
			var endDate = arguments[0],
				endDateNum = 0;
			if(me.isCoordObj(endDate)) {
				endDate = calculates.valof.call(this, endDate);
			}
			dateObj = SFORMAT.checkingDate(endDate);
			if(dateObj) {
				endDateNum = HELPER.convertDateToNum(dateObj);
			} else if(Ext.isNumber(Number(endDate))) {
				endDateNum = endDate;
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: "days"
				};
			}
			return endDateNum - startDateNum;
		},
		days360: function() {
			var len = arguments.length;
			if(2 > len || 3 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "days360"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) {
				startdate = calculates.valof.call(this, startdate);
			}
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "days360"
				};
			}
			var enddate = arguments[1];
			if(me.isCoordObj(enddate)) {
				enddate = calculates.valof.call(this, enddate);
			}
			enddate = SFORMAT.checkingDate(enddate);
			if(enddate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "days360"
				};
			}
			var method = false;
			if(len == 3) {
				method = arguments[2];
				if(me.isCoordObj(method)) {
					method = calculates.valof.call(this, method);
				}
			}
			return HELPER.calDifferentDateByMethod(enddate, startdate, method);
		},
		datevalue: function() {
			if(1 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "datevalue"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			val = SFORMAT.checkingDate(val);
			if(!val) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "datevalue"
				};
			}
			return HELPER.convertDateToNum(val);
		},
		timevalue: function() {
			if(1 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "timevalue"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			val = SFORMAT.checkingTime(val);
			if(!val) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "timevalue"
				};
			}
			return HELPER.convertDateToTimeVal(val);
		},
		networkdays: function() {
			var len = arguments.length;
			if(2 > len || 3 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "networkdays"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) {
				startdate = calculates.valof.call(this, startdate);
			}
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "networkdays"
				};
			}
			var endDate = arguments[1];
			if(me.isCoordObj(endDate)) {
				endDate = calculates.valof.call(this, endDate);
			}
			endDate = SFORMAT.checkingDate(endDate);
			if(endDate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "networkdays"
				};
			}
			var holidays = [];
			if(arguments[2]) {
				me.each(this.sheet, this.row, this.col, [arguments[2]], function(obj, itemType, index, insideIndex, item) {
					var data;
					if("span" == itemType) {
						var sheet = obj[0],
							row = obj[1],
							col = obj[2];
						if(Ext.isDefined(sheet)) {
							var cell = me.getCellData(sheet, row, col, this);
							data = cell.data;
						}
					} else {
						data = obj;
					}
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) {
						holidays.push(holiday);
					}
				}, this);
			}
			return HELPER.calculateNetworkDays(startdate, endDate, holidays);
		},
		networkdays_intl: function() {
			var len = arguments.length;
			if(2 > len || 4 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "networkdays.intl"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) {
				startdate = calculates.valof.call(this, startdate);
			}
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "networkdays.intl"
				};
			}
			var endDate = arguments[1];
			if(me.isCoordObj(endDate)) {
				endDate = calculates.valof.call(this, endDate);
			}
			endDate = SFORMAT.checkingDate(endDate);
			if(endDate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "networkdays.intl"
				};
			}
			var weekend_type = 1;
			if(len > 2) {
				weekend_type = calculates.numberof.call(this, arguments[2]);
			}
			if(weekend_type < 0 || weekend_type > 17 || weekend_type > 7 && weekend_type < 11) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "networkdays.intl"
				};
			}
			var holidays = [];
			if(len == 4) {
				me.each(this.sheet, this.row, this.col, [arguments[3]], function(obj, itemType, index, insideIndex, item) {
					var data;
					if("span" == itemType) {
						var sheet = obj[0],
							row = obj[1],
							col = obj[2];
						if(Ext.isDefined(sheet)) {
							var cell = me.getCellData(sheet, row, col, this);
							data = cell.data;
						}
					} else {
						data = obj;
					}
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) {
						holidays.push(holiday);
					}
				}, this);
			}
			return HELPER.calculateNetworkDaysIntl(startdate, endDate, weekend_type, holidays);
		},
		workday: function() {
			var len = arguments.length;
			if(2 > len || 3 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "workday"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) {
				startdate = calculates.valof.call(this, startdate);
			}
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "workday"
				};
			}
			var days = arguments[1];
			if(me.isCoordObj(days)) {
				days = calculates.numberof.call(this, days);
			}
			var holidays = [];
			if(arguments[2]) {
				me.each(this.sheet, this.row, this.col, [arguments[2]], function(obj, itemType, index, insideIndex, item) {
					var data;
					if("span" == itemType) {
						var sheet = obj[0],
							row = obj[1],
							col = obj[2];
						if(Ext.isDefined(sheet)) {
							var cell = me.getCellData(sheet, row, col, this);
							data = cell.data;
						}
					} else {
						data = obj;
					}
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) {
						holidays.push(holiday);
					}
				}, this);
			}
			var dueDate = HELPER.calculateWorkDay(startdate, days, holidays);
			return HELPER.convertDateToNum(dueDate);
		},
		workday_intl: function() {
			var len = arguments.length;
			if(2 > len || 4 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "workday.intl"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) {
				startdate = calculates.valof.call(this, startdate);
			}
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "workday.intl"
				};
			}
			var days = arguments[1];
			if(me.isCoordObj(days)) {
				days = calculates.numberof.call(this, days);
			}
			var weekend_type = 1;
			if(len > 2) {
				weekend_type = calculates.numberof.call(this, arguments[2]);
			}
			if(weekend_type < 0 || weekend_type > 17 || weekend_type > 7 && weekend_type < 11) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "workday.intl"
				};
			}
			var holidays = [];
			if(len > 3) {
				me.each(this.sheet, this.row, this.col, [arguments[3]], function(obj, itemType, index, insideIndex, item) {
					var data;
					if("span" == itemType) {
						var sheet = obj[0],
							row = obj[1],
							col = obj[2];
						if(Ext.isDefined(sheet)) {
							var cell = me.getCellData(sheet, row, col, this);
							data = cell.data;
						}
					} else {
						data = obj;
					}
					var holiday = SFORMAT.checkingDate(data);
					if(holiday && HELPER.isArrayIncludeDateObj(holidays, holiday) == false) {
						holidays.push(holiday);
					}
				}, this);
			}
			var dueDate = HELPER.calculateWorkDayIntl(startdate, days, weekend_type, holidays);
			return HELPER.convertDateToNum(dueDate);
		},
		yearfrac: function() {
			var len = arguments.length;
			if(2 > len || 3 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "yearfrac"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var startdate = arguments[0];
			if(me.isCoordObj(startdate)) {
				startdate = calculates.valof.call(this, startdate);
			}
			startdate = SFORMAT.checkingDate(startdate);
			if(startdate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "yearfrac"
				};
			}
			var enddate = arguments[1];
			if(me.isCoordObj(enddate)) {
				enddate = calculates.valof.call(this, enddate);
			}
			enddate = SFORMAT.checkingDate(enddate);
			if(enddate == null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "yearfrac"
				};
			}
			var basic = 0;
			if(len == 3) {
				basic = calculates.numberof.call(this, arguments[2]);
			}
			if(basic > 4 || basic < 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "yearfrac"
				};
			}
			if(basic == 0 || basic == 4) {
				var method = true;
				if(basic == 0) {
					method = false;
				}
				var days = HELPER.calDifferentDateByMethod(enddate, startdate, method);
				return Math.abs(days / 360);
			}
			var actualDays = HELPER.convertDateToNum(enddate) - HELPER.convertDateToNum(startdate);
			if(basic == 2) {
				return Math.abs(actualDays / 360);
			} else if(basic == 3) {
				return Math.abs(actualDays / 365);
			} else if(basic == 1) {
				var actual = HELPER._actualDaysPerYear(startdate, enddate);
				return Math.abs(actualDays / actual);
			}
			throw {
				code: "NUM_IS_NOT_RIGHT",
				cal: "yearfrac"
			};
		},
		weekday: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "WEEKDAY"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var enterDate = arguments[0];
			var retVal = 1;
			if(len == 2) {
				retVal = arguments[1];
				if(me.isCoordObj(retVal)) {
					retVal = calculates.valof.call(this, retVal);
				}
			}
			if(retVal === undefined) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "WEEKDAY"
				};
			}
			if(retVal != 1 && retVal != 2 && retVal != 3) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "WEEKDAY"
				};
			}
			if(me.isCoordObj(enterDate)) {
				enterDate = calculates.valof.call(this, enterDate);
			}
			if(enterDate === undefined || HELPER.isEmptyStr(enterDate)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "WEEKDAY"
				};
			}
			if(HELPER.isBoolean(enterDate)) {
				enterDate = HELPER.convertBoolean2Int(enterDate);
			}
			var checkDate = SFORMAT.checkingDate(enterDate);
			if(checkDate) {
				var result = checkDate.getDay();
				if(retVal == 1) {
					result += 1;
				} else if(retVal == 2 && result == 0) {
					result = 7;
				} else if(retVal == 3) {
					result -= 1;
					if(result == -1) {
						result = 6;
					}
				}
				return result;
			} else {
				var val = Number(enterDate);
				if(Ext.isNumber(enterDate)) {
					if(enterDate < 0) {
						throw {
							code: "CAL_PARAM_NEED_BE_NUM",
							cal: "WEEKDAY"
						};
					}
					var result = Math.floor((enterDate + 6) % 7);
					if(retVal == 1) {
						result += 1;
					} else if(retVal == 2 && result == 0) {
						result = 7;
					} else if(retVal == 3) {
						result -= 1;
						if(result == -1) {
							result = 6;
						}
					}
					return result;
				}
				throw {
					code: "CAL_NO_VALUE",
					cal: "WEEKDAY"
				};
			}
		},
		hour: function() {
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "hour"
				};
			}
			var maxDigNum = 0;
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) {
				posOffset = calculates.valof.call(this, posOffset);
			}
			if(HELPER.isBoolean(posOffset)) {
				return 0;
			}
			var posTmp = Number(posOffset);
			if(Ext.isNumber(posTmp) && posTmp < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hour"
				};
			} else if(Ext.isNumber(posTmp) && posTmp >= 0) {
				posTmp = posTmp.toString();
				var as = posTmp.match(/(\.\d+)$/);
				if(as) {
					var sumSecond = Number(as[1]) * 1440;
					return(sumSecond - sumSecond % 60) / 60;
				} else {
					return 0;
				}
			} else if(posOffset.indexOf(".") > -1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "HOUR"
				};
			} else {
				if(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i.test(posOffset)) {
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i, "");
					date = date.replace(/\s+/g, "");
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i);
					if(!date) {
						if(!Ext.isDate(new Date(date))) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "HOUR"
							};
						}
					}
					var h = Number(pm[1]);
					if(h < 0) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "HOUR"
						};
					}
					var m = Number(pm[2]);
					var s = Number(pm[3]);
					if(pm[4]) {
						if(m > -1 && m < 60 && s > -1 && s < 60 && h > -1 && h < 13) {
							if(/pm/i.test(pm[4])) {
								if(h == 12) {
									return 12;
								} else {
									return h + 12;
								}
							} else {
								if(h == 12) {
									return 0;
								} else {
									return h;
								}
							}
						} else {
							throw {
								code: "CAL_NO_VALUE",
								cal: "HOUR"
							};
						}
					} else {
						if(h > 24) {
							return h % 12;
						} else {
							return h;
						}
					}
				} else if(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i.test(posOffset)) {
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i, "");
					date = date.replace(/\s+/g, "");
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i);
					if(!date) {
						if(!Ext.isDate(new Date(date))) {
							throw "SS_ERROR_VALUE";
						}
					}
					var h = Number(pm[1]);
					if(h < 0) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "HOUR"
						};
					}
					var m = Number(pm[2]);
					if(pm[3]) {
						if(m > -1 && m < 60 && h > -1 && h < 13) {
							if(/pm/i.test(pm[3])) {
								if(h == 12) {
									return 12;
								} else {
									return h + 12;
								}
							} else {
								if(h == 12) {
									return 0;
								} else {
									return h;
								}
							}
						} else {
							throw {
								code: "CAL_NO_VALUE",
								cal: "HOUR"
							};
						}
					} else {
						if(h > 24) {
							return h % 12;
						} else {
							return h;
						}
					}
				}
			}
		},
		minute: function() {
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "minute"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var maxDigNum = 0;
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) {
				posOffset = calculates.valof.call(this, posOffset);
			}
			if(HELPER.isBoolean(posOffset)) {
				return 0;
			}
			var posTmp = Number(posOffset);
			if(Ext.isNumber(posTmp) && posTmp > 0) {
				posTmp = posTmp.toString();
				if(posTmp.indexOf(".") > -1) {
					return Math.floor(Number(posTmp) * 1440 % 60);
				} else {
					return 0;
				}
			} else if(posOffset.indexOf(".") > -1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "minute"
				};
			} else {
				if(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i.test(posOffset)) {
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i, "");
					date = date.replace(/\s+/g, "");
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i);
					if(date) {
						if(!Ext.isDate(new Date(date))) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "minute"
							};
						}
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					var s = Number(pm[3]);
					if(m > -1 && m < 60 && s > -1 && s < 60) {
						if(pm[4] && (h < 0 || h > 12)) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "minute"
							};
						}
						return m;
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "minute"
						};
					}
				} else if(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i.test(posOffset)) {
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i, "");
					date = date.replace(/\s+/g, "");
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i);
					if(date) {
						if(!Ext.isDate(new Date(date))) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "minute"
							};
						}
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					if(m > -1 && m < 60) {
						if(pm[3] && (h < 0 || h > 12)) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "minute"
							};
						}
						return m;
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "minute"
						};
					}
				}
			}
		},
		second: function() {
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "second"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) {
				posOffset = calculates.valof.call(this, posOffset);
			}
			if(HELPER.isBoolean(posOffset)) {
				return 0;
			}
			var posTmp = Number(posOffset);
			if(Ext.isNumber(posTmp) && posTmp > 0) {
				posTmp = posTmp.toString();
				if(posTmp.indexOf(".") > -1) {
					var mpos = Number(posTmp) * 1440 % 60;
					var s = Math.floor((mpos - Math.floor(mpos)) * 60);
					return s;
				} else {
					return 0;
				}
			} else if(posOffset.indexOf(".") > -1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "second"
				};
			} else {
				if(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i.test(posOffset)) {
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i, "");
					date = date.replace(/\s+/g, "");
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*:\s*(\d+)(\s+[P|A]M){0,1}/i);
					if(date) {
						if(!Ext.isDate(new Date(date))) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "second"
							};
						}
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					var s = Number(pm[3]);
					if(m > -1 && m < 60 && s > -1 && s < 60) {
						if(pm[4] && (h < 0 || h > 12)) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "second"
							};
						}
						return s;
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "second"
						};
					}
				} else if(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i.test(posOffset)) {
					var date = posOffset.replace(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i, "");
					date = date.replace(/\s+/g, "");
					var pm = posOffset.match(/(\d+)\s*:\s*(\d+)\s*(\s+[P|A]M){0,1}$/i);
					if(date) {
						if(!Ext.isDate(new Date(date))) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "second"
							};
						}
					}
					var h = Number(pm[1]);
					var m = Number(pm[2]);
					if(m > -1 && m < 60) {
						if(pm[3] && (h < 0 || h > 12)) {
							throw {
								code: "CAL_NO_VALUE",
								cal: "second"
							};
						}
						return 0;
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "second"
						};
					}
				}
			}
		},
		time: function() {
			var len = arguments.length;
			if(3 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "time"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var hourPart = calculates.numberof.call(this, arguments[0]);
			var minutePart = calculates.numberof.call(this, arguments[1]);
			var secondPart = calculates.numberof.call(this, arguments[2]);
			if(hourPart < 32768 && minutePart < 32768 && secondPart < 32768) {
				minutePart += Math.floor(secondPart / 60);
				hourPart = Math.floor(hourPart);
				var sumMin = minutePart + hourPart * 60;
				var hsm = sumMin % 60;
				hourPart = (sumMin - hsm) / 60;
				minutePart = hsm % 60;
				var hm = hourPart % 24;
				var zone = "AM";
				if(hm > 11) {
					zone = "PM";
				}
				hourPart = hm % 12;
				if(hourPart == 0) {
					hourPart = 12;
				}
				minutePart = Math.floor(minutePart);
				if(minutePart < 10) {
					minutePart = "0" + minutePart;
				}
				secondPart = Math.floor(secondPart % 60);
				if(secondPart < 10) {
					secondPart = "0" + secondPart;
				}
				return hourPart + ":" + minutePart + ":" + secondPart + " " + zone;
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "time"
			};
		},
		edate: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "edate"
				};
			}
			var startDate = arguments[0];
			if(me.isCoordObj(startDate)) {
				startDate = calculates.valof.call(this, startDate);
			}
			if(startDate === undefined || HELPER.isEmptyStr(startDate)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "edate"
				};
			}
			var months = calculates.numberof.call(this, arguments[1]);
			var checkDate = SFORMAT.checkingDate(startDate);
			if(checkDate) {
				var newDate = Ext.Date.add(checkDate, Ext.Date.MONTH, months);
				return HELPER.convertDateToNum(newDate);
			} else if(Ext.isNumber(Number(startDate))) {
				var temp = Number(startDate);
				var date = new Date(0, 0, temp - 1);
				var newDate = Ext.Date.add(date, Ext.Date.MONTH, months);
				return HELPER.convertDateToNum(newDate);
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "edate"
			};
		},
		eomonth: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "eomonth"
				};
			}
			var startDate = arguments[0];
			if(me.isCoordObj(startDate)) {
				startDate = calculates.valof.call(this, startDate);
			}
			if(startDate === undefined || HELPER.isEmptyStr(startDate)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "eomonth"
				};
			}
			var months = calculates.numberof.call(this, arguments[1]);
			var checkDate = SFORMAT.checkingDate(startDate);
			if(checkDate) {
				var newDate = Ext.Date.add(checkDate, Ext.Date.MONTH, months);
				return HELPER.convertDateToNum(Ext.Date.getLastDateOfMonth(newDate));
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "eomonth"
			};
		},
		mid: function() {
			if(3 != arguments.length) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "mid"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
			if(me.checkRangeMatch(args, 1, false, false)) {
				var arr = [];
				me.each(isheet, irow, icol, args, function(obj, itemType, index, insideIndex, item) {
					var data;
					if("span" == itemType) {
						var sheet = obj[0],
							row = obj[1],
							col = obj[2];
						if(Ext.isDefined(sheet)) {
							var cell = me.getCellData(sheet, row, col, this);
							data = cell.data;
						}
					} else {
						data = obj;
					}
					arr.push(data);
				}, this);
				var str = arr[0],
					startPos = Number(arr[1]),
					charNum = Number(arr[2]);
				if((Ext.isString(str) || Ext.isNumber(str)) && Ext.isNumber(startPos) && Ext.isNumber(charNum) && 0 < startPos && 0 < charNum) {
					str = str.toString();
					return str.substr(startPos - 1, charNum);
				}
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "mid"
			};
		},
		find: function() {
			var len = arguments.length;
			if(2 > len || 3 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "find"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var source = arguments[0],
				target = arguments[1];
			if(me.isCoordObj(target)) {
				target = calculates.valof.call(this, target);
			}
			if(target === undefined || HELPER.isEmptyStr(target)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "FIND"
				};
			}
			if(me.isCoordObj(source)) {
				source = calculates.valof.call(this, source);
			}
			if(source === undefined || HELPER.isEmptyStr(source)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "FIND"
				};
			}
			var start = 0;
			if(3 == len) {
				start = calculates.numberof.call(this, arguments[2]);
				if(start < 1) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "FIND"
					};
				}
			}
			if((Ext.isNumber(source) || Ext.isString(source)) && (Ext.isNumber(target) || Ext.isString(target))) {
				source = source.toString();
				target = target.toString();
				if(0 < start) {
					start = start - 1;
					target = target.slice(start, target.length);
				} else {
					start = 0;
				}
				var index = target.indexOf(source);
				if(-1 == index) {
					index = target.indexOf(source.trim());
					if(-1 == index) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "FIND"
						};
					}
				}
				return index + 1 + start;
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: "FIND"
				};
			}
		},
		rept: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "rept"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var repeatTimes = calculates.numberof.call(this, arguments[1]);
			if(repeatTimes < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "rept"
				};
			}
			if(repeatTimes == 0) {
				return "";
			}
			var repeatText = arguments[0];
			if(me.isCoordObj(repeatText)) {
				repeatText = calculates.valof.call(this, repeatText);
			}
			if(Ext.isString(repeatText) || Ext.isNumber(repeatText) || HELPER.isBoolean(repeatText)) {
				repeatText = repeatText.toString();
				var tmp = [];
				for(var i = 0; i < repeatTimes; i++) {
					tmp.push(repeatText);
				}
				return tmp.join("");
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "rept"
			};
		},
		replace: function() {
			var len = arguments.length;
			if(4 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "replace"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var old_text = arguments[0];
			if(me.isCoordObj(old_text)) {
				old_text = calculates.valof.call(this, old_text);
			}
			var start_num = calculates.numberof.call(this, arguments[1]);
			var num_chars = calculates.numberof.call(this, arguments[2]);
			var new_text = arguments[3];
			if(me.isCoordObj(new_text)) {
				new_text = calculates.valof.call(this, new_text);
			}
			var str = old_text;
			old_text = old_text.toString();
			new_text = new_text.toString();
			if(old_text.length < start_num) {
				str = old_text.concat(new_text);
			} else {
				var part1 = old_text.substr(0, start_num - 1);
				var part2 = old_text.substr(start_num + num_chars - 1, old_text.length);
				str = part1.concat(new_text).concat(part2);
			}
			return str;
		},
		value: function() {
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "value"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			if(val === undefined || HELPER.isEmptyStr(val) || HELPER.isBoolean(val)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "value"
				};
			}
			var checkDate = SFORMAT.checkingDate(val);
			if(checkDate) {
				return HELPER.convertDateToNum(checkDate);
			}
			val = HELPER.getValueFromMoneyData(val);
			var num = Number(val);
			if(!Ext.isNumber(num)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "value"
				};
			}
			return num;
		},
		TRUE: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 == len) {
				return true;
			} else {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "TRUE"
				};
			}
		},
		FALSE: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 == len) {
				return false;
			} else {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "FALSE"
				};
			}
		},
		IF: function(conditionRef, trueValRef, falseValRef) {
			var me = this.me,
				calculates = me.calculates;
			var len = arguments.length;
			if(3 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "IF"
				};
			}
			if(Ext.isFunction(conditionRef)) {
				conditionRef = conditionRef.call(this);
			}
			if(typeof conditionRef == "string") {
				if(conditionRef.toLowerCase() == "true") {
					conditionRef = true;
				} else if(Ext.isNumber(Number(conditionRef))) {
					if(Number(conditionRef) == 0) {
						conditionRef = false;
					} else {
						conditionRef = true;
					}
				} else {
					var checkDate = SFORMAT.checkingDate(conditionRef);
					if(checkDate) {
						conditionRef = true;
					} else {
						conditionRef = false;
					}
				}
			} else if(Ext.isNumber(Number(conditionRef))) {
				if(Number(conditionRef) == 0) {
					conditionRef = false;
				} else {
					conditionRef = true;
				}
			}
			if(me.isCoordObj(conditionRef)) {
				conditionRef = calculates.valof.call(this, conditionRef);
			}
			if(!conditionRef && len == 2) {
				return false;
			}
			if(conditionRef == 0) {
				conditionRef = false;
			}
			if(conditionRef) {
				if(Ext.isFunction(trueValRef)) {
					trueValRef = trueValRef.call(this);
				}
				return trueValRef;
			} else {
				if(Ext.isFunction(falseValRef)) {
					falseValRef = falseValRef.call(this);
				}
				return falseValRef;
			}
		},
		AND: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "AND"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var allArgsAreNotNumber = null;
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				if(Ext.isArray(data)) {
					arr = arr.concat(data);
				} else {
					arr.push(data);
				}
			}, this);
			for(var i = 0, len = arr.length; i < len; i++) {
				var num = arr[i];
				if(num == "Infinity") {
					throw {
						code: "SS_ERROR_INFINITY",
						span: "AND"
					};
				}
				if(null == num || num === undefined || num === "") {
					if(allArgsAreNotNumber == null) {
						allArgsAreNotNumber = true;
					}
				} else if(0 == num || "0" == num || "false" == num || "FALSE" == num) {
					return "FALSE";
				} else if("true" == num || "TRUE" == num) {} else if(HELPER.isEmptyStr(num)) {
					if(allArgsAreNotNumber == null) {
						allArgsAreNotNumber = true;
					}
				} else if(Ext.isNumber(Number(num))) {
					allArgsAreNotNumber = false;
				} else {
					if(allArgsAreNotNumber == null) {
						allArgsAreNotNumber = true;
					}
				}
			}
			if(allArgsAreNotNumber && allArgsAreNotNumber == true) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "AND"
				};
			}
			return true;
		},
		OR: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "OR"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
					}
				} else {
					data = obj;
				}
				var str = data.toString().toUpperCase();
				if("FALSE" == str) {
					data = "false";
				} else if("TRUE" == str) {
					data = "true";
				} else {
					var num = Number(str);
					if(!Ext.isNumber(num)) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "OR"
						};
					}
				}
				if(Ext.isArray(data)) {
					arr = arr.concat(data);
				} else {
					arr.push(data);
				}
			}, this);
			for(var i = 0, len = arr.length; i < len; i++) {
				if(arr[i] && "false" !== arr[i] && "FALSE" != arr[i] && 0 !== Number(arr[i])) {
					return true;
				}
			}
			return false;
		},
		NOT: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "NOT"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var num = arguments[0];
			if(me.isCoordObj(num)) {
				num = calculates.valof.call(this, num);
			}
			if(num == undefined || num == "true" || num == "false" || !isNaN(num) || num == "TRUE" || num == "FALSE") {
				return !num || "false" == num || 0 == num || "FALSE" == num ? "TRUE" : "FALSE";
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: "NOT"
				};
			}
			return true;
		},
		iferror: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "IFERROR"
				};
			}
			var expressFn = arguments[0],
				errVal = arguments[1];
			var val, errFlag;
			if(Ext.isFunction(expressFn)) {
				try {
					val = expressFn.call(this);
					if(val == "Infinity" || val == "#NUM!" || val == "#N/A" || val == "#PARAM!" || val == "#LOOP!" || val == "#DIV/0!" || val == "#VALUE!" || val == "#ERROR!" || val == "#REF!") {
						errFlag = true;
					}
				} catch(e) {
					errFlag = true;
				}
			} else {
				val = expressFn;
			}
			if(!errFlag) {
				if(val === undefined || val === "") {
					val = 0;
				} else if(val == "Infinity") {
					errFlag = true;
				}
			}
			if(errFlag) {
				if(Ext.isFunction(errVal)) {
					errVal = errVal.call(this);
				}
				if(me.isCoordObj(errVal)) {
					var args = me.transferAll2Absolute([errVal], isheet, irow, icol);
					var arg = args[0];
					if(me.checkRangeMatch(args, 1, false, false)) {
						var span = arg.span;
						if(span) {
							var cell = me.getCellData(span[0], span[1], span[2], this);
							errVal = cell.data;
						}
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "IFERROR"
						};
					}
				}
				return errVal;
			}
			return val;
		},
		ifna: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "IFNA"
				};
			}
			var expressFn = arguments[0],
				errVal = arguments[1];
			var val;
			if(Ext.isFunction(expressFn)) {
				try {
					val = expressFn.call(this);
					if(val == "#N/A") {
						expressFn = "#N/A";
					}
				} catch(e) {
					if(e.code && e.code == "VALUE_NOT_AVAILABLE") {
						expressFn = "#N/A";
					}
				}
			} else {
				val = expressFn;
			}
			if(expressFn == "#N/A") {
				if(Ext.isFunction(errVal)) {
					errVal = errVal.call(this);
				}
				if(me.isCoordObj(errVal)) {
					var args = me.transferAll2Absolute([errVal], isheet, irow, icol);
					var arg = args[0];
					if(me.checkRangeMatch(args, 1, false, false)) {
						var span = arg.span;
						if(span) {
							var cell = me.getCellData(span[0], span[1], span[2], this);
							errVal = cell.data;
						}
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "IFNA"
						};
					}
				}
				return errVal;
			}
			return val;
		},
		upper: function() {
			return this.me.stringCommon1(arguments, "upper", this);
		},
		lower: function() {
			return this.me.stringCommon1(arguments, "lower", this);
		},
		proper: function() {
			return this.me.stringCommon1(arguments, "proper", this);
		},
		len: function() {
			return this.me.stringCommon1(arguments, "len", this);
		},
		exact: function() {
			var len = arguments.length;
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "exact"
				};
			}
			var text1 = arguments[0];
			var text2 = arguments[1];
			if(me.isCoordObj(text1)) {
				text1 = calculates.valof.call(this, text1);
			}
			if(me.isCoordObj(text2)) {
				text2 = calculates.valof.call(this, text2);
			}
			if(text1 == text2) {
				return true;
			} else {
				return false;
			}
		},
		trim: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "trim"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var cell = arguments[0];
			if(me.isCoordObj(cell)) {
				cell = calculates.valof.call(this, cell);
			}
			cell = cell.toString();
			if(Ext.isDefined(cell) && "" !== cell) {
				return Ext.String.trim(cell);
			}
			if(cell == "") {
				return "";
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "trim"
			};
		},
		code: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "code"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var cell = arguments[0];
			if(me.isCoordObj(cell)) {
				cell = calculates.valof.call(this, cell);
			}
			cell = cell.toString();
			if(Ext.isDefined(cell) && "" !== cell) {
				return(new String(cell.substr(0, 1))).charCodeAt(0);
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "code"
			};
		},
		trunc: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 == len || len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "TRUNC"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var digital = arguments[1];
			if(me.isCoordObj(digital)) {
				digital = calculates.valof.call(this, digital);
			}
			var posOffset = arguments[0];
			if(me.isCoordObj(posOffset)) {
				posOffset = calculates.valof.call(this, posOffset);
			}
			if(posOffset === undefined) {
				return 0;
			}
			if(HELPER.isBoolean(posOffset)) {
				posOffset = HELPER.convertBoolean2Int(posOffset);
			}
			if(!digital || digital == undefined) {
				digital = 0;
				posOffset += "";
				var nDx = posOffset.indexOf(".");
				if(nDx == 0) {
					return 0;
				} else if(nDx > 0) {
					posOffset = posOffset.substring(0, nDx);
				}
			}
			var num = Number(posOffset);
			digital = Number(digital);
			if(!Ext.isNumber(digital) || !Ext.isNumber(num) || HELPER.isEmptyStr(posOffset)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "TRUNC"
				};
			} else if(num == 0 || digital < 0) {
				return 0;
			}
			if(digital > 0) {
				var maxIdx = 10;
				if(num < 0) {
					maxIdx = 11;
				}
				num += "";
				var base = Math.floor(digital);
				var idx = num.indexOf(".");
				if(idx > -1) {
					var leg = num.length;
					if(idx >= maxIdx) {
						num = Math.round(num);
					} else {
						if(leg - idx - 1 > base) {
							var a = "1";
							for(var k = 0; k < base - 1; k++) {
								a += "0";
							}
							a = Number(a);
							num = num.substring(0, idx + base + 1);
							if(maxIdx - 1 == idx) {
								num = parseFloat(Math.round(num * a)) / a;
							}
						} else {
							var a = "1";
							for(var k = 0; k < maxIdx - idx; k++) {
								a += "0";
							}
							a = Number(a);
							num = num.substring(0, maxIdx + 2);
							num = parseFloat(Math.round(num * a)) / a;
						}
					}
				}
			}
			return num;
		},
		left: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "LEFT"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
			if(me.checkRangeMatch(args, 1, false, false)) {
				var arr = [];
				me.each(isheet, irow, icol, args, function(obj, itemType, index, insideIndex, item) {
					var data;
					if("span" == itemType) {
						var sheet = obj[0],
							row = obj[1],
							col = obj[2];
						if(Ext.isDefined(sheet)) {
							var cell = me.getCellData(sheet, row, col, this);
							data = cell.data;
						}
					} else {
						data = obj;
					}
					arr.push(data);
				}, this);
				var alen = arr.length;
				if(1 == alen) {
					var source = arr[0];
					if(SCOM.canbeNumber(source) || Ext.isString(source)) {
						return source.toString().slice(0, 1);
					}
				} else if(2 == alen) {
					var source = arr[0],
						strLen = Number(arr[1]);
					if((SCOM.canbeNumber(source) || Ext.isString(source)) && Ext.isNumber(strLen)) {
						source = source.toString();
						return source.slice(0, strLen);
					}
				}
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "LEFT"
			};
		},
		right: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "RIGHT"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
			if(me.checkRangeMatch(args, 1, false, false)) {
				var arr = [];
				me.each(isheet, irow, icol, args, function(obj, itemType, index, insideIndex, item) {
					var data;
					if("span" == itemType) {
						var sheet = obj[0],
							row = obj[1],
							col = obj[2];
						if(Ext.isDefined(sheet)) {
							var cell = me.getCellData(sheet, row, col, this);
							data = cell.data;
						}
					} else {
						data = obj;
					}
					arr.push(data);
				}, this);
				var alen = arr.length;
				if(1 == alen) {
					var source = arr[0];
					if(SCOM.canbeNumber(source) || Ext.isString(source)) {
						var source = source.toString();
						var strLen = source.length;
						return source.slice(strLen - 1, strLen);
					}
				} else if(2 == alen) {
					var source = arr[0],
						strPos = Number(arr[1]);
					if((SCOM.canbeNumber(source) || Ext.isString(source)) && Ext.isNumber(strPos)) {
						source = source.toString();
						var strLen = source.length;
						var start = strLen - strPos;
						if(0 > start) {
							start = 0;
						}
						return source.slice(start, strLen);
					}
				}
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "RIGHT"
			};
		},
		concatenate: function() {
			return this.me.concatenateCommonFn(arguments, "CONCATENATE", this);
		},
		verketten: function() {
			return this.me.concatenateCommonFn(arguments, "CONCATENATE", this);
		},
		clean: function() {
			var len = arguments.length;
			if(len != 1) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "CLEAN"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			var result = [];
			if("string" == SCOM.typeOf(val)) {
				for(var i = 0; i < val.length; i++) {
					var ch = val.charCodeAt(i);
					if(0 <= ch && ch <= 31 || 127 === ch || 128 <= ch && ch <= 159) {} else {
						result.push(val[i]);
					}
				}
				return result.join("");
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: "CLEAN"
				};
			}
		},
		fixed: function() {
			var len = arguments.length;
			if(len < 2 || len > 3) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "FIXED"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var nocommas = false;
			if(len == 3) {
				nocommas = arguments[2];
			}
			var num = calculates.numberof.call(this, arguments[0]);
			var decimals = calculates.numberof.call(this, arguments[1]);
			decimals = Math.floor(decimals);
			var str = [];
			num = Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
			if(nocommas) {
				if(nocommas == "true" || nocommas) {
					nocommas = true;
				} else {
					nocommas = false;
				}
			}
			var text = new String(num);
			if(!nocommas) {
				var idx = text.length - text.indexOf(".");
				for(var i = text.length - 1; i >= 0; i--) {
					var s = text.substr(i, 1);
					str.unshift(s);
					var p1 = text.length - i;
					var p2 = text.length - i - idx;
					if(p1 > idx && (p2 - idx) % 3 == 1 && i > 0) {
						str.unshift(",");
					}
				}
				return str.join("");
			} else {
				return text;
			}
		},
		'char': function() {
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "CHAR"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var asc = calculates.numberof.call(this, arguments[0]);
			if(asc < 1 || asc > 255) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "CHAR"
				};
			}
			var chr = String.fromCharCode(asc);
			return chr;
		},
		dollar: function() {
			var len = arguments.length;
			if(1 > len || len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "DOLLAR"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var decimals = 2;
			if(len == 2) {
				decimals = arguments[1];
				if(me.isCoordObj(decimals)) {
					decimals = calculates.numberof.call(this, decimals);
				}
			}
			var num = calculates.numberof.call(this, arguments[0]);
			decimals = Number(decimals);
			num = Number(num);
			if(!Ext.isNumber(decimals) || !Ext.isNumber(num)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "DOLLAR"
				};
			}
			decimals = Math.floor(decimals);
			var format = "$0,000";
			if(decimals > 0) {
				format = format + ".";
				for(var i = 0; i < decimals; i++) {
					format = format + "0";
				}
				return Ext.util.Format.number(num, format);
			}
			num = Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
			return Ext.util.Format.number(num, format);
		},
		text: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "TEXT"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0],
				fm = arguments[1];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			if(me.isCoordObj(fm)) {
				fm = calculates.valof.call(this, fm);
			}
			if(HELPER.isBoolean(val)) {
				return HELPER.getBoolean(val);
			}
			var num = Number(val);
			if(!Ext.isNumber(num)) {
				var date = SFORMAT.checkingDate(val);
				if(date) {
					fm = HELPER.replaceDateFm(fm);
					return Ext.Date.format(date, fm);
				} else {
					return val;
				}
			} else {
				if(fm.indexOf("yy") > -1 || fm.indexOf("dd") > -1 || fm.indexOf("m") > -1) {
					var myDate = new Date(1900, 0, num - 1);
					fm = HELPER.replaceDateFm(fm);
					return Ext.Date.format(myDate, fm);
				}
				return HELPER.formatNumber(val, fm);
			}
		},
		substitute: function() {
			var len = arguments.length;
			if(len > 4 || len < 3) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "SUBSTITUTE"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var text = arguments[0];
			var old_text = arguments[1];
			var new_text = arguments[2];
			var instance_num = 0;
			if(len == 4) {
				instance_num = calculates.numberof.call(this, arguments[3]);
			}
			if(me.isCoordObj(text)) {
				text = calculates.valof.call(this, text);
			}
			if(me.isCoordObj(old_text)) {
				old_text = calculates.valof.call(this, old_text);
			}
			if(me.isCoordObj(new_text)) {
				new_text = calculates.valof.call(this, new_text);
			}
			if(Ext.isString(text)) {
				var temp = HELPER.strTrim(text);
				if(temp == "" || temp.length == 0) {
					return "";
				}
			}
			var str = "";
			if(instance_num == 0) {
				str = text.replace(new RegExp(old_text, "g"), new_text);
			} else {
				var pos = 0;
				for(var i = 0; i < instance_num; i++) {
					pos = text.indexOf(old_text, pos) + 1;
				}
				if(pos > 0) {
					pos--;
					str = text.substr(0, pos) + new_text + text.substr(pos + old_text.length, text.length);
				} else {
					str = text;
				}
			}
			return str;
		},
		pmt: function() {
			var len = arguments.length;
			if(3 > len || len > 5) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "PMT"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var fv = 0,
				type = 0;
			if(4 == len) {
				fv = arguments[3];
			} else if(5 == len) {
				fv = arguments[3];
				type = arguments[4];
			}
			var rate = calculates.numberof.call(this, arguments[0]);
			var nper = calculates.numberof.call(this, arguments[1], true);
			var pv = calculates.numberof.call(this, arguments[2], true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			rate = parseFloat(rate);
			if(rate == 0) {
				rate = 0.000001;
			}
			nper = parseFloat(nper);
			pv = parseFloat(pv);
			type = parseFloat(type);
			fv = parseFloat(fv);
			var pmt1 = Math.round(pv * (rate * Math.pow(1 + rate, nper - type)) / (Math.pow(1 + rate, nper) - 1) * 100) / 100;
			var ir = 0;
			if(1 == type) {
				for(var i = 1; i <= nper; i++) {
					ir = ir + Math.pow(rate + 1, i);
				}
			} else {
				ir = 1;
				for(var i = 1; i < nper; i++) {
					ir = ir + Math.pow(rate + 1, i);
				}
			}
			var pmt2 = Math.round(fv / ir * 100) / 100;
			var result = -(pmt1 + pmt2);
			return Number(Ext.util.Format.number(result, "0.00"));
		},
		ppmt: function() {
			var len = arguments.length;
			if(4 > len || len > 6) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "PPMT"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var fv = 0,
				type = 0;
			if(5 == len) {
				fv = arguments[4];
			}
			if(6 == len) {
				fv = arguments[4];
				type = arguments[5];
			}
			var rate = calculates.numberof.call(this, arguments[0]);
			var per = calculates.numberof.call(this, arguments[1]);
			if(per < 1) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "PPMT"
				};
			}
			var nper = calculates.numberof.call(this, arguments[2]);
			var pv = calculates.numberof.call(this, arguments[3], true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			rate = parseFloat(rate);
			if(rate == 0) {
				rate = 0.000001;
			}
			nper = parseFloat(nper);
			per = parseFloat(per);
			pv = parseFloat(pv);
			type = parseFloat(type);
			fv = parseFloat(fv);
			pv = pv + fv;
			var ppmt = 0 - Math.round(pv * (rate * Math.pow(1 + rate, per - 1 - type)) / (Math.pow(1 + rate, nper) - 1) * 10000) / 10000;
			return Number(Ext.util.Format.number(ppmt, "0.00"));
		},
		ipmt: function() {
			var len = arguments.length;
			if(4 > len || len > 6) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "IPMT"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rate = arguments[0],
				per = arguments[1],
				nper = arguments[2],
				pv = arguments[3],
				fv = 0,
				type = 0;
			if(5 == len) {
				fv = arguments[4];
			}
			if(6 == len) {
				fv = arguments[4];
				type = arguments[5];
			}
			rate = calculates.numberof.call(this, rate);
			per = calculates.numberof.call(this, per);
			nper = calculates.numberof.call(this, nper);
			pv = calculates.numberof.call(this, pv, true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			rate = parseFloat(rate);
			nper = parseFloat(nper);
			per = parseFloat(per);
			pv = parseFloat(pv);
			type = parseFloat(type);
			fv = parseFloat(fv);
			pv = pv + fv;
			var ppmt = -Math.round(pv * (rate * Math.pow(1 + rate, per - 1 - type)) / (Math.pow(1 + rate, nper) - 1) * 100) / 100;
			var pmt1 = Math.round(pv * (rate * Math.pow(1 + rate, nper - type)) / (Math.pow(1 + rate, nper) - 1) * 100) / 100;
			var ir = 0;
			if(1 == type) {
				for(var i = 1; i <= nper; i++) {
					ir = ir + Math.pow(rate + 1, i);
				}
			} else {
				ir = 1;
				for(var i = 1; i < nper; i++) {
					ir = ir + Math.pow(rate + 1, i);
				}
			}
			var pmt2 = Math.round(fv / ir);
			var pmt = -(pmt1 + pmt2);
			var result = pmt - ppmt;
			return Number(Ext.util.Format.number(result, "0.00"));
		},
		rate: function() {
			var len = arguments.length;
			if(3 > len || len > 6) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "RATE"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var fv = 0,
				type = 0,
				guess = 0.1;
			if(4 == len) {
				fv = arguments[3];
			}
			if(5 == len) {
				fv = arguments[3];
				type = arguments[4];
			}
			if(6 == len) {
				fv = arguments[3];
				type = arguments[4];
				guess = arguments[5];
			}
			var nper = calculates.numberof.call(this, arguments[0], true);
			var pmt = calculates.numberof.call(this, arguments[1]);
			var pv = calculates.numberof.call(this, arguments[2], true);
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			guess = calculates.numberof.call(this, guess);
			nper = parseFloat(nper) ? parseFloat(nper) : 0;
			pmt = parseFloat(pmt) ? parseFloat(pmt) : 0;
			pv = parseFloat(pv) ? parseFloat(pv) : 0;
			type = parseFloat(type) ? parseFloat(type) : 0;
			fv = parseFloat(fv) ? parseFloat(fv) : 0;
			guess = parseFloat(guess) ? parseFloat(guess) : 0.1;
			var maxrate = 0;
			var minrate = Math.abs((pmt * nper + fv + pv) / pv / nper);
			if(pmt > 0 && pv > 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "PMT"
				};
			}
			if(pmt < 0 && pv < 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "PMT"
				};
			}
			if(Math.abs(minrate) > 1) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "PMT"
				};
			}
			if(Math.abs(pmt * nper + fv) < Math.abs(pv)) {
				maxrate = -Math.abs(minrate);
				minrate = -1;
			} else {
				maxrate = 1;
			}
			var minRate = 1e-7;
			var rate = maxrate;
			for(var irup = 1; irup < 50; irup++) {
				var ir = 0;
				for(var i = 1; i <= nper; i++) {
					ir = ir + pmt * Math.pow(rate + 1, i);
				}
				var trypv = -(ir / Math.pow(rate + 1, nper + 1 - type) + fv / Math.pow(rate + 1, nper));
				if(pmt > 0) {
					if(trypv < pv) {
						minrate = rate;
						rate = (rate + maxrate) / 2;
						if(1 - Math.abs(rate) < minRate) {
							throw {
								code: "NUM_IS_NOT_RIGHT",
								cal: "PMT"
							};
						}
					} else if(trypv > pv) {
						maxrate = rate;
						rate = (rate + minrate) / 2;
						if(1 - Math.abs(rate) < minRate) {
							throw {
								code: "NUM_IS_NOT_RIGHT",
								cal: "PMT"
							};
						}
					} else if(trypv = pv) {
						return Math.round(rate * 10000000) / 10000000;
					}
				} else {
					if(trypv > pv) {
						minrate = rate;
						rate = (rate + maxrate) / 2;
						if(1 - Math.abs(rate) < minRate) {
							throw {
								code: "NUM_IS_NOT_RIGHT",
								cal: "PMT"
							};
						}
					} else if(trypv < pv) {
						maxrate = rate;
						rate = (rate + minrate) / 2;
						if(1 - Math.abs(rate) < minRate) {
							throw {
								code: "NUM_IS_NOT_RIGHT",
								cal: "PMT"
							};
						}
					} else if(trypv = pv) {
						return Math.round(rate * 10000000) / 10000000;
					}
				}
				irup++;
			}
			var formatVal = Ext.util.Format.number(rate, "0.0000");
			return Number(formatVal);
		},
		mirr: function() {
			var len = arguments.length;
			if(len != 3) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "MIRR"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var values = arguments[0];
			var frate = arguments[1];
			var rrate = arguments[2];
			var nums = [],
				positive = [],
				negative = [];
			if(Ext.isObject(values)) {
				nums = calculates.rangeNumsOf.call(this, [values]);
			} else if(Ext.isString(values)) {
				if(values.charAt(0) == "{" && values.charAt(values.length - 1) == "}") {
					var str = values.slice(1, values.length - 1);
					nums = str.split(",");
				} else {
					throw {
						code: "VALUE_NOT_AVAILABLE",
						cal: "MIRR"
					};
				}
			} else {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "MIRR"
				};
			}
			frate = calculates.numberof.call(this, frate);
			rrate = calculates.numberof.call(this, rrate);
			var totalNegativeNum = 0,
				totalPositiveNum = 0;
			for(var ii = 0; ii < nums.length; ii++) {
				if(!Ext.isNumber(nums[ii])) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "MIRR"
					};
				}
				if(nums[ii] < 0) {
					positive[positive.length] = 0;
					negative[negative.length] = nums[ii];
					totalNegativeNum = totalNegativeNum + 1;
				} else {
					negative[negative.length] = 0;
					positive[positive.length] = nums[ii];
					totalPositiveNum = totalPositiveNum + 1;
				}
			}
			if(totalNegativeNum == 0 || totalPositiveNum == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "MIRR"
				};
			}
			frate = parseFloat(frate) ? parseFloat(frate) : 0;
			rrate = parseFloat(rrate) ? parseFloat(rrate) : 0;
			var fnpv = 0;
			for(var k = 0; k < negative.length; k++) {
				var val1 = negative[k];
				if(me.isCoordObj(val1)) {
					val1 = calculates.valof.call(this, negative[k]);
				}
				var num = Number(val1);
				if(Ext.isNumber(num)) {
					fnpv = fnpv + num / Math.pow(1 + frate, k + 1);
				}
			}
			var rnpv = 0;
			for(var k = 0; k < positive.length; k++) {
				var val1 = positive[k];
				if(me.isCoordObj(val1)) {
					val1 = calculates.valof.call(this, positive[k]);
				}
				var num = Number(val1);
				if(Ext.isNumber(num)) {
					rnpv = rnpv + num / Math.pow(1 + rrate, k + 1);
				}
			}
			var mirr = Math.pow(-rnpv * Math.pow(1 + rrate, nums.length) / (fnpv * (1 + frate)), 1 / (nums.length - 1)) - 1;
			return Number(Ext.util.Format.number(mirr, "0.0000"));
		},
		irr: function() {
			var len = arguments.length;
			if(len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "IRR"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var values = arguments[0],
				guess = 0.1,
				nums = [];
			var MAX_LOOP = 55;
			if(2 == len) {
				guess = calculates.numberof.call(this, arguments[1]);
			}
			if(Ext.isObject(values)) {
				nums = calculates.rangeNumsOf.call(this, [values]);
			} else if(Ext.isNumber(values)) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "IRR"
				};
			} else if(Ext.isString(values)) {
				if(values.charAt(0) == "{" && values.charAt(values.length - 1) == "}") {
					var str = values.slice(1, values.length - 1);
					nums = str.split(",");
				} else {
					throw {
						code: "VALUE_NOT_AVAILABLE",
						cal: "IRR"
					};
				}
			}
			if(HELPER.isBoolean(guess)) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "IRR"
				};
			}
			if(HELPER.isBoolean(values)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "IRR"
				};
			}
			var fsum = 0,
				zsum = 0;
			for(var ii = 0; ii < nums.length; ii++) {
				if(!Ext.isNumber(nums[ii])) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "IRR"
					};
				}
				nums[ii] = parseFloat(nums[ii]);
				if(nums[ii] < 0) {
					fsum = fsum + nums[ii];
				} else {
					zsum = zsum + nums[ii];
				}
			}
			guess = parseFloat(guess);
			var irr = guess,
				lawirr = 0,
				maxirr = 0,
				b = false,
				ir = 0,
				lastir = 0,
				testirr = 0;
			for(var i = 0; i < nums.length; i++) {
				if(nums[i] != 0) {
					ir = ir + nums[i] / Math.pow(irr + 1, i);
				}
			}
			if(ir == 0) {
				return Math.round(irr * 10000000) / 10000000;
			} else if(ir < 0) {
				lastir = ir;
				ir = 0;
				testirr = irr - guess;
				for(var i = 0; i < nums.length; i++) {
					if(nums[i] != 0) {
						ir = ir + nums[i] / Math.pow(testirr + 1, i);
					}
				}
				if(ir < lastir) {
					b = true;
				}
				var count = 0;
				do {
					ir = 0;
					if(b) {
						lawirr = irr;
						irr = irr + guess;
					} else {
						maxirr = irr;
						irr = irr - guess;
					}
					for(var i = 0; i < nums.length; i++) {
						if(nums[i] != 0) {
							ir = ir + nums[i] / Math.pow(irr + 1, i);
						}
					}
					if(count > MAX_LOOP) {
						throw {
							code: "NUM_IS_NOT_RIGHT",
							cal: "IRR"
						};
					}
					count++;
				} while (ir < 0);
				if(b) {
					maxirr = irr;
				} else {
					lawirr = irr;
				}
			} else if(ir > 0) {
				lastir = ir;
				ir = 0;
				testirr = irr + guess;
				for(var i = 0; i < nums.length; i++) {
					if(nums[i] != 0) {
						ir = ir + nums[i] / Math.pow(testirr + 1, i);
					}
				}
				if(ir > lastir) {
					b = true;
				}
				var count = 0;
				do {
					ir = 0;
					if(b) {
						maxirr = irr;
						irr = irr - guess;
					} else {
						lawirr = irr;
						irr = irr + guess;
					}
					for(var i = 0; i < nums.length; i++) {
						if(nums[i] != 0) {
							ir = ir + nums[i] / Math.pow(irr + 1, i);
						}
					}
					if(count > MAX_LOOP) {
						throw {
							code: "NUM_IS_NOT_RIGHT",
							cal: "IRR"
						};
					}
					count++;
				} while (ir > 0);
				if(b) {
					lawirr = irr;
				} else {
					maxirr = irr;
				}
			}
			irr = lawirr;
			for(var irup = 1; irup < 50; irup++) {
				var ir = 0;
				for(var i = 0; i < nums.length; i++) {
					ir = ir + nums[i] / Math.pow(irr + 1, i);
				}
				if(ir == 0) {
					return Math.round(irr * 10000000) / 10000000;
				}
				if(b) {
					if(ir < 0) {
						lawirr = irr;
						irr = (maxirr + irr) / 2;
					} else {
						maxirr = irr;
						irr = (irr + lawirr) / 2;
					}
				} else {
					if(ir < 0) {
						maxirr = irr;
						irr = (irr + lawirr) / 2;
					} else {
						lawirr = irr;
						irr = (maxirr + irr) / 2;
					}
				}
				irup++;
			}
			return Number(Ext.util.Format.number(irr, "0.0000"));
		},
		nper: function() {
			var len = arguments.length;
			if(3 > len || len > 5) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "NPER"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rate = arguments[0],
				pmt = arguments[1],
				pv = arguments[2],
				fv = 0,
				type = 0;
			if(4 == len) {
				fv = arguments[3];
				if(me.isCoordObj(fv)) {
					fv = calculates.numberof.call(this, fv);
				}
				if(fv === undefined || HELPER.isEmptyStr(fv)) {
					fv = 0;
				}
				fv = parseFloat(fv) ? parseFloat(fv) : 0;
			} else if(5 == len) {
				fv = arguments[3];
				if(me.isCoordObj(fv)) {
					fv = calculates.numberof.call(this, fv);
				}
				if(fv === undefined || HELPER.isEmptyStr(fv)) {
					fv = 0;
				}
				type = arguments[4];
				if(me.isCoordObj(type)) {
					type = calculates.numberof.call(this, type);
				}
				if(type === undefined || HELPER.isEmptyStr(type)) {
					type = 0;
				}
				fv = parseFloat(fv) ? parseFloat(fv) : 0;
				type = parseFloat(type) ? parseFloat(type) : 0;
			}
			if(me.isCoordObj(rate)) {
				rate = calculates.numberof.call(this, rate, true);
			}
			if(me.isCoordObj(pmt)) {
				pmt = calculates.numberof.call(this, pmt);
			}
			if(me.isCoordObj(pv)) {
				pv = calculates.numberof.call(this, pv, true);
			}
			rate = parseFloat(rate) ? parseFloat(rate) : 0.0001;
			pmt = parseFloat(pmt) ? parseFloat(pmt) : 0;
			if(HELPER.isBoolean(pv)) {
				pv = HELPER.convertBoolean2Int(pv);
			}
			pv = parseFloat(pv) ? parseFloat(pv) : 0;
			var minnper = (-fv - pv) / pmt;
			minnper = (-fv / Math.pow(1 + rate, minnper - type) - pv) / pmt;
			var maxnper = (-fv - pv * Math.pow(1 + rate, minnper - type)) / pmt;
			var nper = maxnper;
			for(var irup = 1; irup < 50; irup++) {
				var calpmt = (-fv / Math.pow(1 + rate, nper) - pv) * (rate * Math.pow(1 + rate, nper - type)) / (Math.pow(1 + rate, nper) - 1);
				if(calpmt == pmt) {
					return Math.round(calpmt * 10000000) / 10000000;
				} else {
					if(nper < 0) {
						if(Math.abs(calpmt) < Math.abs(pmt)) {
							minnper = nper;
							nper = (maxnper + nper) / 2;
						} else {
							maxnper = nper;
							nper = (nper + minnper) / 2;
						}
					} else {
						if(Math.abs(calpmt) < Math.abs(pmt)) {
							maxnper = nper;
							nper = (nper + minnper) / 2;
						} else {
							minnper = nper;
							nper = (maxnper + nper) / 2;
						}
					}
					if(maxnper == minnper) {
						throw {
							code: "NUM_IS_NOT_RIGHT",
							cal: "NPER"
						};
					}
				}
				irup++;
			}
			return Math.round(nper * 10000000) / 10000000;
		},
		pv: function() {
			var len = arguments.length;
			if(3 > len || len > 5) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "PV"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var fv = 0,
				type = 0;
			var rate = calculates.numberof.call(this, arguments[0], true);
			var nper = calculates.numberof.call(this, arguments[1], true);
			var payment = calculates.numberof.call(this, arguments[2], true);
			if(4 == len) {
				fv = arguments[3];
				if(fv === undefined || HELPER.isEmptyStr(fv)) {
					fv = 0;
				}
			} else if(5 == len) {
				fv = arguments[3];
				if(fv === undefined || HELPER.isEmptyStr(fv)) {
					fv = 0;
				}
				type = arguments[4];
				if(type === undefined || HELPER.isEmptyStr(type)) {
					type = 0;
				}
			}
			fv = calculates.numberof.call(this, fv);
			type = calculates.numberof.call(this, type);
			rate = parseFloat(rate);
			nper = parseFloat(nper);
			payment = parseFloat(payment);
			type = parseFloat(type);
			fv = parseFloat(fv);
			var ir = 0;
			if(nper < 1) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "PV"
				};
			}
			for(var i = 1; i <= nper; i++) {
				ir = ir + payment * Math.pow(rate + 1, i);
			}
			var pv = -(ir / Math.pow(rate + 1, nper + 1 - type) + fv / Math.pow(rate + 1, nper));
			if(isNaN(pv) || pv > 100000000000000000000) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "PV"
				};
			}
			return Number(Ext.util.Format.number(pv, "0.00"));
		},
		npv: function() {
			var len = arguments.length;
			if(2 > len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "NPV"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var npv = 0;
			var rate = arguments[0];
			if(me.isCoordObj(rate)) {
				rate = calculates.valof.call(this, rate);
			}
			if(HELPER.isBoolean(rate)) {
				rate = HELPER.convertBoolean2Int(rate);
			}
			var rate = Number(rate);
			if(!Ext.isNumber(rate)) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "NPV"
				};
			}
			var total = 1,
				coord = [];
			for(var k = 1; k < len; k++) {
				coord.push(arguments[k]);
			}
			var rangeObjs = calculates.rangeNumsOf.call(this, coord);
			for(var i = 0, len = rangeObjs.length; i < len; i++) {
				var data = rangeObjs[i];
				if(HELPER.isBoolean(data)) {
					data = HELPER.convertBoolean2Int(data);
				}
				npv = npv + data / Math.pow(1 + rate, total);
				total = total + 1;
			}
			return Number(Ext.util.Format.number(npv, "0.00"));
		},
		fv: function() {
			var len = arguments.length;
			if(3 > len || len > 5) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "FV"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rate = arguments[0],
				nper = arguments[1],
				payment = arguments[2],
				pv = 0,
				type = 0;
			if(4 == len) {
				pv = arguments[3];
				if(pv === undefined || HELPER.isEmptyStr(pv)) {
					pv = 0;
				}
			}
			if(5 == len) {
				pv = arguments[3];
				if(pv === undefined || HELPER.isEmptyStr(pv)) {
					pv = 0;
				}
				type = arguments[4];
				if(type === undefined || HELPER.isEmptyStr(type)) {
					type = 0;
				}
			}
			if(me.isCoordObj(nper)) {
				nper = calculates.numberof.call(this, nper, true);
			}
			if(me.isCoordObj(rate)) {
				rate = calculates.numberof.call(this, rate);
			}
			if(me.isCoordObj(pv)) {
				pv = calculates.numberof.call(this, pv, true);
			}
			if(me.isCoordObj(payment)) {
				payment = calculates.numberof.call(this, payment);
			}
			if(me.isCoordObj(type)) {
				type = calculates.numberof.call(this, type);
			}
			rate = parseFloat(rate);
			nper = parseFloat(nper);
			payment = parseFloat(payment);
			type = parseFloat(type);
			pv = parseFloat(pv);
			var ir = 0;
			for(var i = 1; i <= nper; i++) {
				ir = ir + payment * Math.pow(rate + 1, i - 1 + type);
			}
			var fv = -(ir + pv * Math.pow(rate + 1, nper));
			return Number(Ext.util.Format.number(fv, "0.00"));
		},
		syd: function() {
			var len = arguments.length;
			if(4 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "SYD"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var cost = arguments[0],
				salvage = arguments[1],
				life = arguments[2],
				per = arguments[3];
			if(me.isCoordObj(cost)) {
				cost = calculates.numberof.call(this, cost);
			}
			if(me.isCoordObj(salvage)) {
				salvage = calculates.numberof.call(this, salvage);
			}
			if(me.isCoordObj(life)) {
				life = calculates.numberof.call(this, life);
			}
			if(me.isCoordObj(per)) {
				per = calculates.numberof.call(this, per);
			}
			if(per > life || per <= 0 || life <= 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "SYD"
				};
			}
			var syd = (cost - salvage) * (life - per + 1) * 2 / (life * (life + 1));
			return Number(Ext.util.Format.number(syd, "0.00"));
		},
		sln: function() {
			var len = arguments.length;
			if(3 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "SLN"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var cost = arguments[0],
				salvage = arguments[1],
				life = arguments[2];
			if(me.isCoordObj(cost)) {
				cost = calculates.numberof.call(this, cost);
			}
			if(me.isCoordObj(salvage)) {
				salvage = calculates.numberof.call(this, salvage);
			}
			if(me.isCoordObj(life)) {
				life = calculates.numberof.call(this, life);
			}
			if(life == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "SLN"
				};
			}
			var sln = (cost - salvage) / life;
			return Number(Ext.util.Format.number(sln, "0.00"));
		},
		db: function() {
			var len = arguments.length;
			if(4 > len || 5 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "DB"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var cost, salvage, life, period, month;
			cost = arguments[0];
			salvage = arguments[1];
			life = arguments[2];
			period = arguments[3];
			if(4 == len) {
				month = 12;
			}
			if(5 == len) {
				month = arguments[4];
			}
			if(me.isCoordObj(cost)) {
				cost = calculates.numberof.call(this, cost);
			}
			if(me.isCoordObj(salvage)) {
				salvage = calculates.numberof.call(this, salvage);
			}
			if(me.isCoordObj(life)) {
				life = calculates.numberof.call(this, life);
			}
			if(me.isCoordObj(period)) {
				period = calculates.numberof.call(this, coperiodst);
			}
			if(me.isCoordObj(month)) {
				month = calculates.numberof.call(this, month);
			}
			var rate = Math.round((1 - Math.pow(salvage / cost, 1 / life)) * 1000) / 1000;
			var persum = 0,
				db = 0;
			for(var i = 1; i <= period; i++) {
				if(i == 1) {
					db = persum = cost * rate * month / 12;
				} else if(i == life) {
					db = (cost - persum) * rate * (12 - month) / 12;
				} else {
					db = (cost - persum) * rate;
					persum = persum + db;
				}
			}
			return Number(Ext.util.Format.number(db, "0.00"));
		},
		ddb: function() {
			var len = arguments.length;
			if(4 > len || 5 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "DDB"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var cost = calculates.numberof.call(this, arguments[0]);
			var salvage = calculates.numberof.call(this, arguments[1]);
			var life = calculates.numberof.call(this, arguments[2]);
			var period = calculates.numberof.call(this, arguments[3]);
			if(cost < 0 || salvage < 0 || life < 0 || period < 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "DDB"
				};
			}
			var factor = 2;
			if(5 == len) {
				factor = calculates.numberof.call(this, arguments[4]);
			}
			var persum = 0,
				db = 0;
			for(var i = 1; i <= period; i++) {
				db = Math.min((cost - persum) * factor / life, cost - salvage - persum);
				persum = persum + db;
			}
			return Number(Ext.util.Format.number(db, "0.00"));
		},
		vdb: function() {
			var len = arguments.length;
			if(5 > len || 7 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "VDB"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var cost = calculates.numberof.call(this, arguments[0]);
			var salvage = calculates.numberof.call(this, arguments[1]);
			var life = calculates.numberof.call(this, arguments[2]);
			var startDate = calculates.numberof.call(this, arguments[3]);
			var endDate = calculates.numberof.call(this, arguments[4]);
			var vdbResult = 0;
			if(cost < 0 || salvage < 0 || life < 0 || startDate < 0 || endDate < 0 || endDate < startDate) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "VDB"
				};
			}
			if(cost < salvage && startDate === 0 && endDate === 1) {
				return cost - salvage;
			}
			var factor = 2;
			if(5 < len) {
				factor = calculates.numberof.call(this, arguments[5]);
			}
			var no_switch = false;
			if(7 == len) {
				no_switch = arguments[6];
				if(me.isCoordObj(no_switch)) {
					no_switch = calculates.valof.call(this, no_switch);
				}
				if(HELPER.isBoolean(no_switch)) {
					no_switch = HELPER.getBoolean(no_switch);
				} else {
					throw {
						code: "CAL_NO_VALUE",
						cal: "VDB"
					};
				}
			}
			var startP = Math.floor(startDate),
				endP = Math.ceil(endDate);
			if(no_switch) {
				for(var i = startP + 1; i <= endP; i++) {
					var vdbTerm = HELPER.getGDA(cost, salvage, life, i, factor);
					if(i === startP + 1) {
						vdbTerm *= Math.min(endDate, startP + 1) - startDate;
					} else if(i === endP) {
						vdbTerm *= endDate + 1 - endP;
					}
					vdbResult += vdbTerm;
				}
			} else {
				var life1 = life;
				var fPart;
				if(startDate != Math.floor(startDate)) {
					if(factor > 1 && startDate >= life / 2) {
						fPart = startDate - life / 2;
						startDate = life / 2;
						endDate -= fPart;
						life1 += 1;
					}
				}
				cost -= HELPER.getVDB(cost, salvage, life, life1, startDate, factor);
				vdbResult = HELPER.getVDB(cost, salvage, life, life - startDate, endDate - startDate, factor);
			}
			return Number(Ext.util.Format.number(vdbResult, "0.00"));
		},
		effect: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "EFFECT"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rate = calculates.numberof.call(this, arguments[0], true);
			var nper = calculates.numberof.call(this, arguments[1]);
			if(rate <= 0 || nper < 1) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "EFFECT"
				};
			}
			return Math.pow(1 + rate / nper, nper) - 1;
		},
		dollarfr: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "dollarfr"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var decimal_dollar = arguments[0],
				fraction = arguments[1];
			if(me.isCoordObj(decimal_dollar)) {
				decimal_dollar = calculates.numberof.call(this, decimal_dollar);
			}
			if(me.isCoordObj(fraction)) {
				fraction = calculates.numberof.call(this, fraction);
			}
			fraction = Math.floor(fraction);
			if(fraction < 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "dollarfr"
				};
			} else if(fraction == 0) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "dollarfr"
				};
			}
			return HELPER.convert2DollarFraction(decimal_dollar, fraction);
		},
		dollarde: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "dollarde"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var fraction_dollar = arguments[0],
				fraction = arguments[1];
			if(me.isCoordObj(fraction_dollar)) {
				fraction_dollar = calculates.numberof.call(this, fraction_dollar);
			}
			if(me.isCoordObj(fraction)) {
				fraction = calculates.numberof.call(this, fraction);
			}
			fraction = Math.floor(fraction);
			if(fraction < 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "dollarde"
				};
			} else if(fraction < 1) {
				throw {
					code: "SS_ERROR_INFINITY",
					cal: "dollarde"
				};
			}
			return HELPER.convert2DollarInt(fraction_dollar, fraction);
		},
		couppcd: function() {
			return this.me.coupCommonFn(arguments, "couppcd", this);
		},
		coupncd: function() {
			return this.me.coupCommonFn(arguments, "coupncd", this);
		},
		coupnum: function() {
			return this.me.coupCommonFn(arguments, "coupnum", this);
		},
		coupdays: function() {
			return this.me.coupCommonFn(arguments, "coupdays", this);
		},
		coupdaysnc: function() {
			return this.me.coupCommonFn(arguments, "coupdaysnc", this);
		},
		columns: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "columns"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			if(me.isCoordObj(arguments[0])) {
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
				var arg = args[0];
				var span = arg.span;
				if(span) {
					return span[4] - span[2] + 1;
				}
			} else {
				if(HELPER.isBoolean(arguments[0])) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "columns"
					};
				}
				if(Ext.isNumber(Number(arguments[0]))) {
					return 1;
				}
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "columns"
			};
		},
		rows: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 == len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "ROWS"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			if(len > 1) {
				var result = 0;
				for(var k = 0; k < len; k++) {
					if(Ext.isArray(arguments[k])) {
						result = result + 1;
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "ROWS"
						};
					}
				}
				return result;
			}
			if(me.isCoordObj(arguments[0])) {
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
				var arg = args[0];
				var span = arg.span;
				if(span) {
					return span[3] - span[1] + 1;
				}
			} else {
				if(HELPER.isBoolean(arguments[0])) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "rows"
					};
				}
				if(Ext.isNumber(Number(arguments[0]))) {
					return 1;
				}
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "ROWS"
			};
		},
		areas: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 > len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "areas"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var count = 0;
			var counting = function(args) {
				for(var i = 0, size = args.length; i < size; i++) {
					var arg = args[i];
					if(me.isCoordObj(arg)) {
						count++;
					} else if(Ext.isArray(arg)) {
						counting(arg);
					}
				}
			};
			counting(arguments);
			return count;
		},
		lookup: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len < 2 && len > 3) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "lookup"
				};
			}
			var lookup_value = arguments[0];
			if(me.isCoordObj(lookup_value)) {
				lookup_value = calculates.valof.call(this, lookup_value);
			}
			if(Ext.isString(lookup_value)) {
				lookup_value = lookup_value.toLowerCase();
			}
			var rangeArray = arguments[1];
			if(Ext.isObject(rangeArray)) {
				rangeArray = calculates.rangeObjsOf.call(this, [rangeArray]);
			}
			if(rangeArray == null || rangeArray.length == 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "lookup"
				};
			}
			var resultArray = rangeArray;
			if(len == 3) {
				if(Ext.isObject(arguments[2])) {
					resultArray = calculates.rangeObjsOf.call(this, [arguments[2]]);
				} else {
					resultArray = arguments[2];
				}
				if(resultArray == null || resultArray.length == 0) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "lookup"
					};
				}
			}
			if(rangeArray.length != resultArray.length) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "lookup"
				};
			}
			for(var k = rangeArray.length; k > 0; k--) {
				var tempVal = rangeArray[k - 1];
				if(tempVal != null && tempVal != undefined) {
					if(HELPER.isNumber(tempVal)) {
						tempVal = Number(tempVal);
					} else {
						tempVal = tempVal.toLowerCase();
					}
				} else {
					continue;
				}
				if(HELPER.isNumber(lookup_value)) {
					if(tempVal <= lookup_value) {
						return resultArray[k - 1];
					}
				} else if(Ext.isString(lookup_value)) {
					if(tempVal.localeCompare(lookup_value) <= 0) {
						return resultArray[k - 1];
					}
				}
			}
			throw {
				code: "VALUE_NOT_AVAILABLE",
				cal: "lookup"
			};
		},
		choose: function() {
			var me = this.me,
				calculates = me.calculates;
			var len = arguments.length;
			if(2 > len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "choose"
				};
			}
			var indexPos = calculates.numberof.call(this, arguments[0]);
			if(0 < indexPos && indexPos < len) {
				indexPos = Math.floor(indexPos);
				var result = arguments[indexPos];
				if(me.isCoordObj(result)) {
					result = calculates.valof.call(this, result);
				}
				return result;
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: "choose"
				};
			}
		},
		column: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len == 0) {
				return icol;
			}
			if(1 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "COLUMN"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			if(me.isCoordObj(arguments[0])) {
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
				var arg = args[0];
				if(arg && arg.span) {
					var span = arg.span;
					return span[2];
				} else {
					throw {
						code: "CAL_NO_VALUE",
						cal: "column"
					};
				}
			} else {
				return arg;
			}
			throw {
				code: "VALUE_NOT_AVAILABLE",
				cal: "COLUMN"
			};
		},
		row: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len == 0) {
				return irow;
			}
			if(1 < len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "ROW"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			if(me.isCoordObj(arguments[0])) {
				var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
				if(this.isArrayFormula) {
					var arr = [];
					for(var i = 0, count = args.length; i < count; i++) {
						var it = args[i];
						var span = it.span;
						for(var j = span[1]; j <= span[3]; j++) {
							arr.push(j);
						}
					}
					return arr;
				}
				var arg = args[0];
				if(arg && arg.span) {
					var span = arg.span;
					return span[1];
				} else {
					throw {
						code: "CAL_NO_VALUE",
						cal: "row"
					};
				}
			} else {
				if(HELPER.isBoolean(arguments[0])) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "row"
					};
				}
				if(Ext.isNumber(Number(arguments[0]))) {
					return 1;
				}
			}
		},
		match: function() {
			var len = arguments.length;
			if(len < 2 && len > 3) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "match"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var lookup_value = arguments[0];
			if(me.isCoordObj(lookup_value)) {
				lookup_value = calculates.valof.call(this, lookup_value);
			}
			var match_type = 1;
			if(len === 3) {
				match_type = calculates.numberof.call(this, arguments[2]);
			}
			if(match_type != 0 && match_type != 1 && match_type != -1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "match"
				};
			}
			var lookarray = calculates.rangeObjsOf.call(this, [arguments[1]]);
			var result = 0;
			for(var i = 0; i < lookarray.length; i++) {
				if(match_type == "0") {
					if(HELPER.isNumber(lookup_value)) {
						if(lookarray[i].toString() == lookup_value) {
							result = i + 1;
							break;
						}
					} else if(1 == SCOM.kmpCompare(lookarray[i].toString(), lookup_value.toString())) {
						result = i + 1;
						break;
					}
				} else if(match_type == "1") {
					if(lookarray[i]) {
						if(lookarray[i].toString() <= lookup_value) {
							result = i + 1;
						} else {
							break;
						}
					}
				} else if(match_type == "-1") {
					if(lookarray[i]) {
						if(lookarray[i].toString() >= lookup_value) {
							result = i + 1;
						} else {
							break;
						}
					}
				}
			}
			if(result == 0) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "match"
				};
			}
			return result;
		},
		vlookup: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len < 3 || len > 4) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "vlookup"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var lookup_value = arguments[0];
			if(me.isCoordObj(lookup_value)) {
				lookup_value = calculates.valof.call(this, lookup_value);
			}
			if(Ext.isString(lookup_value)) {
				lookup_value = lookup_value.toLowerCase();
			}
			var posOffset = arguments[1],
				tableArray = null;
			if(Ext.isObject(posOffset)) {
				var tmpSpan = posOffset.span;
				if("" === tmpSpan[0]) {
					tmpSpan[0] = isheet;
				}
				tableArray = me.calCacheMap.getValueFromCache(tmpSpan);
				if(!tableArray) {
					tableArray = calculates.rangeVal2Dimension.call(this, [posOffset]);
					me.calCacheMap.addValueToCache(tmpSpan, tableArray);
				}
			}
			if(tableArray == null || tableArray.length == 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "vlookup"
				};
			}
			var colIndex = calculates.numberof.call(this, arguments[2]);
			if(colIndex < 1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "vlookup"
				};
			} else if(colIndex > tableArray[0].length) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeLookup = true;
			if(len === 4) {
				rangeLookup = arguments[3];
				if(me.isCoordObj(rangeLookup)) {
					rangeLookup = calculates.valof.call(this, rangeLookup);
				}
				if(HELPER.isNumber(rangeLookup)) {
					if(rangeLookup == 0) {
						rangeLookup = false;
					}
				} else if(HELPER.isBoolean(rangeLookup)) {
					rangeLookup = HELPER.getBoolean(rangeLookup);
				} else {
					throw {
						code: "CAL_NO_VALUE",
						cal: "vlookup"
					};
				}
			}
			var result = null;
			if(rangeLookup) {
				var matchXIndex = -1;
				var selectedValue = null;
				for(var k = 0; k < tableArray.length; k++) {
					var tempVal = tableArray[k][0];
					if(tempVal != null && tempVal != undefined) {
						if(HELPER.isNumber(tempVal)) {
							tempVal = Number(tempVal);
						} else {
							tempVal = tempVal.toLowerCase();
						}
					} else {
						continue;
					}
					if(tempVal === lookup_value) {
						var result = tableArray[k][colIndex - 1];
						if(typeof result == "undefined" || result == null) {
							result = 0;
						}
						return result;
					}
					if(HELPER.isNumber(lookup_value)) {
						if(tempVal < lookup_value) {
							if(selectedValue == null || selectedValue < tempVal) {
								selectedValue = tempVal;
								matchXIndex = k;
							}
						}
					} else if(Ext.isString(lookup_value) && Ext.isString(tempVal)) {
						if(tempVal.localeCompare(lookup_value) < 0) {
							if(selectedValue == null || selectedValue.localeCompare(tempVal) < 0) {
								selectedValue = tempVal;
								matchYIndex = k;
							}
						}
					}
				}
				if(matchXIndex > -1) {
					var result = tableArray[matchXIndex][colIndex - 1];
					if(typeof result == "undefined" || result == null) {
						result = 0;
					}
					return result;
				} else {
					throw {
						code: "VALUE_NOT_AVAILABLE",
						cal: "vlookup"
					};
				}
			} else {
				for(var k = 0; k < tableArray.length; k++) {
					var tempVal = tableArray[k][0];
					if(tempVal != null && tempVal != undefined) {
						if(HELPER.isNumber(tempVal)) {
							tempVal = Number(tempVal);
						} else {
							tempVal = tempVal.toLowerCase();
						}
					} else {
						continue;
					}
					if(tempVal === lookup_value) {
						var result = tableArray[k][colIndex - 1];
						if(typeof result == "undefined" || result == null) {
							result = 0;
						}
						return result;
					}
				}
			}
			if(result == null) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "vlookup"
				};
			}
		},
		hlookup: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(len < 3 || len > 4) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "hlookup"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var lookup_value = arguments[0];
			if(me.isCoordObj(lookup_value)) {
				lookup_value = calculates.valof.call(this, lookup_value);
			}
			if(Ext.isString(lookup_value)) {
				lookup_value = lookup_value.toLowerCase();
			}
			var posOffset = arguments[1],
				tableArray = null;
			if(Ext.isObject(posOffset)) {
				var tmpSpan = posOffset.span;
				if("" === tmpSpan[0]) {
					tmpSpan[0] = isheet;
				}
				tableArray = me.calCacheMap.getValueFromCache(tmpSpan);
				if(!tableArray) {
					tableArray = calculates.rangeVal2Dimension.call(this, [posOffset]);
					me.calCacheMap.addValueToCache(tmpSpan, tableArray);
				}
			}
			if(tableArray == null || tableArray.length == 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "hlookup"
				};
			}
			var rowIndex = calculates.numberof.call(this, arguments[2]);
			if(rowIndex < 1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "hlookup"
				};
			} else if(rowIndex > tableArray.length) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var rangeLookup = true;
			if(len === 4) {
				rangeLookup = arguments[3];
				if(me.isCoordObj(rangeLookup)) {
					rangeLookup = calculates.valof.call(this, rangeLookup);
				}
				if(HELPER.isNumber(rangeLookup)) {
					if(rangeLookup == 0) {
						rangeLookup = false;
					}
				} else if(HELPER.isBoolean(rangeLookup)) {
					rangeLookup = HELPER.getBoolean(rangeLookup);
				} else {
					throw {
						code: "CAL_NO_VALUE",
						cal: "hlookup"
					};
				}
			}
			var result = null;
			if(rangeLookup) {
				var matchYIndex = -1;
				var selectedValue = null;
				for(var k = 0; k < tableArray[0].length; k++) {
					var tempVal = tableArray[0][k];
					if(tempVal != null && tempVal != undefined) {
						if(HELPER.isNumber(tempVal)) {
							tempVal = Number(tempVal);
						} else {
							tempVal = tempVal.toLowerCase();
						}
					} else {
						continue;
					}
					if(tempVal === lookup_value) {
						var result = tableArray[rowIndex - 1][k];
						if(typeof result == "undefined" || result == null) {
							result = 0;
						}
						return result;
					}
					if(HELPER.isNumber(lookup_value)) {
						if(tempVal < lookup_value) {
							if(selectedValue == null || selectedValue < tempVal) {
								selectedValue = tempVal;
								matchYIndex = k;
							}
						}
					} else if(Ext.isString(lookup_value) && Ext.isString(tempVal)) {
						if(tempVal.localeCompare(lookup_value) < 0) {
							if(selectedValue == null || selectedValue.localeCompare(tempVal) < 0) {
								selectedValue = tempVal;
								matchYIndex = k;
							}
						}
					}
				}
				if(matchYIndex > -1) {
					var result = tableArray[rowIndex - 1][matchYIndex];
					if(typeof result == "undefined" || result == null) {
						result = 0;
					}
					return result;
				} else {
					throw {
						code: "VALUE_NOT_AVAILABLE",
						cal: "hlookup"
					};
				}
			} else {
				for(var k = 0; k < tableArray[0].length; k++) {
					var tempVal = tableArray[0][k];
					if(tempVal != null && tempVal != undefined) {
						if(HELPER.isNumber(tempVal)) {
							tempVal = Number(tempVal);
						} else {
							tempVal = tempVal.toLowerCase();
						}
					} else {
						continue;
					}
					if(tempVal === lookup_value) {
						var result = tableArray[rowIndex - 1][k];
						if(typeof result == "undefined" || result == null) {
							result = 0;
						}
						return result;
					}
				}
			}
			if(result == null) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "hlookup"
				};
			}
		},
		index: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(0 > len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "index"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var listAreas = [];
			var isMulArray = false;
			for(var i = 0; i < len; i++) {
				if(Ext.isArray(arguments[i])) {
					listAreas.push(arguments[i]);
					isMulArray = true;
				}
			}
			if(!isMulArray) {
				listAreas.push(arguments[0]);
			}
			var areaSize = listAreas.length;
			var rowIndex = 1,
				colIndex = 1;
			if(1 == len - areaSize) {
				rowIndex = calculates.numberof.call(this, arguments[len - 1]);
			} else if(2 == len - areaSize) {
				rowIndex = calculates.numberof.call(this, arguments[len - 2]);
				colIndex = calculates.numberof.call(this, arguments[len - 1]);
			}
			if(!Ext.isNumber(rowIndex) || 0 > rowIndex) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "index"
				};
			}
			if(0 == rowIndex) {
				rowIndex = 1;
			}
			if(!Ext.isNumber(colIndex) || 0 > colIndex) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "index"
				};
			}
			if(0 == colIndex) {
				colIndex = 1;
			}
			var twoDimensionArray = [];
			if(isMulArray) {
				twoDimensionArray = listAreas;
			} else {
				twoDimensionArray = calculates.rangeVal2Dimension.call(this, [arguments[0]]);
			}
			if(twoDimensionArray.length < rowIndex || twoDimensionArray[0].length < colIndex) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "index"
				};
			}
			return twoDimensionArray[rowIndex - 1][colIndex - 1];
		},
		indirect: function() {
			var me = this.me,
				calculates = me.calculates,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "indirect"
				};
			}
			var coordStr = arguments[0];
			if(Ext.isObject(coordStr)) {
				throw {
					code: "CAL_INCORRECT_COORD",
					cal: "indirect"
				};
			}
			var coord = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.string2Coord(coordStr, isheet, SCONST.ABSOLUTE_COORD);
			var store = this.store,
				coordArr = me.toCoordArr(coord);
			store.setCell(isheet, irow, icol, {
				refs: coordArr
			}, undefined, true);
			return coord;
		},
		offset: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(3 > len || len > 5) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "offset"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var args = me.transferAll2Absolute(arguments, isheet, irow, icol);
			try {
				var rowOffset = args[1],
					colOffset = args[2],
					rowSpan = args[3],
					colSpan = args[4];
				if(me.isCoordObj(rowOffset)) {
					var span = rowOffset.span;
					rowOffset = me.getCellData(span[0], span[1], span[2], this);
				}
				rowOffset = Number(rowOffset);
				if(!Ext.isNumber(rowOffset)) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "offset"
					};
				}
				if(me.isCoordObj(colOffset)) {
					var span = colOffset.span;
					colOffset = me.getCellData(span[0], span[1], span[2], this);
				}
				colOffset = Number(colOffset);
				if(!Ext.isNumber(colOffset)) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "offset"
					};
				}
				if(me.isCoordObj(rowSpan)) {
					var span = rowSpan.span;
					rowSpan = me.getCellData(span[0], span[1], span[2], this);
				}
				if(me.isCoordObj(colSpan)) {
					var span = colSpan.span;
					colSpan = me.getCellData(span[0], span[1], span[2], this);
				}
				var originSpan = args[0].span;
				originSpan[1] += rowOffset;
				originSpan[3] += rowOffset;
				originSpan[2] += colOffset;
				originSpan[4] += colOffset;
				if(Ext.isDefined(rowSpan)) {
					rowSpan = Number(rowSpan);
					if(Ext.isNumber(rowSpan)) {
						originSpan[3] = originSpan[1] + rowSpan - 1;
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "offset"
						};
					}
				}
				if(Ext.isDefined(colSpan)) {
					colSpan = Number(colSpan);
					if(Ext.isNumber(colSpan)) {
						originSpan[4] = originSpan[2] + colSpan - 1;
					} else {
						throw {
							code: "CAL_NO_VALUE",
							cal: "offset"
						};
					}
				}
				return args[0];
			} catch(e) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "offset"
				};
			}
		},
		hyperlink: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 !== len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "hyperlink"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var linkLocation = arguments[0];
			if(me.isCoordObj(linkLocation)) {
				linkLocation = calculates.valof.call(this, linkLocation);
			}
			var friendlyName = linkLocation;
			if(len == 2) {
				friendlyName = arguments[1];
				if(me.isCoordObj(friendlyName)) {
					friendlyName = calculates.valof.call(this, friendlyName);
				}
			}
			if(EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.isCoordSpan(linkLocation)) {
				if("#" === linkLocation.charAt(0)) {
					linkLocation = linkLocation.slice(1);
				}
			} else if(!SCONST.urlProReg.test(linkLocation)) {
				linkLocation = "http://" + linkLocation;
			}
			var cell = store.getCell(isheet, irow, icol);
			var md = {
				clink: linkLocation,
				cfm: "link"
			};
			store.setCell(isheet, irow, icol, md, null, true);
			return friendlyName;
		},
		daverage: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(3 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "daverage"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var dbRange = arguments[0];
			if(Ext.isObject(dbRange)) {
				var dbRow = dbRange.span[1],
					dbCol = dbRange.span[2],
					dbERow = dbRange.span[3],
					dbECol = dbRange.span[4];
				dbRange = calculates.rangeVal2Dimension.call(this, [dbRange]);
			}
			if(dbRange == null || dbRange.length <= 1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "daverage"
				};
			}
			var field = arguments[1];
			if(me.isCoordObj(field)) {
				var fieldRow = field.span[1],
					fieldCol = field.span[2];
				if(fieldRow >= dbRow && fieldRow <= dbERow && fieldCol >= dbCol && fieldCol <= dbECol) {
					field = fieldCol - dbCol;
				} else {
					throw {
						code: "CAL_NO_VALUE",
						cal: "daverage"
					};
				}
			} else {
				var fieldType = typeof field;
				if(fieldType == "number") {
					if(dbECol - dbCol + 1 < field || field < 1) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "daverage"
						};
					}
					field -= 1;
				} else {
					field = dbRange[0].indexOf(field);
					if(field == -1) {
						throw {
							code: "CAL_NO_VALUE",
							cal: "daverage"
						};
					}
				}
			}
			var criteraRange = arguments[2];
			if(Ext.isObject(criteraRange)) {
				criteraRange = calculates.rangeVal2Dimension.call(this, [criteraRange]);
			}
			if(criteraRange == null || criteraRange.length <= 1) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "daverage"
				};
			}
			var rowss = [];
			var ms = [">=", "<=", "<>", ">", "=", "<"];
			for(var i = 1; i < criteraRange.length; i++) {
				var rows = [],
					n = 0;
				for(var j in criteraRange[0]) {
					var label = criteraRange[0][j];
					var db0Index = dbRange[0].indexOf(label);
					if(db0Index > -1) {
						critera = criteraRange[i][j];
						if(!critera) {
							continue;
						}
						n += 1;
						var sFlag = isNaN(critera);
						if(sFlag) {
							var msIndex = -1,
								cIndex = -1;
							for(var m in ms) {
								cIndex = critera.indexOf(ms[m]);
								if(cIndex == 0) {
									msIndex = Number(m);
									break;
								}
							}
							if(cIndex == 0) {
								critera = critera.substring(msIndex > 2 ? 1 : 2);
							}
						}
						for(var k = 1; k < dbRange.length; k++) {
							if(n > 1) {
								if(rows.indexOf(k) == -1) {
									continue;
								}
							}
							var val = dbRange[k][db0Index];
							if(sFlag) {
								if(cIndex == 0) {
									if(isNaN(critera)) {
										var ri = rows.indexOf(k);
										if(ri > -1) {
											rows.splice(ri, 1);
										}
										continue;
									} else {
										if(isNaN(val)) {
											var ri = rows.indexOf(k);
											if(ri > -1) {
												rows.splice(ri, 1);
											}
											continue;
										} else {
											var t;
											switch(msIndex) {
												case 0:
													t = val >= critera;
													break;
												case 1:
													t = val <= critera;
													break;
												case 2:
													t = val != critera;
													break;
												case 3:
													t = val > critera;
													break;
												case 4:
													t = val == critera;
													break;
												case 5:
													t = val < critera;
													break;
												default:
													t = false;
											}
											if(t) {
												if(rows.indexOf(k) == -1) {
													rows.push(k);
												}
											} else {
												var ri = rows.indexOf(k);
												if(ri > -1) {
													rows.splice(ri, 1);
												}
												continue;
											}
										}
									}
								} else {
									if(val == critera) {
										if(rows.indexOf(k) == -1) {
											rows.push(k);
										}
									} else {
										var ri = rows.indexOf(k);
										if(ri > -1) {
											rows.splice(ri, 1);
										}
									}
								}
							} else {
								if(val == critera) {
									if(rows.indexOf(k) == -1) {
										rows.push(k);
									}
								} else {
									var ri = rows.indexOf(k);
									if(ri > -1) {
										rows.splice(ri, 1);
									}
								}
							}
						}
					}
				}
				rowss.push(rows);
			}
			var lastRows = [];
			for(var i in rowss) {
				for(var j in rowss[i]) {
					var k = rowss[i][j];
					if(lastRows.indexOf(k) == -1) {
						lastRows.push(k);
					}
				}
			}
			var sum = 0,
				num = lastRows.length;
			if(num == 0) {
				return "#DIV/0!";
			}
			for(var i = 1; i < dbRange.length; i++) {
				if(lastRows.indexOf(i) > -1) {
					sum += Number(dbRange[i][field]);
				}
			}
			return sum / num;
		},
		delta: function() {
			var len = arguments.length;
			if(0 == len || len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "delta"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number1 = calculates.numberof.call(this, arguments[0]);
			if(isNaN(number1) || number1 === undefined || number1 === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "delta"
				};
			}
			var number2 = 0;
			if(len == 2) {
				number2 = arguments[1];
				if(me.isCoordObj(number2)) {
					number2 = calculates.numberof.call(this, number2);
				}
				if(isNaN(number2) || number2 === undefined || number2 === "") {
					throw {
						code: "CAL_NO_VALUE",
						cal: "delta"
					};
				}
			}
			var result = 0;
			if(number1 == number2) {
				result = 1;
			}
			return result;
		},
		erf: function() {
			var len = arguments.length;
			if(0 == len || len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "ERF"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var lower_limit = calculates.numberof.call(this, arguments[0]);
			if(lower_limit === undefined || lower_limit === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "ERF"
				};
			}
			var result1 = HELPER.calculateErf(lower_limit);
			var upper_limit = 0;
			if(len == 2) {
				upper_limit = calculates.numberof.call(this, arguments[1]);
				if(upper_limit === undefined || upper_limit === "") {
					throw {
						code: "CAL_NO_VALUE",
						cal: "ERF"
					};
				}
				var result2 = HELPER.calculateErf(upper_limit);
				return result2 - result1;
			} else {
				return result1;
			}
		},
		erfc: function() {
			var len = arguments.length;
			if(0 == len || len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "ERFC"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var lower_limit = calculates.numberof.call(this, arguments[0]);
			if(lower_limit === undefined || lower_limit === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "ERFC"
				};
			}
			var result1 = HELPER.calculateErf(lower_limit);
			var upper_limit = 0;
			if(len == 2) {
				upper_limit = calculates.numberof.call(this, arguments[1]);
				if(upper_limit === undefined || upper_limit === "") {
					throw {
						code: "CAL_NO_VALUE",
						cal: "ERFC"
					};
				}
				var result2 = HELPER.calculateErf(upper_limit);
				return 1 - result2 + result1;
			} else {
				return 1 - result1;
			}
		},
		gestep: function() {
			var len = arguments.length;
			if(0 == len || len > 2) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "gestep"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = calculates.numberof.call(this, arguments[0]);
			var step = 0;
			if(len === 2) {
				step = calculates.numberof.call(this, arguments[1]);
			}
			return number >= step ? 1 : 0;
		},
		bitand: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bitand"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number1 = calculates.numberof.call(this, arguments[0]);
			if(number1 === undefined || number1 === "" || number1 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitand"
				};
			}
			var number2 = calculates.numberof.call(this, arguments[1]);
			if(number2 === undefined || number2 === "" || number2 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitand"
				};
			}
			if(HELPER.isInt(number1) && HELPER.isInt(number2)) {
				return number1 & number2;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitand"
				};
			}
		},
		bitor: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bitor"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number1 = calculates.numberof.call(this, arguments[0]);
			if(number1 === undefined || number1 === "" || number1 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitor"
				};
			}
			var number2 = calculates.numberof.call(this, arguments[1]);
			if(number2 === undefined || number2 === "" || number2 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitor"
				};
			}
			if(HELPER.isInt(number1) && HELPER.isInt(number2)) {
				return number1 | number2;
			}
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: "bitand"
			};
		},
		bitxor: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bitxor"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number1 = calculates.numberof.call(this, arguments[0]);
			if(number1 === undefined || number1 === "" || number1 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitxor"
				};
			}
			var number2 = calculates.numberof.call(this, arguments[1]);
			if(number2 === undefined || number2 === "" || number2 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitxor"
				};
			}
			if(HELPER.isInt(number1) && HELPER.isInt(number2)) {
				if(number1 > 281474976710655 || number2 > 281474976710655) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "bitxor"
					};
				}
				return number1 ^ number2;
			}
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: "bitxor"
			};
		},
		bitrshift: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bitrshift"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number1 = calculates.numberof.call(this, arguments[0]);
			if(number1 === undefined || number1 === "" || number1 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitrshift"
				};
			}
			var number2 = calculates.numberof.call(this, arguments[1]);
			if(number2 === undefined || number2 === "" || number2 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitrshift"
				};
			}
			if(HELPER.isInt(number1) && HELPER.isInt(number2)) {
				return number1 >> number2;
			}
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: "bitrshift"
			};
		},
		bitlshift: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bitlshift"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number1 = calculates.numberof.call(this, arguments[0]);
			if(number1 === undefined || number1 === "" || number1 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitlshift"
				};
			}
			var number2 = calculates.numberof.call(this, arguments[1]);
			if(number2 === undefined || number2 === "" || number2 < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bitlshift"
				};
			}
			if(HELPER.isInt(number1) && HELPER.isInt(number2)) {
				return number1 << number2;
			}
			throw {
				code: "CAL_PARAM_NEED_BE_NUM",
				cal: "bitlshift"
			};
		},
		bin2dec: function() {
			var len = arguments.length;
			if(len != 1) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bin2dec"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = calculates.numberof.call(this, arguments[0]);
			if(number === undefined || number === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "bin2dec"
				};
			}
			if(!/^[01]{1,10}$/.test(number)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bin2dec"
				};
			}
			var result = parseInt(number, 2);
			var stringified = number.toString();
			if(stringified.length === 10 && stringified.substring(0, 1) === "1") {
				return parseInt(stringified.substring(1), 2) - 512;
			} else {
				return result;
			}
		},
		bin2hex: function() {
			var len = arguments.length;
			if(2 != len && 1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bin2hex"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = calculates.numberof.call(this, arguments[0]);
			if(number === undefined || number === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "bin2hex"
				};
			}
			if(!/^[01]{1,10}$/.test(number)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "bin2hex"
				};
			}
			var stringified = number.toString();
			if(stringified.length === 10 && stringified.substring(0, 1) === "1") {
				return(1099511627264 + parseInt(stringified.substring(1), 2)).toString(16).toUpperCase();
			}
			var result = parseInt(number, 2).toString(16);
			var places = result.length;
			if(len === 2) {
				places = calculates.numberof.call(this, arguments[1]);
			}
			if(typeof places === "undefined") {
				return result.toUpperCase();
			} else {
				if(isNaN(places)) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "bin2hex"
					};
				}
				if(places < 0) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "bin2hex"
					};
				}
				places = Math.floor(places);
				if(places >= result.length) {
					result = HELPER.repeat("0", places - result.length) + result;
					return result.toUpperCase();
				} else {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "bin2hex"
					};
				}
			}
		},
		bin2oct: function() {
			var len = arguments.length;
			if(2 != len && 1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bin2oct"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = calculates.numberof.call(this, arguments[0]);
			if(number === undefined || number === "") {
				throw {
					code: "CAL_NO_VALUE",
					cal: "bin2oct"
				};
			}
			if(!/^[01]{1,10}$/.test(number)) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "bin2oct"
				};
			}
			var stringified = number.toString();
			if(stringified.length === 10 && stringified.substring(0, 1) === "1") {
				return(1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
			}
			var result = parseInt(number, 2).toString(8);
			var places = result.length;
			if(len === 2) {
				places = calculates.numberof.call(this, arguments[1]);
			}
			if(typeof places === "undefined") {
				return result;
			} else {
				if(isNaN(places)) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "bin2oct"
					};
				}
				if(places < 0) {
					throw {
						code: "NUM_IS_NOT_RIGHT",
						cal: "bin2oct"
					};
				}
				places = Math.floor(places);
				if(places >= result.length) {
					return HELPER.repeat("0", places - result.length) + result;
				}
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "bin2oct"
				};
			}
		},
		hex2dec: function() {
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "hex2dec"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			if(!/^[0-9A-Fa-f]{1,10}$/.test(val)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2dec"
				};
			}
			var decimal = parseInt(val, 16);
			return decimal >= 549755813887 ? decimal - 1099511627776 : decimal;
		},
		hex2bin: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "hex2bin"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			if(!/^[0-9A-Fa-f]{1,10}$/.test(val)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2bin"
				};
			}
			var negative = val.length === 10 && val.substring(0, 1).toLowerCase() === "f" ? true : false;
			var decimal = negative ? parseInt(val, 16) - 1099511627776 : parseInt(val, 16);
			if(decimal < -512 || decimal > 511) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2bin"
				};
			}
			if(negative) {
				return "1" + HELPER.repeat("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
			}
			var result = decimal.toString(2);
			if(1 == len) {
				return result;
			}
			var places = calculates.numberof.call(this, arguments[1]);
			if(places < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2bin"
				};
			}
			places = Math.floor(places);
			if(places >= result.length) {
				return HELPER.repeat("0", places - result.length) + result;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2bin"
				};
			}
		},
		hex2oct: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "hex2oct"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.valof.call(this, val);
			}
			if(!/^[0-9A-Fa-f]{1,10}$/.test(val)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2oct"
				};
			}
			var decimal = parseInt(val, 16);
			if(decimal > 536870911 && decimal < 1098974756864) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2oct"
				};
			}
			if(decimal >= 1098974756864) {
				return(decimal - 1098437885952).toString(8);
			}
			var result = decimal.toString(8);
			if(1 == len) {
				return result;
			}
			var places = calculates.numberof.call(this, arguments[1]);
			if(places < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2oct"
				};
			}
			places = Math.floor(places);
			if(places >= result.length) {
				return HELPER.repeat("0", places - result.length) + result;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "hex2oct"
				};
			}
		},
		dec2bin: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "dec2bin"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = arguments[0];
			if(me.isCoordObj(number)) {
				number = calculates.numberof.call(this, number);
			}
			if(!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2bin"
				};
			}
			if(number < 0) {
				return "1" + HELPER.repeat("0", 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
			}
			var result = parseInt(number, 10).toString(2);
			if(1 == len) {
				return result;
			}
			var places = calculates.numberof.call(this, arguments[1]);
			if(places < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2bin"
				};
			}
			places = Math.floor(places);
			if(places >= result.length) {
				return HELPER.repeat("0", places - result.length) + result;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2bin"
				};
			}
		},
		dec2oct: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "dec2oct"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = arguments[0];
			if(me.isCoordObj(number)) {
				number = calculates.numberof.call(this, number);
			}
			if(!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2oct"
				};
			}
			if(number < 0) {
				return(1073741824 + number).toString(8);
			}
			var result = parseInt(number, 10).toString(8);
			if(1 == len) {
				return result;
			}
			var places = calculates.numberof.call(this, arguments[1]);
			if(places < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2oct"
				};
			}
			places = Math.floor(places);
			if(places >= result.length) {
				return HELPER.repeat("0", places - result.length) + result;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2oct"
				};
			}
		},
		dec2hex: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "dec2hex"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = arguments[0];
			if(me.isCoordObj(number)) {
				number = calculates.numberof.call(this, number);
			}
			if(!/^-?[0-9]{1,15}$/.test(number) || number < -549755813887 || number > 549755813887) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2hex"
				};
			}
			if(number < 0) {
				number = (1099511627775 + number + 1).toString(16);
				return number.toString(16).toUpperCase();
			}
			var result = number.toString(16).toUpperCase();
			if(1 == len) {
				return result;
			}
			var places = calculates.numberof.call(this, arguments[1]);
			if(places < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2hex"
				};
			}
			places = Math.floor(places);
			if(places >= result.length) {
				return HELPER.repeat("0", places - result.length) + result;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "dec2hex"
				};
			}
		},
		oct2bin: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "oct2bin"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = arguments[0];
			if(me.isCoordObj(number)) {
				number = calculates.numberof.call(this, number);
			}
			if(!/^[0-7]{1,10}$/.test(number)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2bin"
				};
			}
			var negative = number.length === 10 && number.substring(0, 1) === "7" ? true : false;
			var decimal = negative ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);
			if(decimal < -512 || decimal > 511) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2bin"
				};
			}
			if(negative) {
				return "1" + HELPER.repeat("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
			}
			var result = decimal.toString(2);
			if(1 == len) {
				return result;
			}
			var places = calculates.numberof.call(this, arguments[1]);
			if(places < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2bin"
				};
			}
			places = Math.floor(places);
			if(places >= result.length) {
				return HELPER.repeat("0", places - result.length) + result;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2bin"
				};
			}
		},
		oct2dec: function() {
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "oct2dec"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = arguments[0];
			if(me.isCoordObj(number)) {
				number = calculates.numberof.call(this, number);
			}
			if(!/^[0-7]{1,10}$/.test(number)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2dec"
				};
			}
			var decimal = parseInt(number, 8);
			return decimal >= 536870912 ? decimal - 1073741824 : decimal;
		},
		oct2hex: function() {
			var len = arguments.length;
			if(1 != len && 2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "oct2hex"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var number = arguments[0];
			if(me.isCoordObj(number)) {
				number = calculates.numberof.call(this, number);
			}
			if(!/^[0-7]{1,10}$/.test(number)) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2hex"
				};
			}
			var decimal = parseInt(number, 8);
			if(decimal >= 536870912) {
				return "FF" + (decimal + 3221225472).toString(16).toUpperCase();
			}
			var result = decimal.toString(16).toUpperCase();
			if(1 == len) {
				return result;
			}
			var places = calculates.numberof.call(this, arguments[1]);
			if(places < 0) {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2hex"
				};
			}
			places = Math.floor(places);
			if(places >= result.length) {
				return HELPER.repeat("0", places - result.length) + result;
			} else {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "oct2hex"
				};
			}
		},
		convert: function() {
			var len = arguments.length;
			if(3 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "convert"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var origNumber = calculates.numberof.call(this, arguments[0], true);
			var fromUnit = arguments[1],
				toUnit = arguments[2];
			if(me.isCoordObj(fromUnit)) {
				fromUnit = calculates.valof.call(this, fromUnit);
			}
			if(me.isCoordObj(toUnit)) {
				toUnit = calculates.valof.call(this, toUnit);
			}
			if(fromUnit === null || toUnit === null) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "convert"
				};
			}
			var fromUnitSet = null,
				toUnitSet = null;
			var fromToUnitData = HELPER.fromToUnitData;
			for(var i = 0; i < fromToUnitData.length; i++) {
				var keyValue = fromToUnitData[i][0];
				if(keyValue == fromUnit) {
					fromUnitSet = fromToUnitData[i];
				}
				if(keyValue == toUnit) {
					toUnitSet = fromToUnitData[i];
				}
			}
			if(fromUnitSet === null || toUnitSet === null) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "convert"
				};
			}
			if(fromUnitSet[1] != toUnitSet[1]) {
				throw {
					code: "VALUE_NOT_AVAILABLE",
					cal: "convert"
				};
			}
			var result = origNumber * fromUnitSet[2] / toUnitSet[2];
			if(fromUnitSet[1] == "temperature") {
				if(fromUnitSet[0] == "C" || fromUnitSet[0] == "cel") {
					if(toUnit[0] == "F" || toUnit[0] == "fah") {
						result = origNumber * 9 / 5 + 32;
					} else {
						result = origNumber + 273.15;
					}
				} else if(fromUnitSet[0] == "F" || fromUnitSet[0] == "fah") {
					result = (origNumber - 32) * 5 / 9;
					if(toUnit[0] == "K" || toUnit[0] == "kel") {
						result = 273.15;
					}
				} else {
					result = origNumber - 273.15;
					if(toUnit[0] == "F" || toUnit[0] == "fah") {
						result = result * 9 / 5 + 32;
					}
				}
			}
			var digitalLen = HELPER.getDigitalLen(result);
			if(digitalLen > 14) {
				result = HELPER.roundUpNonZero(result);
			}
			return result;
		},
		imdiv: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "imdiv"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var inumber1 = arguments[0];
			if(me.isCoordObj(inumber1)) {
				inumber1 = calculates.valof.call(this, inumber1);
			}
			var inumber2 = arguments[1];
			if(me.isCoordObj(inumber2)) {
				inumber2 = calculates.valof.call(this, inumber2);
			}
			return HELPER.IMDIV(inumber1.toString(), inumber2.toString());
		},
		imsum: function() {
			return this.me.imMathCommonFunction2(arguments, "IMSUM", this);
		},
		improduct: function() {
			return this.me.imMathCommonFunction2(arguments, "IMPRODUCT", this);
		},
		imsub: function() {
			return this.me.imMathCommonFunction2(arguments, "IMSUB", this);
		},
		imabs: function() {
			return this.me.imMathCommonFunction(arguments, "IMABS", this);
		},
		imlog2: function() {
			return this.me.imMathCommonFunction(arguments, "IMLOG2", this);
		},
		imln: function() {
			return this.me.imMathCommonFunction(arguments, "IMLN", this);
		},
		imexp: function() {
			return this.me.imMathCommonFunction(arguments, "IMEXP", this);
		},
		imlog10: function() {
			return this.me.imMathCommonFunction(arguments, "IMLOG10", this);
		},
		imsin: function() {
			return this.me.imMathCommonFunction(arguments, "IMSIN", this);
		},
		imcos: function() {
			return this.me.imMathCommonFunction(arguments, "IMCOS", this);
		},
		imcsc: function() {
			return this.me.imMathCommonFunction(arguments, "IMCSC", this);
		},
		imcot: function() {
			return this.me.imMathCommonFunction(arguments, "IMCOT", this);
		},
		imcosh: function() {
			return this.me.imMathCommonFunction(arguments, "IMCOSH", this);
		},
		imcsch: function() {
			return this.me.imMathCommonFunction(arguments, "IMCSCH", this);
		},
		imsinh: function() {
			return this.me.imMathCommonFunction(arguments, "IMSINH", this);
		},
		imsec: function() {
			return this.me.imMathCommonFunction(arguments, "IMSEC", this);
		},
		imsech: function() {
			return this.me.imMathCommonFunction(arguments, "IMSECH", this);
		},
		imargument: function() {
			return this.me.imMathCommonFunction(arguments, "IMARGUMENT", this);
		},
		imaginary: function() {
			return this.me.imMathCommonFunction(arguments, "IMAGINARY", this);
		},
		imconjugate: function() {
			return this.me.imMathCommonFunction(arguments, "IMCONJUGATE", this);
		},
		imreal: function() {
			return this.me.imMathCommonFunction(arguments, "IMREAL", this);
		},
		imsqrt: function() {
			return this.me.imMathCommonFunction(arguments, "IMSQRT", this);
		},
		imtan: function() {
			return this.me.imMathCommonFunction(arguments, "IMTAN", this);
		},
		impower: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "impower"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var inumber = arguments[0];
			if(me.isCoordObj(inumber)) {
				inumber = calculates.valof.call(this, inumber);
			}
			inumber = inumber.toString();
			var expo = calculates.numberof.call(this, arguments[1]);
			var x = HELPER.IMREAL(inumber);
			var y = HELPER.IMAGINARY(inumber);
			var unit = inumber.substring(inumber.length - 1);
			unit = unit === "i" || unit === "j" ? unit : "i";
			if(x === "#NUM!" || y === "#NUM!") {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "impower"
				};
			}
			var abs = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
			var p = Math.pow(abs, expo);
			var t = HELPER.IMARGUMENT(inumber);
			return HELPER.COMPLEX(p * Math.cos(expo * t), p * Math.sin(expo * t), unit);
		},
		imsub: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "imsub"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var inumber = arguments[0];
			if(me.isCoordObj(inumber)) {
				inumber = calculates.valof.call(this, inumber);
			}
			inumber = inumber.toString();
			var inumber2 = arguments[1];
			if(me.isCoordObj(inumber2)) {
				inumber2 = calculates.valof.call(this, inumber2);
			}
			inumber2 = inumber2.toString();
			var a = HELPER.IMREAL(inumber);
			var b = HELPER.IMAGINARY(inumber);
			var c = HELPER.IMREAL(inumber2);
			var d = HELPER.IMAGINARY(inumber2);
			var unit1 = inumber.substring(inumber.length - 1);
			var unit2 = inumber2.substring(inumber2.length - 1);
			var unit = "i";
			if(unit1 === "j") {
				unit = "j";
			} else if(unit2 === "j") {
				unit = "j";
			}
			if(a === "#NUM!" || b === "#NUM!" || c === "#NUM!" || d === "#NUM!") {
				throw {
					code: "CAL_PARAM_NEED_BE_NUM",
					cal: "imsub"
				};
			}
			return HELPER.COMPLEX(a - c, b - d, unit);
		},
		besseli: function() {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "besseli"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);
			if(n < 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "besseli"
				};
			}
			return FORMULA_HELPER.besseli(x, n);
		},
		besselj: function(args) {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "besselj"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);
			if(n < 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "besselj"
				};
			}
			return FORMULA_HELPER.besselj(x, n);
		},
		besselk: function(args) {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "besselk"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);
			if(n < 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "besselk"
				};
			}
			return FORMULA_HELPER.besselk(x, n);
		},
		bessely: function(args) {
			var len = arguments.length;
			if(2 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "bessely"
				};
			}
			var me = this.me,
				calculates = me.calculates;
			var x = calculates.numberof.call(this, arguments[0]);
			var n = calculates.numberof.call(this, arguments[1]);
			if(n < 0) {
				throw {
					code: "CAL_NO_VALUE",
					cal: "bessely"
				};
			}
			return FORMULA_HELPER.bessely(x, n);
		},
		rank: function() {
			return this.me.rankCommonFunction(arguments, "rank", this);
		},
		rank_avg: function() {
			return this.me.rankCommonFunction(arguments, "rank.avg", this);
		},
		rank_eq: function() {
			return this.me.rankCommonFunction(arguments, "rank.eq", this);
		},
		stdev: function() {
			return this.me.stdevCommonFunction(arguments, "stdev", this);
		},
		stdevp: function() {
			return this.me.stdevCommonFunction(arguments, "stdev.p", this);
		},
		var_orig: function() {
			return this.me.stdevCommonFunction(arguments, "var", this);
		},
		varp: function() {
			return this.me.stdevCommonFunction(arguments, "var.p", this);
		},
		normdist: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(4 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "normdist"
				};
			}
			var result = me.checkCoordValid(coord);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var x = arguments[0];
			if(me.isCoordObj(x)) {
				x = calculates.valof.call(this, x);
			}
			var mean = arguments[1];
			if(me.isCoordObj(mean)) {
				mean = calculates.numberof.call(this, mean);
			}
			var standard_dev = arguments[2];
			if(me.isCoordObj(standard_dev)) {
				standard_dev = calculates.numberof.call(this, standard_dev);
			}
			if(standard_dev <= 0) {
				throw {
					code: "NUM_IS_NOT_RIGHT",
					cal: "normdist"
				};
			}
			var cumulative = arguments[3];
			if(me.isCoordObj(cumulative)) {
				cumulative = calculates.valof.call(this, cumulative);
			}
			if(HELPER.isBoolean(cumulative)) {
				cumulative = HELPER.getBoolean(cumulative);
			} else {
				throw {
					code: "CAL_NO_VALUE",
					cal: "normdist"
				};
			}
			if(cumulative) {} else {}
		},
		normsdist: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "normsdist"
				};
			}
			var z = arguments[0];
			if(me.isCoordObj(z)) {
				z = calculates.numberof.call(this, z);
			}
			var maxZval = 6,
				y, x, w;
			if(z === 0) {
				x = 0;
			} else {
				y = 0.5 * Math.abs(z);
				if(y >= maxZval * 0.5) {
					x = 1;
				} else if(y < 1) {
					w = y * y;
					x = ((((((((0.000124818987 * w - 0.001075204047) * w + 0.005198775019) * w - 0.019198292004) * w + 0.059054035642) * w - 0.151968751364) * w + 0.319152932694) * w - 0.5319230073) * w + 0.797884560593) * y * 2;
				} else {
					y -= 2;
					x = (((((((((((((-0.000045255659 * y + 0.00015252929) * y - 0.000019538132) * y - 0.000676904986) * y + 0.001390604284) * y - 0.00079462082) * y - 0.002034254874) * y + 0.006549791214) * y - 0.010557625006) * y + 0.011630447319) * y - 0.009279453341) * y + 0.005353579108) * y - 0.002141268741) * y + 0.000535310849) * y + 0.999936657524;
				}
			}
			return z > 0 ? (x + 1) * 0.5 : (1 - x) * 0.5;
		},
		es_checked: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var len = arguments.length;
			if(1 != len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "es_checked"
				};
			}
			var val = arguments[0];
			if(me.isCoordObj(val)) {
				val = calculates.cellof.call(this, val, "getCellData");
				if(val && val.it && val.it == "checkbox") {
					if(val.itchk == true) {
						return true;
					} else {
						return false;
					}
				}
			}
			throw {
				code: "VALUE_NOT_AVAILABLE",
				cal: "es_checked"
			};
		},
		transpose: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp,
				isheet = this.sheet,
				irow = this.row,
				icol = this.col;
			var len = arguments.length;
			if(1 !== len) {
				throw {
					code: "CAL_PARAM_MISS",
					cal: "TRANSPOSE"
				};
			}
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var arr = [];
			me.each(this.sheet, this.row, this.col, arguments, function(obj, itemType, index, insideIndex, item) {
				var data;
				if("span" == itemType) {
					var sheet = obj[0],
						row = obj[1],
						col = obj[2];
					if(Ext.isDefined(sheet)) {
						var cell = me.getCellData(sheet, row, col, this);
						data = cell.data;
						var index = col - item[2];
						while(arr.length <= index) {
							arr.push([]);
						}
						var it = arr[index];
						it.push(data);
					}
				} else {
					throw {
						code: "CAL_INCORRECT_COORD"
					};
					return;
				}
			}, this);
			return arr;
		},
		_getTplTable: function(table, col) {
			if(undefined === col) {
				return table;
			}
			if(table.cols) {
				var found = table.cols[col];
				return found;
			}
			var n = Number(col);
			if(Ext.isNumber(n)) {
				var span = table.span,
					len = span[4] - span[2] + 1;
				if(n < len) {
					var i = span[2] + n;
					return {
						span: [span[0], span[1], i, span[3], i],
						type: table.type
					};
				}
			}
		},
		overwriteplus: function() {
			var me = this.me,
				calculates = me.calculates;
			var val1 = arguments[0],
				val2 = arguments[1];
			if(me.isCoordObj(val1)) {
				val1 = calculates.valof.call(this, val1);
			}
			if(me.isCoordObj(val2)) {
				val2 = calculates.valof.call(this, val2);
			}
			if(Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
				var num = Number(val1) + Number(val2);
				var digitalLen = HELPER.getDigitalLen(num);
				if(digitalLen > 13) {
					num = HELPER.roundUpNonZero(num);
				}
				return num;
			}
			if(HELPER.isSSDefaultDate(val1)) {
				if(Ext.isNumber(Number(val2))) {
					return HELPER.calculateDate(val1, val2, "+");
				} else if(HELPER.isSSDefaultDate(val2)) {
					return HELPER.calculate2Date(val1, val2, "+");
				}
			}
			if(Ext.isNumber(Number(val1))) {
				if(HELPER.isSSDefaultDate(val2)) {
					return HELPER.calculateDate(val2, val1, "+");
				}
				if(Ext.isString(val2)) {
					throw {
						code: "CAL_NO_VALUE"
					};
				}
			}
			if(Ext.isNumber(Number(val2)) && Ext.isString(val1)) {
				throw {
					code: "CAL_NO_VALUE"
				};
			}
			return val1 + val2;
		},
		overwriteminus: function() {
			var me = this.me,
				calculates = me.calculates;
			var val1 = arguments[0],
				val2 = arguments[1];
			if(me.isCoordObj(val1)) {
				val1 = calculates.valof.call(this, val1);
			}
			if(me.isCoordObj(val2)) {
				val2 = calculates.valof.call(this, val2);
			}
			if(Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
				var num = Number(val1) - Number(val2);
				var digitalLen = HELPER.getDigitalLen(num);
				if(digitalLen > 13) {
					num = HELPER.roundUpNonZero(num);
				}
				return num;
			}
			if(HELPER.isSSDefaultDate(val1)) {
				if(Ext.isNumber(Number(val2))) {
					return HELPER.calculateDate(val1, val2, "-");
				} else if(HELPER.isSSDefaultDate(val2)) {
					return HELPER.calculate2Date(val1, val2, "-");
				}
			}
			if(Ext.isNumber(Number(val1))) {
				if(HELPER.isSSDefaultDate(val2)) {
					return HELPER.calculateDateByNum2(val1, val2, "-");
				}
				if(Ext.isString(val2)) {
					throw {
						code: "CAL_NO_VALUE"
					};
				}
			}
			if(Ext.isNumber(Number(val2)) && Ext.isString(val1)) {
				throw {
					code: "CAL_NO_VALUE"
				};
			}
			return val1 - val2;
		},
		overwriteAnd: function() {
			var me = this.me,
				calculates = me.calculates;
			var store = this.store,
				timestamp = this.timestamp;
			var result = me.checkCoordValid(arguments);
			if(true !== result) {
				throw {
					code: "CAL_INCORRECT_COORD",
					span: result
				};
			}
			var val1 = arguments[0],
				val2 = arguments[1];
			if(me.isCoordObj(val1)) {
				val1 = calculates.valof.call(this, val1);
			}
			if(me.isCoordObj(val2)) {
				val2 = calculates.valof.call(this, val2);
			}
			return val1 + val2;
		},
		overwritemultiple: function() {
			var me = this.me,
				calculates = me.calculates,
				sheetId = this.sheet;
			var val1 = arguments[0],
				val2 = arguments[1],
				isArrayVal1 = false,
				isArrayVal2 = false;
			if(me.isCoordObj(val1)) {
				var tmpSpan = val1.span;
				if("" === tmpSpan[0]) {
					tmpSpan[0] = sheetId;
				}
				var temp = me.calCacheMap.getValueFromCache(tmpSpan);
				if(!temp) {
					val1 = calculates.rangeVal2Dimension.call(this, [val1]);
					me.calCacheMap.addValueToCache(tmpSpan, val1);
				} else {
					val1 = temp;
					temp = [];
				}
				isArrayVal1 = true;
			}
			if(me.isCoordObj(val2)) {
				var tmpSpan = val2.span;
				if("" === tmpSpan[0]) {
					tmpSpan[0] = sheetId;
				}
				var temp = me.calCacheMap.getValueFromCache(tmpSpan);
				if(!temp) {
					val2 = calculates.rangeVal2Dimension.call(this, [val2]);
					me.calCacheMap.addValueToCache(tmpSpan, val2);
				} else {
					val2 = temp;
					temp = [];
				}
				isArrayVal2 = true;
			}
			if(Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
				return Number(val1) * Number(val2);
			}
			if(Ext.isNumber(Number(val2))) {
				var temp = val1;
				if(isArrayVal1) {
					temp = val1[0][0];
				}
				if(HELPER.isSSDefaultDate(temp)) {
					return HELPER.calculateDate(temp, val2, "*");
				}
			}
			if(Ext.isNumber(Number(val1))) {
				var temp = val2;
				if(isArrayVal2) {
					temp = val2[0][0];
				}
				if(HELPER.isSSDefaultDate(temp)) {
					return HELPER.calculateDate(temp, val1, "*");
				}
			}
			if(Ext.isArray(val1) && Ext.isArray(val2)) {
				if(val1.length == 0 || val2.length == 0 || val1.length != val2.length) {
					throw {
						code: "CAL_NO_VALUE",
						cal: "multiple"
					};
				}
				if(Ext.isArray(val1[0]) && Ext.isArray(val2[0])) {
					return HELPER.combine2ArrsAs1Arr(val1, val2, "multiple");
				} else if(!Ext.isArray(val1[0]) && !Ext.isArray(val2[0])) {
					return HELPER.cal2ArrsAs1Arr(val1, val2, "multiple");
				}
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "multiple"
			};
		},
		overwritedivide: function() {
			var me = this.me,
				calculates = me.calculates;
			var val1 = arguments[0],
				val2 = arguments[1];
			if(me.isCoordObj(val1)) {
				val1 = calculates.valof.call(this, val1);
			}
			if(me.isCoordObj(val2)) {
				val2 = calculates.valof.call(this, val2);
			}
			if(Ext.isNumber(Number(val1)) && Ext.isNumber(Number(val2))) {
				return Number(val1) / Number(val2);
			}
			throw {
				code: "CAL_NO_VALUE",
				cal: "multiple"
			};
		},
		overwriteCompareCond: function() {
			var me = this.me,
				calculates = me.calculates,
				sheetId = this.sheet;
			var val1 = arguments[0],
				symbol = arguments[1],
				val2 = arguments[2];
			var val1IsString = false,
				val2IsString = false;
			if(symbol == "=") {
				symbol = "==";
			} else if(symbol == "<>") {
				symbol = "!=";
			}
			if(me.isCoordObj(val2)) {
				val2 = calculates.valof.call(this, val2);
			}
			if(val2 == "") {
				val2 = 0;
				val2IsNum = true;
			} else if(HELPER.isEmptyStr(val2)) {
				val2IsString = true;
			} else {
				var val2IsNum = Ext.isNumber(Number(val2));
				if(val2IsNum) {
					val2 = Number(val2);
				} else if(Ext.isString(val2)) {
					var checkDate = SFORMAT.checkingDate(val2);
					if(checkDate) {
						val2 = HELPER.convertDateToNum(checkDate);
					} else {
						val2IsString = true;
					}
				}
			}
			if(me.isCoordObj(val1)) {
				val1 = calculates.valof.call(this, val1);
			}
			if(val1 == "") {
				val1 = 0;
				val1IsNum = true;
			} else if(HELPER.isEmptyStr(val1)) {
				val1IsString = true;
			} else {
				var val1IsNum = Ext.isNumber(Number(val1));
				if(val1IsNum) {
					val1 = Number(val1);
				} else if(Ext.isString(val1)) {
					var checkDate = SFORMAT.checkingDate(val1);
					if(checkDate) {
						val1 = HELPER.convertDateToNum(checkDate);
					} else {
						val1IsString = true;
					}
				}
			}
			if(val1IsString && val2IsString) {
				return HELPER.compare2String(val1, symbol, val2);
			} else if(val1IsString && val2IsNum) {
				val1 = 9999999999999;
			} else if(val2IsString && val1IsNum) {
				val2 = 9999999999999;
			}
			return eval(val1 + symbol + val2);
		},
		overwriteArrCompareCond: function() {
			var me = this.me,
				calculates = me.calculates,
				sheetId = this.sheet;
			var val1 = arguments[0],
				symbol = arguments[1],
				val2 = arguments[2];
			var val1Arr = null;
			if(Ext.isArray(val1)) {
				val1Arr = val1;
			} else if(Ext.isArray(val1.span)) {
				var tmpSpan = val1.span;
				if("" === tmpSpan[0]) {
					tmpSpan[0] = sheetId;
				}
				var val1Arr = me.calCacheMap.getValueFromCache(tmpSpan);
				if(!val1Arr) {
					val1Arr = calculates.rangeVal2Dimension.call(this, [val1]);
					me.calCacheMap.addValueToCache(tmpSpan, val1Arr);
				}
			}
			if(me.isCoordObj(val2)) {
				val2 = calculates.valof.call(this, val2);
			}
			if(Ext.isString(val2)) {
				val2 = "\"" + val2.toLowerCase() + "\"";
			}
			if(symbol == "=") {
				symbol = "==";
			} else if(symbol == "<>") {
				symbol = "!=";
			}
			var val2IsNum = false,
				val2IsBoolean = false;
			if(HELPER.isBoolean(val2)) {
				val2IsBoolean = true;
			} else {
				val2IsNum = Ext.isNumber(Number(val2));
			}
			if(val1Arr) {
				for(var i = 0; i < val1Arr.length; i++) {
					for(var j = 0; j < val1Arr[0].length; j++) {
						var temp = val1Arr[i][j],
							result = undefined;
						try {
							if(typeof temp != "undefined") {
								var tempIsBoolean = HELPER.isBoolean(temp);
								if(tempIsBoolean && val2IsBoolean) {
									if(HELPER.getBoolean(temp) == HELPER.getBoolean(val2)) {
										val1Arr[i][j] = 1;
									} else {
										val1Arr[i][j] = undefined;
									}
									continue;
								} else if(tempIsBoolean || val2IsBoolean) {
									val1Arr[i][j] = undefined;
									continue;
								}
								if(val2IsNum) {
									if(temp == "") {
										val1Arr[i][j] = undefined;
										continue;
									}
									if(Ext.isNumber(Number(temp))) {
										temp = Number(temp);
									} else if(Ext.isString(temp)) {
										temp = 9999999999999;
									}
								} else if(!Ext.isNumber(Number(temp)) && Ext.isString(temp)) {
									temp = "\"" + temp.toLowerCase() + "\"";
								}
								if(eval(temp + symbol + val2)) {
									result = 1;
								}
							} else if(val2IsNum) {
								temp = 0;
								if(eval(temp + symbol + val2)) {
									result = 1;
								}
							}
						} catch(err) {}
						val1Arr[i][j] = result;
					}
				}
			}
			return val1Arr;
		}
	}
}, function() {
	Ext.apply(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype, {
		calGeneratedStyles: ["clink", "cfm", "onCellClickFn", "onCellDoubleClickFn", "onCellMouseDownFn", "onCellMouseMoveFn", "onCellFocusFn", "onCellBlurFn"],
		calGeneratedStyleMap: {
			clink: "link",
			cfm: "fm"
		},
		escapeErrorFuncs: {
			iferror: true,
			iserror: true,
			'if': true,
			isna: true,
			ifna: true,
			iserr: true
		},
		contentRelatedProperty: ["data", "display", "cal", "arg", "value", "timestamp", "refs", "afrow", "afcol", "aerow", "aecol", "clink", "cfm", "itms"],
		calculateRelatedProperty: ["cal", "arg", "value", "refs", "timestamp", "afrow", "afcol", "aerow", "aecol", "clink", "cfm"],
		formulaAliasMap: {
			DATUM: "DATE",
			DATWERT: "DATEVALUE",
			TAG: "DAY",
			TAGE360: "DAYS360",
			EDATUM: "EDATE",
			MONATSENDE: "EOMONTH",
			STUNDE: "HOUR",
			MONAT: "MONTH",
			NETTOARBEITSTAGE: "NETWORKDAYS",
			JETZT: "NOW",
			SEKUNDE: "SECOND",
			ZEIT: "TIME",
			ZEITWERT: "TIMEVALUE",
			HEUTE: "TODAY",
			WOCHENTAG: "WEEKDAY",
			KALENDERWOCHE: "WEEKNUM",
			ARBEITSTAG: "WORKDAY",
			JAHR: "YEAR",
			BRTEILJAHRE: "YEARFRAC",
			BININDEZ0: "BIN2DEC",
			BININHEX: "BIN2HEX",
			BININOKT: "BIN2OCT",
			KOMPLEXE: "COMPLEX",
			UMWANDELN: "CONVERT",
			DEZINBIN: "DEC2BIN",
			DEZINHEX: "DEC2HEX",
			DEZINOKT: "DEC2OCT",
			GAUSSFEHLER: "ERF",
			GAUSSFKOMPL: "ERFC",
			GGANZZAHL: "GESTEP",
			HEXINBIN: "HEX2BIN",
			HEXINDEZ: "HEX2DEC",
			HEXINOKT: "HEX2OCT",
			'IMAGIN\xC3\x84RTEIL': "IMAGINARY",
			IMARGUMENT: "IMARGUMENT",
			IMKONJUGIERTE: "IMCONJUGATE",
			IMAPOTENZ: "IMPOWER",
			IMPRODUKT: "IMPRODUCT",
			IMREALTEIL: "IMREAL",
			IMWURZEL: "IMSQRT",
			IMSUMME: "IMSUM",
			OKTINBIN: "OCT2BIN",
			OKTINDEZ: "OCT2DEC",
			OKTINHEX: "OCT2HEX",
			ARCCOS: "ACOS",
			ARCCOSHYP: "ACOSH",
			ARCSIN: "ASIN",
			ARCSINHYP: "ASINH",
			ARCTAN: "ATAN",
			ARCTAN2: "ATAN2",
			ARCTANHYP: "ATANH",
			OBERGRENZE: "CEILING",
			KOMBINATIONEN: "COMBIN",
			COSHYP: "COSH",
			GRAD: "DEGREES",
			'FAKULT\xC3\x84T': "FACT",
			'ZWEIFAKULT\xC3\x84T': "FACTDOUBLE",
			UNTERGRENZE: "FLOOR",
			GGT: "GCD",
			GANZZAHL: "INT",
			KGV: "LCM",
			MDET: "MDETERM",
			REST: "MOD",
			VRUNDEN: "MROUND",
			POLYNOMIAL: "MULTINOMIAL",
			UNGERADE: "ODD",
			POTENZ: "POWER",
			PRODUKT: "PRODUCT",
			BOGENMASS: "RADIANS",
			ZUFALLSZAHL: "RAND",
			ZUFALLSBEREICH: "RANDBETWEEN",
			RUNDEN: "ROUND",
			ABRUNDEN: "ROUNDDOWN",
			AUFRUNDEN: "ROUNDUP",
			POTENZREIHE: "SERIESSUM",
			VORZEICHEN: "SIGN",
			SINHYP: "SINH",
			WURZEL: "SQRT",
			WURZELPI: "SQRTPI",
			TEILERGEBNIS: "SUBTOTAL",
			summe: "sum",
			SUMMEWENN: "SUMIF",
			SUMMEWENNS: "SUMIFS",
			SUMMENPRODUKT: "SUMPRODUCT",
			QUADRATESUMME: "SUMSQ",
			SUMMEX2MY2: "SUMX2MY2",
			SUMMEX2PY2: "SUMX2PY2",
			SUMMEXMY2: "SUMXMY2",
			TANHYP: "TANH",
			'K\xC3\x9CRZEN': "TRUNC",
			MITTELABW: "AVEDEV",
			MITTELWERT: "AVERAGE",
			MITTELWERTA: "AVERAGEA",
			MITTELWERTWENN: "AVERAGEIF",
			MITTELWERTWENNS: "AVERAGEIFS",
			BETAVERT: "BETADIST",
			BINOMVERT: "BINOMDIST",
			KORREL: "CORREL",
			ANZAHL: "COUNT",
			ANZAHL2: "COUNTA",
			ANZAHLLEEREZELLEN: "COUNTBLANK",
			'Z\xC3\x84HLENWENN': "COUNTIF",
			'Z\xC3\x84HLENWENNS': "COUNTIFS",
			SUMQUADABW: "DEVSQ",
			EXPONVERT: "EXPONDIST",
			'H\xC3\x84UFIGKEIT': "FREQUENCY",
			GEOMITTEL: "GEOMEAN",
			VARIATION: "GROWTH",
			HARMITTEL: "HARMEAN",
			ACHSENABSCHNITT: "INTERCEPT",
			'KGR\xC3\x96SSTE': "LARGE",
			RGP: "LINEST",
			RKP: "LOGEST",
			LOGNORMVERT: "LOGNORMDIST",
			MODALWERT: "MODE",
			NORMVERT: "NORMDIST",
			STANDNORMVERT: "NORMSDIST",
			STANDNORMINV: "NORMSINV",
			QUANTIL: "PERCENTILE",
			QUANTILSRANG: "PERCENTRANK",
			VARIATIONEN: "PERMUT",
			RANG: "RANK",
			BESTIMMTHEITSMASS: "RSQ",
			SCHIEFE: "SKEW",
			STEIGUNG: "SLOPE",
			KKLEINSTE: "SMALL",
			STABW: "STDEV",
			STABWA: "STDEVA",
			STABWN: "STDEVP",
			STABWNA: "STDEVPA",
			STFEHLERYX: "STEYX",
			TVERT: "TDIST",
			GESTUTZTMITTEL: "TRIMMEAN",
			VARIANZ: "VAR",
			VARIANZA: "VARA",
			VARIANZEN: "VARP",
			VARIANZENA: "VARPA",
			GTEST: "ZTEST",
			ZEICHEN: "CHAR",
			klein: "lower",
			verketten: "concatenate",
			gross: "upper",
			DM: "DOLLAR",
			IDENTISCH: "EXACT",
			FINDEN: "FIND",
			FEST: "FIXED",
			LINKS: "LEFT",
			'L\xC3\x84NGE': "LEN",
			TEIL: "MID",
			GROSS2: "PROPER",
			ERSETZEN: "REPLACE",
			WIEDERHOLEN: "REPT",
			RECHTS: "RIGHT",
			SUCHEN: "SEARCH",
			WECHSELN: "SUBSTITUTE",
			'GL\xC3\x84TTEN': "TRIM",
			WERT: "VALUE",
			ADRESSE: "ADDRESS",
			BEREICHE: "AREAS",
			WAHL: "CHOOSE",
			SPALTE: "COLUMN",
			SPALTEN: "COLUMNS",
			HVERWEIS: "HLOOKUP",
			INDIREKT: "INDIRECT",
			VERWEIS: "LOOKUP",
			VERGLEICH: "MATCH",
			ZEILE: "ROW",
			ZEILEN: "ROWS",
			MTRANS: "TRANSPOSE",
			SVERWEIS: "VLOOKUP",
			ZELLE: "CELL",
			ISTLEER: "ISBLANK",
			ISTFEHL: "ISERR",
			ISTFEHLER: "ISERROR",
			ISTGERADE: "ISEVEN",
			ISTLOG: "ISLOGICAL",
			ISTNV: "ISNA",
			ISTKTEXT: "ISNONTEXT",
			ISTZAHL: "ISNUMBER",
			ISTUNGERADE: "ISODD",
			ISTBEZUG: "ISREF",
			TYP: "TYPE",
			UND: "AND",
			FALSCH: "FALSE",
			WENN: "IF",
			WENNFEHLER: "IFERROR",
			NICHT: "NOT",
			ODER: "OR",
			WAHR: "TRUE",
			ZINSTERMTAGE: "COUPDAYS",
			GDA2: "DB",
			GDA: "DDB",
			EFFEKTIV: "EFFECT",
			ZW: "FV",
			ZINSZ: "IPMT",
			IKV: "IRR",
			QIKV: "MIRR",
			ZZR: "NPER",
			NBW: "NPV",
			RMZ: "PMT",
			KAPZ: "PPMT",
			BW: "PV",
			ZINS: "RATE",
			LIA: "SLN",
			DIA: "SYD",
			XINTZINSFUSS: "XIRR"
		},
		getFormulaAliasMap: function() {
			this.formulaAliasMap = this.formulaAliasMap || {};
			return this.formulaAliasMap;
		},
		addFormulaAlias: function(aliasMap) {
			for(var p in aliasMap) {
				if(aliasMap.hasOwnProperty(p)) {
					var it = aliasMap[p],
						name = it;
					if(Ext.isObject(it)) {
						name = it.originName;
					}
					this.formulaAliasMap[p.toUpperCase()] = name;
				}
			}
		},
		isCalculate: function(str) {
			var reg = new RegExp;
			reg.compile(/^=.+/gi);
			return reg.test(str);
		},
		couldbeCalculate: function(str) {
			var reg = new RegExp;
			reg.compile(/^=/gi);
			return str && reg.test(str);
		},
		isInFun: function(str, pos) {
			var match = 0,
				i;
			for(i = pos - 1; i >= 0; i--) {
				if(")" == str[i]) {
					match--;
				}
				if("(" == str[i]) {
					match++;
				}
				if(1 == match) {
					break;
				}
			}
			var flag = true;
			if(0 == match) {
				flag = false;
			} else if(1 == match) {
				if(")" == str[pos]) {
					return true;
				}
				if(0 >= i) {
					flag = false;
				} else {
					if(/[a-zA-Z0-9_]/.test(str[i - 1])) {
						for(var j = pos, len = str.length; j < len; j++) {
							var ch = str[j];
							if("," == ch || ")" == ch || "\"" == ch || "'" == ch) {
								break;
							}
							if(/[*+-\/\>\<\=\%]/.test(ch)) {
								flag = false;
								break;
							}
						}
						if(flag) {
							for(var j = pos - 1; j >= 0; j--) {
								var ch = str[j];
								if("," == ch || "(" == ch || "\"" == ch || "'" == ch) {
									break;
								}
								if(/[*+-\/\<\>\=\%]/.test(ch)) {
									flag = false;
									break;
								}
							}
						}
					} else {
						flag = false;
					}
				}
			}
			return flag;
		},
		handleTplNamedFunc: function(arg, store, refs) {
			if(store.tplNameReg) {
				store.tplNameReg.lastIndex = 0;
				var map = {};
				arg = arg.replace(store.tplNameReg, function(w) {
					if(arguments[6]) {
						var tplTab = arguments[6].toUpperCase(),
							nextStr = arguments[7],
							tplCol = arguments[8];
						map[tplTab] = true;
						if(tplCol) {
							if(tplCol.toUpperCase) {
								return "_getTplTable(" + tplTab + ",\"" + tplCol.toUpperCase() + "\")";
							} else {
								return "_getTplTable(" + tplTab + ",\"" + tplCol + "\")";
							}
						} else {
							return "_getTplTable(" + tplTab + ")" + nextStr;
						}
					}
					return w;
				});
				for(var p in map) {
					if(map.hasOwnProperty(p)) {
						refs.push(p);
					}
				}
			}
			return arg;
		},
		handleAliasName: function(arg) {
			var calculate = this;
			if(calculate.formulaAliasReg) {
				calculate.formulaAliasReg.lastIndex = 0;
				var aliasMap = calculate.getFormulaAliasMap();
				if(aliasMap) {
					arg = arg.replace(calculate.formulaAliasReg, function(w) {
						var pos = arguments[arguments.length - 2];
						var str = arguments[arguments.length - 1];
						var fname = arguments[1].toUpperCase();
						if(!calculate.isInFun(str, pos)) {
							if(aliasMap[fname]) {
								return aliasMap[fname] + "(";
							} else {
								fname = fname.toLowerCase();
								if(aliasMap[fname]) {
									return aliasMap[fname] + "(";
								}
							}
						}
						return w;
					});
				}
			}
			return arg;
		},
		transferCalculate: function(o, store, sheetId, row, col, forceAbsoluteCoord) {
			if(this.isCalculate(o.data)) {
				o.cal = true;
				var me = this;
				var originCalStr = calStr = HELPER.reCheckDoubleQuote(o.data);
				calStr = HELPER.replaceBraces(calStr);
				calStr = HELPER.convertSpecialFormulaName(calStr);
				calStr = HELPER.reCheckBracesAndExtraComma(calStr);
				var lowCalStr = calStr.toLowerCase();
				if(lowCalStr.indexOf("&") != -1) {
					calStr = HELPER.convertAndSymbol(calStr, true);
				}
				if(lowCalStr.indexOf("sumproduct(") != -1) {
					calStr = HELPER.convertFormulaCondition(calStr, "sumproduct");
				}
				if(calStr.indexOf("+") != -1 || calStr.indexOf("-") != -1) {
					if(/[0-9.]+e[\+\-][0-9]+/i.test(calStr)) {
						calStr = HELPER.addBracket2ScienceData(calStr);
					}
					calStr = HELPER.convertPlusMinus(calStr, true);
				}
				if(calStr.indexOf("*") != -1 || calStr.indexOf("/") != -1) {
					calStr = HELPER.convertMulDiv(calStr, true);
				}
				if(calStr.indexOf("^") != -1) {
					calStr = HELPER.convertPower(calStr);
				}
				if(HELPER.isExpressFn(calStr.substring(1))) {
					calStr = HELPER.convertCondition(calStr, "overwriteCompareCond");
				}
				calStr = this.escapeErrorResult(calStr);
				this.spanReg.lastIndex = 0;
				var refCoord = [],
					visited = {},
					namedFuncs = store.getNamedFuncConfigLookup() || {},
					relativeCoordsInNamedFunc = [];
				calStr = this.handleTplNamedFunc(calStr, store, refCoord);
				var arg = calStr.replace(this.spanReg, function(w) {
					var pos = arguments[arguments.length - 2];
					var str = arguments[arguments.length - 1];
					var ret = me.assembleCoordByRegResult(arguments);
					if(!ret) {
						return w;
					}
					var arr = ret.span,
						next = ret.next,
						ctype = ret.type,
						spanStr = w;
					if(next) {
						spanStr = w.slice(0, -1);
						if(namedFuncs[spanStr.toUpperCase()]) {
							return w;
						}
					} else if(namedFuncs[w.toUpperCase()]) {
						return w;
					}
					arr = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(arr);
					var waitForPush = false;
					if("" !== arr[0] && "string" == SCOM.typeOf(arr[0])) {
						var foundSheetId = store.getSheetIdByName(arr[0]);
						if(Ext.isDefined(foundSheetId)) {
							arr[0] = foundSheetId;
							if(!visited[spanStr]) {
								waitForPush = [].concat(arr);
							}
						}
					} else if(!visited[spanStr]) {
						waitForPush = [sheetId, arr[1], arr[2], arr[3], arr[4]];
					}
					visited[spanStr] = true;
					if(!forceAbsoluteCoord) {
						arr = me.absolute2Relative(arr, row, col, ctype);
					} else {
						if("named_func" === forceAbsoluteCoord) {
							if(SCONST.RELATIVE_COORD === ctype) {
								ctype = SCONST.ABSOLUTE_COORD;
								if(SCOM.isEmptyValue(arr[0])) {
									arr[0] = sheetId;
								}
							} else {
								if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
									arr[4] -= arr[2];
									arr[2] = 0;
									relativeCoordsInNamedFunc.push({
										span: [].concat(arr),
										type: SCONST.ABSOLUTE_ROW_COORD
									});
									waitForPush = false;
								} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
									arr[3] -= arr[1];
									arr[1] = 0;
									relativeCoordsInNamedFunc.push({
										span: [].concat(arr),
										type: SCONST.ABSOLUTE_COL_COORD
									});
									waitForPush = false;
								}
							}
						} else {
							ctype = SCONST.ABSOLUTE_COORD;
							if(SCOM.isEmptyValue(arr[0])) {
								arr[0] = sheetId;
							}
						}
					}
					if(waitForPush) {
						refCoord.push(waitForPush);
					}
					var coord = Ext.encode({
						span: arr,
						type: ctype
					});
					if(!me.isInFun(str, pos)) {
						coord = "valof(" + coord + ")";
					}
					return coord + next;
				});
				arg = arg.slice(1);
				o.arg = this.specialCaseForCalculateStr(arg);
				var namedFuncs = store.getReferedNamedFuncs(originCalStr);
				refCoord = refCoord.concat(namedFuncs);
				if(!forceAbsoluteCoord) {
					refCoord = refCoord.concat(store.getRefCoordFromNamedFuncs(namedFuncs, sheetId, row, col));
				}
				if(0 < refCoord.length) {
					o.refs = refCoord;
				} else {
					o.refs = null;
				}
				if(0 < relativeCoordsInNamedFunc.length) {
					o.relativeCoordsInNamedFunc = relativeCoordsInNamedFunc;
				}
				this.addQuoteForSheetName(o, store);
			} else {
				delete o.cal;
			}
			return o;
		},
		prepareRefNamedFunc: function(namedFuncs, curSheetId, store) {
			var arr = [],
				visited = {};
			var calPro = this;
			var nfv = store.exposeNamedFuncVar;
			var fn = function(vn) {
				if(namedFuncs.hasOwnProperty(vn)) {
					if("visiting" === visited[vn]) {
						return false;
					} else if(true !== visited[vn]) {
						visited[vn] = "visiting";
						var it = namedFuncs[vn],
							json = it.json;
						var jsonArr = it.jsonArr;
						for(var i = 0, len = jsonArr.length; i < len; i++) {
							var jsonObj = jsonArr[i],
								cal = jsonObj.cal,
								scope = jsonObj.scope,
								flag = true;
							cal.replace(/("[^\"]+")|('[^\']+')|([a-z0-9._]+)/gi, function(w) {
								var str = arguments[3];
								if(namedFuncs.hasOwnProperty(str) && !visited[str]) {
									if(false === fn(str)) {
										flag = false;
									}
								}
							});
							if(flag) {
								arr.push({
									name: vn,
									jsonObj: jsonObj
								});
								visited[vn] = true;
							}
						}
					}
				}
			};
			for(var p in namedFuncs) {
				if(namedFuncs.hasOwnProperty(p)) {
					fn(p);
				}
			}
			var items = [],
				vars = [];
			for(var k = 0, size = arr.length; k < size; k++) {
				var p = arr[k],
					name = p.name,
					it = p.jsonObj;
				if(!it.arg) {
					var cal = "=beval(" + it.cal + ")";
					var o = calPro.transferCalculate({
						data: cal
					}, store, curSheetId, undefined, undefined, "named_func");
					it.relativeCoordsInNamedFunc = o.relativeCoordsInNamedFunc;
					it.arg = o.arg;
					it.refs = o.refs;
				}
				var packs = name.split(".");
				var len = packs.length;
				if(1 < len) {
					var invalid;
					for(var i = 0; i < len; i++) {
						if(!/^[a-z_]+[a-z0-9_]*/.test(packs[i])) {
							invalid = true;
							break;
						}
					}
					if(invalid) {
						continue;
					}
					for(var i = 0; i < len; i++) {
						if(0 === i) {
							items.push("var " + packs[i] + "=" + packs[i] + "||{};");
						} else if(i === len - 1) {
							var vname = packs.slice(0, i + 1).join(".");
							vars.push({
								name: vname,
								arg: it.arg,
								scope: it.scope
							});
						} else {
							var vname = packs.slice(0, i + 1).join(".");
							items.push(vname + "=" + vname + "||{};");
						}
					}
				} else {
					items.push("var " + name + ";");
					vars.push({
						name: name,
						arg: it.arg,
						scope: it.scope
					});
				}
			}
			var namedFunStr = items.join(""),
				envStr = calPro.fakeEnv();
			for(var i = 0, len = vars.length; i < len; i++) {
				var it = vars[i],
					scope = it.scope,
					name = it.name,
					arg = it.arg;
				try {
					var str = envStr + namedFunStr + arg;
					(function() {
						eval(str);
					})();
					if(Ext.isDefined(scope)) {
						items.push("if(_curSheetId===" + scope + "){try{" + name + "=function(){var v;if(undefined === " + nfv + "(\"" + name + "\"," + scope + ").value){v=" + arg + ";" + nfv + "(\"" + name + "\"," + scope + ").value=v;return v;}else{return " + nfv + "(\"" + name + "\"," + scope + ").value;}}}catch(e){};}");
					} else {
						items.push("try{" + name + "=" + name + "||function(){var v;if(undefined === " + nfv + "(\"" + name + "\").value){v=" + arg + ";" + nfv + "(\"" + name + "\").value=v;return v;}else{return " + nfv + "(\"" + name + "\").value;}}}catch(e){};");
					}
				} catch(e) {
					var exp = {
						code: e.toString(),
						_isExp: true
					};
					if(Ext.isDefined(scope)) {
						items.push("if(_curSheetId===" + it.scope + "){try{" + name + "=function(){var v;if(undefined === " + nfv + "['" + name + "'].value){v=" + Ext.encode(exp) + ";" + nfv + "['" + name + "'].value=v;return v;}else{return " + nfv + "['" + name + "'].value;}}}catch(e){};}");
					} else {
						items.push("try{" + name + "=" + name + "||function(){var v;if(undefined === " + nfv + "['" + name + "'].value){v=" + Ext.encode(exp) + ";" + nfv + "['" + name + "'].value=v;return v;}else{return " + nfv + "['" + name + "'].value;}}}catch(e){};");
					}
				}
			}
			return items;
		}
	});
});

Ext.define("EnterpriseSheet.pure.sheet.calculate.Condition", {
	extend: "EnterpriseSheet.pure.sheet.calculate.Calculate",
	kitOffset: [5, -1],
	ignoreDate: true,
	constructor: function(config) {
		Ext.apply(this, config);
		this.resetCache();
		EnterpriseSheet.pure.sheet.calculate.Condition.prototype.superclass.constructor.apply(this);
	},
	showConditionReference: function(cell, sheetId, row, col) {
		var store = this.sheet.getStore();
		var cdt = this.sheet.getConditionOfCell(sheetId, row, col);
		if(0 < cdt.length) {
			var coord = [];
			for(var k = 0, count = cdt.length; k < count; k++) {
				var it = cdt[k];
				if(it) {
					var rng = it.rng,
						opt = it.opt,
						name = it.name;
					if("minichart" == name) {
						rng = [Ext.isObject(opt.base) ? opt.base : {
							span: opt.base,
							type: SCONST.ABSOLUTE_COORD
						}];
					}
					if("colorgrad" !== name && "colorbar" !== name && "vd" !== name) {
						for(var i = 0, len = rng.length; i < len; i++) {
							var it = rng[i];
							var span = it.span,
								type = it.type;
							if(SCONST.RELATIVE_COORD == type) {
								span[1] += row;
								span[2] += col;
								span[3] += row;
								span[4] += col;
							}
							coord.push({
								span: span,
								cls: "ss-rm-condition"
							});
						}
					}
				}
			}
			var rm = this.sheet.getReferenceModel();
			rm.setReference(coord, false, false, "ss-cal-ref");
			rm.show();
			return true;
		}
		return false;
	},
	withMiniChart: function(sheetId, row, col) {
		var store = this.sheet.getStore();
		var cdt = this.sheet.getConditionOfCell(sheetId, row, col);
		if(0 < cdt.length) {
			for(var k = 0, count = cdt.length; k < count; k++) {
				var it = cdt[k];
				if("minichart" == it.name) {
					return true;
				}
			}
		}
		return false;
	},
	getMiniChartRangeByCell: function(sheetId, row, col) {
		var store = this.sheet.getStore(),
			cdt = store.getConditionOfCell(sheetId, row, col);
		if(0 < cdt.length) {
			for(var i = 0, len = cdt.length; i < len; i++) {
				var cond = cdt[i];
				if(cond && "minichart" == cond.name) {
					return cond.opt.base;
				}
			}
		}
	},
	getMiniChartRelatedCoord: function(cdt) {
		return [cdt.opt.base.span];
	},
	isAutoExtendType: function(name) {
		return "colorbar" == name || "colorgrad" == name;
	},
	processCondition: function(o, scope, skipUpdateValue) {
		var store = scope.store,
			sheetId = scope.sheet,
			row = scope.row,
			col = scope.col,
			timestamp = scope.timestamp;
		var conditions = this.sheet.getCdtFloatingOfCell(sheetId, row, col, true);
		var cdtVal = o.cdtVal || {};
		var ret = {},
			old = Ext.apply({}, o),
			cdtIds = {},
			cdtFlag = false;
		for(var i = 0, len = conditions.length; i < len; i++) {
			var condition = conditions[i];
			var cdtObj = condition.jsonObj;
			var name = cdtObj.name;
			if(!cdtVal[cdtObj.id]) {
				var fn = this[name];
				if(fn) {
					var property = fn.call(this, o, cdtObj.rng, cdtObj.opt, scope, condition);
					if(property) {
						cdtIds[cdtObj.id] = this.prepareCdtProperty(property);
					}
					cdtFlag = true;
				}
			} else {
				cdtIds[cdtObj.id] = cdtVal[cdtObj.id];
			}
		}
		if(cdtFlag) {
			store.setCell(sheetId, row, col, {
				cdtVal: cdtIds
			}, null, true, undefined, true);
		}
		o.cdtVal = cdtIds;
		return o;
	},
	prepareCdtProperty: function(property) {
		var styles = this.styleMap;
		var o = {};
		for(var p in property) {
			if(property.hasOwnProperty(p)) {
				var q = styles[p] || p;
				o[q] = property[p];
			}
		}
		return o;
	},
	findRepeatInCondition: function(timestamp, store, sheet, row, col, range) {
		var lookup = {},
			repeat = {};
		var fn = function(s, r, c) {
			var cell = this.getCellData(s, r, c, {
				store: store,
				timestamp: timestamp,
				isCdt: true
			});
			if(cell.data) {
				if(lookup[cell.data]) {
					repeat[cell.data] = true;
				} else {
					lookup[cell.data] = true;
				}
			}
		};
		this.walkRange(store, sheet, row, col, range, fn);
		var arr = [];
		for(var p in repeat) {
			arr.push(p);
		}
		return arr;
	},
	getRepeat: function(range, scope) {
		var store = scope.store,
			timestamp = scope.timestamp,
			sheet = scope.sheet,
			row = scope.row,
			col = scope.col;
		range = this.transfer2Absolute(sheet, row, col, range);
		var str = Ext.encode(range);
		var data = this.getFromCache(str, timestamp),
			repeat;
		if(!data || false == SCOM.typeOf(data.repeat)) {
			repeat = this.findRepeatInCondition(timestamp, store, sheet, row, col, range);
			this.keep2Cache(str, timestamp, {
				repeat: repeat
			});
		} else {
			repeat = data.repeat;
		}
		return repeat;
	},
	findPositionValueInCondition: function(position, isPercent, timestamp, store, sheet, row, col, range) {
		var arr = [];
		var fn = function(s, r, c) {
			var cell = this.getCellData(s, r, c, {
				store: store,
				timestamp: timestamp,
				isCdt: true
			});
			if(SCOM.canbeNumber(cell.data)) {
				arr.push(Number(cell.data));
			}
		};
		this.walkRange(store, sheet, row, col, range, fn);
		var len = arr.length;
		if(0 < len) {
			if(isPercent) {
				var posFlag = 0 < position;
				position = Math[posFlag ? "floor" : "ceil"](position * len / 100);
				if(0 == position) {
					position = posFlag ? 1 : -1;
				}
			}
			arr.sort(function(a, b) {
				return a - b;
			});
			if(0 < position) {
				var index = len - position;
				if(0 > index) {
					index = 0;
				}
				return arr[index];
			} else {
				position = -position - 1;
				if(position >= len) {
					position = len - 1;
				}
				return arr[position];
			}
		}
	},
	getPositionValue: function(position, isPercent, range, scope) {
		var store = scope.store,
			timestamp = scope.timestamp,
			sheet = scope.sheet,
			row = scope.row,
			col = scope.col;
		range = this.transfer2Absolute(sheet, row, col, range);
		var str = Ext.encode(range);
		var data = this.getFromCache(str, timestamp),
			value;
		var name = isPercent ? position + "%" : position;
		if(!data || false == SCOM.typeOf(data[name])) {
			value = this.findPositionValueInCondition(position, isPercent, timestamp, store, sheet, row, col, range);
			var obj = {};
			obj[name] = value;
			this.keep2Cache(str, timestamp, obj);
		} else {
			value = data[name];
		}
		return value;
	},
	colorgrad: function(cell, range, option, scope) {
		if(!SCOM.canbeNumber(cell.data)) {
			return;
		}
		scope.me = this;
		var obj = {};
		if(Ext.isDefined(option.min)) {
			condition.cache = condition.cache || {};
			if(Ext.isDefined(condition.cache.min)) {
				if(Ext.isNumber(condition.cache.min)) {
					obj.min = condition.cache.min;
				}
			} else if(Ext.isDefined(option.minArg)) {
				var o = this.evalCal(option.minArg, scope);
				if(Ext.isNumber(o.data)) {
					obj.min = o.data;
					condition.cache.min = o.data;
				}
			}
		}
		if(Ext.isDefined(option.max)) {
			condition.cache = condition.cache || {};
			if(Ext.isDefined(condition.cache.max)) {
				if(Ext.isNumber(condition.cache.max)) {
					obj.max = condition.cache.max;
				}
			} else if(Ext.isDefined(option.maxArg)) {
				var o = this.evalCal(option.maxArg, scope);
				if(Ext.isNumber(o.data)) {
					obj.max = o.data;
					condition.cache.max = o.data;
				}
			}
		}
		if(!Ext.isDefined(obj.min) || !Ext.isDefined(obj.max)) {
			var o = this.getMinMax(range, scope, {
				isCdt: true
			});
			if(o.min > 0 && o.max > 0) {
				o.min--;
			}
			Ext.apply(obj, o);
		}
		if(obj) {
			var min = obj.min,
				max = obj.max;
			var v = cell.data,
				oldcbgc = cell.cbgc;
			if(max == min) {
				v = 1;
			} else {
				v = (v - min) / (max - min);
			}
			var start = option.start,
				stop = option.stop,
				end = option.end,
				r, g, b;
			if(!end) {
				end = stop;
				stop = null;
			}
			if(stop) {
				if(0.5 > v) {
					v = v / 0.5;
					r = Math.round((stop[0] - start[0]) * v + start[0]);
					g = Math.round((stop[1] - start[1]) * v + start[1]);
					b = Math.round((stop[2] - start[2]) * v + start[2]);
				} else {
					v = (v - 0.5) / 0.5;
					r = Math.round((end[0] - stop[0]) * v + stop[0]);
					g = Math.round((end[1] - stop[1]) * v + stop[1]);
					b = Math.round((end[2] - stop[2]) * v + stop[2]);
				}
			} else {
				r = Math.round((end[0] - start[0]) * v + start[0]);
				g = Math.round((end[1] - start[1]) * v + start[1]);
				b = Math.round((end[2] - start[2]) * v + start[2]);
			}
			var bgc = "rgb(" + r + "," + g + "," + b + ")";
			obj = {
				cbgc: bgc
			};
			return obj;
		}
	},
	colorbar: function(cell, range, option, scope, condition) {
		if(!SCOM.canbeNumber(cell.data)) {
			return;
		}
		scope.me = this;
		var obj = {};
		if(Ext.isDefined(option.min)) {
			condition.cache = condition.cache || {};
			if(Ext.isDefined(condition.cache.min)) {
				if(Ext.isNumber(condition.cache.min)) {
					obj.min = condition.cache.min;
				}
			} else if(Ext.isDefined(option.minArg)) {
				var o = this.evalCal(option.minArg, scope);
				if(Ext.isNumber(o.data)) {
					obj.min = o.data;
					condition.cache.min = o.data;
				}
			}
		}
		if(Ext.isDefined(option.max)) {
			condition.cache = condition.cache || {};
			if(Ext.isDefined(condition.cache.max)) {
				if(Ext.isNumber(condition.cache.max)) {
					obj.max = condition.cache.max;
				}
			} else if(Ext.isDefined(option.maxArg)) {
				var o = this.evalCal(option.maxArg, scope);
				if(Ext.isNumber(o.data)) {
					obj.max = o.data;
					condition.cache.max = o.data;
				}
			}
		}
		if(!Ext.isDefined(obj.min) || !Ext.isDefined(obj.max)) {
			var o = this.getMinMax(range, scope, {
				isCdt: true
			});
			if(o.min > 0 && o.max > 0) {
				o.min = o.min * 0.9;
			}
			Ext.apply(obj, o);
		}
		if(obj) {
			var min = obj.min,
				max = obj.max;
			var v = cell.data,
				oldbar = cell.bar,
				l, c;
			if(0 < min) {
				v -= min;
				max -= min;
				min = 0;
			}
			if(v < min) {
				v = min;
			}
			if(v > max) {
				v = max;
			}
			if(max === min) {
				if(0 > max) {
					v = "100%";
					c = option.neg;
					l = "0%";
				} else {
					v = "100%";
					c = option.pos;
					l = "0%";
				}
			} else {
				var span, pos, neg;
				if(max < 0) {
					neg = span = -min;
					pos = 0;
				} else if(0 < min) {
					pos = span = max;
					neg = 0;
				} else {
					span = max - min;
					pos = max;
					neg = -min;
				}
				if(0 > v) {
					c = option.neg;
					v = Math.round(-v / span * 100);
					l = Math.round(neg / span * 100) - v;
					l = l + "%";
					v = v + "%";
				} else {
					c = option.pos;
					v = Math.round(v / span * 100) + "%";
					l = Math.round(neg / span * 100) + "%";
				}
			}
			var bar = "<div class=\"ss-colorbar\" style=\"background:" + c + ";width:" + v + ";left:" + l + ";z-index:" + SCONST.FLOAT_Z_INDEX + ";\"></div>";
			obj = {
				bar: bar
			};
			return obj;
		}
	},
	iconset: function(cell, range, option, scope) {
		if(!SCOM.canbeNumber(cell.data)) {
			return;
		}
		var obj = this.getMinMax(range, scope, {
			isCdt: true
		});
		if(obj) {
			var icon, showIconOnly;
			if(Ext.isDefined(option.set)) {
				var min = obj.min,
					max = obj.max,
					set = option.set,
					level = option.level;
				var v = cell.data;
				var step = (max - min) / level,
					arr = [];
				for(var i = 0; i <= level; i++) {
					arr.push(min + i * step);
				}
				var pos = 0;
				for(var i = arr.length - 1; i > 0; i--) {
					var j = i - 1;
					if(arr[i] > v && v >= arr[j]) {
						pos = level - 1 - j;
						break;
					}
				}
				icon = "url(" + SCONFIG.CONDITION_ICONS_PATH + "/" + set + "/" + pos + ".png)";
			} else if(Ext.isDefined(option.is)) {
				var iconSet = option.is,
					icons;
				if(Ext.isObject(iconSet)) {
					var set = iconSet.set,
						level = iconSet.level;
					var arr = [];
					for(var i = 0, len = iconSet.icons.length; i < len; i++) {
						arr.push({
							set: set,
							idx: iconSet.icons[i]
						});
					}
					icons = arr;
				} else {
					icons = iconSet;
				}
				var reverse = option.rv,
					ths = option.ths;
				showIconOnly = option.only;
				var v = cell.data,
					min = obj.min,
					max = obj.max;
				if(reverse) {
					icon = "url(" + SCONFIG.CONDITION_ICONS_PATH + "/" + icons[icons.length - 1].set + "/" + icons[icons.length - 1].idx + ".png)";
				} else {
					icon = "url(" + SCONFIG.CONDITION_ICONS_PATH + "/" + icons[0].set + "/" + icons[0].idx + ".png)";
				}
				for(var i = 0, len = ths.length; i < len; i++) {
					var it = ths[i],
						val = it.v,
						unit = it.u,
						compare = it.c || "<=";
					if(Ext.isArray(val)) {
						var span = val[0].span;
						val = this.getCellData(span[0], span[1], span[2], scope).data;
					}
					val = Number(val);
					if("percent" == unit) {
						val = min + val / 100 * (max - min);
					}
					if(Ext.isNumber(val)) {
						if("<=" === compare && v <= val || "<" == compare && v < val) {
							var pos = reverse ? icons[i] : icons[icons.length - 1 - i];
							icon = "url(" + SCONFIG.CONDITION_ICONS_PATH + "/" + pos.set + "/" + pos.idx + ".png)";
							break;
						}
					}
				}
			}
			obj = {
				icon: icon,
				showIconOnly: showIconOnly
			};
			return obj;
		}
	},
	minichart: function(cell, range, option, scope) {
		var miniType = option.type;
		if("column" == miniType) {
			return this.showMiniColumn(cell, range, option, scope);
		} else if("line" == miniType) {
			return this.showMiniLine(cell, range, option, scope);
		} else if("gainloss" == miniType) {
			return this.showMiniGainLoss(cell, range, option, scope);
		}
	},
	showMiniGainLoss: function(cell, range, option, scope) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var base = option.base;
		if(Ext.isObject(base) && base.span) {
			base = base.span;
		}
		var positiveColor = option.pc,
			negativeColor = option.nc;
		if(!SCOM.canbeNumber(base[0])) {
			base[0] = sheet.getSheetId();
		}
		var arr = [];
		scope = Ext.apply({
			isCdt: true
		}, scope);
		store.walkRange([base], function(rd) {
			var cell = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col, scope);
			var data = cell.data;
			data = Number(data);
			if(!Ext.isNumber(data)) {
				data = 0;
			}
			arr.push(data);
		}, this);
		var tmp = [];
		var len = arr.length;
		sl = 5, pl = 90 / len, pw = pl - 2, h = 90;
		var positiveHeight = h / 2,
			negativeHeight = h / 2;
		var positiveVPos = "bottom:" + (negativeHeight + 5) + "%",
			negativeVPos = "top:" + (5 + positiveHeight) + "%";
		for(var i = 0; i < len; i++) {
			var th, vpos, bgc;
			if(0 > arr[i]) {
				th = negativeHeight;
				vpos = negativeVPos;
				bgc = negativeColor;
			} else {
				th = 0 == arr[i] ? 0 : positiveHeight;
				vpos = positiveVPos;
				bgc = positiveColor;
			}
			if(0 != th) {
				th += "%;min-height:1px";
			} else {
				th = th + "%";
			}
			tmp.push({
				bgc: bgc,
				h: th,
				w: pw + "%",
				l: sl + i * pl + "%",
				vpos: vpos
			});
		}
		var mini = SLAYOUT.miniColumnTpl.apply(tmp);
		var obj = {
			mini: mini
		};
		return obj;
	},
	showMiniColumn: function(cell, range, option, scope) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var base = option.base;
		if(Ext.isObject(base) && base.span) {
			base = base.span;
		}
		var positiveColor = option.pc,
			negativeColor = option.nc;
		if(!SCOM.canbeNumber(base[0])) {
			base[0] = sheet.getSheetId();
		}
		var arr = [],
			min = false,
			max = false;
		scope = Ext.apply({
			isCdt: true
		}, scope);
		store.walkRange([base], function(rd) {
			var cell = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col, scope);
			var data = cell.data;
			data = Number(data);
			if(!Ext.isNumber(data)) {
				data = 0;
			}
			arr.push(data);
			if(false === min) {
				min = data;
			} else if(min > data) {
				min = data;
			}
			if(false === max) {
				max = data;
			} else if(max < data) {
				max = data;
			}
		}, this);
		var tmp = [];
		var len = arr.length;
		sl = 5, pl = 90 / len, pw = pl - 2, h = 90;
		if(0 > max) {
			var vpos = "top:5%";
			for(var i = 0; i < len; i++) {
				var th = h * arr[i] / min;
				if(0 != th) {
					th += "%;min-height:1px";
				} else {
					th = th + "%";
				}
				tmp.push({
					bgc: negativeColor,
					h: th,
					w: pw + "%",
					l: sl + i * pl + "%",
					vpos: vpos
				});
			}
		} else if(0 > min && 0 < max) {
			var span = max - min;
			var positiveHeight = h * max / span,
				negativeHeight = -h * min / span;
			var positiveVPos = "bottom:" + (negativeHeight + 5) + "%",
				negativeVPos = "top:" + (5 + positiveHeight) + "%";
			for(var i = 0; i < len; i++) {
				var th, vpos, bgc;
				if(0 > arr[i]) {
					th = negativeHeight * arr[i] / min;
					vpos = negativeVPos;
					bgc = negativeColor;
				} else {
					th = positiveHeight * arr[i] / max;
					vpos = positiveVPos;
					bgc = positiveColor;
				}
				if(0 != th) {
					th += "%;min-height:1px";
				} else {
					th = th + "%";
				}
				tmp.push({
					bgc: bgc,
					h: th,
					w: pw + "%",
					l: sl + i * pl + "%",
					vpos: vpos
				});
			}
		} else {
			var vpos = "bottom:5%";
			for(var i = 0; i < len; i++) {
				var th = h * arr[i] / max;
				if(0 != th) {
					th += "%;min-height:1px";
				} else {
					th = th + "%";
				}
				tmp.push({
					bgc: positiveColor,
					h: th,
					w: pw + "%",
					l: sl + i * pl + "%",
					vpos: vpos
				});
			}
		}
		var mini = SLAYOUT.miniColumnTpl.apply(tmp);
		var obj = {
			mini: mini
		};
		return obj;
	},
	showMiniLine: function(cell, range, option, scope) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var base = option.base;
		if(Ext.isObject(base) && base.span) {
			base = base.span;
		}
		var strokeColor = option.sc;
		if(!SCOM.canbeNumber(base[0])) {
			base[0] = sheet.getSheetId();
		}
		var arr = [],
			min = false,
			max = false;
		scope = Ext.apply({
			isCdt: true
		}, scope);
		store.walkRange([base], function(rd) {
			var cell = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col, scope);
			var data = cell.data;
			data = Number(data);
			if(!Ext.isNumber(data)) {
				data = 0;
			}
			arr.push(data);
			if(false === min) {
				min = data;
			} else if(min > data) {
				min = data;
			}
			if(false === max) {
				max = data;
			} else if(max < data) {
				max = data;
			}
		}, this);
		var tmp = [];
		var len = arr.length;
		h = max - min;
		for(var i = 0; i < len; i++) {
			var th = (arr[i] - min) / h * 100;
			tmp.push({
				h: th
			});
		}
		var nw = 100 / (tmp.length - 1);
		var d = ["M"];
		for(var i = 0, len = tmp.length; i < len; i++) {
			var it = tmp[i];
			d.push(i * nw + "," + (100 - it.h));
			if(len - 1 !== i) {
				d.push("L");
			}
		}
		d = d.join("");
		var mini = ["<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0,0,100,100\" preserveAspectRatio=\"none\" class=\"ss-cell-inside ss-incell-canvas\">", "<path zIndex=\"0\" d=\"", d, "\" stroke-width=\"1\" stroke=\"", strokeColor, "\" fill=\"none\"></path>", "</svg>"].join("");
		var obj = {
			mini: mini
		};
		return obj;
	},
	vd: function(cell, range, option, scope) {
		if(0 === scope.row || 0 === scope.col) {
			return;
		}
		var obj = {};
		if(!this.checkValidate(cell, option)) {
			var html = "<div class=\"ss-validation-sign\" style=\"z-index:" + SCONST.CORNER_Z_INDEX + ";\"></div>";
			Ext.apply(obj, {
				cltcorner: html,
				hint: option.hint || option
			});
		}
		return obj;
	},
	checkValidate: function(cell, option) {
		var dt = option.dt,
			op = option.op;
		var dts = SCONST.validateDataType,
			ops = SCONST.validateOption;
		if(option.ignoreBlank && SCOM.isEmptyValue(cell.data)) {
			return true;
		}
		if(dts.number == dt || dts.currency == dt || dts.percent == dt) {
			var data;
			if(dts.percent == dt) {
				var str = (cell.data || "").toString();
				if("%" === str[str.length - 1]) {
					data = Number(str.slice(0, -1));
					if(Ext.isNumber(data)) {
						data = data / 100;
					}
				} else {
					data = Number(cell.data);
				}
			} else {
				data = Number(cell.data);
			}
			if(!Ext.isDefined(op)) {
				op = ops.any_number;
			}
			var onlyInt = option.io;
			if(ops.between === op) {
				var min = option.min,
					max = option.max;
				if(Ext.isNumber(data) && min <= data && data <= max && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.not_between === op) {
				var min = option.min,
					max = option.max;
				if(Ext.isNumber(data) && (min > data || data > max) && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.less === op) {
				var num = option.num;
				if(Ext.isNumber(data) && num > data && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.less_equal === op) {
				var num = option.num;
				if(Ext.isNumber(data) && num >= data && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.greater === op) {
				var num = option.num;
				if(Ext.isNumber(data) && num < data && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.greater_equal === op) {
				var num = option.num;
				if(Ext.isNumber(data) && num <= data && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.equal === op) {
				var num = option.num;
				if(Ext.isNumber(data) && num === data && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.not_equal === op) {
				var num = option.num;
				if(Ext.isNumber(data) && num !== data && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			} else if(ops.any_number === op) {
				if(Ext.isNumber(data) && (!onlyInt || data === Math.floor(data))) {
					return true;
				}
				return false;
			}
		} else if(dts.text == dt) {
			if(ops.contain === op) {
				var txt = option.txt;
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)) {
					str = str.toString();
					if(-1 !== str.indexOf(txt)) {
						return true;
					}
					return false;
				}
			} else if(ops.not_contain === op) {
				var txt = option.txt;
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)) {
					str = str.toString();
					if(-1 === str.indexOf(txt)) {
						return true;
					}
					return false;
				}
			} else if(ops.equal === op) {
				var txt = option.txt;
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)) {
					str = str.toString();
					if(str === txt) {
						return true;
					}
					return false;
				}
			} else if(ops.is_email === op) {
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)) {
					str = str.toString();
					if(Ext.form.field.VTypes.email(str)) {
						return true;
					}
					return false;
				}
			} else if(ops.is_url === op) {
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)) {
					str = str.toString();
					if(Ext.form.field.VTypes.url(str)) {
						return true;
					}
					return false;
				}
			} else if(ops.is_phone === op) {
				var str = cell.data;
				if(!SCOM.nullOrUndefined(str)) {
					str = str.toString();
					if(/^[\s]*[0-9]+[0-9\s\-\(\))]*$/.test(str)) {
						return true;
					}
					return false;
				}
			}
		} else if(dts.phone == dt) {
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)) {
				str = str.toString();
				if(/^[\s]*[0-9]+[0-9\s\-\(\))]*$/.test(str)) {
					return true;
				}
				return false;
			}
		} else if(dts.url == dt) {
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)) {
				str = str.toString();
				if(Ext.form.field.VTypes.url(str)) {
					return true;
				}
				return false;
			}
		} else if(dts.email == dt) {
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)) {
				str = str.toString();
				if(Ext.form.field.VTypes.email(str)) {
					return true;
				}
				return false;
			}
		} else if(dts.date == dt) {
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)) {
				str = Ext.String.trim(str.toString());
			}
			if(ops.equal === op) {
				var date = option.date;
				if(str) {
					var curDate = SFORMAT.checkingDate(str);
					if("date" === cell.fm && curDate) {
						date = SFORMAT.checkingDate(date);
						if(0 === date - curDate) {
							return true;
						}
					}
					return false;
				}
			} else if(ops.date_before === op) {
				var date = option.date;
				if(str) {
					var curDate = SFORMAT.checkingDate(str);
					if("date" === cell.fm && curDate) {
						date = SFORMAT.checkingDate(date);
						if(0 < date - curDate) {
							return true;
						}
					}
					return false;
				}
			} else if(ops.date_on_before === op) {
				var date = option.date;
				if(str) {
					var curDate = SFORMAT.checkingDate(str);
					if("date" === cell.fm && curDate) {
						date = SFORMAT.checkingDate(date);
						if(0 <= date - curDate) {
							return true;
						}
					}
					return false;
				}
			} else if(ops.date_after === op) {
				var date = option.date;
				if(str) {
					var curDate = SFORMAT.checkingDate(str);
					if("date" === cell.fm && curDate) {
						date = SFORMAT.checkingDate(date);
						if(0 > date - curDate) {
							return true;
						}
					}
					return false;
				}
			} else if(ops.date_on_after === op) {
				var date = option.date;
				if(str) {
					var curDate = SFORMAT.checkingDate(str);
					if("date" === cell.fm && curDate) {
						date = SFORMAT.checkingDate(date);
						if(0 >= date - curDate) {
							return true;
						}
					}
					return false;
				}
			} else if(ops.between === op) {
				var minDate = option.mind,
					maxDate = option.maxd;
				if(str) {
					var curDate = SFORMAT.checkingDate(str);
					if("date" === cell.fm && curDate) {
						minDate = SFORMAT.checkingDate(minDate);
						maxDate = SFORMAT.checkingDate(maxDate);
						if(0 <= maxDate - curDate && 0 >= minDate - curDate) {
							return true;
						}
					}
					return false;
				}
			} else if(ops.not_between === op) {
				var minDate = option.mind,
					maxDate = option.maxd;
				if(str) {
					var curDate = SFORMAT.checkingDate(str);
					if("date" === cell.fm && curDate) {
						minDate = SFORMAT.checkingDate(minDate);
						maxDate = SFORMAT.checkingDate(maxDate);
						if(0 > maxDate - curDate || 0 < minDate - curDate) {
							return true;
						}
					}
					return false;
				}
			} else {
				if(str) {
					if(SFORMAT.checkingDate(str) || SFORMAT.checkingDateTime(str)) {
						return true;
					}
					return false;
				}
			}
		} else if(dts.list == dt || dts.single_select == dt) {
			var list = option.list;
			var str = cell.data;
			if(!SCOM.nullOrUndefined(str)) {
				str = Ext.String.trim(str.toString());
				str = Ext.htmlDecode(str);
				if(-1 !== SCOM.indexOfArray(list, str)) {
					return true;
				}
				return false;
			}
		} else if(dts.multi_options == dt) {
			var list = option.list;
			if(!SCOM.isEmptyValue(cell.data)) {
				var str = Ext.htmlDecode(cell.data.toString());
				var itms = str.split(",");
				if(itms) {
					for(var i = 0, len = itms.length; i < len; i++) {
						var str = Ext.String.trim(itms[i]);
						if(-1 == SCOM.indexOfArray(list, str)) {
							return false;
						}
					}
					return true;
				}
			}
		} else if(dts.checkbox == dt || dts.radio == dt) {
			var str = cell.data;
			if(!SCOM.isEmptyValue(str)) {
				return false;
			}
		} else if(dts.multi_checkbox == dt) {}
		return true;
	},
	boolstyle: function(cell, range, option, scope) {
		var style = option.style;
		var obj = {};
		if(this.testBool(cell, option, scope, range)) {
			for(var p in style) {
				if(style.hasOwnProperty(p)) {
					obj[p] = style[p];
				}
			}
		}
		return obj;
	},
	testBool: function(cell, option, scope, range) {
		var type = option.type;
		if("function" == SCOM.typeOf(this["test" + type])) {
			return this["test" + type].apply(this, arguments);
		}
	},
	getRefVal: function(option, scope) {
		var store = scope.store,
			sheet = scope.sheet;
		var base = option.base;
		scope = Ext.apply({
			me: this,
			isCdt: true
		}, scope);
		if(SCOM.canbeNumber(base)) {
			base = Number(base);
		} else if("array" == SCOM.typeOf(base)) {
			base = this.transferCoord2MinMax(base, sheet).min;
			base = this.getCellData(base[0], base[1], base[2], scope);
			base = base.data;
		} else if("object" == SCOM.typeOf(base)) {
			var span = base.span;
			if(SCONST.RELATIVE_COORD == base.type) {
				span[1] += scope.row;
				span[3] += scope.row;
				span[2] += scope.col;
				span[4] += scope.col;
			}
			base = this.transferCoord2MinMax(span, sheet).min;
			base = this.getCellData(base[0], base[1], base[2], scope);
			base = base.data;
		} else if("string" == SCOM.typeOf(base)) {
			if(option.arg) {
				var o = this.evalCal(option.arg, scope);
				base = o.data;
			} else {
				this.sheet.getDataArrayFromCal(base, function(vals) {
					if(1 == vals.length) {
						base = vals[0];
					} else {
						base = null;
					}
				}, this, scope);
			}
		}
		return base;
	},
	testtrue: function(cell, option, scope) {
		var base = this.getRefVal(option, scope);
		if(base) {
			return true;
		}
		return false;
	},
	testgreater: function(cell, option, scope) {
		var data = cell.data;
		var base = this.getRefVal(option, scope);
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
		}
		return data > base;
	},
	testgreaterEqual: function(cell, option, scope) {
		var data = cell.data;
		var base = this.getRefVal(option, scope);
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
		}
		return data >= base;
	},
	testless: function(cell, option, scope) {
		var data = cell.data;
		var base = this.getRefVal(option, scope);
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
		}
		return data < base;
	},
	testlessEqual: function(cell, option, scope) {
		var data = cell.data;
		var base = this.getRefVal(option, scope);
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
		}
		return data <= base;
	},
	testequal: function(cell, option, scope) {
		var data = cell.data;
		var base = this.getRefVal(option, scope);
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
		}
		return data == base;
	},
	testnotEqual: function(cell, option, scope) {
		var data = cell.data;
		var base = this.getRefVal(option, scope);
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
		}
		return data != base;
	},
	testinclude: function(cell, option, scope) {
		var data = cell.data;
		var base = this.getRefVal(option, scope);
		if(SCOM.isEmptyValue(base)) {
			base = "";
		} else {
			base = base.toString();
		}
		data = data.toString();
		return -1 != data.indexOf(base);
	},
	testrepeat: function(cell, option, scope, range) {
		var store = scope.store,
			sheet = scope.sheet;
		var data = cell.data,
			base = option.base;
		var flag = false;
		var repeat = this.getRepeat(range, scope);
		if(SCONST.REPEAT_VALUE == base) {
			for(var i = 0, len = repeat.length; i < len; i++) {
				if(repeat[i] == data) {
					flag = true;
					break;
				}
			}
		} else {
			flag = true;
			for(var i = 0, len = repeat.length; i < len; i++) {
				if(repeat[i] == data) {
					flag = false;
					break;
				}
			}
		}
		return flag;
	},
	testbetween: function(cell, option, scope) {
		var base = option.base;
		var min = this.getRefVal({
				base: base.min,
				arg: base.minArg
			}, scope),
			max = this.getRefVal({
				base: base.max,
				arg: base.maxArg
			}, scope);
		var data = cell.data;
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(min) && SCOM.canbeNumber(max)) {
			data = Number(data);
			min = Number(min);
			max = Number(max);
		}
		return min <= data && data <= max;
	},
	testnotBetween: function(cell, option, scope) {
		var base = option.base;
		var min = this.getRefVal({
				base: base.min,
				arg: base.minArg
			}, scope),
			max = this.getRefVal({
				base: base.max,
				arg: base.maxArg
			}, scope);
		var data = cell.data;
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(min) && SCOM.canbeNumber(max)) {
			data = Number(data);
			min = Number(min);
			max = Number(max);
		}
		return min > data || data > max;
	},
	testdate: function(cell, option, scope) {
		var store = scope.store,
			sheet = scope.sheet;
		var data = cell.data,
			base = option.base;
		var flag = false,
			date = SFORMAT.checkingDate(data),
			todate = new Date;
		var today = Ext.Date.format(todate, "Ymd"),
			day = Ext.Date.format(date, "Ymd");
		if(date) {
			if(SCONST.YESTERDAY == base) {
				if(day < today && Ext.Date.format(Ext.Date.add(date, Ext.Date.DAY, 1), "Ymd") == today) {
					flag = true;
				}
			} else if(SCONST.TODAY == base) {
				if(day == today) {
					flag = true;
				}
			} else if(SCONST.TOMORROW == base) {
				if(day > today && Ext.Date.format(Ext.Date.add(date, Ext.Date.DAY, -1), "Ymd") == today) {
					flag = true;
				}
			} else if(SCONST.SEVEN_DAY == base) {
				if(day <= today && Ext.Date.format(Ext.Date.add(date, Ext.Date.DAY, 6), "Ymd") >= today) {
					flag = true;
				}
			} else if(SCONST.LAST_WEEK == base) {
				if(day < today) {
					var offset = 1 + Number(Ext.Date.format(todate, "w"));
					var end = Ext.Date.add(todate, Ext.Date.DAY, -offset),
						start = Ext.Date.add(end, Ext.Date.DAY, -6);
					if(day <= Ext.Date.format(end, "Ymd") && day >= Ext.Date.format(start, "Ymd")) {
						flag = true;
					}
				}
			} else if(SCONST.THIS_WEEK == base) {
				var offset = Ext.Date.format(todate, "w");
				var start = Ext.Date.add(todate, Ext.Date.DAY, -offset),
					end = Ext.Date.add(start, Ext.Date.DAY, 6);
				if(day <= Ext.Date.format(end, "Ymd") && day >= Ext.Date.format(start, "Ymd")) {
					flag = true;
				}
			} else if(SCONST.NEXT_WEEK == base) {
				if(day > today) {
					var offset = 7 - Ext.Date.format(todate, "w");
					var start = Ext.Date.add(todate, Ext.Date.DAY, offset),
						end = Ext.Date.add(start, Ext.Date.DAY, 6);
					if(day <= Ext.Date.format(end, "Ymd") && day >= Ext.Date.format(start, "Ymd")) {
						flag = true;
					}
				}
			} else if(SCONST.LAST_MONTH == base) {
				if(day < today) {
					var end = Ext.Date.add(todate, Ext.Date.DAY, -Ext.Date.format(todate, "j")),
						start = Ext.Date.getFirstDateOfMonth(end);
					if(day <= Ext.Date.format(end, "Ymd") && day >= Ext.Date.format(start, "Ymd")) {
						flag = true;
					}
				}
			} else if(SCONST.THIS_MONTH == base) {
				var start = Ext.Date.getFirstDateOfMonth(todate),
					end = Ext.Date.getLastDateOfMonth(todate);
				if(day <= Ext.Date.format(end, "Ymd") && day >= Ext.Date.format(start, "Ymd")) {
					flag = true;
				}
			} else if(SCONST.NEXT_MONTH == base) {
				if(day > today) {
					var start = Ext.Date.add(todate, Ext.Date.DAY, Ext.Date.getDaysInMonth(todate) - Ext.Date.format(todate, "j") + 1),
						end = Ext.Date.getLastDateOfMonth(start);
					if(day <= Ext.Date.format(end, "Ymd") && day >= Ext.Date.format(start, "Ymd")) {
						flag = true;
					}
				}
			}
		}
		return flag;
	},
	testaverage: function(cell, option, scope, range) {
		var store = scope.store,
			sheet = scope.sheet;
		var data = cell.data,
			base = option.base;
		var flag = false;
		if(SCOM.canbeNumber(data)) {
			data = Number(data);
			var average = this.getAverage(range, scope, {
				isCdt: true
			});
			if(SCONST.BELOW_AVERAGE == base) {
				if(data < average) {
					flag = true;
				}
			} else {
				if(data > average) {
					flag = true;
				}
			}
		}
		return flag;
	},
	testmax: function(cell, option, scope, range) {
		var store = scope.store,
			sheet = scope.sheet;
		var data = cell.data,
			base = option.base;
		var flag = false;
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
			var value = this.getPositionValue(base, false, range, scope);
			if(false != SCOM.typeOf(value) && data >= value) {
				flag = true;
			}
		}
		return flag;
	},
	testmin: function(cell, option, scope, range) {
		var store = scope.store,
			sheet = scope.sheet;
		var data = cell.data,
			base = option.base;
		var flag = false;
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = -Number(base);
			var value = this.getPositionValue(base, false, range, scope);
			if(false != SCOM.typeOf(value) && data <= value) {
				flag = true;
			}
		}
		return flag;
	},
	testtop: function(cell, option, scope, range) {
		var store = scope.store,
			sheet = scope.sheet;
		var data = cell.data,
			base = option.base;
		var flag = false;
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = Number(base);
			var value = this.getPositionValue(base, true, range, scope);
			if(false != SCOM.typeOf(value) && data >= value) {
				flag = true;
			}
		}
		return flag;
	},
	testbottom: function(cell, option, scope, range) {
		var store = scope.store,
			sheet = scope.sheet;
		var data = cell.data,
			base = option.base;
		var flag = false;
		if(SCOM.canbeNumber(data) && SCOM.canbeNumber(base)) {
			data = Number(data);
			base = -Number(base);
			var value = this.getPositionValue(base, true, range, scope);
			if(false != SCOM.typeOf(value) && data <= value) {
				flag = true;
			}
		}
		return flag;
	},
	beforeRemoveRow: function(sheetId, minrow, maxrow, mincol, maxcol, cdtArr, suspendUpdate) {
		var me = this;
		var dspan = maxrow - minrow + 1;
		var store = this.sheet.getStore(),
			needRefreshCdt, oldCdtCache = {},
			oldCells, curCells, curCdtCache = {},
			rowColCdtCache = {};
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
		var checkRngFn = function(rng) {
			var changed = false,
				newRng = [];
			for(var i = 0, count = rng.length; i < count; i++) {
				var rngItem = rng[i];
				var span = rngItem.span,
					type = rngItem.type;
				var top = span[1],
					bottom = span[3],
					left = span[2],
					right = span[4],
					flag = false;
				if(top || bottom) {
					if(0 === right) {
						rowColCdtCache[it.id] = it;
					}
					if((!mincol || mincol <= left) && (!maxcol || right <= maxcol && 0 !== right)) {
						if(minrow <= bottom || 0 === bottom) {
							var topRow = maxrow < top ? top - dspan : minrow < top ? minrow : top;
							var bottomRow = 0;
							if(0 !== bottom) {
								bottomRow = bottom - dspan;
								if(top < minrow && maxrow > bottom) {
									bottomRow = minrow - 1;
								}
							}
							top = topRow;
							bottom = bottomRow;
							flag = true;
						} else {
							newRng.push(rngItem);
						}
						if(flag) {
							changed = true;
							if(top <= bottom || 0 === bottom && 0 === span[3]) {
								span[1] = top;
								span[3] = bottom;
								newRng.push(rngItem);
							}
						}
					} else if(left <= mincol && (mincol <= right || 0 === right) || left <= maxcol && (maxcol <= right || 0 === right)) {
						var leftCol = mincol < left ? left : mincol,
							rightCol = 0 !== right && maxcol > right ? right : maxcol;
						if(minrow <= bottom || 0 === bottom) {
							var topRow = maxrow < top ? top - dspan : minrow < top ? minrow : top;
							var bottomRow = 0;
							if(0 !== bottom) {
								bottomRow = bottom - dspan;
								if(top < minrow && maxrow > bottom) {
									bottomRow = minrow - 1;
								}
							}
							if(left < leftCol) {
								if(0 === left) {
									left = 1;
								}
								newRng.push({
									span: [span[0], top, left, bottom, leftCol - 1],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							if(bottomRow >= topRow || 0 === bottomRow) {
								newRng.push({
									span: [span[0], topRow, leftCol, bottomRow, rightCol],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							if(right > rightCol || 0 === right) {
								newRng.push({
									span: [span[0], top, rightCol + 1, bottom, right],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							changed = true;
						} else {
							newRng.push(rngItem);
						}
					} else {
						newRng.push(rngItem);
					}
				} else {
					newRng.push(rngItem);
				}
			}
			newRng = me.sheet.connectSpan(newRng);
			return {
				rng: newRng,
				changed: changed
			};
		};
		for(var k = 0, len = cdtArr.length; k < len; k++) {
			var it = cdtArr[k];
			var myRng = it.rng;
			var cdtName = it.name,
				changed, newRng, needRemoved;
			if("minichart" === cdtName) {
				var obj = checkRngFn(myRng);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
				myRng = [it.opt.base];
				obj = checkRngFn(myRng);
				changed = changed || obj.changed;
				newRng = obj.rng;
				it.opt.base = newRng[0];
				needRemoved = needRemoved || 0 === newRng.length;
			} else {
				var obj = checkRngFn(myRng);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
			}
			if(changed) {
				needRefreshCdt = true;
				var cid = it.id + "-" + sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: old ? old.json : undefined
				};
				var json;
				if(needRemoved) {
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt");
					}
				} else {
					json = Ext.encode(it);
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt", json);
					}
				}
				curCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: json
				};
			}
		}
		var ret = {
			oldCdt: oldCdtCache,
			curCdt: curCdtCache,
			needRefreshCdt: needRefreshCdt
		};
		if(oldCells) {
			if(ret.oldCells) {
				Ext.apply(ret.oldCells, oldCells);
			} else {
				ret.oldCells = oldCells;
			}
		}
		if(curCells) {
			if(ret.curCells) {
				Ext.applyIf(ret.curCells, curCells);
			} else {
				ret.curCells = curCells;
			}
		}
		return ret;
	},
	beforeRemoveColumn: function(sheetId, mincol, maxcol, minrow, maxrow, cdtArr, suspendUpdate) {
		var me = this;
		var dspan = maxcol - mincol + 1;
		var store = this.sheet.getStore(),
			needRefreshCdt, oldCdtCache = {},
			curCdtCache = {},
			oldCells, curCells, rowColCdtCache = {};
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
		var checkRngFn = function(rng) {
			var changed = false,
				newRng = [];
			for(var i = 0, count = rng.length; i < count; i++) {
				var rngItem = rng[i];
				var span = rngItem.span,
					type = rngItem.type;
				var top = span[1],
					bottom = span[3],
					left = span[2],
					right = span[4],
					flag = false;
				if(0 == bottom) {
					rowColCdtCache[it.id] = it;
				}
				if(left || right) {
					if((!minrow || minrow <= top) && (!maxrow || bottom <= maxrow && 0 !== bottom)) {
						if(mincol <= right || 0 === right) {
							var leftCol = maxcol < left ? left - dspan : mincol < left ? mincol : left;
							var rightCol = 0;
							if(0 !== right) {
								rightCol = right - dspan;
								if(left < mincol && maxcol > right) {
									rightCol = mincol - 1;
								}
							}
							left = leftCol;
							right = rightCol;
							flag = true;
						}
						if(flag) {
							changed = true;
							if(left <= right || 0 === right && 0 === span[4]) {
								span[2] = left;
								span[4] = right;
								newRng.push(rngItem);
							}
						}
					} else if(top <= minrow && (minrow <= bottom || 0 === bottom) || top <= maxrow && (maxrow <= bottom || 0 === bottom)) {
						var topRow = minrow < top ? top : minrow,
							bottomRow = maxrow > bottom && 0 !== bottom ? bottom : maxrow;
						if(mincol <= right || 0 === right) {
							var leftCol = maxcol < left ? left - dspan : mincol < left ? mincol : left;
							var rightCol = 0;
							if(0 !== right) {
								rightCol = right - dspan;
								if(left < mincol && maxcol > right) {
									rightCol = mincol - 1;
								}
							}
							if(top < topRow) {
								if(0 == top) {
									top = 1;
								}
								newRng.push({
									span: [span[0], top, left, topRow - 1, right],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							if(rightCol >= leftCol || 0 === rightCol) {
								newRng.push({
									span: [span[0], topRow, leftCol, bottomRow, rightCol],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							if(bottom > bottomRow || 0 === bottom) {
								newRng.push({
									span: [span[0], bottomRow + 1, left, bottom, right],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							flag = true;
							changed = true;
						}
					}
				}
				if(!flag) {
					newRng.push(rngItem);
				}
			}
			newRng = me.sheet.connectSpan(newRng);
			return {
				rng: newRng,
				changed: changed
			};
		};
		for(var k = 0, len = cdtArr.length; k < len; k++) {
			var it = cdtArr[k];
			var myRng = it.rng;
			var cdtName = it.name,
				changed, newRng, needRemoved;
			if("minichart" === cdtName) {
				var obj = checkRngFn(myRng);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
				myRng = [it.opt.base];
				obj = checkRngFn(myRng);
				changed = changed || obj.changed;
				newRng = obj.rng;
				it.opt.base = newRng[0];
				needRemoved = needRemoved || 0 === newRng.length;
			} else {
				var obj = checkRngFn(myRng);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
			}
			if(changed) {
				needRefreshCdt = true;
				var cid = it.id + "-" + sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: old ? old.json : undefined
				};
				var json;
				if(needRemoved) {
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt");
					}
				} else {
					json = Ext.encode(it);
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt", json);
					}
				}
				curCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: json
				};
			}
		}
		var ret = {
			oldCdt: oldCdtCache,
			curCdt: curCdtCache,
			needRefreshCdt: needRefreshCdt
		};
		if(oldCells) {
			if(ret.oldCells) {
				Ext.apply(ret.oldCells, oldCells);
			} else {
				ret.oldCells = oldCells;
			}
		}
		if(curCells) {
			if(ret.curCells) {
				Ext.applyIf(ret.curCells, curCells);
			} else {
				ret.curCells = curCells;
			}
		}
		return ret;
	},
	beforeRemoveCell: function(sheet, minrow, maxrow, mincol, maxcol, moveDir) {
		if("up" == moveDir) {
			return this.beforeRemoveRow(sheet, minrow, maxrow, mincol, maxcol);
		} else if("left" == moveDir) {
			return this.beforeRemoveColumn(sheet, mincol, maxcol, minrow, maxrow);
		}
	},
	beforeInsertRow: function(sheetId, minrow, rowSpan, mincol, colSpan, cdtArr, suspendUpdate) {
		var me = this;
		var maxrow = minrow + rowSpan - 1,
			maxcol = mincol + colSpan - 1;
		var store = this.sheet.getStore(),
			needRefreshCdt, oldCdtCache = {},
			curCdtCache = {},
			rowColCdtCache = {},
			newCdtCellsCache = {};
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
		var checkRngFn = function(rng, curCdtName) {
			var changed = false,
				newRng = [];
			for(var i = 0, count = rng.length; i < count; i++) {
				var rngItem = rng[i];
				var span = rngItem.span,
					type = rngItem.type;
				var top = span[1],
					bottom = span[3],
					left = span[2],
					right = span[4],
					flag = false;
				if(top || bottom) {
					if(0 === right) {
						rowColCdtCache[id] = it;
					}
					if((!mincol || mincol <= left) && (!maxcol || right <= maxcol && 0 !== right)) {
						if(minrow <= bottom || 0 === bottom) {
							var topRow = minrow <= top ? top + rowSpan : top;
							var bottomRow = 0;
							if(0 !== bottom) {
								bottomRow = bottom + rowSpan;
							}
							top = topRow;
							bottom = bottomRow;
							if(top < minrow) {
								var coord = newCdtCellsCache[id];
								if(!coord) {
									newCdtCellsCache[id] = {
										coord: [],
										name: curCdtName
									};
									coord = newCdtCellsCache[id].coord;
								} else {
									coord = coord.coord;
								}
								coord.push([span[0], minrow, left, maxrow, right]);
							}
							flag = true;
						} else {
							newRng.push(rngItem);
						}
						if(flag) {
							changed = true;
							span[1] = top;
							span[3] = bottom;
							newRng.push(rngItem);
						}
					} else if(left <= mincol && (mincol <= right || 0 === right) || left <= maxcol && (maxcol <= right || 0 === right)) {
						var leftCol = mincol < left ? left : mincol,
							rightCol = 0 !== right && maxcol > right ? right : maxcol;
						if(minrow <= bottom || 0 === bottom) {
							var topRow = minrow <= top ? top + rowSpan : top;
							var bottomRow = 0;
							if(0 !== bottom) {
								bottomRow = bottom + rowSpan;
							}
							if(left < leftCol) {
								if(0 === left) {
									left = 1;
								}
								newRng.push({
									span: [span[0], top, left, bottom, leftCol - 1],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							newRng.push({
								span: [span[0], topRow, leftCol, bottomRow, rightCol],
								type: SCONST.ABSOLUTE_COORD
							});
							if(top < minrow) {
								var coord = newCdtCellsCache[id];
								if(!coord) {
									newCdtCellsCache[id] = {
										coord: [],
										name: curCdtName
									};
									coord = newCdtCellsCache[id].coord;
								} else {
									coord = coord.coord;
								}
								coord.push([span[0], minrow, leftCol, maxrow, rightCol]);
							}
							if(right > rightCol || 0 === right) {
								newRng.push({
									span: [span[0], top, rightCol + 1, bottom, right],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							changed = true;
						} else {
							newRng.push(rngItem);
						}
					} else {
						newRng.push(rngItem);
					}
				} else {
					newRng.push(rngItem);
				}
			}
			newRng = me.sheet.connectSpan(newRng);
			return {
				rng: newRng,
				changed: changed
			};
		};
		for(var k = 0, len = cdtArr.length; k < len; k++) {
			var it = cdtArr[k],
				id = it.id;
			var myRng = it.rng;
			var cdtName = it.name,
				changed, newRng, needRemoved;
			if("minichart" === cdtName) {
				var obj = checkRngFn(myRng, cdtName);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
				myRng = [it.opt.base];
				obj = checkRngFn(myRng, cdtName);
				changed = changed || obj.changed;
				newRng = obj.rng;
				it.opt.base = newRng[0];
				needRemoved = needRemoved || 0 === newRng.length;
			} else {
				var obj = checkRngFn(myRng, cdtName);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
			}
			if(changed) {
				needRefreshCdt = true;
				var cid = it.id + "-" + sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: old ? old.json : undefined
				};
				var json;
				if(needRemoved) {
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt");
					}
				} else {
					json = Ext.encode(it);
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt", json);
					}
				}
				curCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: json
				};
			}
		}
		return {
			oldCdt: oldCdtCache,
			curCdt: curCdtCache,
			needRefreshCdt: needRefreshCdt
		};
	},
	beforeInsertColumn: function(sheetId, mincol, colSpan, minrow, rowSpan, cdtArr, suspendUpdate) {
		var me = this;
		var maxcol = mincol + colSpan - 1,
			maxrow = minrow + rowSpan - 1;
		var store = this.sheet.getStore(),
			needRefreshCdt, oldCdtCache = {},
			curCdtCache = {},
			rowColCdtCache = {},
			newCdtCellsCache = {};
		cdtArr = cdtArr || store.getConditionBySheet(sheetId);
		var checkRngFn = function(rng, curCdtName) {
			var changed = false,
				newRng = [];
			for(var i = 0, count = rng.length; i < count; i++) {
				var rngItem = rng[i];
				var span = rngItem.span,
					type = rngItem.type;
				var top = span[1],
					bottom = span[3],
					left = span[2],
					right = span[4],
					flag = false;
				if(left || right) {
					if(0 === bottom) {
						rowColCdtCache[id] = it;
					}
					if((!minrow || minrow <= top) && (!maxrow || bottom <= maxrow && 0 !== bottom)) {
						if(mincol <= right || 0 === right) {
							var leftCol = mincol <= left ? left + colSpan : left;
							var rightCol = 0;
							if(0 !== right) {
								rightCol = right + colSpan;
							}
							left = leftCol;
							right = rightCol;
							if(left < mincol) {
								var coord = newCdtCellsCache[id];
								if(!coord) {
									newCdtCellsCache[id] = {
										coord: [],
										name: curCdtName
									};
									coord = newCdtCellsCache[id].coord;
								} else {
									coord = coord.coord;
								}
								coord.push([span[0], top, mincol, bottom, maxcol]);
							}
							flag = true;
						} else {
							newRng.push(rngItem);
						}
						if(flag) {
							changed = true;
							span[2] = left;
							span[4] = right;
							newRng.push(rngItem);
						}
					} else if(top <= minrow && (minrow <= bottom || 0 === bottom) || top <= maxrow && (maxrow <= bottom || 0 === bottom)) {
						var topRow = minrow < top ? top : minrow,
							bottomRow = 0 !== bottom && maxrow > bottom ? bottom : maxrow;
						if(mincol <= right || 0 === right) {
							var leftCol = mincol <= left ? left + colSpan : left;
							var rightCol = 0;
							if(0 !== right) {
								rightCol = right + colSpan;
							}
							if(top < topRow) {
								if(0 === top) {
									top = 1;
								}
								newRng.push({
									span: [span[0], top, left, topRow - 1, right],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							newRng.push({
								span: [span[0], topRow, leftCol, bottomRow, rightCol],
								type: SCONST.ABSOLUTE_COORD
							});
							if(left < mincol) {
								var coord = newCdtCellsCache[id];
								if(!coord) {
									newCdtCellsCache[id] = {
										coord: [],
										name: curCdtName
									};
									coord = newCdtCellsCache[id].coord;
								} else {
									coord = coord.coord;
								}
								coord.push([span[0], topRow, mincol, bottomRow, maxcol]);
							}
							if(bottom > bottomRow || 0 === bottom) {
								newRng.push({
									span: [span[0], bottomRow + 1, left, bottom, right],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							changed = true;
						} else {
							newRng.push(rngItem);
						}
					} else {
						newRng.push(rngItem);
					}
				} else {
					newRng.push(rngItem);
				}
			}
			newRng = me.sheet.connectSpan(newRng);
			return {
				rng: newRng,
				changed: changed
			};
		};
		for(var k = 0, len = cdtArr.length; k < len; k++) {
			var it = cdtArr[k],
				id = it.id;
			var myRng = it.rng;
			var cdtName = it.name,
				changed, newRng, needRemoved;
			if("minichart" === cdtName) {
				var obj = checkRngFn(myRng, cdtName);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
				myRng = [it.opt.base];
				obj = checkRngFn(myRng, cdtName);
				changed = changed || obj.changed;
				newRng = obj.rng;
				it.opt.base = newRng[0];
				needRemoved = needRemoved || 0 === newRng.length;
			} else {
				var obj = checkRngFn(myRng, cdtName);
				changed = obj.changed;
				newRng = obj.rng;
				it.rng = newRng;
				needRemoved = 0 === newRng.length;
			}
			if(changed) {
				needRefreshCdt = true;
				var cid = it.id + "-" + sheetId;
				var old = store.getFloatingById(it.id, sheetId);
				oldCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: old ? old.json : undefined
				};
				var json;
				if(needRemoved) {
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt");
					}
				} else {
					json = Ext.encode(it);
					if(!suspendUpdate) {
						store.setFloatingItem(sheetId, it.id, "cdt", json);
					}
				}
				curCdtCache[cid] = {
					name: it.id,
					sheet: sheetId,
					ftype: "cdt",
					json: json
				};
			}
		}
		return {
			oldCdt: oldCdtCache,
			curCdt: curCdtCache,
			needRefreshCdt: needRefreshCdt
		};
	},
	beforeInsertCell: function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, e, sheet) {
		if("down" == moveDir) {
			return this.beforeInsertRow(sheetId, row, rowSpan, col, colSpan);
		} else if("right" == moveDir) {
			return this.beforeInsertColumn(sheetId, col, colSpan, row, rowSpan);
		}
	},
	resetConditionData: function(cdtObj, store, sheetId, row, col, oldSheetId, oldRow, oldCol) {
		return cdtObj;
	},
	getConditionRelatedCoord: function(cdts, sheetId) {
		var store = this.sheet.getStore();
		var coord = [];
		for(var i = 0, len = cdts.length; i < len; i++) {
			var cdt = cdts[i];
			cdt = store.getConditionById(cdt.id, sheetId);
			var name = cdt.name;
			if("minichart" == name) {
				var opt = cdt.opt;
				coord = coord.concat(opt.base);
			} else {
				var rng = cdt.rng;
				for(var j = 0, count = rng.length; j < count; j++) {
					coord.push(rng[j].span);
				}
			}
		}
		return coord;
	}
}, function() {
	Ext.apply(EnterpriseSheet.pure.sheet.calculate.Condition.prototype, {
		styles: ["cbg", "cbgc", "bar", "icon", "showIconOnly", "ccolor", "cfw", "cltcorner", "hint", "mini"],
		styleMap: {
			cbg: "bg",
			cbgc: "bgc",
			ccolor: "color",
			cfw: "fw",
			cltcorner: "ltcorner"
		},
		stylesWithoutMini: ["cbg", "cbgc", "bar", "icon", "showIconOnly", "ccolor", "cfw", "cltcorner", "hint"],
		presetCdtObj: function(cdt, store) {
			var curSheetId = store.getActivedSheetId(),
				sep = store.separateChar;
			var ret = {};
			var rng = cdt.rng,
				cdtName = cdt.name;
			var coord = [];
			for(var i = 0, len = rng.length; i < len; i++) {
				coord.push(rng[i].span);
			}
			var cells = [].concat(coord),
				refs = [],
				refreshWholeCoordRefs = [],
				relativeCoordMap = {};
			var processRefs = function(arg) {
				var o = this.transferCalculate({
					data: this.isCalculate(arg) ? arg : "=" + arg
				}, store, curSheetId, undefined, undefined, "named_func");
				if(o.refs) {
					var namedFuncs = [];
					for(var k = 0, size = o.refs.length; k < size; k++) {
						var span = o.refs[k];
						refs.push(span);
						refreshWholeCoordRefs.push(span);
						if(Ext.isString(span)) {
							namedFuncs.push(span);
						}
					}
					if(0 < namedFuncs.length) {
						refs = refs.concat(store.prepareRefCoordFromNamedFuncs(namedFuncs, function(span, ctype) {
							if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
								var res = [];
								var tmp = [].concat(span);
								var id = tmp.join(sep) + "-" + ctype;
								relativeCoordMap[id] = {
									span: tmp,
									type: ctype
								};
								for(var x = 0, count = coord.length; x < count; x++) {
									var coordSpan = coord[x];
									if(coordSpan[0] === span[0]) {
										tmp = [].concat(tmp);
										tmp[2] += coordSpan[2];
										tmp[4] += coordSpan[4];
										res.push(tmp);
									}
								}
								return res;
							} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
								var res = [];
								var tmp = [].concat(span);
								var id = tmp.join(sep) + "-" + ctype;
								relativeCoordMap[id] = {
									span: tmp,
									type: ctype
								};
								for(var x = 0, count = coord.length; x < count; x++) {
									var coordSpan = coord[x];
									if(coordSpan[0] === span[0]) {
										tmp = [].concat(tmp);
										tmp[1] += coordSpan[1];
										tmp[3] += coordSpan[3];
										res.push(tmp);
									}
								}
								return res;
							}
						}, this));
					}
				} else if(o.relativeCoordsInNamedFunc) {
					for(var k = 0, size = o.relativeCoordsInNamedFunc.length; k < size; k++) {
						var coordObj = o.relativeCoordsInNamedFunc[k],
							ctype = coordObj.type,
							span = coordObj.span;
						var id = span.join(sep) + "-" + ctype;
						relativeCoordMap[id] = {
							span: span,
							type: ctype
						};
						if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
							for(var x = 0, count = coord.length; x < count; x++) {
								var coordSpan = coord[x];
								if(coordSpan[0] === span[0]) {
									span = [].concat(span);
									span[2] += coordSpan[2];
									span[4] += coordSpan[4];
									refs.push(span);
								}
							}
						} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
							for(var x = 0, count = coord.length; x < count; x++) {
								var coordSpan = coord[x];
								if(coordSpan[0] === span[0]) {
									span = [].concat(span);
									span[1] += coordSpan[1];
									span[3] += coordSpan[3];
									refs.push(span);
								}
							}
						}
					}
				}
				return o;
			};
			if("boolstyle" === cdtName || "minichart" === cdtName) {
				var opt = cdt.opt,
					base = opt.base;
				if(Ext.isObject(base)) {
					if(base.span) {
						coord.push(base.span);
					} else {
						if(Ext.isString(base.min)) {
							var o = processRefs.call(this, base.min);
							if(o.cal) {
								opt.minArg = o.arg;
							} else {
								delete opt.minArg;
							}
						}
						if(Ext.isString(base.max)) {
							var o = processRefs.call(this, base.max);
							if(o.cal) {
								opt.maxArg = o.arg;
							} else {
								delete opt.maxArg;
							}
						}
					}
				} else if(Ext.isString(base)) {
					var o = processRefs.call(this, base);
					if(o.cal) {
						opt.arg = o.arg;
					} else {
						delete opt.arg;
					}
				}
			} else if("colorbar" == cdtName) {
				var opt = cdt.opt,
					min = opt.min,
					max = opt.max;
				var o = processRefs.call(this, min);
				if(o.cal) {
					opt.minArg = o.arg;
				} else {
					delete opt.minArg;
				}
				o = processRefs.call(this, max);
				if(o.cal) {
					opt.maxArg = o.arg;
				} else {
					delete opt.maxArg;
				}
			}
			refs = refs.concat(coord);
			var res = Ext.apply(ret, {
				cells: cells,
				refs: refs
			});
			if("boolstyle" === cdtName && 0 < refreshWholeCoordRefs.length) {
				res.refreshWholeCoordRefs = refreshWholeCoordRefs;
				res.relativeCoordMap = relativeCoordMap;
			}
			return res;
		},
		generateHint: function(json) {
			var dtype = json.dt,
				op = json.op;
			var text = "";
			var dts = SCONST.validateDataType;
			var options = SCONST.validateOption;
			for(var p in dts) {
				if(dts[p] === dtype) {
					text = SLANG[p] + " : ";
					break;
				}
			}
			if(Ext.isDefined(op)) {
				for(var p in options) {
					if(options[p] === op) {
						text += SLANG[p];
						break;
					}
				}
				if(dts.number === dtype) {
					var intOnly = json.io,
						min = json.min,
						max = json.max,
						num = json.num;
					if(options.between === op || options.not_between === op) {
						text += " [" + min + ", " + max + "]";
					} else if(options.any_number !== op) {
						text += " " + num;
					}
					if(intOnly) {
						text += "; " + SLANG.integer_only;
					}
				} else if(dts.date === dtype) {
					var mind = json.mind,
						maxd = json.maxd;
					if(options.between === op || options.not_between === op) {
						text += " [" + mind + ", " + maxd + "]";
					} else if(options.is_date !== op) {
						text += " " + json.date;
					}
				} else if(dts.text === dtype) {
					if(options.is_email !== op && options.is_url !== op) {
						text += " \"" + json.txt + "\"";
					}
				}
			} else if(dts.list === dtype || dts.single_select === dtype) {
				text = SLANG.should_be_one_of + " : {" + json.list.join(", ") + "}";
			} else if(dts.multi_options === dtype) {
				text = SLANG.should_be_part_of + " : {" + json.list.join(", ") + "}";
			} else if(dts.checkbox === dtype) {
				text += SLANG.check_uncheck_only;
			} else if(dts.phone === dtype) {
				text += SLANG.phone_type_hint;
			} else if(dts.url === dtype) {
				text += SLANG.url_type_hint;
			} else if(dts.email === dtype) {
				text += SLANG.email_type_hint;
			} else if(dts.currency === dtype) {
				text += SLANG.should_be_a_number;
			} else if(dts.percent === dtype) {
				text += SLANG.should_be_a_number_or_percent;
			}
			return text;
		}
	});
});

Ext.define("EnterpriseSheet.pure.sheet.data.CalReferenceMap", {
	extend: "EnterpriseSheet.pure.common.SortedArray",
	requires: ["EnterpriseSheet.pure.sheet.calculate.Coordinate"],
	constructor: function(config) {
		Ext.apply(this, config);
		this.namedFuncMap = {};
		EnterpriseSheet.pure.sheet.data.CalReferenceMap.prototype.superclass.constructor.apply(this);
	},
	emptyNamedFuncMap: function() {
		this.namedFuncMap = {};
	},
	compare: function(a, b) {
		var len = 5;
		for(var i = 0; i < len; i++) {
			var ai = a[i],
				bi = b[i];
			if(ai < bi) {
				return -1;
			} else if(ai > bi) {
				return 1;
			}
		}
		return 0;
	},
	add: function(span, pos) {
		if(Ext.isArray(span)) {
			var res = this.find(span),
				i = res.index;
			if(0 === res.flag) {
				var it = this.arr[i],
					map = it[5];
				Ext.apply(map, pos);
			} else {
				span = span.concat([pos]);
				this.arr.splice(i, 0, span);
			}
		} else {
			var nf = this.namedFuncMap[span] = this.namedFuncMap[span] || {};
			Ext.apply(nf, pos);
		}
	},
	getDirectRelatedForNamedFunc: function(name) {
		var map = this.namedFuncMap[name];
		return Ext.apply({}, map);
	},
	getDirectRelatedCells: function() {
		if(3 === arguments.length) {
			return this.getDirectRelatedForCell.apply(this, arguments);
		} else {
			return this.getDirectRelatedForNamedFunc.apply(this, arguments);
		}
	},
	getDirectRelatedForCell: function(s, r, c) {
		return this.getDirectRelatedForRange(s, r, c, r, c);
	},
	getDirectRelatedForRange: function(s, r, c, er, ec) {
		var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var span = [s, r, c, er, ec];
		var start = this.find(span).index;
		var span1 = [s, er, ec + 1, er, ec + 1];
		var end = this.find(span1).index,
			arr = this.arr;
		var lookup = {};
		for(var i = start; i < end; i++) {
			var it = arr[i],
				map = it[5];
			Ext.apply(lookup, map);
		}
		for(var i = start - 1; 0 <= i; i--) {
			var it = arr[i];
			if(it[0] === s) {
				if((0 === it[3] || 0 === r || it[3] >= r) && (0 === it[4] || 0 === c || it[4] >= c)) {
					Ext.apply(lookup, it[5]);
				} else {
					if(0 < i) {
						var pre = arr[i - 1];
						if(pre[0] === s && pre[1] === it[1] && pre[2] === it[2]) {
							var tmp = [s, it[1], it[2], it[1], it[2]];
							var res = this.find(tmp, 0, i - 1);
							i = res.index;
						}
					}
				}
			} else {
				break;
			}
		}
		if(0 === r && 0 === c) {
			for(var i = end, len = arr.length; i < len; i++) {
				var it = arr[i];
				if(it[0] === s) {
					Ext.apply(lookup, it[5]);
				} else {
					break;
				}
			}
		} else if(0 === r) {
			for(var i = end, len = arr.length; i < len; i++) {
				var it = arr[i];
				if(it[0] === s) {
					if(coordPro.isOverlappedSpan(it, span)) {
						Ext.apply(lookup, it[5]);
					}
				} else {
					break;
				}
			}
		} else if(0 === c) {
			for(var i = end, len = arr.length; i < len; i++) {
				var it = arr[i];
				if(it[0] === s && it[1] === er) {
					Ext.apply(lookup, it[5]);
				} else {
					break;
				}
			}
		} else {}
		return lookup;
	},
	getAllRelatedCells: function(s, r, c) {
		var stack = [
				[s, r, c]
			],
			cells = {};
		while(stack.length) {
			var it = stack.pop();
			var found = this.getDirectRelatedCells(it[0], it[1], it[2]);
			for(var p in found) {
				if(found.hasOwnProperty(p) && !cells.hasOwnProperty(p)) {
					stack.push(found[p]);
				}
			}
			Ext.apply(cells, found);
		}
		return cells;
	},
	syncMap: function(id, refs, oldRefs, pos) {
		var arr = this.arr;
		if(oldRefs) {
			for(var i = 0, len = oldRefs.length; i < len; i++) {
				var span = oldRefs[i];
				var res = this.find(span);
				if(0 === res.flag) {
					delete arr[res.index][5][id];
				}
			}
		}
		if(refs) {
			var obj = {};
			obj[id] = pos;
			for(var i = 0, len = refs.length; i < len; i++) {
				var span = refs[i];
				this.add(span, obj);
			}
		}
	}
}, function() {});

Ext.define("EnterpriseSheet.pure.sheet.data.Format", {
	requires: ["EnterpriseSheet.pure.common.Common", "EnterpriseSheet.pure.common.Helper"],
	constructor: function() {
		var defaultDateFormat = SCONST.DEFAULT_DATE_FORMAT,
			defaultTimeFormat = SCONST.DEFAULT_TIME_FORMAT;
		var dateCheckFormats = ["Ymd", "YmdHis", "Y-m-d", "Y-m-d H:i:s", "Y-m-d H:i", "Y/m/d", "Y/m/d H:i:s", "Y/m/d H:i", "m/d/Y", "m/d/Y H:i:s", "m/d/Y H:i", "d-M-y", "d-M-y H:i", "d-M-y H:i:s", "d-M-Y", "d-M-Y H:i", "d-M-Y H:i:s", "d/M/y", "d/M/y H:i", "d/M/y H:i:s", "d/M/Y", "d/M/Y H:i", "d/M/Y H:i:s", "M/d/Y", "M/d/Y H:i:s", "M/d/Y H:i", "M d, Y", "M d, Y H:i:s", "M d, Y H:i", "Ymj", "YmjHis", "Y-m-j", "Y-m-j H:i:s", "Y-m-j H:i", "Y/m/j", "Y/m/j H:i:s", "Y/m/j H:i", "m/j/Y", "m/j/Y H:i:s", "m/j/Y H:i", "j-M-y", "j-M-y H:i", "j-M-y H:i:s", "j-M-Y", "j-M-Y H:i", "j-M-Y H:i:s", "j/M/y", "j/M/y H:i", "j/M/y H:i:s", "j/M/Y", "j/M/Y H:i", "j/M/Y H:i:s", "M/j/Y", "M/j/Y H:i:s", "M/j/Y H:i", "M j, Y", "M j, Y H:i:s", "M j, Y H:i", "Ynd", "YndHis", "Y-n-d", "Y-n-d H:i:s", "Y-n-d H:i", "Y/n/d", "Y/n/d H:i:s", "Y/n/d H:i", "n/d/Y", "n/d/Y H:i:s", "n/d/Y H:i", "d-n-y", "d-n-y H:i", "d-n-y H:i:s", "d-n-Y", "d-n-Y H:i", "d-n-Y H:i:s", "d/n/y", "d/n/y H:i", "d/n/y H:i:s", "d/n/Y", "d/n/Y H:i", "d/n/Y H:i:s", "n/d/Y", "n/d/Y H:i:s", "n/d/Y H:i", "n d, Y", "n d, Y H:i:s", "n d, Y H:i", "Ynj", "YnjHis", "Y-n-j", "Y-n-j H:i:s", "Y-n-j H:i", "Y/n/j", "Y/n/j H:i:s", "Y/n/j H:i", "n/j/Y", "n/j/Y H:i:s", "n/j/Y H:i", "j-n-y", "j-n-y H:i", "j-n-y H:i:s", "j-n-Y", "j-n-Y H:i", "j-n-Y H:i:s", "j/n/y", "j/n/y H:i", "j/n/y H:i:s", "j/n/Y", "j/n/Y H:i", "j/n/Y H:i:s", "n/j/Y", "n/j/Y H:i:s", "n/j/Y H:i", "n j, Y", "n j, Y H:i:s", "n j, Y H:i", "YFd", "YFdHis", "Y-F-d", "Y-F-d H:i:s", "Y-F-d H:i", "Y/F/d", "Y/F/d H:i:s", "Y/F/d H:i", "F/d/Y", "F/d/Y H:i:s", "F/d/Y H:i", "d-F-y", "d-F-y H:i", "d-F-y H:i:s", "d-F-Y", "d-F-Y H:i", "d-F-Y H:i:s", "d/F/y", "d/F/y H:i", "d/F/y H:i:s", "d/F/Y", "d/F/Y H:i", "d/F/Y H:i:s", "F/d/Y", "F/d/Y H:i:s", "F/d/Y H:i", "F d, Y", "F d, Y H:i:s", "F d, Y H:i"];
		var dateFormats = ["Y-m-d", "y-m-d", "Y-M-d", "y-M-d", "Y-n-d", "y-n-d", "Y-m-j", "y-m-j", "Y-M-j", "y-M-j", "Y-n-j", "y-n-j", "Y-F-d", "y-F-d", "Y-F-j", "y-F-j", "m-d-Y", "m-d-y", "M-d-Y", "M-d-y", "n-d-Y", "n-d-y", "m-j-Y", "m-j-y", "M-j-Y", "M-j-y", "n-j-Y", "n-j-y", "F-d-Y", "F-d-y", "F-j-Y", "F-j-y", "d-m-Y", "d-m-y", "d-M-Y", "d-M-y", "d-n-Y", "d-n-y", "j-m-Y", "j-m-y", "j-M-Y", "j-M-y", "j-n-Y", "j-n-y", "d-F-Y", "d-F-y", "j-F-Y", "j-F-y", "Y/m/d", "y/m/d", "Y/M/d", "y/M/d", "Y/n/d", "y/n/d", "Y/m/j", "y/m/j", "Y/M/j", "y/M/j", "Y/n/j", "y/n/j", "Y/F/d", "y/F/d", "Y/F/j", "y/F/j", "m/d/Y", "m/d/y", "M/d/Y", "M/d/y", "n/d/Y", "n/d/y", "m/j/Y", "m/j/y", "M/j/Y", "M/j/y", "n/j/Y", "n/j/y", "F/d/Y", "F/d/y", "F/j/Y", "F/j/y", "d/m/Y", "d/m/y", "d/M/Y", "d/M/y", "d/n/Y", "d/n/y", "j/m/Y", "j/m/y", "j/M/Y", "j/M/y", "j/n/Y", "j/n/y", "d/F/Y", "d/F/y", "j/F/Y", "j/F/y", "Y.m.d", "y.m.d", "Y.M.d", "y.M.d", "Y.n.d", "y.n.d", "Y.m.j", "y.m.j", "Y.M.j", "y.M.j", "Y.n.j", "y.n.j", "Y.F.d", "y.F.d", "Y.F.j", "y.F.j", "m.d.Y", "m.d.y", "M.d.Y", "M.d.y", "n.d.Y", "n.d.y", "m.j.Y", "m.j.y", "M.j.Y", "M.j.y", "n.j.Y", "n.j.y", "F.d.Y", "F.d.y", "F.j.Y", "F.j.y", "d.m.Y", "d.m.y", "d.M.Y", "d.M.y", "d.n.Y", "d.n.y", "j.m.Y", "j.m.y", "j.M.Y", "j.M.y", "j.n.Y", "j.n.y", "d.F.Y", "d.F.y", "j.F.Y", "j.F.y", "Y,m,d", "y,m,d", "Y,M,d", "y,M,d", "Y,n,d", "y,n,d", "Y,m,j", "y,m,j", "Y,M,j", "y,M,j", "Y,n,j", "y,n,j", "Y,F,d", "y,F,d", "Y,F,j", "y,F,j", "m,d,Y", "m,d,y", "M,d,Y", "M,d,y", "n,d,Y", "n,d,y", "m,j,Y", "m,j,y", "M,j,Y", "M,j,y", "n,j,Y", "n,j,y", "F,d,Y", "F,d,y", "F,j,Y", "F,j,y", "d,m,Y", "d,m,y", "d,M,Y", "d,M,y", "d,n,Y", "d,n,y", "j,m,Y", "j,m,y", "j,M,Y", "j,M,y", "j,n,Y", "j,n,y", "d,F,Y", "d,F,y", "j,F,Y", "j,F,y", "m,d Y", "m,d y", "M,d Y", "M,d y", "n,d Y", "n,d y", "m,j Y", "m,j y", "M,j Y", "M,j y", "n,j Y", "n,j y", "d,F Y", "d,F y", "j,F Y", "j,F y", "d,m Y", "d,m y", "d,M Y", "d,M y", "d,n Y", "d,n y", "j,m Y", "j,m y", "j,M Y", "j,M y", "j,n Y", "j,n y", "d,F Y", "d,F y", "j,F Y", "j,F y", "M d, Y", "m d, Y", "F d, Y", "m/d Y", "m/d y", "M/d Y", "M/d y", "n/d Y", "n/d y", "m/j Y", "m/j y", "M/j Y", "M/j y", "n/j Y", "n/j y", "d/F Y", "d/F y", "j/F Y", "j/F y", "d/m Y", "d/m y", "d/M Y", "d/M y", "d/n Y", "d/n y", "j/m Y", "j/m y", "j/M Y", "j/M y", "j/n Y", "j/n y", "F/d Y", "F/d y", "F/j Y", "F/j y", "Y m d", "y m d", "Y M d", "y M d", "Y n d", "y n d", "Y m j", "y m j", "Y M j", "y M j", "Y n j", "y n j", "Y F d", "y F d", "Y F j", "y F j", "m d Y", "m d y", "M d Y", "M d y", "n d Y", "n d y", "m j Y", "m j y", "M j Y", "M j y", "n j Y", "n j y", "F d Y", "F d y", "F j Y", "F j y", "d m Y", "d m y", "d M Y", "d M y", "d n Y", "d n y", "j m Y", "j m y", "j M Y", "j M y", "j n Y", "j n y", "d F Y", "d F y", "j F Y", "j F y", "Y\u5E74m\u6708j\u65E5", "Y\u5E74m\u6708d\u65E5", "Y\u5E74n\u6708j\u65E5", "Y\u5E74n\u6708d\u65E5", "y\u5E74m\u6708j\u65E5", "y\u5E74m\u6708d\u65E5", "m\u6708j\u65E5", "m\u6708d\u65E5"];
		var timeCheckFormats = ["H:i:s", "H:i", "i:s", "H:i:s a", "H:i a", "H:i:s A", "H:i A", "h:i:s", "h:i", "h:i:s a", "h:i a", "h:i:s A", "h:i A", "G:i:s a", "G:i a", "G:i:s", "G:i", "G:i:s A", "G:i A", "g:i:s a", "g:i a", "g:i:s", "g:i", "g:i:s A", "g:i A", "Gis", "Gi", "G", "gisA", "giA", "gA", "gisa", "gia", "ga", "His", "Hi", "H"];
		var dateTimeCheckFormats = ["Y-m-d H:i", "Y-m-d H:i:s", "Y-m-d H", "Y-m-d H:i:s A", "Y-m-d H:i A", "Y-m-d H:i:s a", "Y-m-d H:i a", "Y-m-d i:s", "Y-m-d G:i:s", "Y-m-d G:i", "Y-m-d G:i:s", "Y-m-d G:i"];
		var isValidStrInDate = function(str) {
			str = str.toLowerCase();
			return !(-1 == Ext.Array.indexOf(SCONST.shortMonthNames_low, str) && -1 == Ext.Array.indexOf(SCONST.fullMonthNames_low, str) && "am" != str && "pm" != str);
		};
		var checkingDateStr = function(data, infoRef) {
			if(SCOM.nullOrUndefined(data) || "" == data) {
				return;
			}
			var dateStr = data.toString();
			if(dateStr == null || !Ext.isString(dateStr)) {
				return false;
			}
			dateStr = Ext.String.trim(dateStr);
			var valid = true;
			dateStr.replace(/[a-zA-Z%]+/gi, function(w) {
				if(!isValidStrInDate(w)) {
					valid = false;
					return false;
				}
			});
			if(!valid) {
				return;
			}
			var withTime = -1 != dateStr.indexOf(":");
			var dateFormat = SCONST.DEFAULT_DATE_FORMAT;
			try {
				var date;
				for(var i = 0, len = dateFormats.length; i < len; i++) {
					var fm = dateFormats[i];
					date = Ext.Date.parse(dateStr, fm);
					if(date && Ext.Date.format(date, fm) == dateStr) {
						if(Ext.isObject(infoRef)) {
							infoRef.dfm = fm;
						}
						if(!withTime) {
							date = Ext.Date.clearTime(date, true);
						}
						return date;
					}
				}
			} catch(e) {
				return false;
			}
		};
		var checkingDate = function(data, infoRef) {
			var date = checkingDateStr(data, infoRef);
			if(!date) {
				if(Ext.isNumber(Number(data))) {
					var temp = Number(data);
					var tempDate = new Date(0, 0, temp - 1);
					return tempDate;
				}
			} else {
				return date;
			}
		};
		var checkingTime = function(data) {
			if(SCOM.nullOrUndefined(data) || "" == data) {
				return;
			}
			data = data.toString();
			var valid = true;
			data.replace(/[a-zA-Z%]+/gi, function(w) {
				if(!isValidStrInDate(w)) {
					valid = false;
					return false;
				}
			});
			if(!valid) {
				return;
			}
			var ampm = SCOM.getAMPM();
			data = data.replace(/AM/gi, ampm.am);
			data = data.replace(/PM/gi, ampm.pm);
			try {
				var date = new Date(data);
				if(date) {
					var str = Ext.Date.format(date, SCONST.DEFAULT_TIME_FORMAT);
					if(str && -1 == str.indexOf("NaN")) {
						return date;
					}
				}
				for(var i = 0, len = timeCheckFormats.length; i < len; i++) {
					date = Ext.Date.parseDate(data, timeCheckFormats[i]);
					if(date) {
						return date;
					}
				}
			} catch(e) {}
		};
		var checkingDateTime = function(data, infoRef) {
			if(SCOM.nullOrUndefined(data) || "" == data) {
				return;
			}
			var dateStr = data.toString();
			if(dateStr == null || !Ext.isString(dateStr)) {
				return false;
			}
			var valid = true;
			dateStr.replace(/[a-zA-Z%]+/gi, function(w) {
				if(!isValidStrInDate(w)) {
					valid = false;
					return false;
				}
			});
			if(!valid) {
				return;
			}
			var withTime = -1 != dateStr.indexOf(":");
			var dateFormat = SCONST.DEFAULT_DATE_TIME_FORMAT;
			try {
				var date;
				for(var i = 0, len = dateFormats.length; i < len; i++) {
					var fm = dateTimeCheckFormats[i];
					date = Ext.Date.parseDate(dateStr, fm);
					if(date && Ext.Date.format(date, fm) == dateStr) {
						if(Ext.isObject(infoRef)) {
							infoRef.dfm = fm;
						}
						return date;
					}
				}
			} catch(e) {
				return false;
			}
		};
		var floatCellData = function(cell) {
			var data = cell.data;
			var ta = cell.ta ? "text-align:" + cell.ta + ";" : "";
			var height = cell.height + "px",
				width = cell.width + "px";
			if("normal" == cell.ws) {
				ta += "position:static;";
			}
			cell.data = "<div class=\"ss-cell-inside\" style=\"position:absolute;z-index:" + cell.zd + ";width:" + width + ";height:" + height + ";margin-left:-2px;padding:0px 2px;top:2px;\" >" + "<div class=\"ss-cell-inside\" style=\"width:" + width + ";height:" + height + ";display:table-cell;vertical-align:" + cell.va + ";" + ta + "\">" + data + "</div></div>";
			delete cell.zd;
			return cell;
		};
		Ext.apply(this, {
			checkingDate: checkingDate,
			checkingTime: checkingTime,
			checkingDateTime: checkingDateTime,
			floatCellData: floatCellData,
			transferFormat: function(cell, format) {
				var isNumber = false,
					isBool = true === cell.data || false === cell.data;
				var num = 0,
					percision = "",
					dataStr = "",
					upper = "";
				var isEmpty = SCOM.isEmptyValue(cell.data);
				num = isBool || isEmpty ? NaN : Number(cell.data);
				if(!SCOM.nullOrUndefined(cell.data)) {
					dataStr = cell.data.toString();
					upper = dataStr.toUpperCase();
					if(!isBool) {
						isBool = "TRUE" == upper || "FALSE" == upper;
					}
				}
				if(Ext.isNumber(num)) {
					isNumber = true;
					var numStr = dataStr;
					var parts = numStr.split(".");
					if(2 == parts.length) {
						percision = parts[1];
					}
					if(SCONST.FORMAT_PERCENT == format) {
						num = num * 100;
						var digitalLen = HELPER.getDigitalLen(num);
						if(digitalLen > 13) {
							num = HELPER.roundUpNonZero(num);
						}
						cell.data = num;
						dataStr = num.toString();
					}
				}
				var dpd = Number(cell.dpd);
				if(Ext.isNumber(dpd)) {
					if(isNumber) {
						var numStr = dataStr;
						var parts = numStr.split(".");
						percision = "";
						if(2 == parts.length) {
							percision = parts[1];
							if(percision.length < dpd) {
								for(var i = percision.length; i < dpd; i++) {
									percision += "0";
								}
								cell.data = parts[0] + "." + percision;
							} else {
								var base = Math.pow(10, dpd);
								cell.data = Math.round(Number(numStr) * base) / base;
							}
						} else {
							cell.data = parts[0];
							if(0 < dpd) {
								cell.data += ".";
							}
							for(var i = 0; i < dpd; i++) {
								cell.data += "0";
							}
						}
					}
				}
				format = format || "regular";
				if(cell && format && !isEmpty) {
					var data = cell.data;
					if(cell.cal && Ext.isDefined(cell.value)) {
						data = cell.value;
					}
					if("regular" == format) {
						if(!cell.ta && isNumber) {
							cell.ta = "right";
						}
					} else if("bool" == format) {
						if(isBool) {
							cell.data = upper;
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_NUMBER == format) {
						if(isNumber) {
							if(cell.dfm) {
								var format = cell.dfm;
								var formatResult = HELPER.formatNumberWithCustom(format, num);
								cell.data = formatResult.result;
								if(formatResult.color) {
									cell.color = formatResult.color;
								}
							}
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_FRACTION == format) {
						if(isNumber) {
							var format = cell.dfm || SCONST.DEFAULT_FRACTION_FORMAT;
							var formatResult = HELPER.formatNumberWithCustom(format, num);
							cell.data = formatResult.result;
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_COMMA == format) {
						if(isNumber) {
							if(num < 0) {
								cell.data = "-" + Ext.util.Format.number(-num, SCONST.DEFAULT_COMMA_FORMAT);
							} else {
								cell.data = Ext.util.Format.number(num, SCONST.DEFAULT_COMMA_FORMAT);
							}
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_CURRENCY == format || HELPER.startWith(format, "money|")) {
						if(isNumber) {
							format = SCONST.FORMAT_CURRENCY == format ? SCONFIG.default_currency : format;
							var symbol = SCONST.money_code[SCONFIG.default_currency];
							if(HELPER.startWith(format, "money|")) {
								var formatResult = HELPER.formatMoneyWithPrecise(format, num);
								cell.data = formatResult.data;
								if(formatResult.color) {
									cell.color = formatResult.color;
								}
							} else {
								var result = symbol + Ext.util.Format.number(num, SCONST.DEFAULT_CURRENCY_FORMAT);
								if(num < 0) {
									result = "-" + symbol + Ext.util.Format.number(-num, SCONST.DEFAULT_CURRENCY_FORMAT);
								}
								cell.data = result;
							}
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_LOCALE == format) {
						if(isNumber) {
							var dfm = cell.dfm;
							cell.data = HELPER.formatNumberWithLocale(num, dfm);
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_DATE_TIME == format) {
						var dateData = data,
							timeData = null;
						if(-1 != data.toString().indexOf(":")) {
							var dateTime = HELPER.parseDateTime(data.toString());
							if(dateTime) {
								dateData = dateTime.date;
								timeData = dateTime.time;
							}
						}
						var dfm = cell.dfm || SCONST.DEFAULT_DATE_TIME_FORMAT;
						if(timeData) {
							var date = checkingDate(dateData);
							var time = checkingTime(timeData);
							if(date && time) {
								var dateTimeStr = Ext.Date.format(date, "Y-m-d") + " " + Ext.Date.format(time, "H:i:s");
								var formttedDate = Ext.Date.parse(dateTimeStr, "Y-m-d H:i:s");
								cell.data = Ext.Date.format(formttedDate, dfm);
								if(!cell.ta) {
									cell.ta = "right";
								}
							} else {
								cell.data = data;
							}
						} else {
							var date = checkingDateTime(data);
							if(date) {
								cell.data = Ext.Date.format(date, dfm);
								if(!cell.ta) {
									cell.ta = "right";
								}
							} else {
								date = checkingDate(data);
								if(date) {
									cell.data = Ext.Date.format(date, dfm);
									if(!cell.ta) {
										cell.ta = "right";
									}
								} else {
									cell.data = data;
								}
							}
						}
					} else if(SCONST.FORMAT_DATE == format) {
						var dateData = data,
							timeData = null;
						if(-1 != data.toString().indexOf(":")) {
							var dateTime = HELPER.parseDateTime(data.toString());
							if(dateTime) {
								dateData = dateTime.date;
							}
						}
						var date = checkingDate(dateData);
						if(date) {
							var dfm = cell.dfm || defaultDateFormat;
							cell.data = Ext.Date.format(date, dfm);
							if(!cell.ta) {
								cell.ta = "right";
							}
						} else if(Ext.isNumber(Number(data))) {
							var temp = Number(data);
							var tempDate = new Date(0, 0, temp - 1);
							var dfm = cell.dfm || defaultDateFormat;
							cell.data = Ext.Date.format(tempDate, dfm);
							if(!cell.ta) {
								cell.ta = "right";
							}
						} else {
							cell.data = data;
						}
					} else if(SCONST.FORMAT_TIME == format) {
						var date = checkingTime(data);
						if(!date) {
							date = checkingDate(data);
						}
						if(date) {
							var tfm = cell.dfm || defaultTimeFormat;
							cell.data = Ext.Date.format(date, tfm);
							if(!cell.ta) {
								cell.ta = "right";
							}
						} else {
							cell.data = "######";
						}
					} else if(SCONST.FORMAT_PERCENT == format) {
						if(isNumber) {
							var format = cell.dfm;
							if(format == null) {
								format = SCONST.NO_DECIMAL_PERCENT_FORMAT;
								if(HELPER.includeComma(cell.data)) {
									format = SCONST.DEFAULT_PERCENT_FORMAT;
								}
							}
							cell.data = Ext.util.Format.number(cell.data, format.substring(0, format.length - 1)) + "%";
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_SCIENCE == format) {
						if(isNumber) {
							var format = cell.dfm || SCONST.DEFAULT_SCIENCE_FORMAT;
							var fractionSize = HELPER.getExpFractionDigits(format);
							cell.data = num.toExponential(fractionSize);
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if(SCONST.FORMAT_SPECIAL == format) {
						if(isNumber) {
							cell.data = HELPER.applySpecialFormat(num, cell.dfm);
							if(!cell.ta) {
								cell.ta = "right";
							}
						}
					} else if("text" == format) {
						cell.ta = "";
					}
				}
				if(cell.link && Ext.isDefined(cell.data)) {
					cell.data = "<a class=\"ss-cell-inside\" href=\"#\">" + cell.data + "</a>";
				}
				if(!cell.ta && isBool) {
					cell.ta = "right";
					cell.data = upper;
				}
				return cell;
			},
			syncFormat: function(value, fm) {
				if(SCONST.FORMAT_DATE == fm) {
					var date = checkingDate(value);
					if(date) {
						return {
							data: Ext.Date.format(date, "Y-m-d")
						};
					}
				} else if("time" == fm) {
					var time = checkingTime(value);
					if(time) {
						return {
							data: Ext.Date.format(time, "H:i")
						};
					}
				} else if(SCONST.FORMAT_PERCENT == fm || SCONST.FORMAT_COMMA == fm) {
					return this.transfer2Number(value);
				}
			},
			decideFormat: function(value) {
				if(SCOM.canbeNumber(value)) {
					return;
				}
				if(Ext.isObject(value)) {
					return;
				}
				var upper = value.toString().toUpperCase();
				if(HELPER.startWith(upper, "=")) {
					return;
				}
				if("TRUE" == upper || "FALSE" == upper) {
					return {
						fm: "bool"
					};
				}
				if(value && value.indexOf(" ") == -1 && SCONST.strictUrlReg.test(value)) {
					var url = value;
					if(SCONST.emailReg.test(value)) {
						url = "mailto:" + url;
					} else if(!SCONST.urlProReg.test(url)) {
						url = "http://" + url;
					}
					return {
						link: url
					};
				} else {
					var refObj = {};
					var date = checkingDate(value, refObj);
					if(date) {
						return {
							fm: SCONST.FORMAT_DATE,
							data: Ext.Date.format(date, SCONST.DEFAULT_DATE_FORMAT),
							dfm: refObj.dfm
						};
					} else {
						var o = this.transfer2Number(value);
						if(o) {
							return o;
						}
						return;
					}
				}
			},
			transfer2Number: function(value) {
				var raw = value;
				var str = value.toString();
				var num = Number(str);
				if(Ext.isNumber(num)) {
					return {
						data: num
					};
				}
				if(!/[^0-9,.%]+/gi.test(str)) {
					var nocomma = str.replace(/,/gi, function() {
						return "";
					});
					var nocommaStr = nocomma;
					nocomma = Number(nocomma);
					if(Ext.isNumber(nocomma)) {
						var arr = nocommaStr.split(".");
						var len = arr.length;
						if(1 == len) {
							num = Ext.util.Format.number(nocomma, "0,0");
						} else if(2 == len) {
							num = Ext.util.Format.number(Number(arr[0]), "0,0");
							num = num + "." + arr[1];
						} else {
							return;
						}
						if(num == value) {
							value = nocomma;
							return {
								data: value,
								fm: "comma"
							};
						}
					} else if(Ext.isString(nocommaStr)) {
						var len = nocommaStr.length;
						var lastChr = nocommaStr.charAt(len - 1);
						if("%" == lastChr) {
							var fig = nocommaStr.slice(0, len - 1);
							var num = Number(fig);
							if(Ext.isNumber(num)) {
								return {
									data: num / 100,
									fm: SCONST.FORMAT_PERCENT
								};
							}
						}
					}
				}
			}
		});
	}
}, function() {
	SFORMAT = Ext.create("EnterpriseSheet.pure.sheet.data.Format");
});

Ext.define("EnterpriseSheet.pure.sheet.data.Store", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.Config", "EnterpriseSheet.pure.common.Common", "EnterpriseSheet.pure.sheet.data.reader.CellReader", "EnterpriseSheet.pure.sheet.calculate.Condition", "EnterpriseSheet.pure.sheet.data.CalReferenceMap"],
	limitCellNumAtSingleLoad: 3000,
	enableBorderFixer: true,
	exposeNamedFuncVar: "_nfv_",
	zoomDisabled: false,
	fontZoomRatio: 1,
	crossSepChar: "-",
	getId: function() {
		if(!this.id) {
			this.id = Ext.id("sheet_store");
		}
		return this.id;
	},
	constructProperty: function() {
		this.leftWidthSet = {};
		this.avoidMembers = ["config", "cdtPriority"];
		this.propertyNameArray = ["bg", "bgc", "ff", "fz", "fs", "fw", "color", "ws", "ww", "ta", "va", "u", "o", "s", "pl", "pr", "pt", "pb", "blw", "bls", "blc", "blt", "blf", "brw", "brs", "brc", "brt", "brf", "btw", "bts", "btc", "btt", "btf", "bbw", "bbs", "bbc", "bbt", "bbf", "wpr", "wpb"];
		this.defaultProperty = {
			cdt: "",
			width: 80,
			height: 20,
			ff: "",
			fz: 10,
			fs: "",
			fw: "",
			color: "",
			bgc: "",
			bg: "",
			ws: "",
			ww: "",
			ta: "",
			ti: 0,
			va: "",
			u: "",
			o: "",
			s: "",
			pl: 2,
			pr: 2,
			pt: 2,
			pb: 2,
			blw: 0,
			bls: "",
			blc: "",
			blt: "",
			blf: "",
			brw: 1,
			brs: "",
			brc: "",
			brt: "",
			brf: "",
			btw: 0,
			bts: "",
			btc: "",
			btt: "",
			btf: "",
			bbw: 1,
			bbs: "",
			bbc: "",
			bbt: "",
			bbf: "",
			wpr: 5,
			wpb: 5,
			it: "",
			itn: "",
			fm: ""
		};
	},
	constructor: function(config) {
		this.constructProperty();
		this.getId();
		Ext.apply(this, config);
		Ext.applyIf(this, {
			loadUrl: SCONFIG.urls.loadActivedSheetOfFile,
			loadMoreUrl: SCONFIG.urls.loadCellOnDemand,
			loadFloatingsUrl: SCONFIG.urls.loadElementOnDemand
		});
		this.originDefaultProperty = Ext.apply({}, this.defaultProperty);
		this.reader = Ext.create("EnterpriseSheet.pure.sheet.data.reader.CellReader", {
			store: this
		});
		this.separateChar = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar;
		this.calRefsMap = Ext.create("EnterpriseSheet.pure.sheet.data.CalReferenceMap", {
			store: this
		});
		var separateChar = this.separateChar;
		var getIdBasedData = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.getIdBasedData;
		this.getIdBasedData = getIdBasedData;
		EnterpriseSheet.pure.sheet.data.Store.prototype.superclass.constructor.apply(this);
		this.floatings = {};
		this.mergeLookup = {};
		this.cdtLookup = {};
		this.initSheets();
	},
	defaultSheetNumber: 3,
	defaultLeftWidth: 31,
	splitOffset: 5,
	minFontSize: 6,
	defaultFontSize: 10,
	uuid: 1,
	uut: 1,
	borderOffset: 1,
	cellPaddingOffset: 4,
	cellWidthOffset: 5,
	cellHeightOffset: 5,
	defaultCellWidth: 80,
	defaultCellHeight: 20,
	originDefaultCellWidth: 80,
	originDefaultCellHeight: 20,
	originDefaultFontSize: 10,
	headerCellHeight: 25,
	defaultBackgroundColor: "white",
	defaultBorderColor: "silver",
	getByMapId: function(id) {
		var data = this.getData();
		var o = data[id];
		if(o) {
			return {
				data: {
					sheet: o[0],
					row: o[1],
					col: o[2],
					json: o[3]
				}
			};
		}
	},
	getRecord: function(sheetId, row, col) {
		if(1 === arguments.length) {
			var pos = sheetId.split(this.separateChar);
			sheetId = pos[0];
			row = pos[1];
			col = pos[2];
		}
		var found = this.findStoreBySheetId(sheetId);
		if(found) {
			var store = found.store;
			var sid = found.sheetObj.id;
			return store.getByMapId(store.getIdBasedData({
				sheet: sid,
				row: row,
				col: col
			}));
		}
	},
	setLeftWidth: function(sheet, lw) {
		if(false !== SCOM.typeOf(lw)) {
			this.leftWidthSet[sheet] = lw;
		}
	},
	newRecord: function(sheet, row, col, data) {
		var json = Ext.apply({}, data);
		var o = {
			sheet: sheet,
			row: row,
			col: col,
			json: json
		};
		var id = this.getIdBasedData(o);
		var r = {
			data: o
		};
		o = [sheet, row, col, json];
		this.getData()[id] = o;
		return r;
	},
	setCalCell2Lookup: function(id, o) {
		var lookup = this.getCalLookup();
		if(o) {
			lookup[id] = o;
		} else {
			delete lookup[id];
		}
	},
	getCalLookup: function() {
		if(!this.calLookup) {
			this.calLookup = {};
		}
		return this.calLookup;
	},
	setCalLookup: function(lookup) {
		this.calLookup = lookup;
	},
	loadRecords: function(recs, options) {
		options = options || {};
		var data, calLookup, tmp = {};
		if(options.addRecords) {
			data = this.getData();
			calLookup = this.getCalLookup();
		} else {
			data = {};
			calLookup = {};
		}
		var notOverwrite = options.notOverwrite;
		for(var i = 0, len = recs.length; i < len; i++) {
			var rec = recs[i];
			var id = [rec[0], rec[1], rec[2]].join(this.separateChar);
			if(!notOverwrite || !data[id]) {
				data[id] = rec;
				if(rec[3].cal) {
					calLookup[id] = rec;
					tmp[id] = rec;
				}
			}
		}
		this.setData(data);
		this.setCalLookup(calLookup);
		if(options.addRecords) {
			if(!this.needResetupCalMap) {
				for(var p in tmp) {
					if(tmp.hasOwnProperty(p)) {
						var it = tmp[p];
						this.updateCalMap(p, it[3].refs, undefined, [it[0], it[1], it[2]]);
					}
				}
			}
		} else {
			this.refreshCalLookup();
		}
	},
	getRangeWidth: function(sheet, start, end, includeHidden, withZoom) {
		var me = this,
			zoom = withZoom ? this.getZoom() : 1;
		var dw = this.zoomSize(me.defaultCellWidth, withZoom);
		this.colWRangeLookup = this.colWRangeLookup || {};
		var id = [sheet, start, end].join(this.separateChar);
		if(0 < end) {
			var found = this.colWRangeLookup[id];
			if(found && found.hasOwnProperty(zoom)) {
				return found[zoom];
			}
		}
		var w = 0,
			empty = 0,
			lookup = this.getColWidthCache(sheet);
		var len = end - start + 1;
		if(100 < len) {
			for(var p in lookup) {
				if(lookup.hasOwnProperty(p)) {
					if(start <= p && p <= end) {
						w += this.zoomSize(lookup[p], withZoom);
						empty++;
					}
				}
			}
			var rs = w + (len - empty) * dw;
			this.colWRangeLookup[id] = this.colWRangeLookup[id] || {};
			this.colWRangeLookup[id][zoom] = rs;
			return rs;
		} else {
			for(var i = start; i <= end; i++) {
				if(Ext.isNumber(lookup[i])) {
					w += this.zoomSize(lookup[i], withZoom);
				} else {
					empty++;
				}
			}
			var rs = w + empty * dw;
			this.colWRangeLookup[id] = this.colWRangeLookup[id] || {};
			this.colWRangeLookup[id][zoom] = rs;
			return rs;
		}
	},
	cacheRangeWidth: function(x, startCol, endCol, sheet) {
		var zoom = this.getZoom();
		this.colWRangeLookup = this.colWRangeLookup || {};
		var id = [sheet, startCol, endCol].join(this.separateChar);
		this.colWRangeLookup[id] = this.colWRangeLookup[id] || {};
		this.colWRangeLookup[id][zoom] = x;
	},
	cacheRangeHeight: function(y, startRow, endRow, sheet) {
		var zoom = this.getZoom();
		var id = [sheet, startRow, endRow].join(this.separateChar);
		this.rowHRangeLookup = this.rowHRangeLookup || {};
		this.rowHRangeLookup[id] = this.rowHRangeLookup[id] || {};
		this.rowHRangeLookup[id][zoom] = y;
	},
	getColWidth: function(sheet, col, skipHidden, withZoom) {
		if(0 == col) {
			if(this.rowNameHidden) {
				return 0;
			} else {
				var lw = this.leftWidthSet[sheet] || this.defaultLeftWidth;
				return this.zoomSize(lw, withZoom);
			}
		} else {
			var cell = this.getCell(sheet, 0, col);
			if(skipHidden && cell.hidden) {
				return 0;
			} else {
				var w = cell.width;
				if(!SCOM.canbeNumber(w)) {
					w = this.defaultCellWidth;
				}
				return this.zoomSize(w, withZoom);
			}
		}
	},
	getRowHeightCache: function(sheetId) {
		this.rowHCache = this.rowHCache || {};
		if(!this.rowHCache[sheetId]) {
			var lookup = {};
			this.each(function(rd) {
				var row = rd.data.row,
					json = rd.data.json;
				if(sheetId == rd.data.sheet && 0 === rd.data.col) {
					if(0 !== row) {
						if(json.hidden) {
							lookup[row] = 0;
						} else {
							var h = json.height;
							if(!Ext.isNumber(h)) {
								h = json.autoHeight;
							}
							if(Ext.isNumber(h)) {
								lookup[row] = h;
							} else {
								delete lookup[row];
							}
						}
					}
				}
			}, this);
			this.rowHCache[sheetId] = lookup;
		}
		this.rowHCache[sheetId][0] = this.headerCellHeight;
		return this.rowHCache[sheetId];
	},
	resetRowHeightColWidthCache: function(sheetId) {
		this.rowHRangeLookup = {};
		this.colWRangeLookup = {};
		this.colWCache = this.colWCache || {};
		this.rowHCache = this.rowHCache || {};
		delete this.colWCache[sheetId];
		delete this.rowHCache[sheetId];
		this.getRowHeightCache(sheetId);
		this.getColWidthCache(sheetId);
	},
	resetRowHeightCache: function(sheetId) {
		this.rowHRangeLookup = {};
		this.rowHCache = this.rowHCache || {};
		delete this.rowHCache[sheetId];
		this.getRowHeightCache(sheetId);
	},
	resetColWidthCache: function(sheetId) {
		this.colWRangeLookup = {};
		this.colWCache = this.colWCache || {};
		delete this.colWCache[sheetId];
		this.getColWidthCache(sheetId);
	},
	syncRowHeightCache: function(sheetId, row) {
		this.rowHRangeLookup = {};
		this.rowHCache = this.rowHCache || {};
		var lookup = this.rowHCache[sheetId] || {};
		var json = this.getCell(sheetId, row, 0);
		if(json.hidden) {
			lookup[row] = 0;
		} else {
			var h = json.height;
			if(!Ext.isNumber(h)) {
				h = json.autoHeight;
			}
			if(Ext.isNumber(h)) {
				lookup[row] = h;
			} else {
				delete lookup[row];
			}
		}
		this.rowHCache[sheetId] = lookup;
	},
	syncColWidthCache: function(sheetId, col) {
		this.colWRangeLookup = {};
		this.colWCache = this.colWCache || {};
		var lookup = this.colWCache[sheetId] || {};
		var json = this.getCell(sheetId, 0, col);
		if(json.hidden) {
			lookup[col] = 0;
		} else {
			var w = json.width;
			if(Ext.isNumber(w)) {
				lookup[col] = w;
			} else {
				delete lookup[col];
			}
		}
		this.colWCache[sheetId] = lookup;
	},
	getColWidthCache: function(sheetId) {
		this.colWCache = this.colWCache || {};
		if(!this.colWCache[sheetId]) {
			var lookup = {};
			this.each(function(rd) {
				var col = rd.data.col,
					json = rd.data.json;
				if(sheetId == rd.data.sheet && 0 === rd.data.row) {
					if(0 !== col) {
						if(json.hidden) {
							lookup[col] = 0;
						} else {
							var w = json.width;
							if(Ext.isNumber(w)) {
								lookup[col] = w;
							} else {
								delete lookup[col];
							}
						}
					}
				}
			}, this);
			this.colWCache[sheetId] = lookup;
		}
		var lw = this.leftWidthSet[sheetId] || this.defaultLeftWidth;
		this.colWCache[sheetId][0] = lw;
		return this.colWCache[sheetId];
	},
	getRangeHeight: function(sheet, start, end, includeHidden, withZoom) {
		var me = this,
			zoom = withZoom ? this.getZoom() : 1;
		var dh = this.zoomSize(me.defaultCellHeight, withZoom);
		this.rowHRangeLookup = this.rowHRangeLookup || {};
		var id = [sheet, start, end].join(this.separateChar);
		if(0 < end) {
			var found = this.rowHRangeLookup[id];
			if(found && found.hasOwnProperty(zoom)) {
				return found[zoom];
			}
		}
		var h = 0,
			empty = 0,
			lookup = this.getRowHeightCache(sheet);
		var len = end - start + 1;
		if(100 < len) {
			for(var p in lookup) {
				if(lookup.hasOwnProperty(p)) {
					if(start <= p && p <= end) {
						h += this.zoomSize(lookup[p], withZoom);
						empty++;
					}
				}
			}
			var rs = h + (len - empty) * dh;
			this.rowHRangeLookup[id] = this.rowHRangeLookup[id] || {};
			this.rowHRangeLookup[id][zoom] = rs;
			return rs;
		} else {
			for(var i = start; i <= end; i++) {
				if(Ext.isNumber(lookup[i])) {
					h += this.zoomSize(lookup[i], withZoom);
				} else {
					empty++;
				}
			}
			var rs = h + empty * dh;
			this.rowHRangeLookup[id] = this.rowHRangeLookup[id] || {};
			this.rowHRangeLookup[id][zoom] = rs;
			return rs;
		}
	},
	getRowHeight: function(sheet, row, skipHidden, withZoom) {
		if(0 == row) {
			return this.colNameHidden ? 0 : this.zoomSize(this.headerCellHeight, withZoom);
		} else {
			var cell = this.getCell(sheet, row, 0);
			if(skipHidden && cell.hidden) {
				return 0;
			} else {
				var h = cell.height;
				if(!SCOM.canbeNumber(h)) {
					h = cell.autoHeight || this.defaultCellHeight;
				}
				return this.zoomSize(h, withZoom);
			}
		}
	},
	isExistedCell: function(sheet, row, col) {
		var id = this.getIdBasedData({
			sheet: sheet,
			row: row,
			col: col
		});
		var c = this.getByMapId(id);
		return c;
	},
	getCell: function(sheet, row, col, returnCopy, id) {
		var id = id || this.getIdBasedData({
			sheet: sheet,
			row: row,
			col: col
		});
		var c = this.getByMapId(id);
		var json = {};
		if(c) {
			if(returnCopy) {
				json = Ext.apply({}, c.data.json);
			} else {
				json = c.data.json;
			}
		}
		return json;
	},
	getCellProperty: function(sheet, row, col, discareMerge, discareSelf) {
		var o = this.getCell(sheet, row, col);
		if(!discareMerge && this.isMergedCell(o, sheet, row, col)) {
			var minrow = row + o.minrow;
			var mincol = col + o.mincol;
			if(!discareSelf) {
				o = this.getCell(sheet, minrow, mincol, true);
			} else {
				o = {};
			}
			o.data = o.data || "";
			if(0 !== row && 0 !== col) {
				var l = this.getCell(sheet, minrow, 0);
				var h = this.getCell(sheet, 0, mincol);
				var c = this.getCell(sheet, 0, 0);
				this.applyProperty(o, l, h, c);
			} else if(0 !== row || 0 !== col) {
				var c = this.getCell(sheet, 0, 0);
				this.applyProperty(o, c);
			}
			SCOM.deleteMembers(o, this.avoidMembers);
		} else {
			if(!discareSelf) {
				o = Ext.apply({}, o);
			} else {
				o = {};
			}
			o.data = o.data || "";
			if(0 !== row && 0 !== col) {
				var l = this.getCell(sheet, row, 0);
				var h = this.getCell(sheet, 0, col);
				var c = this.getCell(sheet, 0, 0);
				this.applyProperty(o, l, h, c);
			} else if(0 !== row || 0 !== col) {
				var c = this.getCell(sheet, 0, 0);
				this.applyProperty(o, c);
			}
			SCOM.deleteMembers(o, this.avoidMembers);
		}
		return o;
	},
	compareBorderPriority: function(current, neighbor, dirs) {
		var p = dirs[0],
			q = dirs[1];
		var pt = "b" + p + "t",
			qt = "b" + q + "t";
		if(current.wrap && current[pt]) {
			if(neighbor.wrap && neighbor[qt]) {
				if("double" !== current[pt] && "double" === neighbor[qt]) {
					return true;
				}
			}
		} else {
			if(neighbor.wrap && neighbor[qt]) {
				return true;
			}
			var ps = "b" + p + "s",
				qs = "b" + q + "s";
			var pw = "b" + p + "w",
				qw = "b" + q + "w",
				pf = "b" + p + "f",
				qf = "b" + q + "f";
			var cw = Math.max(current[pw] || 0, current[pf] || 0),
				nw = Math.max(neighbor[qw] || 0, neighbor[qf] || 0);
			if(cw < nw) {
				return true;
			} else if(cw === nw) {
				var map = {
					solid: 3,
					dashed: 2,
					dotted: 1
				};
				var cs = map[current[ps]] || 0,
					ns = map[neighbor[qs]] || 0;
				return ns > cs;
			}
		}
	},
	borderSetCompare: function(set1, set2) {
		var map = {
			solid: 3,
			dashed: 2,
			dotted: 1,
			clear: 0
		};
		if(set1[3] && set2[3]) {
			if(set1[3] !== set2[3]) {
				return "double" == set1[3] ? set1[2] : set2[2];
			} else {
				var flag = SCOM.whichColorDarker(set1[2], set2[2]);
				if(1 === flag) {
					return set1[2];
				} else if(-1 === flag) {
					return set2[2];
				}
			}
		} else if(set1[3]) {
			return set1[2];
		} else if(set2[3]) {
			return set2[2];
		}
		if(set1[0] > set2[0]) {
			return set1[2];
		} else if(set1[0] < set2[0]) {
			return set2[2];
		} else {
			if(map[set1[1]] > map[set2[1]]) {
				return set1[2];
			} else if(map[set1[1]] < map[set2[1]]) {
				return set2[2];
			} else {
				var flag = SCOM.whichColorDarker(set1[2], set2[2]);
				if(1 === flag) {
					return set1[2];
				} else if(-1 === flag) {
					return set2[2];
				}
			}
		}
	},
	fixDiagonalBorder: function(o, sheet, row, col, rightCell, bottomCell, leftCell, topCell, rbCell) {
		var isMerge = this.isMergedCell(o);
		var fixedBorder = {},
			ranking = this.reader.borderRankingMap,
			widthMap = this.reader.widthMap;
		var compare = function(set1, set2, withoutColor) {
			if(ranking[set1[0]] > ranking[set2[0]]) {
				return 1;
			} else if(ranking[set1[0]] < ranking[set2[0]]) {
				return -1;
			} else {
				if(withoutColor) {
					return 0;
				}
				return SCOM.whichColorDarker(set1[1], set2[1]);
			}
		};
		var getWinner = function(set1, set2) {
			var res = compare(set1, set2);
			if(-1 === res) {
				return set2;
			} else {
				return set1;
			}
		};
		var isTri = function(s) {
			return "double" == s || "thick" == s;
		};
		var ltCell, rtCell, lbCell, ds = "clear",
			dc = "silver";
		if(!isMerge || 0 === o.maxrow || 0 === o.maxcol) {
			if(rightCell.xbbs || rightCell.xbbc || rightCell.cbgc || rightCell.bgc || rbCell.xbts || rbCell.xbtc || rbCell.xbls || rbCell.xblc || rbCell.cbgc || rbCell.bgc || bottomCell.xbrs || bottomCell.xbrc || bottomCell.cbgc || bottomCell.bgc) {
				var oRightSet = getWinner([o.xbrs || ds, o.xbrc || o.brc || dc], [rightCell.xbls || ds, rightCell.xblc || dc]),
					oBottomSet = getWinner([o.xbbs || ds, o.xbbc || o.bbc || dc], [bottomCell.xbts || ds, bottomCell.xbtc || dc]);
				var rightSet = getWinner([rightCell.xbbs || ds, rightCell.xbbc || rightCell.cbgc || rightCell.bgc || dc], [rbCell.xbts || ds, rbCell.xbtc || rbCell.cbgc || rbCell.bgc || dc]),
					bottomSet = getWinner([bottomCell.xbrs || ds, bottomCell.xbrc || bottomCell.cbgc || bottomCell.bgc || dc], [rbCell.xbls || ds, rbCell.xblc || rbCell.cbgc || rbCell.bgc || dc]),
					set = getWinner(rightSet, bottomSet);
				if(0 < compare(set, oRightSet) && 0 < compare(set, oBottomSet) && !("double" === oRightSet[0] && "double" === oBottomSet[0])) {
					var bbw = Math.max(widthMap[rightSet[0]], widthMap[oBottomSet[0]]),
						brw = Math.max(widthMap[oRightSet[0]], widthMap[bottomSet[0]]);
					fixedBorder.rb = {
						h: Math.min(bbw, 2),
						w: Math.min(brw, 2),
						color: set [1],
						bs: "double" === oRightSet[0] ? undefined : rightSet[0],
						tc: rightSet[1],
						rs: "double" === oBottomSet[0] ? undefined : bottomSet[0],
						lc: bottomSet[1]
					};
				}
			}
		}
		if(1 < row && 1 < col && (!isMerge || 0 === o.minrow || 0 === o.mincol)) {
			ltCell = this.getCellProperty(sheet, row - 1, col - 1, true);
			if(leftCell.xbts || leftCell.xbtc || ltCell.xbbs || ltCell.xbbc || topCell.xbls || topCell.xblc || ltCell.xbrs || ltCell.xbrc) {
				var oLeftSet = getWinner([o.xbls || ds, o.xblc || dc], [leftCell.xbrs || ds, leftCell.xbrc || dc]),
					oTopSet = getWinner([o.xbts || ds, o.xbtc || dc], [topCell.xbbs || ds, topCell.xbbc || dc]);
				var leftSet = getWinner([leftCell.xbts || ds, leftCell.xbtc || dc], [ltCell.xbbs || ds, ltCell.xbbc || dc]),
					topSet = getWinner([topCell.xbls || ds, topCell.xblc || dc], [ltCell.xbrs || ds, ltCell.xbrc || dc]),
					set = getWinner(leftSet, topSet);
				if((isTri(leftSet[0]) || isTri(oTopSet[0])) && (isTri(topSet[0]) || isTri(oLeftSet[0])) && 0 < compare(set, oLeftSet) && 0 < compare(set, oTopSet)) {
					fixedBorder.lt = {
						h: 1,
						w: 1,
						color: set [1]
					};
				}
			}
		}
		if(1 < col && (!isMerge || 0 === o.maxrow || 0 === o.mincol)) {
			lbCell = this.getCellProperty(sheet, row + 1, col - 1, true);
			if(leftCell.xbbs || leftCell.xbbc || lbCell.xbts || lbCell.xbtc || bottomCell.xbls || bottomCell.xblc || lbCell.xbrs || lbCell.xbrc) {
				var oLeftSet = getWinner([o.xbls || ds, o.xblc || dc], [leftCell.xbrs || ds, leftCell.xbrc || dc]),
					oBottomSet = getWinner([o.xbbs || ds, o.xbbc || dc], [bottomCell.xbts || ds, bottomCell.xbtc || dc]);
				var leftSet = getWinner([leftCell.xbbs || ds, leftCell.xbbc || dc], [lbCell.xbts || ds, lbCell.xbtc || dc]),
					bottomSet = getWinner([bottomCell.xbls || ds, bottomCell.xblc || dc], [lbCell.xbrs || ds, lbCell.xbrc || dc]),
					set = getWinner(leftSet, bottomSet);
				if((isTri(bottomSet[0]) || isTri(oLeftSet[0])) && !("double" == oBottomSet[0] && "double" == set[0]) && 0 < compare(set, oLeftSet) && 0 < compare(set, oBottomSet)) {
					fixedBorder.lb = {
						h: Math.min(2, Math.max(widthMap[leftSet[0]], widthMap[oBottomSet[0]])),
						w: 1,
						rc: -1 === compare(bottomSet, leftSet) ? "double" === leftSet[0] ? "white" : leftSet[1] : bottomSet[1],
						tc: 1 !== compare(bottomSet, leftSet) ? leftSet[1] : bottomSet[1]
					};
				}
			}
		}
		if(1 < row && (!isMerge || 0 === o.minrow || 0 === o.maxcol)) {
			rtCell = this.getCellProperty(sheet, row - 1, col + 1, true);
			if(rightCell.xbts || rightCell.xbtc || rtCell.xbbs || rtCell.xbbc || topCell.xbrs || topCell.xbrc || rtCell.xbls || rtCell.xblc) {
				var oRightSet = getWinner([o.xbrs || ds, o.xbrc || dc], [rightCell.xbls || ds, rightCell.xblc || dc]),
					oTopSet = getWinner([o.xbts || ds, o.xbtc || dc], [topCell.xbbs || ds, topCell.xbbc || dc]);
				var rightSet = getWinner([rightCell.xbts || ds, rightCell.xbtc || dc], [rtCell.xbbs || ds, rtCell.xbbc || dc]),
					topSet = getWinner([topCell.xbrs || ds, topCell.xbrc || dc], [rtCell.xbls || ds, rtCell.xblc || dc]),
					set = getWinner(rightSet, topSet);
				if((isTri(rightSet[0]) || isTri(oTopSet[0])) && !("double" == oRightSet[0] && "double" == set[0]) && 0 < compare(set, oRightSet) && 0 < compare(set, oTopSet)) {
					fixedBorder.rt = {
						h: 1,
						w: Math.min(2, Math.max(widthMap[topSet[0]], widthMap[oRightSet[0]])),
						lc: -1 === compare(topSet, rightSet) ? rightSet[1] : topSet[1],
						bc: 1 === compare(topSet, rightSet) ? "double" === topSet[0] ? "white" : topSet[1] : rightSet[1]
					};
				}
			}
		}
		if(!SCOM.isEmptyObj(fixedBorder)) {
			o.fixedBorder = fixedBorder;
		}
	},
	fixBorderGap: function(o, sheet, row, col) {
		var isMerge = this.isMergedCell(o);
		var fixedBorder = o.fixedBorder || {},
			ranking = this.reader.borderRankingMap;
		var ds = "clear",
			dc = "silver";
		var dp = this.defaultProperty,
			brw = o.brw || dp.brw,
			bbw = o.bbw || dp.bbw,
			blw = o.blw || dp.blw,
			btw = o.btw || dp.btw,
			brc = o.brc || dp.brc || dc,
			bbc = o.bbc || dp.bbc || dc,
			brt = o.brt,
			brs = o.brs || dp.brs || ds,
			bbs = o.bbs || dp.bbs || ds,
			blt = o.blt,
			blc = o.blc || dp.blc || dc,
			btc = o.btc || dp.btc || dc,
			btt = o.btt,
			bls = o.bls || dp.bls || ds,
			bts = o.bts || dp.bts || ds,
			bbt = o.bbt;
		var color;
		if(brc !== bbc && !fixedBorder.rb && (!isMerge || 0 === o.maxrow || 0 === o.maxcol)) {
			color = this.borderSetCompare([brw, brs, brc, brt], [bbw, bbs, bbc, bbt]);
			if(color) {
				fixedBorder.rb = {
					h: bbw,
					w: brw,
					color: color
				};
			}
		}
		if(blw && !fixedBorder.lb && (!isMerge || 0 === o.maxrow || 0 === o.mincol)) {
			color = this.borderSetCompare([blw, bls, blc, blt], [bbw, bbs, bbc, bbt]);
			if(color) {
				fixedBorder.lb = {
					h: bbw,
					w: blw,
					color: color
				};
			}
		}
		if(btw && !fixedBorder.rt && (!isMerge || 0 === o.minrow || 0 === o.maxcol)) {
			color = this.borderSetCompare([brw, brs, brc, brt], [btw, bts, btc, btt]);
			if(color) {
				fixedBorder.rt = {
					h: btw,
					w: brw,
					color: color
				};
			}
		}
		if(blw && btw && !fixedBorder.lt && (!isMerge || 0 === o.minrow || 0 === o.mincol)) {
			color = this.borderSetCompare([blw, bls, blc, blt], [btw, bts, btc, btt]);
			if(color) {
				fixedBorder.lt = {
					h: btw,
					w: blw,
					color: color
				};
			}
		}
		if(!SCOM.isEmptyObj(fixedBorder)) {
			o.fixedBorder = fixedBorder;
		}
	},
	processBorder: function(sheet, row, col, o, beforeProcessBorder) {
		var reader = this.reader;
		var rightCell = this.getCellProperty(sheet, row, col + 1, true),
			leftCell, bottomCell = this.getCellProperty(sheet, row + 1, col, true),
			topCell, rbCell = this.getCellProperty(sheet, row + 1, col + 1, true);
		if(1 < col) {
			leftCell = this.getCellProperty(sheet, row, col - 1, true);
		}
		if(1 < row) {
			topCell = this.getCellProperty(sheet, row - 1, col, true);
		}
		reader.presetBorderProperty(o, true);
		if(beforeProcessBorder) {
			var pbFn = beforeProcessBorder.fn;
			if(pbFn) {
				pbFn.call(beforeProcessBorder.scope, o, sheet, row, col);
				pbFn.call(beforeProcessBorder.scope, rbCell, sheet, row + 1, col + 1);
			}
		}
		var property = rightCell;
		reader.presetBorderProperty(property, true);
		if(beforeProcessBorder) {
			var pbFn = beforeProcessBorder.fn;
			if(pbFn) {
				pbFn.call(beforeProcessBorder.scope, property, sheet, row, col + 1);
			}
		}
		if(property.wrap && property.blt) {
			if(this.compareBorderPriority(o, property, ["r", "l"])) {
				Ext.apply(o, this.getBorderConfig("r", 3, property.blt, property.blc, true));
			}
		} else if(property.blf) {
			if(this.compareBorderPriority(o, property, ["r", "l"])) {
				Ext.apply(o, this.getBorderConfig("r", property.blf, property.bls, property.blc, true));
			}
		}
		var obrc = o.cbgc || o.bgc;
		if(!o.brc) {
			if(this.isMergedCell(property)) {
				var minrow = row + property.minrow;
				var mincol = col + 1 + property.mincol;
				property = this.getCell(sheet, minrow, mincol, true);
			}
			var pbrc = property.cbgc || property.bgc;
			o.brc = 1 === SCOM.whichColorDarker(obrc, pbrc) ? obrc : pbrc;
		}
		property = bottomCell;
		reader.presetBorderProperty(property, true);
		if(beforeProcessBorder) {
			var pbFn = beforeProcessBorder.fn;
			if(pbFn) {
				pbFn.call(beforeProcessBorder.scope, property, sheet, row + 1, col);
			}
		}
		if(property.wrap && property.btt) {
			if(this.compareBorderPriority(o, property, ["b", "t"])) {
				Ext.apply(o, this.getBorderConfig("b", 3, property.btt, property.btc, true));
			}
		} else if(property.btf) {
			if(this.compareBorderPriority(o, property, ["b", "t"])) {
				Ext.apply(o, this.getBorderConfig("b", property.btf, property.bts, property.btc, true));
			}
		}
		var obbc = o.cbgc || o.bgc;
		if(!o.bbc) {
			if(this.isMergedCell(property)) {
				var minrow = row + 1 + property.minrow;
				var mincol = col + property.mincol;
				property = this.getCell(sheet, minrow, mincol, true);
			}
			var pbbc = property.cbgc || property.bgc;
			o.bbc = 1 === SCOM.whichColorDarker(obbc, pbbc) ? obbc : pbbc;
		}
		if(1 < col) {
			property = leftCell;
			reader.presetBorderProperty(property, true);
			if(beforeProcessBorder) {
				var pbFn = beforeProcessBorder.fn;
				if(pbFn) {
					pbFn.call(beforeProcessBorder.scope, property, sheet, row, col - 1);
				}
			}
			if(property.wrap && property.brt) {
				Ext.apply(o, this.getBorderConfig("l", 3, property.brt, property.brc, true));
			}
		}
		if(1 < row) {
			property = topCell;
			reader.presetBorderProperty(property, true);
			if(beforeProcessBorder) {
				var pbFn = beforeProcessBorder.fn;
				if(pbFn) {
					pbFn.call(beforeProcessBorder.scope, property, sheet, row - 1, col);
				}
			}
			if(property.wrap && property.bbt) {
				Ext.apply(o, this.getBorderConfig("t", 3, property.bbt, property.bbc, true));
			}
		}
		if(0 !== row && 0 !== col) {
			if(this.enableBorderFixer) {
				this.fixDiagonalBorder(o, sheet, row, col, rightCell, bottomCell, leftCell, topCell, rbCell);
				this.fixBorderGap(o, sheet, row, col);
			}
		}
		return o;
	},
	avoidEmptyProperty: function(json) {
		for(var p in json) {
			if(json.hasOwnProperty(p)) {
				var v = json[p];
				if("" === v || null === v) {
					delete json[p];
				}
			}
		}
	},
	avoidEmptyAndDefaultProperty: function(json) {
		var dp = this.originDefaultProperty;
		for(var p in json) {
			if(json.hasOwnProperty(p)) {
				var v = json[p];
				if("" === v || null === v || v === dp[p]) {
					delete json[p];
				}
			}
		}
	},
	lgUUStamp: function(a, b) {
		return a[0] > b[0] || a[0] === b[0] && a[1] > b[1];
	},
	applyProperty: function() {
		var target = arguments[0],
			lookup = {};
		for(var i = 1, len = arguments.length; i < len; i++) {
			var source = arguments[i];
			for(var p in source) {
				if(source.hasOwnProperty(p)) {
					if("_" !== p.charAt(0)) {
						var q = "_" + p;
						if(source.hasOwnProperty(q)) {
							if(!target.hasOwnProperty(q) || this.lgUUStamp(source[q], target[q])) {
								target[p] = source[p];
								target[q] = source[q];
							}
						} else if(!target.hasOwnProperty(q) && !target.hasOwnProperty(p)) {
							target[p] = source[p];
						}
					} else {
						var q = p.slice(1);
						if(!target.hasOwnProperty(p) || this.lgUUStamp(source[p], target[p])) {
							target[p] = source[p];
							delete target[q];
						}
					}
				}
			}
		}
	},
	getCellData: function(sheet, row, col, cleanData, withoutDefault, beforeProcessBorder, withoutZoom) {
		var o, body = true,
			merged = false,
			defaultProperty = this.defaultProperty,
			defaultHeight = defaultProperty.height,
			defaultWidth = defaultProperty.width;
		var lhDefault = {
			incell: false,
			va: "top"
		};
		if(0 == col) {
			body = false;
			if(0 != row) {
				o = Ext.apply({
					width: this.leftWidthSet[sheet] || this.defaultLeftWidth
				}, lhDefault);
				var l = this.getCell(sheet, row, 0);
				Ext.applyIf(o, l);
				if(o.wrap) {
					o.wrap = false;
				}
				if(!SCOM.canbeNumber(o.height)) {
					o.height = o.autoHeight || defaultHeight;
				}
				o.data = o.data || this.getRowName(row);
				this.processRowGroup(o, sheet, row, col);
				if(this.getCell(sheet, row - 1, col).hidden) {
					o.css = "ss-hdrow";
				}
			} else {
				o = this.getCell(sheet, 0, 0, true);
				o.height = this.headerCellHeight;
			}
		} else if(0 != row) {
			o = this.getCell(sheet, row, col);
			var l = this.getCell(sheet, row, 0);
			var height = l.height;
			if(!SCOM.canbeNumber(height)) {
				height = l.autoHeight || defaultHeight;
			}
			merged = this.isMergedCell(o, sheet, row, col);
			if(merged) {
				o = this.processMergedCell(sheet, row, col, o, withoutDefault, beforeProcessBorder);
			} else {
				var w = this.getCell(sheet, 0, 0);
				o = Ext.apply({
					incell: false,
					data: ""
				}, o);
				delete o.width;
				delete o.woff;
				var h = this.getCell(sheet, 0, col);
				this.applyProperty(o, l, h, w);
				o = this.processBorder(sheet, row, col, o, beforeProcessBorder);
				if(!this.isVerticalAlign(o.va)) {
					o.va = "top";
				}
			}
			o = SCOM.deleteMembers(o, this.avoidMembers);
			o.height = height;
		} else {
			body = false;
			o = this.getCell(sheet, 0, col, true);
			Ext.apply(o, lhDefault);
			if(o.wrap) {
				o.wrap = false;
			}
			if(!SCOM.canbeNumber(o.width)) {
				o.width = defaultWidth;
			}
			o.height = this.headerCellHeight;
			o.data = o.data || this.getColName(col);
			this.processColumnGroup(o, sheet, row, col);
			if(this.getCell(sheet, row, col - 1).hidden) {
				o.css = "ss-hdcol";
			}
		}
		o.wrap = o.wrap || false;
		o.body = body;
		if(!withoutDefault) {
			Ext.applyIf(o, this.defaultProperty);
		}
		o = this.processOffset(o, sheet, row, col, withoutZoom);
		if(cleanData) {
			o.data = SCOM.removeHTMLTag(o.data);
		}
		for(var p in EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.calGeneratedStyleMap) {
			if(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.calGeneratedStyleMap.hasOwnProperty(p)) {
				var q = EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.calGeneratedStyleMap[p];
				if(Ext.isDefined(o[p])) {
					o[q] = o[p];
				}
			}
		}
		return o;
	},
	processRowGroup: function(o, sheet, row, col) {
		this.fireEvent("processrowgroup", o, sheet, row, col, this);
	},
	processColumnGroup: function(o, sheet, row, col) {
		this.fireEvent("processcolumngroup", o, sheet, row, col, this);
	},
	processOffset: function(o, sheet, row, col, zoomed) {
		var dp = this.defaultProperty;
		if(!this.zoomDisabled && !zoomed) {
			o.width = this.zoomSize(o.width, true);
			o.height = this.zoomSize(o.height, true);
			o.fz = this.zoomSize(o.fz, true);
		}
		o.width -= this.cellWidthOffset;
		if(o.width < 0) {
			var off = o.width;
			o.width = 0;
			if(o.wrap) {
				o.wpr += off;
			}
			o.pr += off;
			if(0 > o.pr) {
				off = o.pr;
				o.pr = 0;
			} else {
				off = 0;
			}
			if(0 > off) {
				o.pl += off;
				if(0 > o.pl) {
					off = o.pl;
					o.pl = 0;
				} else {
					off = 0;
				}
				if(0 > off) {
					off += o.blw;
					o.blw = 0;
					if(0 > off) {
						o.brw += off;
					}
				}
			}
		}
		o.height -= this.cellHeightOffset;
		if(o.height < 0) {
			var off = o.height;
			o.height = 0;
			o.wpb += off;
			o.pb += off;
			if(0 > o.pb) {
				off = o.pb;
				o.pb = 0;
			} else {
				off = 0;
			}
			if(0 > off) {
				o.pt += off;
				if(0 > o.pt) {
					off = o.pt;
					o.pt = 0;
				} else {
					off = 0;
				}
				if(0 > off) {
					off += o.btw;
					o.btw = 0;
					if(0 > off) {
						o.bbw += off;
					}
				}
			}
		}
		if(0 === row) {
			o.width += o.pl + o.pr;
		}
		if(0 === col) {
			o.height += o.pt + o.pb;
		}
		return o;
	},
	isVerticalAlign: function(va) {
		return "middle" == va || "bottom" == va;
	},
	isMergedCell: function(cell, sheet, row, col) {
		if(!cell) {
			cell = this.getCell(sheet, row, col);
		}
		if(false != SCOM.typeOf(cell.minrow)) {
			return true;
		}
		return false;
	},
	isLeftTopMergeCell: function(cell, sheet, row, col) {
		if(!cell) {
			cell = this.getCell(sheet, row, col);
		}
		if(false != SCOM.typeOf(cell.minrow)) {
			return 0 === cell.minrow && 0 === cell.mincol;
		}
		return false;
	},
	processMergedCell: function(sheet, row, col, o, withoutDefault, beforeProcessBorder) {
		var incell = {
			minrow: o.minrow,
			mincol: o.mincol,
			maxrow: o.maxrow,
			maxcol: o.maxcol
		};
		var minrow = row + o.minrow;
		var mincol = col + o.mincol;
		var maxrow = row + o.maxrow;
		var maxcol = col + o.maxcol;
		for(var i = maxcol; i >= mincol; i--) {
			if(!this.isVisibleColumn(sheet, i)) {
				maxcol--;
			} else {
				break;
			}
		}
		for(var i = maxrow; i >= minrow; i--) {
			if(!this.isVisibleRow(sheet, i)) {
				maxrow--;
			} else {
				break;
			}
		}
		o = this.getCell(sheet, minrow, mincol, true);
		Ext.apply(o, incell);
		var l = this.getCell(sheet, minrow, 0);
		var h = this.getCell(sheet, 0, mincol);
		delete o.width;
		delete o.woff;
		var c = this.getCell(sheet, 0, 0);
		this.applyProperty(o, l, h, c);
		if(mincol != col) {
			h = this.getCell(sheet, 0, col);
			o.width = h.width;
		}
		o.w = this.getRangeWidth(sheet, mincol, maxcol, undefined, true);
		o.iw = o.w - this.cellWidthOffset;
		if(o.iw < 0) {
			o.iw = 0;
		}
		o.h = this.getRangeHeight(sheet, minrow, maxrow, undefined, true);
		o.ih = o.h - this.cellHeightOffset;
		if(o.ih < 0) {
			o.ih = 0;
		}
		o.l = -this.getRangeWidth(sheet, mincol, col - 1, undefined, true);
		o.t = -this.getRangeHeight(sheet, minrow, row - 1, undefined, true);
		if(minrow == row && mincol == col) {
			if(!withoutDefault) {
				Ext.applyIf(o, this.defaultProperty);
			}
		}
		if(col == mincol || col == maxcol || row == minrow || row == maxrow) {
			if(!(minrow == row && mincol == col)) {
				var c = this.getCellProperty(sheet, row, col, true);
				if(!withoutDefault) {
					Ext.applyIf(c, this.defaultProperty);
				}
				var tmp = ["xbls", "xblc", "xbrs", "xbrc", "xbts", "xbtc", "xbbs", "xbbc", "brc", "brw", "brs", "blc", "blw", "bls", "bbc", "bbw", "bbs", "btc", "btw", "bts", "wrap", "pl", "pr", "pt", "pb", "hoff", "woff", "wpr", "wpb"];
				for(var i = 0, len = tmp.length; i < len; i++) {
					var p = tmp[i];
					delete o[p];
					o[p] = c[p];
				}
			}
			o = this.processBorder(sheet, row, col, o, beforeProcessBorder);
		} else {
			if(Ext.isString(o.data)) {
				o.data = o.data.replace(/\n/gi, "<br/>");
			}
		}
		if(row != maxrow) {
			o.pb = this.defaultProperty.pb + 1;
			o.bbw = 0;
		}
		if(col != maxcol) {
			o.pr = this.defaultProperty.pr + 1;
			o.brw = 0;
		}
		if(col != mincol) {
			if(!Ext.isNumber(o.pl)) {
				o.pl = this.defaultProperty.pl;
			}
			o.pl += o.blw || 0;
			o.blw = 0;
		}
		if(row != minrow) {
			if(!Ext.isNumber(o.pt)) {
				o.pt = this.defaultProperty.pt;
			}
			o.pt += o.btw || 0;
			o.btw = 0;
		}
		o.l -= (o.pl + o.blw);
		o.t -= (o.pt + o.btw);
		o.incell = true;
		if(!this.isVerticalAlign(o.va)) {
			o.va = "top";
		}
		return o;
	},
	getColName: function(col) {
		return SCOM.number2Letter(col);
	},
	getRowName: function(row) {
		return row;
	},
	withStyleProperty: function(json) {
		if(json) {
			for(var i = 0, len = this.propertyNameArray.length; i < len; i++) {
				var p = this.propertyNameArray[i];
				if(json.hasOwnProperty(p)) {
					return true;
				}
			}
		}
	},
	needUUStamp: function(sheet, row, col, p) {
		if(0 === row || 0 === col) {
			return true;
		}
		var cell = this.getCell(sheet, 0, col);
		if(cell[p]) {
			return true;
		}
		var cell = this.getCell(sheet, row, 0);
		if(cell[p]) {
			return true;
		}
		var cell = this.getCell(sheet, 0, 0);
		if(cell[p]) {
			return true;
		}
	},
	setCell: function(sheet, row, col, modified, deleted, suspendEvent, applyWay) {
		var found = this.findStoreBySheetId(sheet);
		if(found) {
			var store = found.store;
			if(store === this) {
				return this.setOwnCell(found.sheetObj.id, row, col, modified, deleted, suspendEvent, applyWay);
			} else {}
		}
	},
	setOwnCell: function(sheet, row, col, modified, deleted, suspendEvent, applyWay) {
		this.fireEvent("preparesetcell", sheet, row, col, modified, deleted, suspendEvent, applyWay, this);
		var ips = EnterpriseSheet.pure.sheet.data.Store.prototype.inheritProperities;
		modified = modified || {};
		var uuid = this.getUUStamp();
		for(var p in modified) {
			if(modified.hasOwnProperty(p) && "_" !== p.charAt(0) && ips.hasOwnProperty(p)) {
				var q = "_" + p;
				if(this.needUUStamp(sheet, row, col, q)) {
					if(!modified[q]) {
						modified[q] = uuid;
					}
				}
			}
		}
		if(deleted) {
			for(var i = 0, len = deleted.length; i < len; i++) {
				var p = deleted[i];
				if("_" !== p.charAt(0) && ips.hasOwnProperty(p)) {
					var q = "_" + p;
					if(this.needUUStamp(sheet, row, col, q)) {
						if(!modified[q]) {
							modified[q] = uuid;
						}
					}
				}
			}
		}
		var id = this.getIdBasedData({
			sheet: sheet,
			row: row,
			col: col
		});
		var cell = this.getByMapId(id);
		var origin;
		if(cell) {
			origin = Ext.apply({}, cell.data.json);
			if("applyIf" == applyWay) {
				Ext.applyIf(cell.data.json, modified);
			} else if("clear" == applyWay) {
				cell.data.json = Ext.apply({}, modified);
				this.getData()[id][3] = cell.data.json;
			} else {
				Ext.apply(cell.data.json, modified);
			}
		} else {
			cell = this.newRecord(sheet, row, col, modified);
		}
		var originCopy = Ext.apply({}, origin);
		var json = cell.data.json;
		if(modified) {
			deleted = deleted || [];
			if(Ext.isDefined(modified.data) && modified.data !== originCopy.data && !Ext.isDefined(modified.itms)) {
				deleted.push("itms");
			}
			if(Ext.isDefined(modified.data) && !Ext.isDefined(modified.valId) && -1 == deleted.indexOf("valId")) {
				deleted.push("valId");
			}
		}
		if(deleted) {
			for(var i = 0, len = deleted.length; i < len; i++) {
				var p = deleted[i];
				delete json[p];
			}
		}
		if(0 === row && 0 === col) {
			this.prepareDefaultWidthHeight(json);
			this.resetRowHeightColWidthCache(sheet);
		}
		var current = Ext.apply({}, json);
		if(!Ext.isNumber(current.afrow)) {
			delete current.afrow;
			delete current.afcol;
			delete current.aerow;
			delete current.aecol;
		}
		if(!Ext.isNumber(originCopy.afrow)) {
			delete originCopy.afrow;
			delete originCopy.afcol;
			delete originCopy.aerow;
			delete originCopy.aecol;
		}
		if(0 !== row && 0 === col) {
			this.syncRowHeightCache(sheet, row);
		} else if(0 === row && 0 !== col) {
			this.syncColWidthCache(sheet, col);
		}
		var dataChanged = originCopy.data !== current.data || originCopy.itchk !== current.itchk || originCopy.afrow !== current.afrow || originCopy.afcol !== current.afcol || originCopy.aerow !== current.aerow || originCopy.aecol !== current.aecol;
		if(!suspendEvent) {
			if(dataChanged) {
				var timestamp = SCOM.genTimeStamp();
				this.fireEvent("datachange", timestamp, sheet, row, col, modified, deleted, origin, current, this, false);
			}
			this.fireEvent("cellchange", sheet, row, col, modified, deleted, origin, current, this);
		}
		var oldVal = originCopy.value;
		if(!Ext.isDefined(oldVal)) {
			oldVal = originCopy.data;
		}
		var curVal = current.value;
		if(!Ext.isDefined(curVal)) {
			curVal = current.data;
		}
		var valueChanged = false;
		if(dataChanged || oldVal !== curVal) {
			valueChanged = true;
			this.fireEvent("valuechange", sheet, row, col, modified, deleted, origin, current, this);
		}
		if(current.cal) {
			this.setCalCell2Lookup(id, this.getData()[id]);
		} else {
			this.setCalCell2Lookup(id);
		}
		if(!this.needResetupCalMap) {
			if(modified.refs) {
				this.updateCalMap(id, current.refs, origin ? origin.refs : undefined, [sheet, row, col]);
			} else if(origin && origin.cal && !current.cal) {
				this.updateCalMap(id, undefined, origin.refs, [sheet, row, col]);
			}
		}
		return [origin, current, dataChanged, valueChanged];
	},
	getBrokenMergedCells: function(sheetId, minrow, maxrow, mincol, maxcol, dir) {
		var brokens = {},
			visited = {};
		this.each(function(rec) {
			var data = rec.data;
			var json = data.json;
			var r = data.row,
				c = data.col;
			if(sheetId == data.sheet && false != SCOM.typeOf(json.minrow)) {
				var minr = json.minrow + r;
				var minc = json.mincol + c;
				var maxr = json.maxrow + r;
				var maxc = json.maxcol + c;
				var id = [minr, minc, maxr, maxc].join(this.separateChar);
				if(!visited[id]) {
					visited[id] = true;
					if("row" == dir) {
						if(minrow <= maxr) {
							if(!(mincol <= minc && maxc <= maxcol) && (mincol >= minc && mincol <= maxc || maxcol >= minc && maxcol <= maxc)) {
								brokens[id] = {
									minrow: minr,
									mincol: minc,
									maxrow: maxr,
									maxcol: maxc
								};
							}
						}
					} else if("col" == dir) {
						if(mincol <= maxc) {
							if(!(minrow <= minr && maxr <= maxrow) && (minrow >= minr && minrow <= maxr || maxrow >= minr && maxrow <= maxr)) {
								brokens[id] = {
									minrow: minr,
									mincol: minc,
									maxrow: maxr,
									maxcol: maxc
								};
							}
						}
					}
				}
			}
		}, this);
		return brokens;
	},
	isBrokenArrayFormulaCells: function(sheetId, minrow, maxrow, mincol, maxcol, dir) {
		var lookup = {},
			flag = false,
			span = [sheetId, minrow, mincol, maxrow, maxcol];
		this.each(function(rec) {
			var data = rec.data;
			var json = data.json;
			var r = data.row,
				c = data.col;
			if(sheetId == data.sheet && Ext.isNumber(json.afrow)) {
				var afrow = json.afrow + r,
					afcol = json.afcol + c,
					aerow = json.aerow,
					aecol = json.aecol;
				var id = afrow + "-" + afcol;
				if(!lookup[id]) {
					if(!Ext.isNumber(aerow)) {
						var cell = this.getCell(data.sheet, afrow, afcol);
						aerow = cell.aerow;
						aecol = cell.aecol;
					}
					aerow += r;
					aecol += c;
					if("row" == dir) {
						if(minrow <= aerow) {
							if(0 === mincol) {
								if(!(minrow <= afrow && maxrow >= aerow) && maxrow >= afrow) {
									flag = true;
									return false;
								}
							} else if((mincol >= afcol && mincol <= aecol || maxcol >= afcol && maxcol <= aecol) && !(mincol === afcol && maxcol === aecol)) {
								flag = true;
								return false;
							}
						}
					} else {
						if(mincol <= aecol) {
							if(0 === minrow) {
								if(!(mincol <= afcol && maxcol >= aecol) && maxcol >= afcol) {
									flag = true;
									return false;
								}
							} else if((minrow >= afrow && minrow <= aerow || maxrow >= afrow && maxrow <= aerow) && !(minrow === afrow && maxrow === aerow)) {
								flag = true;
								return false;
							}
						}
					}
					lookup[id] = true;
				}
			}
		}, this);
		return flag;
	},
	checkMergedCellChangeOld: function(sheet, rowSpan, colSpan, dir, suspendEvent) {
		var beforeFn, insideFn;
		if(rowSpan && colSpan) {
			insideFn = function(r, m) {
				return r.sheet == sheet && rowSpan.min <= r.row && rowSpan.max >= r.row && colSpan.min <= r.col && colSpan.max >= r.col && !(rowSpan.min <= m[0] && m[2] <= rowSpan.max && colSpan.min <= m[1] && m[3] <= colSpan.max);
			};
			beforeFn = function(r) {
				return r.sheet == sheet && rowSpan.min <= r.row && colSpan.min <= r.col;
			};
		} else if(rowSpan) {
			insideFn = function(r, m) {
				return r.sheet == sheet && rowSpan.min <= r.row && rowSpan.max >= r.row && !(rowSpan.min <= m[0] && m[2] <= rowSpan.max);
			};
			beforeFn = function(r) {
				return r.sheet == sheet && rowSpan.min <= r.row;
			};
		} else if(colSpan) {
			insideFn = function(r, m) {
				return r.sheet == sheet && colSpan.min <= r.col && colSpan.max >= r.col && !(colSpan.min <= m[1] && m[3] <= colSpan.max);
			};
			beforeFn = function(r) {
				return r.sheet == sheet && colSpan.min <= r.col;
			};
		} else {
			return;
		}
		var merged = {},
			s = this.separateChar;
		this.each(function(rec) {
			var data = rec.data;
			var json = data.json;
			var row = data.row,
				col = data.col;
			if(false != SCOM.typeOf(json.minrow) && beforeFn(data)) {
				var minrow = row + json.minrow;
				var maxrow = row + json.maxrow;
				var mincol = col + json.mincol;
				var maxcol = col + json.maxcol;
				var inside = insideFn(data, [minrow, mincol, maxrow, maxcol]);
				var id = [minrow, mincol, maxrow, maxcol].join(s);
				if(merged[id]) {
					if(inside) {
						merged[id].inside = inside;
					}
				} else {
					merged[id] = {
						minrow: minrow,
						mincol: mincol,
						maxrow: maxrow,
						maxcol: maxcol,
						inside: inside
					};
				}
			}
		}, this);
		if(!suspendEvent) {
			var cells = {};
			for(var p in merged) {
				var o = merged[p];
				var minrow = o.minrow;
				var mincol = o.mincol;
				var maxrow = o.maxrow;
				var maxcol = o.maxcol;
				this.setCell(sheet, minrow, mincol, null, null);
			}
		}
		return merged;
	},
	checkMergedCellChange: function(sheet, rowSpan, colSpan, dir, suspendEvent, insertMode) {
		var merges = this.getMergeFloatings();
		var merged = {};
		for(var p in merges) {
			if(merges.hasOwnProperty(p)) {
				var it = merges[p],
					sheetId = it.sheet,
					span = it.jsonObj;
				if(sheetId === sheet) {
					var minrow = span[0],
						mincol = span[1],
						maxrow = span[2],
						maxcol = span[3];
					if("row" === dir) {
						if(!colSpan || colSpan.min <= mincol && maxcol <= colSpan.max) {
							if(rowSpan.min <= maxrow) {
								merged[p] = {
									minrow: minrow,
									mincol: mincol,
									maxrow: maxrow,
									maxcol: maxcol,
									inside: insertMode ? rowSpan.max > minrow : rowSpan.max >= minrow
								};
							}
						}
					} else {
						if(!rowSpan || rowSpan.min <= minrow && maxrow <= rowSpan.max) {
							if(colSpan.min <= maxcol) {
								merged[p] = {
									minrow: minrow,
									mincol: mincol,
									maxrow: maxrow,
									maxcol: maxcol,
									inside: insertMode ? colSpan.max > mincol : colSpan.max >= mincol
								};
							}
						}
					}
				}
			}
		}
		if(!suspendEvent) {
			var cells = {};
			for(var p in merged) {
				var o = merged[p];
				var minrow = o.minrow;
				var mincol = o.mincol;
				var maxrow = o.maxrow;
				var maxcol = o.maxcol;
				for(var i = minrow; i <= maxrow; i++) {
					for(var j = mincol; j <= maxcol; j++) {
						this.setCell(sheet, i, j, null, null);
					}
				}
			}
		}
		return merged;
	},
	setWhole: function(sheet, modified, deleted, suspendEvent, applyWay) {
		applyWay = applyWay || "apply";
		this.setCell(sheet, 0, 0, modified, deleted, suspendEvent, applyWay);
	},
	setColumn: function(sheet, col, modified, deleted, suspendCellChange, suspendColChange, applyWay, noNeedCellProcess) {
		applyWay = applyWay || "apply";
		var rs = this.setCell(sheet, 0, col, modified, deleted, suspendCellChange, applyWay);
		if(!suspendColChange) {
			this.checkMergedCellChange(sheet, null, {
				min: col,
				max: col
			}, "col");
			this.fireEvent("columnchange", sheet, col, modified, deleted, rs[0], rs[1], this);
		}
	},
	setRow: function(sheet, row, modified, deleted, suspendCellChange, suspendRowChange, applyWay, noNeedCellProcess) {
		applyWay = applyWay || "apply";
		var rs = this.setCell(sheet, row, 0, modified, deleted, suspendCellChange, applyWay);
		if(!suspendRowChange) {
			this.checkMergedCellChange(sheet, {
				min: row,
				max: row
			}, null, "row");
			this.fireEvent("rowchange", sheet, row, modified, deleted, rs[0], rs[1], this);
		}
	},
	syncMaxRowColOfSheet: function(sheetId, dir) {
		var sheetObj = this.getSheetById(sheetId);
		if("row" === dir) {
			this.each(function(rec) {
				if(rec.data.sheet === sheetId) {
					if(rec.data.row > sheetObj.maxRow) {
						sheetObj.maxRow = rec.data.row;
					}
				}
			}, this);
		} else if("col" === dir) {
			this.each(function(rec) {
				if(rec.data.sheet === sheetId) {
					if(rec.data.col > sheetObj.maxCol) {
						sheetObj.maxCol = rec.data.col;
					}
				}
			}, this);
		} else {
			this.each(function(rec) {
				if(rec.data.sheet === sheetId) {
					if(rec.data.row > sheetObj.maxRow) {
						sheetObj.maxRow = rec.data.row;
					}
					if(rec.data.col > sheetObj.maxCol) {
						sheetObj.maxCol = rec.data.col;
					}
				}
			}, this);
		}
	},
	removeCellMoveLeft: function(sheet, minrow, maxrow, mincol, maxcol, suspendEvent, suspendPull) {
		var removeCol = !minrow || !maxrow ? true : false;
		var moveDir = "left";
		var span = maxcol - mincol + 1;
		if(0 >= span) {
			return;
		}
		var merged = this.checkMergedCellChange(sheet, removeCol ? null : {
			min: minrow,
			max: maxrow
		}, {
			min: mincol,
			max: maxcol
		}, "col", true);
		var deleted = this.queryBy(function(rec) {
			var col = rec.data.col,
				row = rec.data.row;
			if(rec.data.sheet == sheet && mincol <= col && col <= maxcol && (removeCol || minrow <= row && row <= maxrow)) {
				return true;
			}
		}, this);
		if(!suspendEvent) {
			if(removeCol) {
				if(false === this.fireEvent("beforeremovecolumn", sheet, mincol, maxcol, deleted, merged, this)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremovecolumn", sheet, mincol, maxcol, deleted, merged, this)) {
						return;
					}
				}
				this.fireEvent("prepareremovecolumn", sheet, mincol, maxcol, deleted, merged, this);
			} else {
				if(false === this.fireEvent("beforeremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
						return;
					}
				}
				this.fireEvent("prepareremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
			}
		} else {
			if(removeCol) {
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremovecolumn", sheet, mincol, maxcol, deleted, merged, this)) {
						return;
					}
				}
			} else {
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
						return;
					}
				}
			}
		}
		var affected;
		this.premarkActionPos();
		var data = this.getData();
		var oldP = {},
			newP = {};
		var separateChar = this.separateChar;
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var s = it[0],
					c = it[2],
					r = it[1];
				if(s == sheet && (removeCol || minrow <= r && r <= maxrow)) {
					if(c > maxcol) {
						it[2] -= span;
						var id = [s, r, it[2]].join(separateChar);
						newP[id] = it;
						if(!newP[p]) {
							oldP[p] = true;
						}
					} else if(mincol <= c) {
						delete data[p];
					}
				}
			}
		}
		for(var p in oldP) {
			if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)) {
				delete data[p];
			}
		}
		Ext.apply(data, newP);
		this.refreshCalLookup();
		if(removeCol) {
			this.resetColWidthCache(sheet);
			if(!suspendPull) {
				this.fireEvent("beforeholdremovecolumn", sheet, mincol, maxcol, deleted, merged, this);
			}
		} else {
			if(!suspendPull) {
				this.fireEvent("beforeholdremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
			}
		}
		this.syncMaxRowColOfSheet(sheet, removeCol ? "col" : undefined);
		if(!suspendEvent) {
			if(removeCol) {
				if(false !== this.fireEvent("holdremovecolumn", sheet, mincol, maxcol, deleted, merged, this)) {
					this.fireEvent("removecolumn", sheet, mincol, maxcol, deleted, merged, this);
				}
			} else {
				if(false !== this.fireEvent("holdremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
					this.fireEvent("removecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
				}
			}
			var changedMerged = {};
			for(var p in merged) {
				var o = merged[p];
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow;
				var maxc = o.maxcol;
				var span = maxcol - mincol + 1;
				if(o.inside) {
					if(mincol > minc && maxc > maxcol) {
						maxc -= span;
					} else if(mincol > minc) {
						maxc = mincol - 1;
					} else {
						maxc -= span;
						minc = mincol;
					}
					if(minr > maxr || maxc < minc || minr === maxr && minc === maxc) {
						if(minr === maxr && minc === maxc) {
							this.setCell(sheet, minr, minc, null, ["minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol"]);
						}
					} else {
						changedMerged[p] = {
							minrow: minr,
							mincol: minc,
							maxrow: maxr,
							maxcol: maxc,
							inside: true
						};
						for(var row = minr; row <= maxr; row++) {
							for(var col = minc; col <= maxc; col++) {
								this.setCell(sheet, row, col, {
									mincol: minc - col,
									maxcol: maxc - col
								});
							}
						}
					}
				} else {
					minc -= span;
					maxc -= span;
					changedMerged[p] = {
						minrow: minr,
						mincol: minc,
						maxrow: maxr,
						maxcol: maxc,
						inside: false
					};
					this.setCell(sheet, minr, minc, null, null);
				}
			}
			affected = this.getAffectedAction();
			if(removeCol) {
				this.fireEvent("columnremoved", sheet, mincol, maxcol, affected, deleted, changedMerged, this);
			} else {
				this.fireEvent("cellremoved", sheet, minrow, maxrow, mincol, maxcol, moveDir, affected, deleted, changedMerged, this);
			}
		} else {
			affected = this.getAffectedAction();
		}
		if(removeCol) {
			this.fireEvent("columnremovednotice", sheet, mincol, maxcol, affected, deleted, changedMerged, this);
		} else {
			this.fireEvent("cellremovednotice", sheet, minrow, maxrow, mincol, maxcol, moveDir, affected, deleted, changedMerged, this);
		}
	},
	removeCellMoveUp: function(sheet, minrow, maxrow, mincol, maxcol, suspendEvent, suspendPull) {
		var removeRow = !mincol || !maxcol ? true : false;
		var moveDir = "up";
		var span = maxrow - minrow + 1;
		if(0 >= span) {
			return;
		}
		var merged = this.checkMergedCellChange(sheet, {
			min: minrow,
			max: maxrow
		}, removeRow ? null : {
			min: mincol,
			max: maxcol
		}, "row", true);
		var deleted = this.queryBy(function(rec) {
			var row = rec.data.row,
				col = rec.data.col;
			if(sheet == rec.data.sheet && minrow <= row && row <= maxrow && (removeRow || mincol <= col && col <= maxcol)) {
				return true;
			}
		}, this);
		if(!suspendEvent) {
			if(removeRow) {
				if(false === this.fireEvent("beforeremoverow", sheet, minrow, maxrow, deleted, merged, this)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremoverow", sheet, minrow, maxrow, deleted, merged, this)) {
						return;
					}
				}
				this.fireEvent("prepareremoverow", sheet, minrow, maxrow, deleted, merged, this);
			} else {
				if(false === this.fireEvent("beforeremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
						return;
					}
				}
				this.fireEvent("prepareremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
			}
		} else {
			if(removeRow) {
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremoverow", sheet, minrow, maxrow, deleted, merged, this)) {
						return;
					}
				}
			} else {
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
						return;
					}
				}
			}
		}
		var affected;
		this.premarkActionPos();
		var data = this.getData();
		var oldP = {},
			newP = {},
			separateChar = this.separateChar;
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var s = it[0],
					r = it[1],
					c = it[2];
				if(s == sheet && (removeRow || mincol <= c && c <= maxcol)) {
					if(r > maxrow) {
						it[1] -= span;
						var id = [s, it[1], c].join(separateChar);
						newP[id] = it;
						if(!newP[p]) {
							oldP[p] = true;
						}
					} else if(minrow <= r) {
						delete data[p];
					}
				}
			}
		}
		for(var p in oldP) {
			if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)) {
				delete data[p];
			}
		}
		Ext.apply(data, newP);
		this.refreshCalLookup();
		if(removeRow) {
			this.resetRowHeightCache(sheet);
			if(!suspendPull) {
				this.fireEvent("beforeholdremoverow", sheet, minrow, maxrow, deleted, merged, this);
			}
		} else {
			if(!suspendPull) {
				this.fireEvent("beforeholdremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
			}
		}
		this.syncMaxRowColOfSheet(sheet, removeRow ? "row" : undefined);
		if(!suspendEvent) {
			if(removeRow) {
				if(false !== this.fireEvent("holdremoverow", sheet, minrow, maxrow, deleted, merged, this)) {
					this.fireEvent("removerow", sheet, minrow, maxrow, deleted, merged, this);
				}
			} else {
				if(false !== this.fireEvent("holdremovecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this)) {
					this.fireEvent("removecell", sheet, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, this);
				}
			}
			var changedMerged = {};
			for(var p in merged) {
				var o = merged[p];
				var span = maxrow - minrow + 1;
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow;
				var maxc = o.maxcol;
				if(o.inside) {
					if(minrow > minr && maxr > maxrow) {
						maxr -= span;
					} else if(minrow > minr) {
						maxr = minrow - 1;
					} else {
						maxr -= span;
						minr = minrow;
					}
					if(minr > maxr || minc > maxc || minr == maxr && maxc == minc) {
						if(minr == maxr && maxc == minc) {
							this.setCell(sheet, minr, minc, null, ["minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol"]);
						}
					} else {
						changedMerged[p] = {
							minrow: minr,
							mincol: minc,
							maxrow: maxr,
							maxcol: maxc,
							inside: true
						};
						for(var row = minr; row <= maxr; row++) {
							for(var col = minc; col <= maxc; col++) {
								this.setCell(sheet, row, col, {
									minrow: minr - row,
									maxrow: maxr - row
								});
							}
						}
					}
				} else {
					minr -= span;
					maxr -= span;
					changedMerged[p] = {
						minrow: minr,
						mincol: minc,
						maxrow: maxr,
						maxcol: maxc,
						inside: false
					};
					this.setCell(sheet, minr, minc, null, null);
				}
			}
			affected = this.getAffectedAction();
			if(removeRow) {
				this.fireEvent("rowremoved", sheet, minrow, maxrow, affected, deleted, changedMerged, this);
			} else {
				this.fireEvent("cellremoved", sheet, minrow, maxrow, mincol, maxcol, moveDir, affected, deleted, changedMerged, this);
			}
		} else {
			affected = this.getAffectedAction();
		}
		if(removeRow) {
			this.fireEvent("rowremovednotice", sheet, minrow, maxrow, affected, deleted, changedMerged, this);
		} else {
			this.fireEvent("cellremovednotice", sheet, minrow, maxrow, mincol, maxcol, moveDir, affected, deleted, changedMerged, this);
		}
	},
	removeCell: function(sheet, minrow, maxrow, mincol, maxcol, moveDir, suspendEvent) {
		if("left" == moveDir) {
			this.removeCellMoveLeft(sheet, minrow, maxrow, mincol, maxcol, suspendEvent);
		} else {
			this.removeCellMoveUp(sheet, minrow, maxrow, mincol, maxcol, suspendEvent);
		}
	},
	removeRow: function(sheet, minrow, maxrow, suspendEvent, suspendPull) {
		this.removeCellMoveUp(sheet, minrow, maxrow, 0, 0, suspendEvent, suspendPull);
	},
	removeColumn: function(sheet, mincol, maxcol, suspendEvent, suspendPull) {
		this.removeCellMoveLeft(sheet, 0, 0, mincol, maxcol, suspendEvent, suspendPull);
	},
	insertCellMoveRight: function(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache, suspendPull, expandCalInNext) {
		var insertCol = !row || !rowSpan ? true : false;
		var moveDir = "right";
		var merged = this.checkMergedCellChange(sheet, insertCol ? null : {
			min: row,
			max: row + rowSpan - 1
		}, {
			min: col,
			max: col
		}, "col", true, "insert");
		if(!suspendEvent) {
			if(insertCol) {
				if(false === this.fireEvent("beforeinsertcolumn", sheet, col, colSpan, merged, this, expandCalInNext)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoinsertcolumn", sheet, col, colSpan, merged, this, expandCalInNext)) {
						return;
					}
				}
				this.fireEvent("prepareinsertcolumn", sheet, col, colSpan, merged, this);
			} else {
				if(false === this.fireEvent("beforeinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext)) {
						return;
					}
				}
				this.fireEvent("prepareinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext);
			}
		} else {
			if(insertCol) {
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoinsertcolumn", sheet, col, colSpan, merged, this, expandCalInNext)) {
						return;
					}
				}
			} else {
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext)) {
						return;
					}
				}
			}
		}
		var affected;
		this.premarkActionPos();
		var data = this.getData();
		var minrow = row,
			maxrow = row + rowSpan - 1;
		var oldP = {},
			newP = {},
			separateChar = this.separateChar;
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var s = it[0],
					r = it[1],
					c = it[2];
				if(s == sheet && c >= col && (insertCol || minrow <= r && r <= maxrow)) {
					it[2] += colSpan;
					id = [s, r, it[2]].join(separateChar);
					newP[id] = it;
					if(!newP[p]) {
						oldP[p] = true;
					}
				}
			}
		}
		for(var p in oldP) {
			if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)) {
				delete data[p];
			}
		}
		Ext.apply(data, newP);
		this.refreshCalLookup();
		if(insertCol) {
			this.resetColWidthCache(sheet);
			if(!suspendPull) {
				this.fireEvent("beforeholdinsertcolumn", sheet, col, colSpan, merged, this, expandCalInNext);
			}
		} else {
			if(!suspendPull) {
				this.fireEvent("beforeholdinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext);
			}
		}
		var insertCacheFn = function() {
			if(insertCellCache) {
				for(var p in insertCellCache) {
					if(insertCellCache.hasOwnProperty(p)) {
						var it = insertCellCache[p];
						var sid = it.sheetId,
							r = it.row,
							c = it.col,
							json = it.json;
						this.setCell(sid, r, c, json, undefined, true, "clear");
					}
				}
			}
			this.syncMaxRowColOfSheet(sheet, insertCol ? "col" : undefined);
		};
		if(!suspendEvent) {
			if(insertCol) {
				if(false !== this.fireEvent("holdinsertcolumn", sheet, col, colSpan, merged, this, insertCellCache, expandCalInNext)) {
					insertCacheFn.call(this);
					this.fireEvent("insertcolumn", sheet, col, colSpan, merged, this, expandCalInNext);
				} else {
					insertCacheFn.call(this);
				}
			} else {
				if(false !== this.fireEvent("holdinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, insertCellCache, expandCalInNext)) {
					insertCacheFn.call(this);
					this.fireEvent("insertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext);
				} else {
					insertCacheFn.call(this);
				}
			}
			for(var p in merged) {
				var o = merged[p];
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow;
				var maxc = o.maxcol + colSpan;
				if(o.inside) {
					for(var r = minr; r <= maxr; r++) {
						for(var c = maxc; c >= minc; c--) {
							this.setCell(sheet, r, c, {
								mincol: minc - c,
								maxcol: maxc - c,
								minrow: minr - r,
								maxrow: maxr - r
							});
						}
					}
				} else {
					this.setCell(sheet, minr, minc + colSpan, null, null);
				}
			}
			affected = this.getAffectedAction();
			if(insertCol) {
				this.fireEvent("columninserted", sheet, col, colSpan, affected, merged, this, expandCalInNext);
			} else {
				this.fireEvent("cellinserted", sheet, row, col, rowSpan, colSpan, moveDir, affected, merged, this, expandCalInNext);
			}
		} else {
			insertCacheFn.call(this);
			affected = this.getAffectedAction();
		}
		if(insertCol) {
			this.fireEvent("columninsertednotice", sheet, col, colSpan, affected, merged, this, expandCalInNext);
		} else {
			this.fireEvent("cellinsertednotice", sheet, row, col, rowSpan, colSpan, moveDir, affected, merged, this, expandCalInNext);
		}
	},
	insertCellMoveDown: function(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache, suspendPull, expandCalInNext) {
		var insertRow = !col || !colSpan ? true : false;
		var moveDir = "down";
		var merged = this.checkMergedCellChange(sheet, {
			min: row,
			max: row
		}, insertRow ? null : {
			min: col,
			max: col + colSpan - 1
		}, "row", true, "insert");
		if(!suspendEvent) {
			if(insertRow) {
				if(false === this.fireEvent("beforeinsertrow", sheet, row, rowSpan, merged, this, expandCalInNext)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoinsertrow", sheet, row, rowSpan, merged, this, expandCalInNext)) {
						return;
					}
				}
				this.fireEvent("prepareinsertrow", sheet, row, rowSpan, merged, this);
			} else {
				if(false === this.fireEvent("beforeinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext)) {
					return;
				}
				if(!suspendPull) {
					if(false === this.fireEvent("beforegoinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext)) {
						return;
					}
				}
				this.fireEvent("prepareinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext);
			}
		} else if(!suspendPull) {
			if(insertRow) {
				if(false === this.fireEvent("beforegoinsertrow", sheet, row, rowSpan, merged, this, expandCalInNext)) {
					return;
				}
			} else {
				if(false === this.fireEvent("beforegoinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext)) {
					return;
				}
			}
		}
		var affected;
		this.premarkActionPos();
		var data = this.getData();
		var mincol = col,
			maxcol = col + colSpan - 1;
		var oldP = {},
			newP = {},
			separateChar = this.separateChar;
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var s = it[0],
					r = it[1],
					c = it[2];
				if(s == sheet && r >= row && (insertRow || mincol <= c && c <= maxcol)) {
					it[1] += rowSpan;
					id = [s, it[1], c].join(separateChar);
					newP[id] = it;
					if(!newP[p]) {
						oldP[p] = true;
					}
				}
			}
		}
		for(var p in oldP) {
			if(oldP.hasOwnProperty(p) && !newP.hasOwnProperty(p)) {
				delete data[p];
			}
		}
		Ext.apply(data, newP);
		this.refreshCalLookup();
		if(insertRow) {
			this.resetRowHeightCache(sheet);
			if(!suspendPull) {
				this.fireEvent("beforeholdinsertrow", sheet, row, rowSpan, merged, this, expandCalInNext);
			}
		} else {
			if(!suspendPull) {
				this.fireEvent("beforeholdinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext);
			}
		}
		var insertCacheFn = function() {
			if(insertCellCache) {
				for(var p in insertCellCache) {
					if(insertCellCache.hasOwnProperty(p)) {
						var it = insertCellCache[p];
						var sid = it.sheetId,
							r = it.row,
							c = it.col,
							json = it.json;
						this.setCell(sid, r, c, json, undefined, true, "clear");
					}
				}
			}
		};
		if(!suspendEvent) {
			if(insertRow) {
				if(false !== this.fireEvent("holdinsertrow", sheet, row, rowSpan, merged, this, insertCellCache, expandCalInNext)) {
					insertCacheFn.call(this);
					this.fireEvent("insertrow", sheet, row, rowSpan, merged, this, expandCalInNext);
				} else {
					insertCacheFn.call(this);
				}
			} else {
				if(false !== this.fireEvent("holdinsertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, insertCellCache, expandCalInNext)) {
					insertCacheFn.call(this);
					this.fireEvent("insertcell", sheet, row, col, rowSpan, colSpan, moveDir, merged, this, expandCalInNext);
				} else {
					insertCacheFn.call(this);
				}
			}
			this.syncMaxRowColOfSheet(sheet, insertRow ? "row" : undefined);
			for(var p in merged) {
				var o = merged[p];
				var minr = o.minrow;
				var minc = o.mincol;
				var maxr = o.maxrow + rowSpan;
				var maxc = o.maxcol;
				if(o.inside) {
					for(var r = maxr; r >= minr; r--) {
						for(var c = minc; c <= maxc; c++) {
							this.setCell(sheet, r, c, {
								mincol: minc - c,
								maxcol: maxc - c,
								minrow: minr - r,
								maxrow: maxr - r
							});
						}
					}
				} else {
					this.setCell(sheet, minr + rowSpan, minc, null, null);
				}
			}
			affected = this.getAffectedAction();
			if(insertRow) {
				this.fireEvent("rowinserted", sheet, row, rowSpan, affected, merged, this, expandCalInNext);
			} else {
				this.fireEvent("cellinserted", sheet, row, col, rowSpan, colSpan, moveDir, affected, merged, this, expandCalInNext);
			}
		} else {
			insertCacheFn.call(this);
			affected = this.getAffectedAction();
		}
		if(insertRow) {
			this.fireEvent("rowinsertednotice", sheet, row, rowSpan, affected, merged, this, expandCalInNext);
		} else {
			this.fireEvent("cellinsertednotice", sheet, row, col, rowSpan, colSpan, moveDir, affected, merged, this, expandCalInNext);
		}
	},
	premarkActionPos: function() {},
	getAffectedAction: function() {},
	insertCell: function(sheet, row, col, rowSpan, colSpan, moveDir, suspendEvent, insertCellCache, suspendPull) {
		if("right" == moveDir) {
			this.insertCellMoveRight(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache, suspendPull);
		} else {
			this.insertCellMoveDown(sheet, row, col, rowSpan, colSpan, suspendEvent, insertCellCache, suspendPull);
		}
	},
	insertRow: function(sheet, row, span, suspendEvent, insertCellCache, suspendPull, expandCalInNext) {
		this.insertCellMoveDown(sheet, row, 0, span, 0, suspendEvent, insertCellCache, suspendPull, expandCalInNext);
	},
	insertColumn: function(sheet, col, span, suspendEvent, insertCellCache, suspendPull, expandCalInNext) {
		this.insertCellMoveRight(sheet, 0, col, 0, span, suspendEvent, insertCellCache, suspendPull, expandCalInNext);
	},
	isVisibleRow: function(sheet, row, data) {
		var id = this.getIdBasedData({
			sheet: sheet,
			row: row,
			col: 0
		});
		var c;
		if(data) {
			c = data.key(id);
		} else {
			c = this.getByMapId(id);
		}
		if(c && c.data.json.hidden) {
			return false;
		}
		return true;
	},
	isVisibleColumn: function(sheet, col, data) {
		var id = this.getIdBasedData({
			sheet: sheet,
			row: 0,
			col: col
		});
		var c;
		if(data) {
			c = data.key(id);
		} else {
			c = this.getByMapId(id);
		}
		if(c && c.data.json.hidden) {
			return false;
		}
		return true;
	},
	countVisibleRow: function(sheet, minrow, maxrow) {
		var count = 0;
		for(var i = minrow; i <= maxrow; i++) {
			if(this.isVisibleRow(sheet, i)) {
				count++;
			}
		}
		return count;
	},
	countVisibleColumn: function(sheet, mincol, maxcol) {
		var count = 0;
		for(var i = mincol; i <= maxcol; i++) {
			if(this.isVisibleColumn(sheet, i)) {
				count++;
			}
		}
		return count;
	},
	hideRow: function(sheet, minrow, maxrow, suspendEvent) {
		if(false !== this.fireEvent("beforehiderow", sheet, minrow, maxrow, this)) {
			this.fireEvent("preparehiderow", sheet, minrow, maxrow, this);
			var visibles = [],
				data = this.getData(),
				sep = this.separateChar;
			for(var i = minrow; i <= maxrow; i++) {
				if(this.isVisibleRow(sheet, i)) {
					visibles.push(i);
				}
				var id = [sheet, i, 0].join(sep);
				var cell = data[id];
				if(!cell) {
					cell = {};
					data[id] = [sheet, i, 0, cell];
				} else {
					cell = cell[3];
				}
				cell.hidden = true;
				this.syncRowHeightCache(sheet, i);
			}
			if(!suspendEvent) {
				this.fireEvent("hiderow", sheet, minrow, maxrow, this);
			}
			return visibles;
		}
	},
	hideColumn: function(sheet, mincol, maxcol, suspendEvent) {
		if(false !== this.fireEvent("beforehidecolumn", sheet, mincol, maxcol, this)) {
			this.fireEvent("preparehidecolumn", sheet, mincol, maxcol, this);
			var visibles = [],
				data = this.getData(),
				sep = this.separateChar;
			for(var i = mincol; i <= maxcol; i++) {
				if(this.isVisibleColumn(sheet, i)) {
					visibles.push(i);
				}
				var id = [sheet, 0, i].join(sep);
				var cell = data[id];
				if(!cell) {
					cell = {};
					data[id] = [sheet, 0, i, cell];
				} else {
					cell = cell[3];
				}
				cell.hidden = true;
				this.syncColWidthCache(sheet, i);
			}
			if(!suspendEvent) {
				this.fireEvent("hidecolumn", sheet, mincol, maxcol, this);
			}
			return visibles;
		}
	},
	showRow: function(sheet, minrow, maxrow, suspendEvent) {
		if(false !== this.fireEvent("beforeshowrow", sheet, minrow, maxrow, this)) {
			this.fireEvent("prepareshowrow", sheet, minrow, maxrow, this);
			var hiddens = [],
				data = this.getData(),
				sep = this.separateChar;
			for(var i = minrow; i <= maxrow; i++) {
				if(!this.isVisibleRow(sheet, i)) {
					hiddens.push(i);
				}
				var id = [sheet, i, 0].join(sep);
				var cell = data[id];
				if(!cell) {
					cell = {};
					data[id] = [sheet, i, 0, cell];
				} else {
					cell = cell[3];
				}
				cell.hidden = false;
				this.syncRowHeightCache(sheet, i);
			}
			if(!suspendEvent) {
				this.fireEvent("showrow", sheet, minrow, maxrow, this);
			}
			return hiddens;
		}
	},
	showColumn: function(sheet, mincol, maxcol, suspendEvent) {
		if(false !== this.fireEvent("beforeshowcolumn", sheet, mincol, maxcol, this)) {
			this.fireEvent("prepareshowcolumn", sheet, mincol, maxcol, this);
			var hiddens = [],
				data = this.getData(),
				sep = this.separateChar;
			for(var i = mincol; i <= maxcol; i++) {
				if(!this.isVisibleColumn(sheet, i)) {
					hiddens.push(i);
				}
				var id = [sheet, 0, i].join(sep);
				var cell = data[id];
				if(!cell) {
					cell = {};
					data[id] = [sheet, 0, i, cell];
				} else {
					cell = cell[3];
				}
				cell.hidden = false;
				this.syncColWidthCache(sheet, i);
			}
			if(!suspendEvent) {
				this.fireEvent("showcolumn", sheet, mincol, maxcol, this);
			}
			return hiddens;
		}
	},
	getBorderConfig: function(dir, width, style, color, flag) {
		var o = {};
		var dp = this.defaultProperty;
		if(3 == width) {
			var brw = bbw = blw = btw = 1;
			if("solid" == style) {
				brw = 2;
				bbw = 2;
			}
			var type = style;
			style = "solid";
			if("r" == dir) {
				if(flag) {
					Ext.apply(o, {
						wrap: true,
						brw: brw,
						brt: type,
						brs: style,
						brc: color,
						pr: 1
					});
				} else {
					Ext.apply(o, {
						brw: dp.brw,
						pr: dp.pr,
						brt: false
					});
				}
			} else if("b" == dir) {
				if(flag) {
					Ext.apply(o, {
						wrap: true,
						bbw: bbw,
						bbt: type,
						bbs: style,
						bbc: color,
						pb: 1
					});
				} else {
					Ext.apply(o, {
						bbw: dp.bbw,
						pb: dp.pb,
						bbt: false
					});
				}
			} else if("l" == dir) {
				if(flag) {
					Ext.apply(o, {
						wrap: true,
						blw: blw,
						blt: type,
						bls: style,
						blc: color,
						pl: 1
					});
				} else {
					Ext.apply(o, {
						blw: dp.blw,
						pl: dp.pl,
						blt: false,
						blf: 0
					});
				}
			} else if("t" == dir) {
				if(flag) {
					Ext.apply(o, {
						wrap: true,
						btw: btw,
						btt: type,
						bts: style,
						btc: color,
						pt: 1
					});
				} else {
					Ext.apply(o, {
						btw: dp.btw,
						pt: pt,
						btt: false,
						btf: 0
					});
				}
			}
		} else {
			var brw = dp.brw + width - 1,
				bbw = dp.bbw + width - 1;
			var pb = dp.pb - width + 1,
				pr = dp.pr - width + 1,
				pt = dp.pt;
			if("r" == dir) {
				if(flag) {
					Ext.apply(o, {
						brc: color,
						brs: style,
						brw: brw,
						brt: false,
						pr: pr
					});
				} else {
					Ext.apply(o, {
						brw: dp.brw,
						pr: dp.pr,
						brt: false
					});
				}
			} else if("b" == dir) {
				if(flag) {
					Ext.apply(o, {
						bbc: color,
						bbs: style,
						bbw: bbw,
						bbt: false,
						pb: pb
					});
				} else {
					Ext.apply(o, {
						bbw: dp.bbw,
						pb: dp.pb,
						bbt: false
					});
				}
			} else if("l" == dir) {
				if(flag) {
					Ext.apply(o, {
						blw: dp.blw,
						pl: dp.pl,
						blc: color,
						bls: style,
						blt: false,
						blf: width
					});
				} else {
					Ext.apply(o, {
						blw: dp.blw,
						pl: dp.pl,
						blt: false,
						blf: 0
					});
				}
			} else if("t" == dir) {
				if(flag) {
					Ext.apply(o, {
						btw: dp.btw,
						pt: pt,
						btc: color,
						bts: style,
						btt: false,
						btf: width
					});
				} else {
					Ext.apply(o, {
						btw: dp.btw,
						pt: pt,
						btt: false,
						btf: 0
					});
				}
			}
		}
		return o;
	},
	getXBorderConfig: function(dir, width, style, color, flag) {
		var o = {};
		var s = "xb" + dir + "s",
			c = "xb" + dir + "c";
		o[s] = "";
		o[c] = "";
		if(flag) {
			o[c] = color;
			if(3 === width) {
				if("double" === style) {
					o[s] = "double";
				} else {
					o[s] = "thick";
				}
			} else if(2 === width) {
				if("dashed" === style) {
					o[s] = "mediumDashed";
				} else if("dotted" === style) {
					o[s] = "dotted";
				} else {
					o[s] = "medium";
				}
			} else {
				if("dashed" === style) {
					o[s] = "dashed";
				} else if("dotted" === style) {
					o[s] = "hair";
				} else {
					o[s] = "thin";
				}
			}
		}
		return o;
	},
	setRangeBorder: function(sheet, row, col, config, suspendEvent) {
		var o = {};
		for(var i = 0, len = config.length; i < len; i++) {
			var it = config[i];
			Ext.apply(o, this.getXBorderConfig(it.dir, it.width, it.style, it.color, it.flag));
		}
		if(0 == row && 0 == col) {
			this.setWhole(sheet, o, null, suspendEvent);
		} else if(0 == row) {
			this.setColumn(sheet, col, o, null, suspendEvent);
		} else if(0 == col) {
			this.setRow(sheet, row, o, null, suspendEvent);
		} else {
			this.setCell(sheet, row, col, o, null, suspendEvent);
		}
	},
	setColumnWidth: function(sheet, col, width, suspendCellChange, suspendColChange) {
		if(0 < width) {
			this.setColumn(sheet, col, {
				width: width
			}, null, suspendCellChange, suspendColChange, undefined, true);
		}
	},
	setRowHeight: function(sheet, row, height, suspendCellChange, suspendRowChange) {
		if(0 < height) {
			this.setRow(sheet, row, {
				height: height
			}, null, suspendCellChange, suspendRowChange, undefined, true);
		}
	},
	setRowAutoHeight: function(sheet, row, height, suspendCellChange, suspendRowChange) {
		if(0 < height) {
			this.setRow(sheet, row, {
				autoHeight: height
			}, ["height"], suspendCellChange, suspendRowChange, undefined, true);
		}
	},
	disassembleData: function() {
		var arr = [];
		this.each(function(rd) {
			var data = rd.data;
			var sheet = data.sheet,
				row = data.row,
				col = data.col,
				json = data.json;
			for(var p in json) {
				arr.push([sheet, row, col, p, json[p]]);
			}
		}, this);
		return arr;
	},
	walkWhole: function(sheet, fn, scope) {
		var ret;
		this.each(function(rd, internalId) {
			if(rd.data.sheet == sheet && !(0 === rd.data.row && 0 === rd.data.col)) {
				ret = fn.call(scope, rd, [sheet, 0, 0, 0, 0], this, internalId);
				return ret;
			}
		}, this);
		var id = this.getIdBasedData({
			sheet: sheet,
			row: 0,
			col: 0
		});
		var c = this.getByMapId(id);
		if(!c) {
			var rd = {
				data: {
					sheet: sheet,
					row: 0,
					col: 0,
					json: {}
				}
			};
			return fn.call(scope, rd, [sheet, 0, 0, 0, 0], this, id);
		} else {
			return fn.call(scope, c, [sheet, 0, 0, 0, 0], this, id);
		}
		return ret;
	},
	walkRow: function(sheet, minRow, maxRow, minCol, fn, scope, coverFn) {
		minCol = minCol || 0;
		var ret, cols = [];
		this.each(function(rd, internalId) {
			var row = rd.data.row,
				col = rd.data.col;
			if(rd.data.sheet === sheet && 0 !== col && row >= minRow && maxRow >= row && minCol <= col) {
				ret = fn.call(scope, rd, [sheet, minRow, minCol, maxRow, 0], this, internalId);
				return ret;
			}
		}, this);
		if(false === ret) {
			return false;
		}
		if(coverFn) {
			this.each(function(rd) {
				var row = rd.data.row,
					col = rd.data.col;
				if(rd.data.sheet === sheet && 0 === row) {
					if(coverFn.call(scope, rd)) {
						cols.push(col);
					}
				}
			}, this);
			for(var i = 0, len = cols.length; i < len; i++) {
				var col = cols[i];
				for(var j = minRow; j <= maxRow; j++) {
					var id = this.getIdBasedData({
						sheet: sheet,
						row: j,
						col: col
					});
					if(!this.getByMapId(id)) {
						var rd = {
							data: {
								sheet: sheet,
								row: j,
								col: col,
								json: {}
							}
						};
						if(false === fn.call(scope, rd, [sheet, minRow, 0, maxRow, 0], this, id)) {
							return false;
						}
					}
				}
			}
		}
		for(var i = minRow; i <= maxRow; i++) {
			var id = this.getIdBasedData({
				sheet: sheet,
				row: i,
				col: 0
			});
			var c = this.getByMapId(id);
			if(!c) {
				var rd = {
					data: {
						sheet: sheet,
						row: i,
						col: 0,
						json: {}
					}
				};
				if(false === fn.call(scope, rd, [sheet, minRow, 0, maxRow, 0], this, id)) {
					return false;
				}
			} else {
				if(false === fn.call(scope, c, [sheet, minRow, 0, maxRow, 0], this, id)) {
					return false;
				}
			}
		}
		return ret;
	},
	walkColumn: function(sheet, minCol, maxCol, minRow, fn, scope, coverFn) {
		minRow = minRow || 0;
		var ret, rows = [];
		this.each(function(rd, internalId) {
			var col = rd.data.col,
				row = rd.data.row;
			if(rd.data.sheet == sheet && 0 !== row && col >= minCol && col <= maxCol && minRow <= row) {
				ret = fn.call(scope, rd, [sheet, minRow, minCol, 0, maxCol], this, internalId);
				return ret;
			}
		}, this);
		if(false === ret) {
			return false;
		}
		if(coverFn) {
			this.each(function(rd) {
				var row = rd.data.row,
					col = rd.data.col;
				if(rd.data.sheet === sheet && 0 === col) {
					if(coverFn.call(scope, rd)) {
						rows.push(row);
					}
				}
			}, this);
			for(var i = 0, len = rows.length; i < len; i++) {
				var row = rows[i];
				for(var j = minCol; j <= maxCol; j++) {
					var id = this.getIdBasedData({
						sheet: sheet,
						row: row,
						col: j
					});
					if(!this.getByMapId(id)) {
						var rd = {
							data: {
								sheet: sheet,
								row: row,
								col: j,
								json: {}
							}
						};
						if(false === fn.call(scope, rd, [sheet, 0, minCol, 0, maxCol], this, id)) {
							return false;
						}
					}
				}
			}
		}
		for(var i = minCol; i <= maxCol; i++) {
			var id = this.getIdBasedData({
				sheet: sheet,
				row: 0,
				col: i
			});
			var c = this.getByMapId(id);
			if(!c) {
				var rd = {
					data: {
						sheet: sheet,
						row: 0,
						col: i,
						json: {}
					}
				};
				if(false === fn.call(scope, rd, [sheet, 0, minCol, 0, maxCol], this, id)) {
					return false;
				}
			} else {
				if(false === fn.call(scope, c, [sheet, 0, minCol, 0, maxCol], this, id)) {
					return false;
				}
			}
		}
		return ret;
	},
	walkRange: function(ranges, fn, scope, skipEmpty, coverFn, ignore) {
		var cache = {};
		for(var i = 0, len = ranges.length; i < len; i++) {
			var span = ranges[i];
			if(Ext.isArray(span)) {
				var s = span[0];
				var found = this.findStoreBySheetId(s);
				if(found) {
					var store = found.store;
					if(store) {
						var id = store.getId();
						cache[id] = cache[id] || {
							store: store,
							ranges: [],
							map: {}
						};
						cache[id].map[found.sheetObj.id] = span[0];
						span[0] = found.sheetObj.id;
						cache[id].ranges.push(span);
					}
				}
			}
		}
		for(var p in cache) {
			if(cache.hasOwnProperty(p)) {
				var it = cache[p];
				it.store.walkOwnRange(it.ranges, fn ? function(rd, span, theStore, internalId) {
					rd.data.sheet = it.map[rd.data.sheet];
					return fn.call(scope, rd, span, theStore, internalId);
				} : fn, this, skipEmpty, coverFn ? function(rd) {
					rd.data.sheet = it.map[rd.data.sheet];
					return coverFn.call(scope, rd);
				} : coverFn, ignore);
			}
		}
	},
	walkOwnRange: function(ranges, fn, scope, skipEmpty, coverFn, ignore) {
		var sheetLookup = this.getSheetIdLookup();
		for(var i = 0, len = ranges.length; i < len; i++) {
			var span = ranges[i];
			var s = span[0];
			if(0 === span[1] && 0 === span[2] && !ignore) {
				if(false === this.walkWhole(s, fn, scope)) {
					return;
				}
			} else if(0 === span[3] && !ignore) {
				if(false === this.walkColumn(s, span[2], span[4], span[1], fn, scope, coverFn)) {
					return;
				}
			} else if(0 === span[4] && !ignore) {
				if(false === this.walkRow(s, span[1], span[3], span[2], fn, scope, coverFn)) {
					return;
				}
			} else {
				for(var r = span[1]; r <= span[3]; r++) {
					for(var c = span[2]; c <= span[4]; c++) {
						var id = this.getIdBasedData({
							sheet: s,
							row: r,
							col: c
						});
						var rd = this.getByMapId(id);
						if(!skipEmpty && !rd) {
							rd = {
								data: {
									sheet: s,
									row: r,
									col: c,
									json: {}
								}
							};
						}
						if(rd) {
							if(false === fn.call(scope, rd, span, this, id)) {
								return;
							}
						}
					}
				}
			}
		}
	},
	withBrokenMergedCell: function(coord) {
		var withBroken = false;
		this.walkRange(coord, function(rd, span) {
			var json = rd.data.json;
			if(this.isMergedCell(rd.data.json, rd.data.sheet, rd.data.row, rd.data.col)) {
				var minrow = rd.data.row + json.minrow;
				var maxrow = rd.data.row + json.maxrow;
				var mincol = rd.data.col + json.mincol;
				var maxcol = rd.data.col + json.maxcol;
				withBroken = !((0 == span[1] || span[1] <= minrow) && (0 == span[2] || span[2] <= mincol) && (0 == span[3] || span[3] >= maxrow) && (0 == span[4] || span[4] >= maxcol));
				if(withBroken) {
					return false;
				}
			}
		}, this, true);
		return withBroken;
	},
	withBrokenTplCell: function(coord) {
		var withBroken = false,
			tpls = {};
		this.walkRange(coord, function(rd, span) {
			var json = rd.data.json;
			if(json.tpl && !tpls[json.tpl]) {
				tpls[json.tpl] = true;
				var tpl = Ext.decode(json.tpl);
				var minrow = tpl.span[1];
				var maxrow = tpl.span[3];
				var mincol = tpl.span[2];
				var maxcol = tpl.span[4];
				withBroken = !((0 == span[1] || span[1] <= minrow) && (0 == span[2] || span[2] <= mincol) && (0 == span[3] || span[3] >= maxrow) && (0 == span[4] || span[4] >= maxcol));
				if(withBroken) {
					return false;
				}
			}
		}, this, true);
		return withBroken;
	},
	initSheets: function() {
		this.sheets = [];
		for(var i = 0, len = this.defaultSheetNumber; i < len; i++) {
			var name = "Sheet" + (i + 1);
			this.sheets.push({
				id: i,
				name: name,
				loaded: true
			});
		}
	},
	getSheetById: function(sheetId) {
		var lookup = this.getSheetIdLookup();
		var sheetObj = lookup[sheetId];
		if(sheetObj) {
			return sheetObj;
		} else if(this.cfsRefs) {
			for(var p in this.cfsRefs) {
				if(this.cfsRefs.hasOwnProperty(p)) {
					sheetObj = this.cfsRefs[p].getSheetById(sheetId);
					if(sheetObj) {
						return sheetObj;
					}
				}
			}
		}
	},
	getSheetIdLookup: function(forceRefresh) {
		var storeId = this.getId();
		if(!this.sheetIdLookup || forceRefresh) {
			var sheets = this.getSheets(),
				lookup = {},
				map = {},
				reverse = {};
			for(var i = 0, len = sheets.length; i < len; i++) {
				var sheet = sheets[i];
				lookup[sheet.id] = sheet;
				var crossId = [storeId, sheet.id].join(this.crossSepChar);
				lookup[crossId] = sheet;
				map[crossId] = sheet.id;
				reverse[sheet.id] = crossId;
			}
			this.sheetIdLookup = lookup;
			this.crossIdMap = map;
			this.idCrossMap = reverse;
		}
		return this.sheetIdLookup;
	},
	getSheetNameLookup: function(forceRefresh) {
		if(!this.sheetNameLookup || forceRefresh) {
			var sheets = this.getSheets(),
				lookup = {};
			for(var i = 0, len = sheets.length; i < len; i++) {
				var sheet = sheets[i];
				lookup[sheet.name] = sheet;
			}
			this.sheetNameLookup = lookup;
		}
		return this.sheetNameLookup;
	},
	syncSheetLookup: function() {
		this.getSheetIdLookup(true);
		this.getSheetNameLookup(true);
	},
	updateLoadedEmptyCells: function(posLookup, sheetLookup, ranges) {
		var separateChar = this.separateChar;
		sheetLookup = sheetLookup || this.getSheetIdLookup();
		for(var p in posLookup) {
			if(posLookup.hasOwnProperty(p)) {
				var it = posLookup[p],
					s = it[0];
				var sheetObj = sheetLookup[s];
				sheetObj.loadedEmptyCells = sheetObj.loadedEmptyCells || {};
				var map = sheetObj.loadedEmptyCells;
				map[p] = true;
			}
		}
		for(var i = 0, len = ranges.length; i < len; i++) {
			var span = ranges[i],
				s = span[0];
			if(0 === span[1] && 0 !== span[2]) {
				var sheetObj = sheetLookup[s];
				sheetObj.loadedEmptyCells = sheetObj.loadedEmptyCells || {};
				var map = sheetObj.loadedEmptyCells;
				for(var j = span[2]; j <= span[4]; j++) {
					var id = [s, 0, j].join(separateChar);
					map[id] = true;
				}
			} else if(0 !== span[1] && 0 === span[2]) {
				var sheetObj = sheetLookup[s];
				sheetObj.loadedEmptyCells = sheetObj.loadedEmptyCells || {};
				var map = sheetObj.loadedEmptyCells;
				for(var j = span[1]; j <= span[3]; j++) {
					var id = [s, j, 0].join(separateChar);
					map[id] = true;
				}
			}
		}
	},
	getSheetNameById: function(sheetId) {
		var found = this.findStoreBySheetId(sheetId);
		if(found) {
			var store = found.store;
			var lookup = store.getSheetIdLookup();
			if(lookup[sheetId]) {
				var sheetObj = lookup[sheetId];
				if(store !== this) {
					return "[" + found.refName + "]\"" + sheetObj.name + "\"";
				} else {
					return sheetObj.name;
				}
			}
		}
	},
	getSheetWidthById: function(sheetId) {
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			if(sheet.id == sheetId) {
				return sheet.width;
			}
		}
	},
	getSheetIdByName: function(sheetName, exactMatch, checkLastOldName) {
		var fchar = sheetName.charAt(0),
			lchar = sheetName.charAt(sheetName.length - 1);
		if("\"" === fchar && "\"" === lchar || "'" === fchar && "'" === lchar) {
			sheetName = sheetName.slice(1, sheetName.length - 1);
		} else {
			var crossFile;
			var onlySheetName = sheetName.replace(/^\[([\S]+)\]/i, function(w) {
				crossFile = arguments[1];
				return "";
			});
			if(crossFile) {
				return this.getCrossSheetIdByName(crossFile, onlySheetName);
			}
		}
		sheetName = Ext.String.trim(sheetName.toUpperCase());
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			var name = Ext.String.trim(sheet.name.toUpperCase());
			if(sheetName === name) {
				return sheet.id;
			} else if(!exactMatch && ("\"" + name + "\"" == sheetName || "'" + name + "'" == sheetName)) {
				return sheet.id;
			}
			if(checkLastOldName && Ext.isDefined(sheet.lastOldName)) {
				name = Ext.String.trim(sheet.lastOldName.toUpperCase());
				if(sheetName === name) {
					return sheet.id;
				} else if(!exactMatch && ("\"" + name + "\"" == sheetName || "'" + name + "'" == sheetName)) {
					return sheet.id;
				}
			}
		}
		return this.getCrossSheetIdByName(undefined, sheetName);
	},
	getCrossSheetIdByName: function(crossFileName, sheetName) {
		if(this.cfsRefs) {
			if(crossFileName) {
				var refStore = this.cfsRefs[crossFileName];
				if(refStore) {
					var id = refStore.getSheetIdByName(sheetName);
					return [refStore.getId(), id].join(this.crossSepChar);
				}
			} else {
				for(var p in this.cfsRefs) {
					if(this.cfsRefs.hasOwnProperty(p)) {
						var refStore = this.cfsRefs[p];
						var id = refStore.getSheetIdByName(sheetName);
						if(id) {
							return [refStore.getId(), id].join(this.crossSepChar);
						}
					}
				}
			}
		}
	},
	getSheets: function() {
		return this.sheets;
	},
	sortSpan: function(span, keys, dir, sortOn, expand, allString, suspendEvent, suspendPull) {
		if(suspendEvent || false !== this.fireEvent("beforesortspan", span, keys, dir, sortOn, expand, allString, this)) {
			this.fireEvent("preparesortspan", span, keys, dir, sortOn, expand, allString, this);
			var diff;
			if("row" == sortOn) {
				diff = this.sortSpanOnRow(span, keys, dir, expand, allString);
			} else {
				diff = this.sortSpanOnColumn(span, keys, dir, expand, allString);
			}
			if(expand) {
				this.resetRowHeightColWidthCache(span[0]);
			}
			if(!suspendEvent) {
				this.fireEvent("sortspan", span, keys, dir, sortOn, expand, allString, diff, this);
			}
			this.fireEvent("aftersortspan", span, keys, dir, sortOn, expand, allString, diff, this);
			this.syncMaxRowColOfSheet(span[0]);
			return diff;
		}
	},
	sortSpanOnColumn: function(span, keys, dir, expand, allString) {
		span = [].concat(span);
		var sheet = span[0],
			minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4];
		var sortKey = mincol;
		if(keys && 0 < keys.length) {
			sortKey = keys[0];
		}
		var values = {},
			indexs = [];
		var range;
		if(0 == minrow && 0 == mincol) {} else if(0 == maxrow || minrow != maxrow) {
			range = [
				[sheet, minrow, sortKey, maxrow, sortKey]
			];
		}
		if(range) {
			var start = false,
				rowVisible = {};
			this.walkRange(range, function(rd) {
				if(0 !== rd.data.row) {
					var visible = rowVisible[rd.data.row];
					if(!Ext.isDefined(visible)) {
						visible = this.isVisibleRow(rd.data.sheet, rd.data.row);
						rowVisible[rd.data.row] = visible;
					}
					if(visible) {
						var o = this.getCellData(rd.data.sheet, rd.data.row, rd.data.col);
						if(false != SCOM.typeOf(o.data)) {
							if(false === start) {
								start = rd.data.row;
							} else if(start > rd.data.row) {
								start = rd.data.row;
							}
							values[rd.data.row] = o.data;
							indexs.push(rd.data.row);
						}
					}
				}
			}, this, true);
			indexs = this.sortIndexByValue(indexs, values, dir, allString);
			if(false === start) {
				start = 1;
			}
			start = 0 == minrow ? start : minrow;
			return this.arrangeRows(start, indexs, expand, rowVisible, sheet, minrow, mincol, maxrow, maxcol);
		}
	},
	sortSpanOnRow: function(span, keys, dir, expand, allString) {},
	sortIndexByValue: function(indexs, values, dir, allString) {
		var fn;
		if("desc" == dir || "DESC" == dir) {
			fn = function(a, b) {
				var va = values[a],
					vb = values[b];
				if(!allString && SCOM.canbeNumber(va) && SCOM.canbeNumber(vb)) {
					var na = Number(va),
						nb = Number(vb);
					return nb - na;
				} else {
					va = va.toString();
					vb = vb.toString();
					return va > vb ? -1 : va < vb ? 1 : 0;
				}
			};
		} else {
			fn = function(a, b) {
				var va = values[a],
					vb = values[b];
				if(!allString && SCOM.canbeNumber(va) && SCOM.canbeNumber(vb)) {
					var na = Number(va),
						nb = Number(vb);
					return na - nb;
				} else {
					va = va.toString();
					vb = vb.toString();
					return va > vb ? 1 : va < vb ? -1 : 0;
				}
			};
		}
		indexs.sort(fn);
		return indexs;
	},
	arrangeRows: function(start, sorted, expand, rowVisible, sheet, minrow, mincol, maxrow, maxcol) {
		var diff = {};
		var oldNo = start;
		for(var i = 0, len = sorted.length; i < len; i++) {
			var newNo = Number(sorted[i]);
			while(!rowVisible[oldNo]) {
				oldNo++;
			}
			if(oldNo !== newNo) {
				diff[oldNo] = newNo;
			}
			oldNo++;
		}
		if(expand) {
			mincol = maxcol = 0;
		}
		this.moveRows(sheet, diff, mincol, maxcol, false, true, true);
		return diff;
	},
	moveRows: function(sheet, diff, mincol, maxcol, keyAsSource, suspendPull, suspendEvent) {
		mincol = mincol || 0;
		maxcol = maxcol || 0;
		var tmp = {};
		if(!keyAsSource) {
			for(var p in diff) {
				if(diff.hasOwnProperty(p)) {
					var q = diff[p];
					tmp[q] = p;
				}
			}
			diff = tmp;
		}
		var data = this.getData(),
			newData = {};
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var sheetId = it[0],
					row = it[1],
					col = it[2];
				if(sheetId === sheet && diff.hasOwnProperty(row)) {
					if((0 === mincol || mincol <= col) && (0 === maxcol || col <= maxcol)) {
						it[1] = Number(diff[row]);
						var q = it.slice(0, 3).join(this.separateChar);
						newData[q] = it;
						delete data[p];
					}
				}
			}
		}
		Ext.apply(data, newData);
		this.refreshCalLookup();
		if(!suspendEvent) {
			this.fireEvent("moverows", sheet, diff, mincol, maxcol, keyAsSource, this);
		}
		this.syncMaxRowColOfSheet(sheet);
	},
	getData: function() {
		if(!this.data) {
			this.data = {};
		}
		return this.data;
	},
	setData: function(data) {
		this.data = data;
	},
	each: function(callback, scope) {
		var data = this.getData();
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var o = {
					data: {
						sheet: it[0],
						row: it[1],
						col: it[2],
						json: it[3]
					}
				};
				if(false === callback.call(scope, o, p)) {
					return false;
				}
			}
		}
	},
	queryBy: function(callback, scope) {
		var arr = [];
		var data = this.getData();
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var o = {
					data: {
						sheet: it[0],
						row: it[1],
						col: it[2],
						json: it[3]
					}
				};
				var ret = callback.call(scope, o);
				if(true === ret) {
					arr.push(o);
				} else if(false === ret) {
					break;
				}
			}
		}
		return arr;
	},
	eachCal: function(callback, scope) {
		var lookup = this.getCalLookup(),
			data = this.getData(),
			separateChar = this.separateChar;
		for(var p in lookup) {
			if(lookup.hasOwnProperty(p)) {
				var it = lookup[p];
				var o = {
					data: {
						sheet: it[0],
						row: it[1],
						col: it[2],
						json: it[3]
					}
				};
				if(false === callback.call(scope, o, p)) {
					return;
				}
			}
		}
	},
	mergeNamedFuncConfig: function(name, config) {
		var found = this.getNamedFuncConfigByName(name);
		if(found) {
			var map = {};
			for(var i = 0, len = config.jsonArr.length; i < len; i++) {
				var it = config.jsonArr[i];
				var scope = Ext.isDefined(it.scope) ? it.scope : "doc";
				map[scope] = it;
			}
			for(var i = 0, len = found.jsonArr.length; i < len; i++) {
				var it = found.jsonArr[i];
				var scope = Ext.isDefined(it.scope) ? it.scope : "doc";
				if(!map[scope]) {
					config.jsonArr.push(it);
				} else {
					if(it.comment) {
						map[scope].comment = it.comment;
					} else {
						delete map[scope].comment;
					}
				}
			}
		}
		return config;
	},
	eachCalAndNamedFunc: function(callback, scope) {
		this.eachCal(callback, scope);
		var nameRefs = this.getNamedFuncConfigLookup();
		for(var p in nameRefs) {
			if(nameRefs.hasOwnProperty(p)) {
				var nf = nameRefs[p],
					jsonArr = nf.jsonArr;
				for(var i = 0, len = jsonArr.length; i < len; i++) {
					var it = jsonArr[i];
					var o = {
						named_func: p,
						data: {
							json: {
								cal: true,
								scope: it.scope,
								data: it.cal,
								arg: it.arg,
								refs: it.refs
							}
						}
					};
					if(false === callback.call(scope, o, p)) {
						return;
					}
				}
			}
		}
	},
	updateCalMap: function(id, refs, oldRefs, pos) {
		this.calRefsMap.syncMap(id, refs, oldRefs, pos);
	},
	refreshCalLookup: function() {
		var data = this.getData(),
			cals = {};
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				var json = it[3];
				if(json.cal) {
					cals[p] = it;
				}
			}
		}
		this.setCalLookup(cals);
		this.needResetupCalMap = true;
	},
	getDirectRelatedCells: function() {
		if(this.needResetupCalMap) {
			this.setupCalMap();
		}
		var cells = this.calRefsMap.getDirectRelatedCells.apply(this.calRefsMap, arguments);
		return cells;
	},
	getDirectRelatedCellsForCoord: function(coord) {
		if(this.needResetupCalMap) {
			this.setupCalMap();
		}
		var cells = {};
		for(var i = 0, len = coord.length; i < len; i++) {
			var span = coord[i];
			Ext.apply(cells, this.calRefsMap.getDirectRelatedForRange.apply(this.calRefsMap, span));
		}
		return cells;
	},
	getAllRelatedCells: function(sheetId, row, col) {
		if(this.needResetupCalMap) {
			this.setupCalMap();
		}
		return this.calRefsMap.getAllRelatedCells(sheetId, row, col);
	},
	getReferedNamedFuncs: function(calStr) {
		var lookup = {},
			arr = [];
		this.getNamedFuncReg();
		var reg = this.namedFuncReg;
		if(reg) {
			reg.lastIndex = 0;
			calStr.replace(reg, function(w) {
				var match = arguments[2];
				lookup[match] = true;
			});
			for(var p in lookup) {
				if(lookup.hasOwnProperty(p)) {
					arr.push(p);
				}
			}
		}
		return arr;
	},
	clearValueForNamedFunc: function(name) {
		var found = this.getNamedFuncConfigLookup()[name];
		if(found) {
			var jsonArr = found.jsonArr;
			for(var i = 0, len = jsonArr.length; i < len; i++) {
				var it = jsonArr[i];
				it.lastValue = it.value;
				delete it.value;
			}
		}
	},
	prepareRefCoordFromNamedFuncs: function(namedFuncs, callback, scope) {
		var coord = [],
			nflookup = this.getNamedFuncConfigLookup(),
			visited = {};
		var fn = function(namedFunc) {
			var jsonArr = namedFunc.jsonArr;
			for(var j = 0, count = jsonArr.length; j < count; j++) {
				var it = jsonArr[j];
				var refs = it.refs,
					relativeCoordsInNamedFunc = it.relativeCoordsInNamedFunc;
				if(refs) {
					for(var k = 0, size = refs.length; k < size; k++) {
						var span = refs[k];
						if(Ext.isString(span) && !visited[span]) {
							visited[span] = true;
							var found = nflookup[span];
							if(found) {
								fn.call(this, found);
							}
						}
					}
				}
				if(relativeCoordsInNamedFunc) {
					for(var k = 0, size = relativeCoordsInNamedFunc.length; k < size; k++) {
						var spanObj = relativeCoordsInNamedFunc[k],
							ctype = spanObj.type,
							span = spanObj.span;
						if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
							span = [].concat(span);
							if(callback) {
								var res = callback.call(scope, span, ctype);
								if(res) {
									coord = coord.concat(res);
								}
							}
						} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
							span = [].concat(span);
							if(callback) {
								var res = callback.call(scope, span, ctype);
								if(res) {
									coord = coord.concat(res);
								}
							}
						}
					}
				}
			}
		};
		for(var i = 0, len = namedFuncs.length; i < len; i++) {
			var name = namedFuncs[i];
			if(!visited[name]) {
				visited[name] = true;
				var nf = nflookup[name];
				if(nf) {
					fn.call(this, nf);
				}
			}
		}
		return coord;
	},
	getRefCoordFromNamedFuncs: function(namedFuncs, sheetId, row, col) {
		return this.prepareRefCoordFromNamedFuncs(namedFuncs, function(span, ctype) {
			if(SCONST.ABSOLUTE_ROW_COORD == ctype) {
				span[4] += col;
				span[2] += col;
				return [span];
			} else if(SCONST.ABSOLUTE_COL_COORD == ctype) {
				span[3] += row;
				span[1] += row;
				return [span];
			}
		}, this);
	},
	setupRefMap: function() {
		var nameRefs = this.getNamedFuncConfigLookup();
		for(var p in nameRefs) {
			if(nameRefs.hasOwnProperty(p)) {
				var nf = nameRefs[p];
				var jsonArr = nf.jsonArr;
				var o = {};
				o[p] = "named_func";
				for(var i = 0, len = jsonArr.length; i < len; i++) {
					var refs = jsonArr[i].refs;
					if(refs) {
						for(var j = 0, size = refs.length; j < size; j++) {
							var span = refs[j];
							this.calRefsMap.add(span, o);
						}
					}
				}
			}
		}
	},
	setupCalMap: function() {
		this.calRefsMap.empty();
		this.calRefsMap.emptyNamedFuncMap();
		this.eachCal(function(rec, id) {
			var json = rec.data.json;
			var refs = json.refs;
			if(refs) {
				var o = {};
				o[id] = [rec.data.sheet, rec.data.row, rec.data.col];
				for(var i = 0, len = refs.length; i < len; i++) {
					var span = refs[i];
					this.calRefsMap.add(span, o);
				}
			}
		}, this);
		this.setupRefMap();
		delete this.needResetupCalMap;
		this.fireEvent("aftersetupcalmap", this);
	},
	backupData: function() {
		var data = this.getData();
		return SCOM.copy(data);
	},
	recoverData: function(copy) {
		if(this.data) {
			Ext.apply(this.data, copy);
		}
	},
	getGroupsBySheetId: function(sheetId) {
		var groups = {};
		if(this.floatings) {
			for(var p in this.floatings) {
				if(this.floatings.hasOwnProperty(p)) {
					var it = this.floatings[p];
					if(sheetId == it.sheet) {
						if("rowGroups" == it.name) {
							groups.rowGroups = it.json;
						} else if("colGroups" == it.name) {
							groups.colGroups = it.json;
						}
					}
					if(groups.rowGroups && groups.colGroups) {
						return groups;
					}
				}
			}
		}
		return groups;
	},
	getFloorsBySheetId: function(sheetId) {
		var floors = [];
		if(this.floatings) {
			for(var p in this.floatings) {
				if(this.floatings.hasOwnProperty(p)) {
					var it = this.floatings[p];
					if(sheetId == it.sheet) {
						if("rowGroups" != it.name && "colGroups" != it.name && "colHiddens" != it.name && "rowHiddens" != it.name) {
							floors.push(Ext.decode(it.json));
						}
					}
				}
			}
		}
		return floors;
	},
	getFloorById: function(name, sheetId) {
		if(this.floatings) {
			var id = name + this.separateChar + sheetId;
			var it = this.floatings[id];
			if(it) {
				return Ext.decode(it.json);
			}
			return it;
		}
	},
	getFloatingById: function(name, sheetId) {
		if(this.floatings) {
			var id = name + this.separateChar + sheetId;
			var it = this.floatings[id];
			if(it) {
				return SCOM.copy(it);
			}
			return it;
		}
	},
	getFileConfigById: function(name, ctype) {
		if(this.fileConfig) {
			var id = name + this.separateChar + ctype;
			var it = this.fileConfig[id];
			if(it) {
				return SCOM.copy(it);
			}
			return it;
		}
	},
	getConditionById: function(name, sheetId) {
		if(this.floatings) {
			var id = name + this.separateChar + sheetId;
			var it = this.floatings[id];
			if(it) {
				return it.jsonObj || Ext.decode(it.json);
			}
		}
	},
	getConditionBySheet: function(sheetId) {
		var arr = [];
		if(this.floatings) {
			for(var p in this.floatings) {
				if(this.floatings.hasOwnProperty(p)) {
					var it = this.floatings[p];
					if(it && it.sheet == sheetId && "cdt" == it.ftype) {
						arr.push(it.jsonObj || Ext.decode(it.json));
					}
				}
			}
		}
		return arr;
	},
	getConditionObjsByName: function(name) {
		var arr = [];
		if(this.floatings) {
			for(var p in this.floatings) {
				if(this.floatings.hasOwnProperty(p)) {
					var it = this.floatings[p];
					if(it && "cdt" == it.ftype && (!name || it.cdtName === name)) {
						arr.push({
							cdt: it.jsonObj || Ext.decode(it.json),
							sheetId: it.sheet
						});
					}
				}
			}
		}
		return arr;
	},
	getValidationBySheet: function(sheetId) {
		var arr = [];
		if(this.floatings) {
			for(var p in this.floatings) {
				if(this.floatings.hasOwnProperty(p)) {
					var it = this.floatings[p];
					if(it && it.sheet == sheetId && "cdt" == it.ftype) {
						var json = Ext.decode(it.json);
						if("vd" == json.name) {
							var opt = json.opt;
							opt.id = it.name;
							opt.coord = json.rng;
							arr.push(opt);
						}
					}
				}
			}
			return arr;
		}
	},
	getFloatingBySheet: function(sheetId, ftype) {
		var arr = [];
		if(this.floatings) {
			for(var p in this.floatings) {
				if(this.floatings.hasOwnProperty(p)) {
					var it = this.floatings[p];
					if(it && it.sheet == sheetId && ftype == it.ftype) {
						arr.push(it);
					}
				}
			}
			return arr;
		}
	},
	eachFloating: function(fn, scope) {
		if(this.floatings) {
			for(var p in this.floatings) {
				if(this.floatings.hasOwnProperty(p)) {
					var it = this.floatings[p];
					if(false === fn.call(scope, it)) {
						return;
					}
				}
			}
		}
	},
	isLoadedSheet: function(sheetId) {
		var sheet = this.getSheetById(sheetId);
		if(sheet) {
			return sheet.loaded;
		}
		return false;
	},
	isAllCellLoadedInSheet: function(sheetId) {
		var sheet = this.getSheetById(sheetId);
		if(sheet) {
			return sheet.allCellDataLoaded;
		}
		return false;
	},
	loadMore: function(activeSheetId, startCellId, total, callback, scope, skipCal, message) {
		var me = this,
			data = this.getData();
		Ext.Ajax.request({
			timeout: SCONST.PULLING_TIMEOUT,
			url: this.loadMoreUrl,
			params: {
				fileId: this.fileId,
				sheetId: activeSheetId,
				startCellId: startCellId,
				size: this.limitCellNumAtSingleLoad,
				skipCal: skipCal
			},
			success: function(response, options) {
				var dataMap = this.getData();
				var json = Ext.decode(response.responseText);
				var separateChar = this.separateChar;
				if(true === json.success || "true" === json.success) {
					startCellId = json.startCellId;
					var me = this,
						records = me.reader.read(json.results);
					var recLen = records.length;
					if(skipCal) {
						for(var i = 0; i < recLen; i++) {
							var it = records[i];
							if(!it[3].cal) {
								var cid = [it[0], it[1], it[2]].join(separateChar);
								if(!dataMap[cid]) {
									dataMap[cid] = it;
								} else {
									recLen--;
								}
							}
						}
					} else {
						newRecs = records;
						me.loadRecords(newRecs, {
							addRecords: true
						});
					}
					var sheetObj = me.getSheetById(activeSheetId);
					sheetObj.currentCellCount += recLen;
					this.fireEvent("loadingmore", activeSheetId, this);
					if(startCellId != 0) {
						me.loadMore(activeSheetId, startCellId, total, callback, scope, skipCal, message);
					} else {
						if(callback) {
							callback.call(scope, true);
						}
					}
				}
			},
			failure: function(response) {
				if(callback) {
					callback.call(scope, false);
				}
			},
			scope: this
		});
	},
	loadFloatingsBySheetId: function(sheetId, callback, scope, startElementId, _floatingsArr) {
		var me = this,
			sheetObj = this.getSheetById(sheetId);
		if(!Ext.isArray(_floatingsArr)) {
			_floatingsArr = [];
		}
		Ext.Ajax.request({
			timeout: SCONST.PULLING_TIMEOUT,
			url: this.loadFloatingsUrl,
			params: {
				fileId: this.fileId,
				sheetId: sheetId,
				startElementId: startElementId,
				size: this.limitCellNumAtSingleLoad
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(true === json.success || "true" === json.success) {
					startElementId = json.startElementId;
					var floatings = json.results;
					_floatingsArr = _floatingsArr.concat(floatings);
					sheetObj.currentCellCount += floatings.length;
					me.fireEvent("loadingmore", sheetId, me);
					if(startElementId != 0) {
						me.loadFloatingsBySheetId(sheetId, callback, scope, startElementId, _floatingsArr);
					} else {
						if(callback) {
							callback.call(scope, true, _floatingsArr);
						}
					}
				}
			},
			failure: function(response) {
				if(callback) {
					callback.call(scope, false);
				}
			},
			scope: this
		});
	},
	getTotalCellCount: function() {
		var count = 0;
		for(var i = 0, len = this.sheets.length; i < len; i++) {
			var sheetObj = this.sheets[i];
			if(Ext.isNumber(sheetObj.totalCellCount)) {
				count += sheetObj.totalCellCount;
			}
		}
		return count;
	},
	load: function(options) {
		this._loadingFlag = true;
		options = options || {};
		var me = this;
		var callback = options.callback,
			scope = options.scope;
		options.callback = function(operation, successful, response) {
			if(!successful) {
				if(callback) {
					callback.apply(scope, [me], false);
				}
				return;
			}
			var json = Ext.decode(response.responseText);
			var total = json.total;
			var message = json.message,
				results = json.results;
			this.loadRecords(this.reader.read(results));
			var startCellId;
			if(message && Ext.isDefined(message.startCellId)) {
				startCellId = message.startCellId;
			}
			var recLen = results ? results.length : 0;
			me.readSheets(message.sheets);
			delete message.sheets;
			var activeSheetId = me.getActivedSheetId();
			message.loadSheetId = activeSheetId;
			var sheetObj = me.getSheetById(activeSheetId);
			sheetObj.currentCellCount = recLen;
			sheetObj.currentFloatingCount = 0;
			sheetObj.totalFloatingCount = message.floatingTotal;
			sheetObj.totalCellCount = total;
			if(0 !== startCellId && !SCOM.isEmptyValue(startCellId)) {
				me.loadMore(activeSheetId, startCellId, total, function() {
					me.loadFloatingsBySheetId(activeSheetId, function(success, floatings) {
						message.floatings = floatings;
						me.getMessageAfterLoad.apply(me, [message]);
						if(callback) {
							callback.apply(scope, [me], true);
						}
					}, me);
				}, me, undefined, message);
			} else {
				me.loadFloatingsBySheetId(activeSheetId, function(success, floatings) {
					message.floatings = floatings;
					me.getMessageAfterLoad.apply(me, [message]);
					if(callback) {
						callback.apply(scope, [me], true);
					}
				}, me);
			}
		};
		if(false !== this.fireEvent("beforeload", this)) {
			Ext.Ajax.request(Ext.apply(options, {
				url: this.loadUrl
			}));
		}
	},
	readSheets: function(sheets) {
		if(Ext.isArray(sheets)) {
			this.sheets = SCOM.copy(sheets);
			this.syncSheetLookup();
		}
	},
	prepareDefaultWidthHeightForActiveSheet: function() {
		var cell = this.getCell(this.getActivedSheetId(), 0, 0);
		this.prepareDefaultWidthHeight(cell);
	},
	prepareDefaultWidthHeight: function(cell) {
		if(!Ext.isDefined(cell.width)) {
			cell.width = cell.dw;
		}
		if(!Ext.isDefined(cell.height)) {
			cell.height = cell.dh;
		}
		delete cell.dw;
		delete cell.dh;
		if(Ext.isNumber(cell.width)) {
			this.defaultCellWidth = cell.width;
			this.defaultProperty.width = cell.width;
		} else {
			this.defaultCellWidth = this.originDefaultCellWidth;
			this.defaultProperty.width = this.originDefaultCellWidth;
		}
		if(Ext.isNumber(cell.height)) {
			this.defaultCellHeight = cell.height;
			this.defaultProperty.height = cell.height;
		} else {
			this.defaultCellHeight = this.originDefaultCellHeight;
			this.defaultProperty.height = this.originDefaultCellHeight;
		}
		this.defaultProperty.fz = this.originDefaultFontSize;
	},
	getUUStamp: function() {
		this.uut++;
		return [this.uuid || 1, this.uut];
	},
	getMessageAfterLoad: function(message) {
		var me = this;
		this.floatings = {};
		this.mergeLookup = {};
		this.cdtLookup = {};
		delete this._cdtCoord;
		me.cachedMessage = message;
		me.fileName = message.fileName;
		me.fileStared = message.fileStared;
		me.fileColor = message.fileColor;
		me.fileExname = message.exname;
		me.filePermission = message.permission;
		me.fileOwner = message.owner;
		me.isPublic = message.isPublic;
		me.uuid = message.uuid;
		me.uut = 0;
		me.readSheets(message.sheets);
		var activedSheetId = me.getActivedSheetId();
		var sconfig = me.getSheetConfig(activedSheetId);
		if(sconfig) {
			me.setZoom(sconfig.zoom || 1);
		} else {
			me.setZoom(1);
		}
		me.readFileConfig(message.fileConfig);
		me.checkReferenceString(true);
		me.readFloatings(message.floatings);
		me.checkNamedTableTemplate();
		me.userInfo = Ext.apply({}, message.user);
		this.prepareDefaultWidthHeightForActiveSheet();
		if(this._cdtCoord) {
			this.checkLoadCoord(this._cdtCoord, function() {
				if(false !== me.fireEvent("beforeafterload", this)) {
					me.afterLoad();
				}
			}, this);
		}
	},
	checkNamedTableTemplate: function() {
		var tplNames = {},
			arr = [];
		this.each(function(rec) {
			var json = rec.data.json;
			if(json.tpl) {
				var tpl = Ext.decode(json.tpl),
					span = tpl.span;
				if(tpl._totalsRowCount) {
					span[3]--;
				}
				if(tpl._name) {
					var name = tpl._name.toUpperCase();
					if(!tplNames[name]) {
						var cols = {},
							sheetId = span[0];
						if(SCOM.isEmptyValue(sheetId)) {
							sheetId = this.getActivedSheetId();
						}
						store.walkRange([
							[sheetId, span[1], span[2], span[1], span[4]]
						], function(rec) {
							var data = rec.data.json.data;
							if(!SCOM.isEmptyValue(data)) {
								data = data.toUpperCase();
								if(!cols[data]) {
									cols[data] = {
										span: [sheetId, span[1], rec.data.col, span[3], rec.data.col],
										type: SCONST.ABSOLUTE_COORD
									};
								}
							}
						}, this);
						var coord = Ext.encode({
							span: span,
							type: SCONST.ABSOLUTE_COORD,
							cols: cols
						});
						arr.push(name);
						tplNames[name] = {
							ctype: "named_func",
							name: name,
							source: "tpl",
							jsonArr: [{
								cal: coord,
								arg: "beval(" + coord + ")",
								refs: [span]
							}]
						};
					}
				}
			}
		}, this);
		this.namedFuncConfig = this.namedFuncConfig || {};
		if(0 < arr.length) {
			this.tplNameReg = new RegExp("(\\\"[^\\\"]*\\\"([^!\\\"']|$))|('[^']*'([^!'\\\"]|$))|((" + arr.join("|") + ")([\\s,\\}\\]\\)\\+\\-\\*\\/\\>\\<\\=\\&]|!=|\\[([^\\[]+)\\]|$))", "gi");
		}
		Ext.apply(this.namedFuncConfig, tplNames);
	},
	readFileConfig: function(fileConfig) {
		var lookup = {},
			refLookup = {};
		if(fileConfig) {
			for(var i = 0, len = fileConfig.length; i < len; i++) {
				var it = fileConfig[i];
				var id = it.name + this.separateChar + it.ctype;
				lookup[id] = SCOM.copy(it);
				if("named_func" === it.ctype) {
					var jsonObj = Ext.decode(lookup[id].json);
					if(!Ext.isArray(jsonObj)) {
						jsonObj = [jsonObj];
					}
					lookup[id].jsonArr = jsonObj;
					refLookup[it.name] = lookup[id];
				}
			}
		}
		this.namedFuncConfig = refLookup;
		this.fileConfig = lookup;
	},
	isValidVariable: function(varName) {
		var id = varName + this.separateChar + "var";
		if(this.fileConfig) {
			return !this.fileConfig[id];
		} else {
			alert("TODO - will coming ... at this moment, only saved file is allowed to bind vaiable.");
		}
	},
	readMerges: function() {
		var lookup = this.floatings,
			megs = this.mergeLookup;
		for(var p in megs) {
			if(megs.hasOwnProperty(p)) {
				var it = lookup[p],
					json = it.jsonObj;
				this.presetMerge2Cell(json, it.sheet, p);
			}
		}
	},
	readFloatings: function(floatings) {
		var lookup = {},
			megs = {},
			cdts = {},
			coord = [];
		if(floatings) {
			for(var i = 0, len = floatings.length; i < len; i++) {
				var it = floatings[i];
				var id = [it.name, it.sheet].join(this.separateChar);
				lookup[id] = it;
				if(!it.json && Ext.isObject(it.jsonObj)) {
					it.json = Ext.encode(it.jsonObj);
				}
				if("meg" == it.ftype) {
					if(!it.jsonObj) {
						var json = Ext.decode(it.json);
						it.jsonObj = json;
					}
					megs[id] = true;
				} else if("cdt" == it.ftype) {
					var json;
					if(!it.jsonObj) {
						json = Ext.decode(it.json);
						it.jsonObj = json;
					} else {
						json = it.jsonObj;
					}
					json.id = it.name;
					it.cdtName = json.name;
					if("vd" !== it.cdtName) {
						var rng = json.rng;
						for(var k = 0, size = rng.length; k < size; k++) {
							coord.push(rng[k].span);
						}
					}
					this.presetCdt2Cells(it);
					cdts[id] = true;
				} else if("row" == it.ftype) {
					var json;
					if(!it.jsonObj) {
						json = Ext.decode(it.json);
						it.jsonObj = json;
					} else {
						json = it.jsonObj;
					}
					this.presetRowHiddens(it.sheet, json);
				} else if("col" == it.ftype) {
					var json;
					if(!it.jsonObj) {
						json = Ext.decode(it.json);
						it.jsonObj = json;
					} else {
						json = it.jsonObj;
					}
					this.presetColHiddens(it.sheet, json);
				} else if("pb" == it.ftype) {
					if(!it.jsonObj) {
						var json = Ext.decode(it.json);
						it.jsonObj = json;
					}
				}
				this.fireEvent("processfloating", it, this);
			}
		}
		this._cdtCoord = coord;
		this.floatings = lookup;
		this.mergeLookup = megs;
		this.cdtLookup = cdts;
	},
	presetTplForCells: function(coord, clearFlag, suspendPull) {
		var tpls = {},
			separateChar = this.separateChar;
		if(coord) {
			this.walkRange(coord, function(rec) {
				var json = rec.data.json,
					tpl = json.tpl;
				if(tpl) {
					var tplObj = Ext.decode(tpl);
					var span = tplObj.span;
					span[0] = rec.data.sheet;
					if(span[1] === rec.data.row && span[2] === rec.data.col) {
						var id = span.join(separateChar);
						if(!tpls[id]) {
							tpls[id] = {
								tpl: tplObj,
								tplStr: tpl
							};
						}
					}
				}
			}, this, true);
		} else {
			this.each(function(rec) {
				var json = rec.data.json,
					tpl = json.tpl;
				if(tpl) {
					var tplObj = Ext.decode(tpl);
					var span = tplObj.span;
					span[0] = rec.data.sheet;
					var id = span.join(separateChar);
					if(!tpls[id]) {
						tpls[id] = {
							tpl: tplObj,
							tplStr: tpl
						};
					}
				}
			}, this);
		}
		var arr = [];
		for(var p in tpls) {
			if(tpls.hasOwnProperty(p)) {
				var it = tpls[p],
					tpl = it.tpl,
					span = tpl.span;
				arr.push(span);
				var sheetId = span[0];
				for(var r = span[1]; r <= span[3]; r++) {
					for(var c = span[2]; c <= span[4]; c++) {
						if(clearFlag) {
							this.setCell(sheetId, r, c, undefined, ["tpl"], true, undefined, suspendPull);
						} else {
							this.setCell(sheetId, r, c, {
								tpl: it.tplStr
							}, undefined, true, undefined, suspendPull);
						}
					}
				}
			}
		}
		return arr;
	},
	presetCdt2Cells: function(floating) {
		var cdt = floating.jsonObj;
		var cdtPro = EnterpriseSheet.pure.sheet.calculate.Condition.prototype;
		var o = cdtPro.presetCdtObj(cdt, this);
		Ext.apply(floating, o);
	},
	clearCdtForCoord: function(coord) {
		var deleteCdtStyles = ["cdtVal"];
		var store = this,
			timestamp = SCOM.genTimeStamp();
		store.walkRange(coord, function(rec, walkSpan, store, internalId) {
			store.setCell(rec.data.sheet, rec.data.row, rec.data.col, {
				timestamp: timestamp
			}, deleteCdtStyles, true);
		}, this, true);
	},
	isConditionCell: function(sheetId, row, col) {
		var cellCoord = [sheetId, row, col],
			coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		for(var p in this.cdtLookup) {
			if(this.floatings.hasOwnProperty(p)) {
				var it = this.floatings[p];
				var refs = it.cells;
				if(coordPro.isCellInCoord(cellCoord, refs)) {
					return true;
				}
			}
		}
		return false;
	},
	getConditionOfCell: function(sheetId, row, col) {
		var cellCoord = [sheetId, row, col],
			coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var conditions = [];
		for(var p in this.cdtLookup) {
			if(this.floatings.hasOwnProperty(p)) {
				var it = this.floatings[p];
				var jsonObj = it.jsonObj;
				var refs = it.cells;
				if(coordPro.isCellInCoord(cellCoord, refs)) {
					conditions.push(jsonObj);
				}
			}
		}
		return conditions;
	},
	addSyncCdtPriority: function(sheetId, name) {
		var cell = this.getCell(sheetId, 0, 0);
		var cdtPriority = cell.cdtPriority;
		if(cdtPriority) {
			cdtPriority = Ext.decode(cdtPriority);
		} else {
			cdtPriority = {};
		}
		if(!cdtPriority.hasOwnProperty(name)) {
			var max = false;
			for(var p in cdtPriority) {
				if(cdtPriority.hasOwnProperty(p)) {
					var priority = cdtPriority[p];
					if(false === max || max < priority) {
						max = priority;
					}
				}
			}
			if(false === max) {
				max = 0;
			} else {
				max++;
			}
			cdtPriority[name] = max;
			this.setCell(sheetId, 0, 0, {
				cdtPriority: Ext.encode(cdtPriority)
			}, undefined, true);
			this.getCdtPriority(sheetId, true);
		}
	},
	removeCdtPriority: function(sheetId, name) {
		var cell = this.getCell(sheetId, 0, 0);
		var cdtPriority = cell.cdtPriority;
		if(cdtPriority) {
			cdtPriority = Ext.decode(cdtPriority);
		} else {
			cdtPriority = {};
		}
		if(cdtPriority.hasOwnProperty(name)) {
			delete cdtPriority[name];
			if(SCOM.isEmptyObj(cdtPriority)) {
				this.setCell(sheetId, 0, 0, undefined, ["cdtPriority"], true);
			} else {
				this.setCell(sheetId, 0, 0, {
					cdtPriority: Ext.encode(cdtPriority)
				}, undefined, true);
			}
			this.getCdtPriority(sheetId, true);
		}
	},
	getCdtPriorityLookup: function(sheetId) {
		var cell = this.getCell(sheetId, 0, 0);
		var cdtPriority = cell.cdtPriority;
		if(cdtPriority) {
			return Ext.decode(cdtPriority);
		}
	},
	getCdtPriority: function(sheetId, forceRefresh) {
		if(!this.cachedCdtPriority || forceRefresh) {
			var cell = this.getCell(sheetId, 0, 0);
			var cdtPriority = cell.cdtPriority;
			var arr = [];
			if(cdtPriority) {
				if(Ext.isString(cdtPriority)) {
					cdtPriority = Ext.decode(cdtPriority);
				} else {
					this.setCell(sheetId, 0, 0, {
						cdtPriority: Ext.encode(cdtPriority)
					}, undefined, true);
				}
				for(var p in cdtPriority) {
					if(cdtPriority.hasOwnProperty(p)) {
						var id = p + this.separateChar + sheetId;
						arr.push({
							priority: cdtPriority[p],
							id: id,
							cdtId: p
						});
					}
				}
				arr.sort(function(a, b) {
					return a.priority - b.priority;
				});
			} else {
				var cdtPriority = {};
				for(var p in this.cdtLookup) {
					if(this.cdtLookup.hasOwnProperty(p)) {
						var it = this.floatings[p];
						if(it) {
							var jsonObj = it.jsonObj;
							arr.unshift({
								id: p,
								cdtId: jsonObj.id
							});
						}
					}
				}
			}
			this.cachedCdtPriority = arr;
			for(var i = 0, len = arr.length; i < len; i++) {
				var it = this.floatings[arr[i].id];
				cdtPriority[it.name] = i;
			}
			this.setCell(sheetId, 0, 0, {
				cdtPriority: Ext.encode(cdtPriority)
			}, undefined, true);
		}
		return this.cachedCdtPriority;
	},
	getCdtFloatingOfCell: function(sheetId, row, col) {
		var cellCoord = [sheetId, row, col],
			coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var priority = this.getCdtPriority(sheetId);
		var conditions = [];
		for(var i = 0, len = priority.length; i < len; i++) {
			var id = priority[i].id;
			var it = this.floatings[id];
			var jsonObj = it.jsonObj;
			var refs = it.cells;
			if(coordPro.isCellInCoord(cellCoord, refs)) {
				conditions.push(it);
			}
		}
		return conditions;
	},
	getConditionLookup: function() {
		var conditions = {};
		for(var p in this.cdtLookup) {
			if(this.floatings.hasOwnProperty(p)) {
				var it = this.floatings[p];
				var jsonObj = it.jsonObj;
				conditions[p] = it;
			}
		}
		return conditions;
	},
	presetMerge2Cell: function(merge, sheetId, mergeId) {
		var span = [sheetId].concat(merge);
		this.walkRange([span], function(rd) {
			var sid = rd.data.sheet,
				r = rd.data.row,
				c = rd.data.col;
			var modified = {
				minrow: merge[0] - r,
				maxrow: merge[2] - r,
				mincol: merge[1] - c,
				maxcol: merge[3] - c,
				abminrow: merge[0],
				abmincol: merge[1],
				abmaxrow: merge[2],
				abmaxcol: merge[3]
			};
			this.setCell(sid, r, c, modified, null, true, undefined, true);
		}, this);
	},
	clearMerge2Cell: function(merge, sheetId) {
		var minrow = merge[0],
			mincol = merge[1],
			maxrow = merge[2],
			maxcol = merge[3];
		var span = [sheetId].concat(merge);
		this.walkRange([span], function(rd) {
			var sid = rd.data.sheet,
				r = rd.data.row,
				c = rd.data.col,
				o = rd.data.json;
			if(this.isMergedCell(o, sheetId, r, c)) {
				this.setCell(sheetId, r, c, null, ["minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol"], true, undefined, r === maxrow && c === maxcol ? false : true);
			}
		}, this);
	},
	appendFloatings: function(floatings) {
		this.floatings = this.floatings || {};
		for(var i = 0, len = floatings.length; i < len; i++) {
			var it = floatings[i];
			var id = [it.name, it.sheet].join(this.separateChar);
			this.floatings[id] = it;
			if("meg" == it.ftype) {
				var json = Ext.decode(it.json);
				it.jsonObj = json;
				this.presetMerge2Cell(json, it.sheet, id);
				this.mergeLookup[id] = true;
			} else if("cdt" == it.ftype) {
				var json = Ext.decode(it.json);
				it.cdtName = json.name;
				json.id = it.name;
				it.jsonObj = json;
				this.presetCdt2Cells(it);
				this.cdtLookup[id] = true;
			} else if("row" == it.ftype) {
				var json = Ext.decode(it.json);
				this.presetRowHiddens(it.sheet, json);
			} else if("col" == it.ftype) {
				var json = Ext.decode(it.json);
				this.presetColHiddens(it.sheet, json);
			} else if("pb" == it.ftype) {
				var json = Ext.decode(it.json);
				it.jsonObj = json;
			}
		}
	},
	getUserInfo: function() {
		return this.userInfo;
	},
	afterLoad: function() {
		this.readMerges();
		this.presetTplForCells();
		delete this._loadingFlag;
		this.resetRowHeightColWidthCache(this.getActivedSheetId());
		this.setupCalMap();
		this.fireEvent("prepareafterload", this);
		this.fireEvent("afterload", this);
	},
	isLoadingCells: function() {
		return this._loadingFlag;
	},
	addSheet: function(tabConfig, callback, scope, loaded) {
		tabConfig = tabConfig || {};
		var tabName = tabConfig.name,
			position = tabConfig.position;
		var sheets = this.sheets;
		if(this.isExistedSheetName(tabName)) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.tab_name_existed);
			}
			return "name_existed";
		}
		var sheetId = -1;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var id = sheets[i].id;
			if(sheetId < id) {
				sheetId = id;
			}
		}
		sheetId++;
		delete tabConfig.position;
		var obj = Ext.apply({
			id: sheetId,
			actived: false,
			loaded: loaded
		}, tabConfig);
		if(Ext.isNumber(position)) {
			sheets.splice(position, 0, obj);
		} else {
			sheets.push(obj);
		}
		this.syncSheetLookup();
		if(callback) {
			callback.call(scope, obj);
		}
		this.fireEvent("addsheet", obj.id, name, this);
	},
	hideSheet: function(sheetId, callback, scope, skipPull, suspendEvent) {
		var sheetObj = this.getSheetById(sheetId);
		sheetObj.hidden = true;
		if(callback) {
			callback.call(scope, sheetObj, this, true);
		}
		if(!suspendEvent) {
			this.fireEvent("hidesheet", sheetId, this, skipPull);
		}
	},
	showSheet: function(sheetId, callback, scope, skipPull, suspendEvent) {
		var sheetObj = this.getSheetById(sheetId);
		sheetObj.hidden = false;
		if(callback) {
			callback.call(scope, sheetObj, this, true);
		}
		if(!suspendEvent) {
			this.fireEvent("showsheet", sheetId, this, skipPull);
		}
	},
	deleteSheet: function(sheetId, callback, scope, skipPull, suspendEvent) {
		var sheets = this.sheets;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var id = sheets[i].id;
			if(sheetId == id) {
				sheets.splice(i, 1);
				break;
			}
		}
		this.syncSheetLookup();
		var deleted = [],
			data = this.getData();
		for(var p in data) {
			if(data.hasOwnProperty(p)) {
				var it = data[p];
				if(it[0] === sheetId) {
					deleted.push({
						data: {
							sheet: it[0],
							row: it[1],
							col: it[2],
							json: it[3]
						}
					});
					delete data[p];
				}
			}
		}
		this.refreshCalLookup();
		if(callback) {
			callback.call(scope, deleted, true);
		}
		if(!suspendEvent) {
			this.fireEvent("deletesheet", sheetId, deleted, this, skipPull);
		}
	},
	renameSheet: function(sheetId, newName, callback, scope) {
		var sheetTab = this.getSheetById(sheetId);
		if(Ext.isDefined(newName) && this.isExistedSheetName(newName) && sheetTab.name !== newName) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.cannot_rename_existed_tabname);
			}
			return "name_existed";
		}
		var sheets = this.sheets;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			var id = sheet.id;
			if(sheetId == id) {
				sheet.lastOldName = sheet.name;
				sheet.name = newName;
				break;
			}
		}
		this.syncSheetLookup();
		if(callback) {
			callback.call(scope);
		}
		this.fireEvent("renamesheet", sheetId, newName, this);
	},
	changeSheetColor: function(sheetId, color, callback, scope) {
		var sheets = this.sheets;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			var id = sheet.id;
			if(sheetId == id) {
				sheet.color = color;
				break;
			}
		}
		if(callback) {
			callback.call(scope);
		}
		this.fireEvent("chagesheetcolor", sheetId, color, this);
	},
	changeSheetWidth: function(sheetId, width, callback, scope) {
		var sheets = this.sheets;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			var id = sheet.id;
			if(sheetId == id) {
				sheet.width = width;
				break;
			}
		}
		if(callback) {
			callback.call(scope);
		}
		this.fireEvent("chagesheetwidth", sheetId, width, this);
	},
	updateSheetTab: function(sheetId, config, callback, scope) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getActivedSheetId();
		}
		var sheetTab = this.getSheetById(sheetId);
		config = config || {};
		var name = config.name;
		if(Ext.isDefined(name) && this.isExistedSheetName(name) && sheetTab.name !== name) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.cannot_rename_existed_tabname);
			}
			return "name_existed";
		}
		var sheets = this.sheets;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			var id = sheet.id;
			if(sheetId == id) {
				Ext.apply(sheet, config);
				break;
			}
		}
		this.syncSheetLookup();
		if(callback) {
			callback.call(scope, sheetId);
		}
		this.fireEvent("updatesheettab", sheetId, config, this);
	},
	loadFile: function(config, callback, scope) {
		config = config || {};
		if(!SCOM.nullOrUndefined(config.fileId)) {
			this.fileId = config.fileId;
		}
		this.load({
			params: {
				fileId: this.fileId,
				startCellId: 0,
				size: this.limitCellNumAtSingleLoad
			},
			callback: function() {
				if(callback) {
					callback.apply(scope, arguments);
				}
			},
			scope: this
		});
	},
	loadJsonFile: function(json, callback, scope) {
		json = SCOM.copy(json);
		var me = this;
		Ext.apply(this, {
			fileId: json.fileId,
			fileName: json.fileName || json.name || "",
			fileStared: json.fileStared || json.stared,
			fileColor: json.fileColor || json.color,
			fileExname: json.exname
		});
		var sheets = json.sheets;
		if(sheets) {
			var actived;
			for(var i = 0, len = sheets.length; i < len; i++) {
				var it = sheets[i];
				it.loaded = true;
				it.allCellDataLoaded = true;
				if(it.actived) {
					actived = i;
				}
			}
			if(!Ext.isDefined(actived)) {
				sheets[0].actived = true;
			}
		}
		var cells = json.cells;
		if(cells) {
			for(var i = 0, len = cells.length; i < len; i++) {
				var thisCell = cells[i];
				if(Ext.isDefined(thisCell.x)) {
					thisCell.row = thisCell.x;
					thisCell.col = thisCell.y;
					thisCell.sheet = thisCell.i;
					thisCell.json = thisCell.j;
					if(thisCell.c) {
						thisCell.isCal = thisCell.c;
						delete thisCell.c;
					}
				}
				var o = thisCell.json;
				if(Ext.isString(o)) {
					o = Ext.decode(o);
				}
				if(Ext.isDefined(o.data)) {
					if(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.isCalculate(o.data)) {
						o.cal = true;
					}
				}
				if(!o.cal) {
					delete o.cal;
					delete o.arg;
					delete o.refs;
					delete o.value;
				}
				for(var p in o) {
					if(o.hasOwnProperty(p) && "_" === p.charAt(0)) {
						delete o[p];
					}
				}
				var arr = [thisCell.sheet, thisCell.row, thisCell.col, o];
				cells[i] = arr;
			}
			var records = me.reader.read(cells);
			me.loadRecords(records, {
				addRecords: false
			});
		}
		this.getMessageAfterLoad(json);
	},
	loadMoreJsonFile: function(json, callback, scope) {
		var me = this,
			dataMap = this.getData();
		var cells = json.cells;
		for(var i = 0, len = cells.length; i < len; i++) {
			var thisCell = cells[i];
			if(Ext.isDefined(thisCell.x)) {
				thisCell.row = thisCell.x;
				thisCell.col = thisCell.y;
				thisCell.sheet = thisCell.i;
				thisCell.json = thisCell.j;
				if(thisCell.c) {
					thisCell.isCal = thisCell.c;
					delete thisCell.c;
				}
			}
			var o = thisCell.json;
			if(Ext.isString(o)) {
				o = Ext.decode(o);
			}
			if(Ext.isDefined(o.data)) {
				if(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.isCalculate(o.data)) {
					o.cal = true;
				}
			}
			if(!o.cal) {
				delete o.cal;
				delete o.arg;
				delete o.refs;
				delete o.value;
			}
			for(var p in o) {
				if(o.hasOwnProperty(p) && "_" === p.charAt(0)) {
					delete o[p];
				}
			}
			var arr = [thisCell.sheet, thisCell.row, thisCell.col, o];
			cells[i] = arr;
		}
		var records = me.reader.read(cells);
		var separateChar = this.separateChar;
		var recLen = records.length,
			sheetCellCount = {};
		for(var i = 0; i < recLen; i++) {
			var it = records[i],
				sheetId = it[0];
			sheetCellCount[sheetId] = sheetCellCount[sheetId] || 0;
			var cid = [it[0], it[1], it[2]].join(separateChar);
			if(!dataMap[cid]) {
				sheetCellCount[sheetId]++;
			}
		}
		me.loadRecords(records, {
			addRecords: true
		});
		for(var p in sheetCellCount) {
			if(sheetCellCount.hasOwnProperty(p)) {
				var sheetObj = this.getSheetById(p);
				sheetObj.totalCellCount += sheetCellCount[p];
				sheetObj.currentCellCount += sheetCellCount[p];
			}
		}
		if(callback) {
			callback.call(scope);
		}
	},
	loadTabJsonFile: function(json, callback, scope) {
		var me = this,
			separateChar = this.separateChar,
			dataMap = this.getData();
		var cells = json.cells;
		var records = me.reader.read(cells);
		var recLen = records.length,
			newRecs = [],
			sheetCellCount = {};
		for(var i = 0; i < recLen; i++) {
			var it = records[i],
				sheetId = it[0];
			sheetCellCount[sheetId] = sheetCellCount[sheetId] || 0;
			var cid = [it[0], it[1], it[2]].join(separateChar);
			if(!dataMap[cid]) {
				dataMap[cid] = it;
				sheetCellCount[sheetId]++;
			}
		}
		for(var p in sheetCellCount) {
			if(sheetCellCount.hasOwnProperty(p)) {
				var sheetObj = this.getSheetById(p);
				sheetObj.totalCellCount += sheetCellCount[p];
				sheetObj.currentCellCount += sheetCellCount[p];
			}
		}
		this.floatings = {};
		this.mergeLookup = {};
		this.cdtLookup = {};
		if(json) {
			me.readFloatings(json.floatings);
			me.readFileConfig(json.fileConfig);
			me.userInfo = Ext.apply({}, json.user);
			me.checkReferenceString(true);
		}
		this.prepareDefaultWidthHeightForActiveSheet();
		if(false !== me.fireEvent("beforeafterload", this)) {
			me.afterLoad();
		}
		if(callback) {
			callback.call(scope);
		}
	},
	getJsonData: function(compress) {
		var cells = this.getCellsJson(compress);
		var floatings = this.getFloatingsJson();
		var fileConfig = this.getFileConfigJson();
		var sheets = this.getSheets(),
			arr = [];
		for(var i = 0, len = sheets.length; i < len; i++) {
			var it = sheets[i];
			arr.push({
				id: it.id,
				name: it.name,
				actived: it.actived,
				color: it.color,
				hidden: it.hidden == null ? false : it.hidden,
				tabOrder: it.tabOrder == null ? i + 1 : it.tabOrder
			});
		}
		var json = {
			sheets: arr,
			cells: cells,
			floatings: floatings,
			fileConfig: fileConfig
		};
		var obj = this.getLoadedFile();
		return Ext.apply(obj, json);
	},
	saveJsonFile: function(config, callback, scope) {
		if(!Ext.isDefined(this.getFileId())) {
			Ext.applyIf(config, this.getJsonData(true));
			Ext.Ajax.request({
				url: SCONFIG.urls.saveJsonFile,
				params: {
					json: Ext.encode(config)
				},
				success: function(response, options) {
					var json = Ext.decode(response.responseText);
					var sheetIdMap = json.sheetIdMap;
					this.sync2NewSheetIds(sheetIdMap);
					this.setFileId(json.fileId);
					this.fireEvent("savejsonfile", sheetIdMap, json.fileId, this);
					if(callback) {
						callback.call(scope, json.fileId);
					}
				},
				failure: function() {},
				scope: this
			});
		} else {
			var params = Ext.apply({
				oldFileId: this.getFileId()
			}, config);
			Ext.Ajax.request({
				url: SCONFIG.urls.saveFileAs,
				params: params,
				success: function(response, options) {
					var json = Ext.decode(response.responseText);
					var newFileId = json.fileId || params.id;
					this.setFileId(newFileId);
					this.fireEvent("savefileas", newFileId, this);
					if(callback) {
						callback.call(scope, newFileId);
					}
				},
				failure: function() {},
				scope: this
			});
		}
	},
	setFileId: function(fileId) {
		this.fileId = fileId;
	},
	getFileId: function() {
		return this.fileId;
	},
	getFileName: function() {
		return this.fileName;
	},
	getLoadedFile: function() {
		return {
			id: this.fileId,
			name: this.fileName,
			stared: this.fileStared,
			color: this.fileColor,
			exname: this.fileExname,
			permission: this.filePermission,
			owner: this.fileOwner,
			isPublic: this.isPublic
		};
	},
	getLoadedFileName: function() {
		var file = this.getLoadedFile();
		if(file) {
			return file.name;
		}
	},
	isShareableFile: function() {
		var file = this.getLoadedFile();
		if(file && Ext.isDefined(file.id)) {
			var permission = 7;
			if(Ext.isDefined(file.permission)) {
				permission = file.permission;
			}
			return 7 === permission;
		}
	},
	isViewOnlyFile: function() {
		var file = this.getLoadedFile();
		if(file && Ext.isDefined(file.id)) {
			var permission = 7;
			if(Ext.isDefined(file.permission)) {
				permission = file.permission;
			}
			return 2 > permission;
		}
	},
	isExportableFile: function() {
		var file = this.getLoadedFile();
		if(file && Ext.isDefined(file.id)) {
			var permission = 7;
			if(Ext.isDefined(file.permission)) {
				permission = file.permission;
			}
			return 2 < permission;
		}
	},
	getFloatingItem: function(sheetId, name) {
		this.floatings = this.floatings || {};
		var id = name + this.separateChar + sheetId;
		var found = this.floatings[id];
		return found;
	},
	setFloatingItem: function(sheetId, name, ftype, json, suspendEvent) {
		this.floatings = this.floatings || {};
		var id = name + this.separateChar + sheetId;
		var found = this.floatings[id];
		this.fireEvent("preparesetfloatingitem", found, id, this);
		if(found) {
			if(SCOM.nullOrUndefined(json)) {
				delete this.floatings[id];
				delete this.mergeLookup[id];
				if(this.cdtLookup[id]) {
					delete this.cdtLookup[id];
					this.removeCdtPriority(sheetId, name);
				}
				if(!suspendEvent) {
					this.fireEvent("removefloatingitem", found, this);
				}
			} else {
				found.ftype = ftype;
				found.json = json;
				if("cdt" === ftype) {
					var jsonObj = Ext.decode(json);
					jsonObj.id = name;
					found.cdtName = jsonObj.name;
					found.jsonObj = jsonObj;
					found.json = Ext.encode(jsonObj);
					this.presetCdt2Cells(found);
				} else if("pb" === ftype) {
					var jsonObj = Ext.decode(json);
					found.jsonObj = jsonObj;
				}
				this.fireEvent("processfloating", found, this);
				if(!suspendEvent) {
					this.fireEvent("updatefloatingitem", found, this);
				}
			}
			return found;
		}
		if(!SCOM.nullOrUndefined(json)) {
			var it = {
				sheet: sheetId,
				name: name,
				ftype: ftype,
				json: json
			};
			this.floatings[id] = it;
			if("cdt" === ftype) {
				var jsonObj = Ext.decode(json);
				it.cdtName = jsonObj.name;
				it.jsonObj = jsonObj;
				this.presetCdt2Cells(it);
				this.cdtLookup[id] = true;
				this.addSyncCdtPriority(sheetId, name);
			} else if("meg" === ftype) {
				var jsonObj = Ext.decode(json);
				it.jsonObj = jsonObj;
				this.mergeLookup[id] = true;
			} else if("pb" === ftype) {
				var jsonObj = Ext.decode(json);
				it.jsonObj = jsonObj;
			}
			this.fireEvent("processfloating", it, this);
			if(!suspendEvent) {
				this.fireEvent("createfloatingitem", it, this);
			}
			return it;
		}
	},
	updateRowGroups: function(sheetId, rowGroups, suspendEvent) {
		if(rowGroups) {
			rowGroups = SCOM.copy(rowGroups);
			this.setFloatingItem(sheetId, "rowGroups", "rowgroup", Ext.encode(rowGroups), suspendEvent);
		} else {
			this.setFloatingItem(sheetId, "rowGroups", "rowgroup", null, suspendEvent);
		}
		return rowGroups;
	},
	updateColumnGroups: function(sheetId, colGroups, suspendEvent) {
		if(colGroups) {
			colGroups = SCOM.copy(colGroups);
			this.setFloatingItem(sheetId, "colGroups", "colgroup", Ext.encode(colGroups), suspendEvent);
		} else {
			this.setFloatingItem(sheetId, "colGroups", "colgroup", null, suspendEvent);
		}
		return colGroups;
	},
	updateSheetConfig: function(sheetId, config, suspendEvent) {
		if(config) {
			this.setCell(sheetId, 0, 0, {
				config: Ext.encode(config)
			}, null, suspendEvent);
		} else {
			this.setCell(sheetId, 0, 0, null, ["config"], suspendEvent);
		}
	},
	getSheetConfig: function(sheetId) {
		var cell = this.getCell(sheetId, 0, 0);
		var config = {};
		if(cell.config) {
			config = Ext.decode(cell.config);
		}
		return config;
	},
	getActivedSheetId: function() {
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			if(sheet.actived) {
				return sheet.id;
			}
		}
		return sheets[0].id;
	},
	setActivedSheetId: function(sheetId) {
		var sheets = this.getSheets(),
			found, oldActived, oldActivedSheetId;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			if(sheet.actived) {
				oldActived = sheet;
				oldActivedSheetId = sheet.id;
				sheet.actived = false;
			}
		}
		for(var i = 0, len = sheets.length; i < len; i++) {
			var sheet = sheets[i];
			if(sheet.id == sheetId) {
				found = sheet;
				sheet.actived = true;
			}
		}
		this.prepareDefaultWidthHeightForActiveSheet();
		if(oldActivedSheetId !== sheetId) {
			this.fireEvent("changeactivedsheetid", oldActivedSheetId, sheetId, this);
		}
		return [oldActived, found];
	},
	indexOfSheetId: function(sheetId) {
		for(var i = 0, len = this.sheets.length; i < len; i++) {
			var tab = this.sheets[i];
			if(tab.id === sheetId) {
				return i;
			}
		}
	},
	changeSheetOrder: function(preIndex, curIndex, callback, scope) {
		var sheet = this.sheets.splice(preIndex, 1)[0];
		this.sheets.splice(curIndex, 0, sheet);
		if(callback) {
			callback.call(scope, true);
		}
	},
	changeFileName: function(fileObj, callback, scope, suspendEvent) {
		this.fileName = fileObj.fileName;
		if(callback) {
			callback.call(scope, true);
		}
		if(!suspendEvent) {
			this.fireEvent("filenamechanged", this.fileName, this);
		}
	},
	changeFileColor: function(fileObj, callback, scope, suspendEvent) {
		this.fileColor = fileObj.color;
		if(callback) {
			callback.call(scope, true);
		}
		if(!suspendEvent) {
			this.fireEvent("filecolorchanged", this.fileColor, this);
		}
	},
	changeFileStared: function(fileStared, callback, scope, suspendEvent) {
		this.fileStared = fileStared;
		if(callback) {
			callback.call(scope, true);
		}
		if(!suspendEvent) {
			this.fireEvent("filestaredchanged", this.fileStared, this);
		}
	},
	getCopyName: function(sheetId) {
		var sheetName = this.getSheetNameById(sheetId);
		sheetName = "Copy of " + sheetName;
		var sheets = this.getSheets();
		var checkName = function(name) {
			for(var i = 0, len = sheets.length; i < len; i++) {
				var sheet = sheets[i];
				if(sheet.name == name) {
					return false;
				}
			}
			return true;
		};
		var index = 1;
		while(!checkName(sheetName)) {
			sheetName = sheetName + "(" + index + ")";
			index++;
		}
		return sheetName;
	},
	copyFloatings: function(oldSheetId, newSheetId) {
		var floatings = this.floatings,
			newFloatings = [];
		for(var p in floatings) {
			if(floatings.hasOwnProperty(p)) {
				var it = floatings[p];
				if(oldSheetId == it.sheet) {
					var name = it.name,
						json = it.json;
					if("meg" === it.ftype) {
						name = name.replace(oldSheetId + "$", newSheetId + "$");
					} else {
						json = json.replace("\"span\":[" + oldSheetId + ",", "\"span\":[" + newSheetId + ",");
					}
					var obj = {
						sheet: newSheetId,
						name: name,
						ftype: it.ftype,
						json: json
					};
					newFloatings.push(obj);
				}
			}
		}
		this.appendFloatings(newFloatings);
	},
	copySheet: function(oldSheetId, newSheetName, callback, scope, newSheetId, skipPull) {
		if(this.isExistedSheetName(newSheetName)) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.cannot_rename_existed_tabname);
			}
			return "name_existed";
		}
		var sheets = this.sheets;
		var sheetId = newSheetId;
		var oldSheet = this.getSheetById(oldSheetId);
		if(!Ext.isDefined(sheetId)) {
			var max = -1;
			for(var i = 0, len = sheets.length; i < len; i++) {
				var id = sheets[i].id;
				if(max < id) {
					max = id;
				}
			}
			sheetId = max + 1;
		}
		var obj = Ext.applyIf({
			actived: false,
			id: sheetId,
			name: newSheetName
		}, oldSheet);
		delete obj.loadedEmptyCells;
		this.sheets.push(obj);
		this.syncSheetLookup();
		this.each(function(rd) {
			if(oldSheetId == rd.data.sheet) {
				this.newRecord(sheetId, rd.data.row, rd.data.col, rd.data.json);
			}
		}, this);
		this.copyFloatings(oldSheetId, sheetId);
		this.refreshCalLookup();
		if(callback) {
			callback.call(scope, obj, this);
		}
		this.fireEvent("copysheet", sheetId, newSheetName, this);
	},
	loadSheet: function(sheetId, callback, scope) {
		if(callback) {
			callback.call(scope);
		}
	},
	checkLoadCells: function(lookup, callback, scope) {
		if(callback) {
			callback.call(scope);
		}
		return true;
	},
	checkLoadCoord: function(coord, callback, scope) {
		if(callback) {
			callback.call(scope);
		}
		return true;
	},
	findMatchCells: function(exp, callback, scope, startCellId) {
		exp = exp.trim();
		var items = [exp],
			isSingleWord = true;
		if(exp.indexOf(" ") > -1 && exp.length > 6) {
			items = [];
			exp = exp.substring(1, exp.length - 1);
			var tempItems = exp.split(" ");
			for(var i = 0; i < tempItems.length; i++) {
				var strItem = tempItems[i].trim();
				if(strItem && strItem.length > 1) {
					items.push("*" + strItem + "*");
				}
			}
		}
		if(items.length > 1) {
			isSingleWord = false;
		}
		var reg = SCOM.genRegExp(items[0]);
		var reg2 = null,
			reg3 = null,
			reg4 = null;
		if(items.length == 2) {
			reg2 = SCOM.genRegExp(items[1]);
		} else if(items.length == 3) {
			reg2 = SCOM.genRegExp(items[1]);
			reg3 = SCOM.genRegExp(items[2]);
		} else if(items.length > 3) {
			reg2 = SCOM.genRegExp(items[1]);
			reg3 = SCOM.genRegExp(items[2]);
			reg4 = SCOM.genRegExp(items[3]);
		}
		var matchs = [];
		this.each(function(rd) {
			var json = rd.data.json,
				row = rd.data.row,
				col = rd.data.col;
			if(0 != row && 0 != col) {
				var data = json.data;
				reg.lastIndex = 0;
				if(reg2 != null) {
					reg2.lastIndex = 0;
				}
				if(reg3 != null) {
					reg3.lastIndex = 0;
				}
				if(reg4 != null) {
					reg4.lastIndex = 0;
				}
				if(data) {
					var addFlag = false;
					if(isSingleWord && reg.test(data)) {
						addFlag = true;
					} else {
						if(reg4 != null && (reg.test(data) || reg2.test(data) || reg3.test(data) || reg4.test(data))) {
							var result1 = reg.test(data),
								result2 = reg2.test(data),
								result3 = reg3.test(data),
								result4 = reg4.test(data);
							if(result1 || result2 || result3 || result4) {
								addFlag = true;
							}
						} else if(reg3 != null) {
							var result1 = reg.test(data),
								result2 = reg2.test(data),
								result3 = reg3.test(data);
							if(result1 || result2 || result3) {
								addFlag = true;
							}
						} else if(reg2 != null) {
							var result1 = reg.test(data),
								result2 = reg2.test(data);
							if(result1 || result2) {
								addFlag = true;
							}
						}
					}
					if(addFlag) {
						matchs.push({
							sheet: rd.data.sheet,
							sheetName: this.getSheetNameById(rd.data.sheet),
							row: row,
							col: col,
							cell: this.getColName(col) + row,
							data: data
						});
					}
				}
			}
		}, this);
		if(callback) {
			callback.call(scope, matchs, startCellId);
		}
	},
	setNamedFuncConfig: function(name, obj, suspendEvent, suspendCheck) {
		obj = obj || {};
		var json;
		if(obj.jsonArr) {
			var arr = [];
			for(var i = 0, len = obj.jsonArr.length; i < len; i++) {
				var it = obj.jsonArr[i];
				var o = {
					cal: it.cal
				};
				if(Ext.isDefined(it.scope)) {
					o.scope = it.scope;
				}
				if(it.comment) {
					o.comment = it.comment;
				}
				arr.push(o);
			}
			json = Ext.encode(arr);
		}
		this.setFileConfig("named_func", name, json, suspendEvent);
		if(json) {
			var refs = [];
			for(var i = 0, len = obj.jsonArr.length; i < len; i++) {
				var r = obj.jsonArr[i].refs;
				if(r) {
					refs = refs.concat(r);
				}
			}
			var found = this.namedFuncConfig[name];
			if(found) {
				var oldRefs = [];
				for(var i = 0, len = found.jsonArr.length; i < len; i++) {
					var r = found.jsonArr[i].refs;
					if(r) {
						oldRefs = oldRefs.concat(r);
					}
				}
				this.updateCalMap(name, refs, oldRefs, "named_func");
				Ext.apply(found, obj);
			} else {
				var id = name + this.separateChar + "named_func";
				var it = this.fileConfig[id];
				this.updateCalMap(name, refs, undefined, "named_func");
				Ext.apply(it, obj);
				this.namedFuncConfig[name] = it;
			}
		} else {
			var found = this.namedFuncConfig[name];
			if(found) {
				var oldRefs = [];
				for(var i = 0, len = found.jsonArr.length; i < len; i++) {
					var r = found.jsonArr[i].refs;
					if(r) {
						oldRefs = oldRefs.concat(r);
					}
				}
				this.updateCalMap(name, undefined, oldRefs, "named_func");
			}
			delete this.namedFuncConfig[name];
		}
		if(!suspendCheck) {
			this.checkReferenceString();
		}
	},
	setFileConfig: function(ctype, name, json, suspendEvent) {
		this.fileConfig = this.fileConfig || {};
		var id = name + this.separateChar + ctype;
		var found = this.fileConfig[id];
		this.fireEvent("preparesetfileconfig", found, id, this);
		if(found) {
			var oldJson = found.json;
			if(SCOM.nullOrUndefined(json)) {
				delete this.fileConfig[id];
				if(!suspendEvent) {
					found = SCOM.copy(found);
					this.fireEvent("removefileconfig", found, this, oldJson);
				}
			} else {
				found.json = json;
				if(!suspendEvent) {
					found = SCOM.copy(found);
					this.fireEvent("updatefileconfig", found, this, oldJson);
				}
			}
		} else if(!SCOM.nullOrUndefined(json)) {
			//2018 6.29 改正json为""时，解析错误
			var it = {
				name: name,
				ctype: ctype,
				json: json,
				jsonObj: json
			};
			this.fileConfig[id] = it;
			if(!suspendEvent) {
				it = SCOM.copy(it);
				this.fireEvent("createfileconfig", it, this);
			}
		}
	},
	getNamedFuncReg: function() {
		var tmp = [];
		var nameRefs = this.getNamedFuncConfigLookup();
		if(!SCOM.isEmptyObj(nameRefs)) {
			for(var p in nameRefs) {
				if(nameRefs.hasOwnProperty(p) && "tpl" !== nameRefs[p].source) {
					tmp.push(p);
				}
			}
			this.namedFuncReg = new RegExp("(^|[\\(\\,\\+\\-\\*\\%]*)(" + tmp.join("|") + ")([\\)\\,\\+\\-\\*\\%]|$)", "gi");
		} else {
			delete this.namedFuncReg;
		}
	},
	checkReferenceString: function(suspendEvent) {
		var oldRefStr = this.configReferenceStr;
		var nameRefs = this.getNamedFuncConfigLookup();
		var curSheetId = this.getActivedSheetId();
		this.getNamedFuncReg();
		var calPro = EnterpriseSheet.pure.sheet.calculate.Calculate.prototype;
		var arr = calPro.prepareRefNamedFunc(nameRefs, curSheetId, this);
		this.configReferenceStr = arr.join("");
		if(oldRefStr != this.configReferenceStr && !suspendEvent) {
			var changes = this.compareNameRefChanges(this.oldNameRefs, nameRefs);
			this.fireEvent("namedfuncconfigchange", this.configReferenceStr, this, changes, nameRefs);
		}
		this.oldNameRefs = SCOM.copy(nameRefs);
	},
	compareNameRefChanges: function(oldRefs, newRefs) {
		oldRefs = oldRefs || {};
		newRefs = newRefs || {};
		var changes = {};
		for(var p in oldRefs) {
			if(oldRefs.hasOwnProperty(p)) {
				var old = oldRefs[p];
				if(!newRefs.hasOwnProperty(p)) {
					changes[p] = "deleted";
				} else if(newRefs[p].json !== old.json) {
					changes[p] = "changed";
				}
			}
		}
		for(var p in newRefs) {
			if(newRefs.hasOwnProperty(p) && !oldRefs.hasOwnProperty(p)) {
				changes[p] = "added";
			}
		}
		return changes;
	},
	getNamedFuncValue: function(name, sheetId) {
		var found = this.namedFuncConfig[name];
		if(found) {
			if(this.hasRelativeCoordInNamedFunc(found)) {
				return {};
			}
			var jsonArr = found.jsonArr,
				a;
			for(var i = 0, len = jsonArr.length; i < len; i++) {
				var it = jsonArr[i];
				if(sheetId === it.scope) {
					return it;
				} else if(!Ext.isDefined(it.scope)) {
					a = it;
				}
			}
			return a;
		}
	},
	hasRelativeCoordInNamedFunc: function(namedFunc) {
		var jsonArr = namedFunc.jsonArr;
		for(var i = 0, len = jsonArr.length; i < len; i++) {
			var it = jsonArr[i];
			if(it.relativeCoordsInNamedFunc && 0 < it.relativeCoordsInNamedFunc.length) {
				return true;
			} else if(it.refs) {
				var refs = it.refs;
				for(var j = 0, count = refs.length; j < count; j++) {
					var span = refs[j];
					if(Ext.isString(span)) {
						var found = this.namedFuncConfig[span];
						if(found) {
							if(this.hasRelativeCoordInNamedFunc(found)) {
								return true;
							}
						}
					}
				}
			}
		}
		return false;
	},
	prepareFileConfigReference: function() {
		return this.configReferenceStr || "";
	},
	getNamedFuncConfig: function() {
		var configs = this.fileConfig || {};
		var arr = [];
		for(var p in configs) {
			if(configs.hasOwnProperty(p)) {
				var it = configs[p];
				if("named_func" == it.ctype) {
					arr.push(Ext.apply({}, it));
				}
			}
		}
		return arr;
	},
	getNamedFuncConfigLookup: function() {
		this.namedFuncConfig = this.namedFuncConfig || {};
		return this.namedFuncConfig;
	},
	getNamedFuncConfigByName: function(name) {
		return this.namedFuncConfig[name];
	},
	withFilterInSheet: function(sheetId) {
		var me = this;
		var flag = false;
		me.each(function(rd) {
			if(rd.data.sheet === sheetId) {
				var json = rd.data.json;
				if(json.filter) {
					flag = true;
					return false;
				}
			}
		});
		return flag;
	},
	isDisabledForMe: function(dsd) {
		if(dsd) {
			if("ed" === dsd) {
				return true;
			} else {
				dsd = Ext.decode(dsd);
				var userId = this.getUserInfo().id;
				return -1 === dsd.indexOf(userId);
			}
		}
		return false;
	},
	isDisabledCell: function(sheetId, row, col) {
		if(!SCOM.nullOrUndefined(sheetId)) {
			sheetId = this.getActivedSheetId();
		}
		var cd = this.getCellData(sheetId, row, col);
		return this.isDisabledForMe(cd.dsd);
	},
	getCellsJson: function(shortName) {
		var json = [],
			sheetName = "sheet",
			rowName = "row",
			colName = "col",
			calName = "cal",
			jsonName = "json";
		if(shortName) {
			sheetName = "i";
			rowName = "x";
			colName = "y";
			calName = "c";
			jsonName = "j";
		}
		var dp = this.defaultProperty;
		var avoidProperty = ["cdt", "minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol", "display"].concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.styles).concat(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.calGeneratedStyles);
		this.each(function(rec) {
			var data = rec.data;
			var obj = {};
			obj[sheetName] = data.sheet;
			obj[rowName] = data.row;
			obj[colName] = data.col;
			obj[calName] = data.json.cal;
			var cp = Ext.apply({}, data.json);
			for(var i = 0, len = avoidProperty.length; i < len; i++) {
				delete cp[avoidProperty[i]];
			}
			if(0 < SCOM.countObjMember(cp)) {
				obj[jsonName] = Ext.encode(cp);
				json.push(obj);
			}
		}, this);
		return json;
	},
	getFloatings: function() {
		return this.floatings;
	},
	getMergeFloatings: function() {
		var obj = {};
		for(var p in this.mergeLookup) {
			if(this.mergeLookup.hasOwnProperty(p)) {
				obj[p] = this.floatings[p];
			}
		}
		return obj;
	},
	getFloatingsJson: function() {
		var json = [];
		for(var p in this.floatings) {
			if(this.floatings.hasOwnProperty(p)) {
				json.push(Ext.apply({}, this.floatings[p]));
			}
		}
		return json;
	},
	getFileConfigJson: function() {
		var json = [];
		for(var p in this.fileConfig) {
			if(this.fileConfig.hasOwnProperty(p)) {
				json.push(Ext.apply({}, this.fileConfig[p]));
			}
		}
		return json;
	},
	sync2NewSheetIds: function(map) {
		for(var i = 0, len = this.sheets.length; i < len; i++) {
			var it = this.sheets[i];
			it.id = Number(map[it.id]);
		}
		var recs = [];
		this.each(function(rec) {
			var data = rec.data;
			data.sheet = Number(map[data.sheet]);
			delete data.id;
			recs.push(data);
		}, this);
		var records = this.reader.read(recs);
		this.loadRecords(records, {
			addRecords: false
		});
		for(var p in this.floatings) {
			if(this.floatings.hasOwnProperty(p)) {
				var it = this.floatings[p];
				it.sheet = Number(map[it.sheet]);
			}
		}
	},
	isExistedSheetName: function(name) {
		name = name.toUpperCase();
		var sheets = this.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++) {
			var s = sheets[i];
			if(name == s.name.toUpperCase()) {
				return true;
			}
		}
		return false;
	},
	shrinkCoordWithContent: function(coord) {
		for(var i = 0, len = coord.length; i < len; i++) {
			var span = coord[i];
			var sheetId = span[0],
				minRow = span[1],
				minCol = span[2],
				maxRow = span[3],
				maxCol = span[4];
			if(0 === maxRow && 0 === maxCol) {
				var contentMaxRow = false,
					contentMaxCol = false;
				this.each(function(rd) {
					if(rd.data.sheet === sheetId) {
						var row = rd.data.row,
							col = rd.data.col,
							json = rd.data.json;
						if(minRow < row && minCol <= col && json.data) {
							if(false === contentMaxRow || contentMaxRow < row) {
								contentMaxRow = row;
							}
							if(false === contentMaxCol || contentMaxCol < col) {
								contentMaxCol = col;
							}
						}
					}
				}, this);
				if(false !== contentMaxRow) {
					span[3] = contentMaxRow;
					if(0 === span[1]) {
						span[1] = 1;
					}
				}
				if(false !== contentMaxCol) {
					span[4] = contentMaxCol;
					if(0 === span[2]) {
						span[2] = 1;
					}
				}
			} else if(0 === maxRow) {
				var contentMaxRow = false;
				this.each(function(rd) {
					if(rd.data.sheet === sheetId) {
						var row = rd.data.row,
							col = rd.data.col,
							json = rd.data.json;
						if(minRow < row && json.data && minCol <= col && col <= maxCol) {
							if(false === contentMaxRow || contentMaxRow < row) {
								contentMaxRow = row;
							}
						}
					}
				}, this);
				if(false !== contentMaxRow) {
					span[3] = contentMaxRow;
					if(0 === span[1]) {
						span[1] = 1;
					}
				}
			} else if(0 === maxCol) {
				var contentMaxCol = false;
				this.each(function(rd) {
					if(rd.data.sheet === sheetId) {
						var row = rd.data.row,
							col = rd.data.col,
							json = rd.data.json;
						if(minCol < col && json.data && minRow <= row && row <= maxRow) {
							if(false === contentMaxCol || contentMaxCol < col) {
								contentMaxCol = col;
							}
						}
					}
				}, this);
				if(false !== contentMaxCol) {
					span[4] = contentMaxCol;
					if(0 === span[2]) {
						span[2] = 1;
					}
				}
			}
		}
		return coord;
	},
	isLinkCell: function(cell) {
		return cell.clink || cell.link ? true : false;
	},
	getCellLink: function(cell) {
		return cell.clink || cell.link;
	},
	getCellFormat: function(cell) {
		return cell.cfm || cell.fm;
	},
	setValueToVariable: function(vnVals, suspendEvent) {
		var changedCells = {},
			vcells = [],
			varLookup = {};
		this.each(function(rec) {
			var sheetId = rec.data.sheet;
			var json = rec.data.json,
				vname = json.vname;
			if(Ext.isDefined(vname)) {
				vcells.push(rec);
				var arr = vname.split(".");
				var found = vnVals[vname];
				if(1 < arr.length) {
					var last = arr.pop();
					var pname = arr.join(".");
					varLookup[pname] = varLookup[pname] || {
						names: {},
						posArr: []
					};
					var obj = varLookup[pname];
					obj.names[last] = found;
					obj.posArr.push([sheetId, rec.data.row, rec.data.col]);
				}
			}
		}, this);
		for(var p in varLookup) {
			if(varLookup.hasOwnProperty(p)) {
				var it = varLookup[p],
					names = it.names,
					posArr = it.posArr,
					rowFlag = undefined,
					colFlag = undefined,
					sheetId, row, col;
				for(var i = 0, len = posArr.length; i < len; i++) {
					var pos = posArr[i],
						rid = pos[0] + "-" + pos[1],
						cid = pos[0] + "-" + pos[2];
					sheetId = pos[0];
					row = pos[1];
					col = pos[2];
					if(!Ext.isDefined(rowFlag)) {
						rowFlag = rid;
					} else if(rowFlag !== rid) {
						rowFlag = false;
					}
					if(!Ext.isDefined(colFlag)) {
						colFlag = cid;
					} else if(colFlag !== cid) {
						colFlag = false;
					}
				}
				if(false !== rowFlag) {
					var max = 0;
					for(var q in names) {
						if(names.hasOwnProperty(q)) {
							var len = names[q].length;
							if(max < len) {
								max = len;
							}
						}
					}
					var i = row + 1,
						minr, maxr;
					while(true) {
						var cell = this.getCell(sheetId, i, 0);
						if(cell.vng !== p) {
							break;
						} else {
							if(!Ext.isDefined(minr) || minr > i) {
								minr = i;
							}
							if(!Ext.isDefined(maxr) || maxr < i) {
								maxr = i;
							}
						}
						i++;
					}
					var mergedBroken = false;
					this.walkRange([
						[sheetId, row, 0, row, 0]
					], function(rd) {
						var r = rd.data.row,
							c = rd.data.col,
							json = rd.data.json;
						if(Ext.isDefined(json.minrow) && json.minrow !== json.maxrow) {
							mergedBroken = true;
						}
					}, this);
					if(!mergedBroken) {
						if(Ext.isDefined(minr)) {
							this.removeRow(sheetId, minr, maxr);
						}
						this.insertRow(sheetId, row + 1, max - 1);
						this.walkRange([
							[sheetId, row, 0, row, 0]
						], function(rd) {
							var r = rd.data.row,
								c = rd.data.col,
								json = rd.data.json;
							if(Ext.isDefined(json.minrow)) {
								for(var i = row + 1, end = row + max; i < end; i++) {
									this.setCell(sheetId, i, c, Ext.copyTo({}, json, "minrow,mincol,maxrow,maxcol,abminrow,abmincol,abmaxrow,abmaxcol"), null, true);
								}
							}
						}, this);
						for(var i = row + 1, end = row + max; i < end; i++) {
							this.setCell(sheetId, i, 0, {
								vng: p
							}, undefined, true);
						}
					}
				}
			}
		}
		for(var k = 0, size = vcells.length; k < size; k++) {
			var rec = vcells[k];
			var sheetId = rec.data.sheet;
			var json = rec.data.json,
				vname = json.vname;
			var arr = vname.split(".");
			var found = vnVals[vname];
			if(Ext.isDefined(found)) {
				if(Ext.isArray(found)) {
					for(var i = 0, len = found.length; i < len; i++) {
						this.setCell(sheetId, rec.data.row + i, rec.data.col, {
							data: found[i]
						}, undefined, suspendEvent);
						var pos = [sheetId, rec.data.row + i, rec.data.col],
							id = pos.join(this.separateChar);
						changedCells[id] = pos;
					}
				} else {
					this.setCell(sheetId, rec.data.row, rec.data.col, {
						data: found
					}, undefined, suspendEvent);
					var pos = [sheetId, rec.data.row, rec.data.col],
						id = pos.join(this.separateChar);
					changedCells[id] = pos;
				}
			}
		}
		return changedCells;
	},
	isCoordContainDisabledCell: function(coord) {
		var flag = false;
		this.walkRange(coord, function(rec) {
			var json = rec.data.json;
			if(this.isDisabledForMe(json.dsd)) {
				flag = true;
				return false;
			}
		}, this);
		if(!flag) {
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				var cell = this.getCell(span[0], 0, 0);
				if(this.isDisabledForMe(cell.dsd)) {
					return true;
				}
				for(var r = span[1]; r <= span[3]; r++) {
					var cell = this.getCell(span[0], r, 0);
					if(this.isDisabledForMe(cell.dsd)) {
						return true;
					}
				}
				for(var c = span[2]; c <= span[4]; c++) {
					var cell = this.getCell(span[0], 0, c);
					if(this.isDisabledForMe(cell.dsd)) {
						return true;
					}
				}
			}
		}
		return flag;
	},
	getRowHiddens: function(sheetId) {
		var hiddens = [];
		this.each(function(rec) {
			if(sheetId === rec.data.sheet && 0 === rec.data.col) {
				var hidden = rec.data.json.hidden;
				if(hidden) {
					hiddens.push(rec.data.row);
				}
			}
		}, this);
		var hidePairs = SCOM.transferArr2Pairs(hiddens);
		return hidePairs;
	},
	getColHiddens: function(sheetId) {
		var hiddens = [];
		this.each(function(rec) {
			if(sheetId === rec.data.sheet && 0 === rec.data.row) {
				var hidden = rec.data.json.hidden;
				if(hidden) {
					hiddens.push(rec.data.col);
				}
			}
		}, this);
		var hidePairs = SCOM.transferArr2Pairs(hiddens);
		return hidePairs;
	},
	presetRowHiddens: function(sheetId, json) {
		var data = this.getData(),
			sep = this.separateChar;
		for(var i = 0, len = json.length; i < len; i++) {
			var it = json[i];
			for(var j = it[0]; j <= it[1]; j++) {
				var id = [sheetId, j, 0].join(sep);
				var found = data[id];
				if(found) {
					found[3].hidden = true;
				} else {
					this.newRecord(sheetId, j, 0, {
						hidden: true
					});
				}
			}
		}
	},
	presetColHiddens: function(sheetId, json) {
		var data = this.getData(),
			sep = this.separateChar;
		for(var i = 0, len = json.length; i < len; i++) {
			var it = json[i];
			for(var j = it[0]; j <= it[1]; j++) {
				var id = [sheetId, 0, j].join(sep);
				var found = data[id];
				if(found) {
					found[3].hidden = true;
				} else {
					this.newRecord(sheetId, 0, j, {
						hidden: true
					});
				}
			}
		}
	},
	syncColHiddens: function(sheetId, json) {
		var data = this.getData(),
			sep = this.separateChar,
			lookup = {};
		if(json) {
			for(var i = 0, len = json.length; i < len; i++) {
				var it = json[i];
				for(var j = it[0]; j <= it[1]; j++) {
					lookup[j] = true;
				}
			}
		}
		this.each(function(rec) {
			if(rec.data.sheet === sheetId && 0 === rec.data.row) {
				if(!lookup[rec.data.col]) {
					var id = [sheetId, 0, rec.data.col].join(sep);
					var found = data[id];
					if(found) {
						delete found[3].hidden;
						this.syncColWidthCache(sheetId, rec.data.col);
					}
				}
			}
		}, this);
		for(var j in lookup) {
			if(lookup.hasOwnProperty(j)) {
				var id = [sheetId, 0, j].join(sep);
				var found = data[id];
				if(found) {
					found[3].hidden = true;
				} else {
					this.newRecord(sheetId, 0, j, {
						hidden: true
					});
				}
				this.syncColWidthCache(sheetId, j);
			}
		}
	},
	syncRowHiddens: function(sheetId, json) {
		var data = this.getData(),
			sep = this.separateChar,
			lookup = {};
		if(json) {
			for(var i = 0, len = json.length; i < len; i++) {
				var it = json[i];
				for(var j = it[0]; j <= it[1]; j++) {
					lookup[j] = true;
				}
			}
		}
		this.each(function(rec) {
			if(rec.data.sheet === sheetId && 0 === rec.data.col) {
				if(!lookup[rec.data.row]) {
					var id = [sheetId, rec.data.row, 0].join(sep);
					var found = data[id];
					if(found) {
						delete found[3].hidden;
						this.syncRowHeightCache(sheetId, rec.data.row);
					}
				}
			}
		}, this);
		for(var i in lookup) {
			if(lookup.hasOwnProperty(i)) {
				var id = [sheetId, i, 0].join(sep);
				var found = data[id];
				if(found) {
					found[3].hidden = true;
				} else {
					this.newRecord(sheetId, i, 0, {
						hidden: true
					});
				}
				this.syncRowHeightCache(sheetId, i);
			}
		}
	},
	saveExtraInfo: function(sheetId, extraInfo, applyWay, callback, scope) {
		var sheet = this.getSheetById(sheetId);
		if("clear" === applyWay) {
			sheet.extraInfo = Ext.encode(extraInfo);
		} else {
			var exInfo = {};
			if(sheet.extraInfo) {
				exInfo = Ext.decode(sheet.extraInfo);
			}
			Ext.apply(exInfo, extraInfo);
			sheet.extraInfo = Ext.encode(exInfo);
		}
		Ext.Ajax.request({
			url: SCONFIG.urls.updateExtraInfo,
			params: {
				sheetId: sheetId,
				extraInfo: sheet.extraInfo
			},
			callback: function(options, success, response) {
				if("true" === success || true === success) {
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, SLANG.change_saved);
					}
				} else {
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, SLANG.fail2save);
					}
				}
				if(callback) {
					callback.call(scope, success, response);
				}
			},
			scope: this
		});
	},
	getRelatedCdtCoord: function(coords) {
		var passRef = passRef || {};
		var lookup = {},
			store = this;
		var cdts = store.getConditionLookup(),
			coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var namedFuncs = [],
			tmpCoords = [];
		for(var i = 0, len = coords.length; i < len; i++) {
			var span = coords[i];
			if(Ext.isString(span)) {
				namedFuncs.push(span);
			} else {
				tmpCoords.push(span);
			}
		}
		cdts = Ext.apply({}, cdts);
		for(var i = 0, len = namedFuncs.length; i < len; i++) {
			var namedFunc = namedFuncs[i];
			for(var p in cdts) {
				if(cdts.hasOwnProperty(p) && !lookup.hasOwnProperty(p)) {
					var it = cdts[p],
						jsonObj = it.jsonObj,
						refs = it.refs;
					if("vd" !== jsonObj.name) {
						var sheetId;
						if(jsonObj.rng) {
							sheetId = jsonObj.rng[0].span[0];
						} else {
							sheetId = this.getActivedSheetId();
						}
						if(refs && -1 !== refs.indexOf(namedFunc)) {
							delete it.cache;
							lookup[p] = {
								sheet: sheetId,
								id: jsonObj.id,
								refreshWhole: true
							};
							delete cdts[p];
						}
					}
				}
			}
		}
		store.walkRange(tmpCoords, function(rec) {
			var sheetId = rec.data.sheet,
				row = rec.data.row,
				col = rec.data.col;
			var cellCoord = [sheetId, row, col];
			for(var p in cdts) {
				if(cdts.hasOwnProperty(p) && !lookup.hasOwnProperty(p)) {
					var it = cdts[p],
						jsonObj = it.jsonObj,
						refs = it.refs,
						refreshWholeCoordRefs = it.refreshWholeCoordRefs,
						relativeCoordMap = it.relativeCoordMap;
					if("vd" !== jsonObj.name) {
						if(refreshWholeCoordRefs && coordPro.isCellInCoord(cellCoord, refreshWholeCoordRefs)) {
							delete it.cache;
							lookup[p] = {
								sheet: sheetId,
								id: jsonObj.id,
								refreshWhole: true
							};
							delete cdts[p];
						} else {
							var flag = true;
							if(relativeCoordMap) {
								var arr = [];
								for(var q in relativeCoordMap) {
									if(relativeCoordMap.hasOwnProperty(q)) {
										var coordObj = relativeCoordMap[q],
											ctype = coordObj.type,
											span = coordObj.span;
										if(coordPro.isCellInSpan(cellCoord, span)) {
											flag = false;
											var range = jsonObj.rng;
											for(var i = 0, len = range.length; i < len; i++) {
												var tmpSpan = range[i].span;
												if(tmpSpan[0] === span[0]) {
													if(SCONST.ABSOLUTE_ROW_COORD === ctype) {
														if((tmpSpan[2] <= col || 0 === tmpSpan[2]) && (col <= tmpSpan[4] || 0 === tmpSpan[4])) {
															arr.push([tmpSpan[0], tmpSpan[1], col, tmpSpan[3], col]);
														}
													} else if(SCONST.ABSOLUTE_COL_COORD === ctype) {
														if((tmpSpan[1] <= row || 0 === tmpSpan[1]) && (row <= tmpSpan[3] || 0 === tmpSpan[3])) {
															arr.push([tmpSpan[0], row, tmpSpan[2], row, tmpSpan[4]]);
														}
													}
												}
											}
										}
									}
								}
								if(0 < arr.length) {
									delete it.cache;
									if(!lookup[p]) {
										lookup[p] = {
											sheet: sheetId,
											id: jsonObj.id,
											relativeCoord: arr
										};
									}
								}
							}
							if(flag && refs && coordPro.isCellInCoord(cellCoord, refs)) {
								delete it.cache;
								lookup[p] = {
									sheet: sheetId,
									id: jsonObj.id,
									refreshWhole: true
								};
								delete cdts[p];
							}
						}
					}
				}
			}
		}, this, true);
		var cdtCoord = [],
			sep = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar,
			map = {};
		for(var p in lookup) {
			if(lookup.hasOwnProperty(p)) {
				var it = lookup[p],
					id = it.id,
					sheetId = it.sheet,
					refreshWhole = it.refreshWhole,
					relativeCoord = it.relativeCoord;
				if(relativeCoord) {
					for(var i = 0, len = relativeCoord.length; i < len; i++) {
						var span = relativeCoord[i];
						var spanId = span.join(sep);
						if(!map[spanId]) {
							map[spanId] = true;
							cdtCoord.push(span);
							var tmpObj = {};
							tmpObj[it.id] = true;
							passRef[spanId] = {
								span: span,
								cdtIds: tmpObj
							};
						} else {
							passRef[spanId].cdtIds[it.id] = true;
						}
					}
				} else {
					var cdt = store.getConditionById(id, sheetId),
						name = cdt.name,
						range = cdt.rng;
					for(var i = 0, len = range.length; i < len; i++) {
						var span = range[i].span;
						if(refreshWhole) {
							var spanId = span.join(sep);
							if(!map[spanId]) {
								map[spanId] = true;
								cdtCoord.push(span);
								var tmpObj = {};
								tmpObj[it.id] = true;
								passRef[spanId] = {
									span: span,
									cdtIds: tmpObj
								};
							} else {
								passRef[spanId].cdtIds[it.id] = true;
							}
						}
					}
				}
			}
		}
		return {
			coord: cdtCoord,
			spanCdtMap: passRef
		};
	},
	getDefinedNameContent: function(name) {
		var item = this.getFileConfigById(name, "named_func");
		if(item) {
			var json = Ext.decode(item.json);
			return json;
		} else {
			item = this.getFileConfigById(name, "ref");
			if(item) {
				return Ext.decode(item.json);
			}
		}
	},
	prepareBorderPropertyForSave: function(json) {
		var obj = Ext.apply({}, json);
		obj = this.reader.reverseBorderConfig(json, obj);
		var borderStyles = EnterpriseSheet.pure.sheet.data.Store.prototype.borderStyles;
		var paddingStyles = EnterpriseSheet.pure.sheet.data.Store.prototype.paddingStyles;
		for(var i = 0, len = paddingStyles.length; i < len; i++) {
			var p = paddingStyles[i],
				q = "_" + p;
			delete obj[p];
			delete obj[q];
		}
		for(var i = 0, len = borderStyles.length; i < len; i++) {
			var p = borderStyles[i],
				q = "_" + p;
			delete obj[p];
			delete obj[q];
		}
		return obj;
	},
	getZoom: function() {
		if(!this.zoomDisabled) {
			return this.zoom || 1;
		} else {
			return 1;
		}
	},
	setZoom: function(zoom) {
		if(!this.zoomDisabled) {
			this.zoom = zoom;
		}
	},
	zoomSize: function(size, withZoom) {
		if(withZoom && !this.zoomDisabled) {
			var zoom = Ext.isNumber(withZoom) ? withZoom : this.getZoom();
			return Math.ceil(size * zoom);
		} else {
			return size;
		}
	},
	unzoomSize: function(size) {
		if(!this.zoomDisabled) {
			var zoom = this.getZoom();
			return Math.ceil(size / zoom);
		}
	},
	isTemplateSheet: function(sheetObj) {
		var sheetId = sheetObj.id,
			flag;
		this.each(function(rec) {
			if(sheetId === rec.data.sheet && 0 === rec.data.row) {
				var json = rec.data.json;
				var dcfg = json.dcfg;
				if(dcfg) {
					dcfg = Ext.decode(dcfg);
					if(dcfg) {
						flag = true;
						return false;
					}
				}
			}
		}, this);
		return flag;
	},
	getColumnTypeForSheet: function(sheetId) {
		var columnTypes = [];
		this.each(function(rec) {
			if(sheetId === rec.data.sheet && 0 === rec.data.row) {
				var json = rec.data.json;
				var dcfg = json.dcfg;
				if(dcfg) {
					dcfg = Ext.decode(dcfg);
					if(dcfg) {
						if(!Ext.isDefined(dcfg.id)) {
							dcfg.id = this.genNewColumnId();
							store.setCell(rec.data.sheet, rec.data.row, rec.data.col, {
								dcfg: Ext.encode(dcfg)
							});
						}
						columnTypes.push({
							id: dcfg.id,
							title: json.data || this.getColName(rec.data.col),
							ticon: json.itcon,
							dcfg: dcfg
						});
					}
				}
			}
		}, this);
		return columnTypes;
	},
	genNewColumnId: function() {
		return this.getUUStamp().join("-");
	},
	generateFormConfig: function(sheetId) {
		var config = {
				cols: {}
			},
			flag;
		var DTS = SCONST.validateDataType;
		this.each(function(rec) {
			var sid = rec.data.sheet,
				row = rec.data.row,
				col = rec.data.col,
				json = rec.data.json;
			if(sheetId === sid && 0 === row) {
				var dcfg = json.dcfg ? Ext.decode(json.dcfg) : undefined;
				if(dcfg) {
					if(!Ext.isDefined(dcfg.id)) {
						dcfg.id = this.genNewColumnId();
					}
					config.cols[dcfg.id] = {
						col: col,
						dcfg: dcfg,
						title: json.data || this.getColName(col)
					};
					flag = true;
				}
			}
		}, this);
		if(flag) {
			var cols = config.cols,
				arr = [];
			for(var p in cols) {
				if(cols.hasOwnProperty(p)) {
					var o = cols[p];
					arr.push(o);
				}
			}
			arr.sort(function(a, b) {
				return a.col - b.col;
			});
			config.cols = arr;
			return {
				sheetId: sheetId,
				config: config
			};
		}
	},
	addCrossRefered: function(refMeStore) {
		this.refMeStors = this.refMeStors || {};
		this.refMeStors[refMeStore.getId()] = refMeStore;
	},
	addCrossFileStoreReference: function(refName, crossFileStore) {
		var me = this;
		this.storeId2RefName = this.storeId2RefName || {};
		this.storeId2RefName[crossFileStore.getId()] = refName;
		this.cfsRefs = this.cfsRefs || {};
		this.cfsRefs[refName] = crossFileStore;
		crossFileStore.addCrossRefered(this);
	},
	getCrossFileStoreReference: function(refName) {
		if(this.storeId2RefName) {
			return this.storeId2RefName[refName];
		}
	},
	getStoreRefName: function(store) {
		return this.storeId2RefName[store.getId()];
	},
	findStoreBySheetId: function(sheetId) {
		var lookup = this.getSheetIdLookup();
		var sheetObj = lookup[sheetId];
		if(sheetObj) {
			return {
				store: this,
				sheetObj: sheetObj
			};
		}
		if(this.cfsRefs) {
			for(var p in this.cfsRefs) {
				if(this.cfsRefs.hasOwnProperty(p)) {
					var store = this.cfsRefs[p];
					lookup = store.getSheetIdLookup();
					var sheetObj = lookup[sheetId];
					if(sheetObj) {
						return {
							store: store,
							refName: p,
							sheetObj: sheetObj
						};
					}
				}
			}
		}
	},
	isNameFnExistWithNameScope: function(name, scopeSheetId) {
		var found = this.getFileConfigById(name, "named_func");
		if(found) {
			var json = found.jsonArr;
			for(var i = 0, len = json.length; i < len; i++) {
				var it = json[i];
				if(it.scope === scopeSheetId) {
					return true;
				}
			}
		}
		return false;
	},
	isLoopRefered: function(sheetId, row, col) {
		var sep = this.separateChar,
			coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var pos = [
			[this.getId(), sheetId].join(this.crossSepChar), row, col
		];
		var cell = this.getCell(sheetId, row, col);
		var queue = [];
		if(cell.refs) {
			queue = queue.concat(cell.refs);
		}
		var flag = false;
		while(queue.length) {
			var span = queue.shift();
			this.walkRange([
				[].concat(span)
			], function(rec) {
				var json = rec.data.json,
					refs = json.refs,
					cal = json.cal;
				if(cal && refs) {
					for(var i = 0, len = refs.length; i < len; i++) {
						var sp = refs[i];
						if(coordPro.isCellInSpan(pos, sp)) {
							flag = true;
							return false;
						}
					}
					queue = queue.concat(refs);
				}
			}, this, true);
			if(flag) {
				return true;
			}
		}
		return false;
	},
	isFactorSpan: function(factor, mother, skipHidden) {
		if(skipHidden) {
			var hiddenRows = {},
				hiddenCols = {},
				sep = this.separateChar;
			var mRowSpan = mother[3] - mother[1] + 1,
				mColSpan = mother[4] - mother[2] + 1;
			var fRowSpan = factor[3] - factor[1] + 1,
				fColSpan = factor[4] - factor[2] + 1;
			for(var i = factor[1]; i <= factor[3]; i++) {
				if(!this.isVisibleRow(factor[0], i)) {
					fRowSpan--;
					hiddenRows[factor[0] + sep + i] = true;
				}
			}
			for(var i = factor[2]; i <= factor[4]; i++) {
				if(!this.isVisibleColumn(factor[0], i)) {
					fColSpan--;
					hiddenCols[factor[0] + sep + i] = true;
				}
			}
			if(mRowSpan && mColSpan && fRowSpan && fColSpan) {
				var flag = 0 == mRowSpan % fRowSpan && 0 == mColSpan % fColSpan;
				if(flag) {
					var rowProp = Math.floor(mRowSpan / fRowSpan);
					var colProp = Math.floor(mColSpan / fColSpan);
					return {
						rowSpan: fRowSpan,
						colSpan: fColSpan,
						rowProp: rowProp,
						colProp: colProp,
						hiddenRows: hiddenRows,
						hiddenCols: hiddenCols
					};
				} else {
					return {
						rowSpan: fRowSpan,
						colSpan: fColSpan,
						hiddenRows: hiddenRows,
						hiddenCols: hiddenCols
					};
				}
			}
		} else {
			var o = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.isFactorSpan(factor, mother);
			var fRowSpan = factor[3] - factor[1] + 1,
				fColSpan = factor[4] - factor[2] + 1;
			o = o || {};
			o.rowSpan = fRowSpan;
			o.colSpan = fColSpan;
			return o;
		}
	},
	skipHiddenForCoord: function(coord) {
		var arr = [];
		for(var i = 0, len = coord.length; i < len; i++) {
			var span = coord[i],
				sheetId = span[0];
			arr = arr.concat(this.splitSpanByHidden(span));
		}
		return arr;
	},
	splitSpanByHidden: function(span) {
		var sheetId = span[0],
			rvs = [],
			cvs = [],
			start = false;
		for(var r = span[1]; r <= span[3]; r++) {
			if(this.isVisibleRow(sheetId, r)) {
				if(false === start) {
					start = r;
				}
				end = r;
			} else if(false !== start) {
				rvs.push([start, end]);
				start = false;
			}
		}
		if(false !== start) {
			rvs.push([start, end]);
			start = false;
		}
		for(var c = span[2]; c <= span[4]; c++) {
			if(this.isVisibleColumn(sheetId, c)) {
				if(false === start) {
					start = c;
				}
				end = c;
			} else if(false !== start) {
				cvs.push([start, end]);
				start = false;
			}
		}
		if(false !== start) {
			cvs.push([start, end]);
			start = false;
		}
		var arr = [];
		for(var i = 0, len = rvs.length; i < len; i++) {
			var rt = rvs[i];
			for(var j = 0, count = cvs.length; j < count; j++) {
				var ct = cvs[j];
				arr.push([sheetId, rt[0], ct[0], rt[1], ct[1]]);
			}
		}
		return arr;
	}
}, function() {
	Ext.apply(EnterpriseSheet.pure.sheet.data.Store.prototype, {
		borderStyles: ["blf", "blt", "blw", "bls", "blc", "brf", "brt", "brw", "brs", "brc", "btf", "btt", "btw", "bts", "btc", "bbf", "bbt", "bbw", "bbs", "bbc", "wrap"],
		paddingStyles: ["pl", "pr", "pt", "pb", "wpr", "wpb", "woff", "hoff"],
		colProperties: {
			dcfg: true
		},
		rowProperties: {
			dcfg: true
		},
		avoidPropertiesForApply: {},
		inheritProperities: {
			comment: true,
			bgc: true,
			bg: true,
			color: true,
			ta: true,
			va: true,
			ff: true,
			fs: true,
			fz: true,
			fw: true,
			xblc: true,
			xbls: true,
			xbrc: true,
			xbrs: true,
			xbtc: true,
			xbts: true,
			xbbc: true,
			xbbs: true,
			ws: true,
			ww: true,
			ti: true,
			u: true,
			o: true,
			s: true,
			fm: true,
			it: true,
			itn: true
		}
	});
});

Ext.define("EnterpriseSheet.pure.sheet.data.DynamicRange", {
	requires: ["EnterpriseSheet.pure.sheet.data.Store"],
	constructor: function(config) {
		Ext.apply(this, config);
		var store = this.sheet.getStore();
		store.on({
			scope: this,
			createfloatingitem: this.onCreateFloatingItem,
			prepareafterload: this.onPrepareAfterLoad,
			processfloating: this.onProcessFloating,
			holdremoverow: this.holdRemoveRow,
			holdremovecolumn: this.holdRemoveColumn,
			holdremovecell: this.holdRemoveCell,
			holdinsertrow: this.holdInsertRow,
			holdinsertcolumn: this.holdInsertColumn,
			holdinsertcell: this.holdInsertCell
		});
		this.sheet.on("insertdynamicrange", this.onInsertDynamicRange, this);
		this.sheet.on("deletedynamicrange", this.onDeleteDynamicRange, this)
	},
	onProcessFloating: function(it) {
		if("dynamicRange" === it.ftype && it.json && !it.jsonObj) {
			it.jsonObj = Ext.decode(it.json)
		}
	},
	onCreateFloatingItem: function(it) {
		if("dynamicRange" === it.ftype) {
			this.sheet.fireEvent("createdynamicrange", it, this, this.sheet);
			var cache = this.processDynamicRange(it);
			this.sheet.fireEvent("afterprocessdynamicrange", it, cache, this, this.sheet)
		}
	},
	holdRemoveRow: function(sheetId, minrow, maxrow, deleted, merged, store) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			dspan = maxrow - minrow + 1;
		if(store.floatings) {
			for(var p in store.floatings) {
				if(store.floatings.hasOwnProperty(p)) {
					var it = store.floatings[p];
					if("dynamicRange" === it.ftype) {
						var jsonObj = it.jsonObj,
							sid = it.sheet,
							arr = jsonObj.span,
							type = jsonObj.type;
						if(sheetId === sid && jsonObj.span && this._curProcessingDynamicRange !== it.name) {
							var changed = false;
							var oldEndRow = arr[3];
							if(minrow < arr[1]) {
								if(maxrow >= arr[1]) {
									arr[1] = minrow
								} else {
									arr[1] -= dspan
								}
								if(0 !== arr[3]) {
									arr[3] -= dspan
								}
								changed = true
							} else {
								if(minrow <= arr[3]) {
									if(maxrow > arr[3]) {
										arr[3] = minrow - 1
									} else {
										arr[3] -= dspan
									}
									changed = true
								}
							}
							if(changed) {
								if(arr[1] > arr[3] && 0 !== oldEndRow) {
									arr[1] = arr[3]
								}
								store.setFloatingItem(sheetId, it.name, it.ftype, Ext.encode(jsonObj))
							}
						}
					}
				}
			}
		}
	},
	holdRemoveColumn: function(sheetId, mincol, maxcol, deleted, merged, store) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			dspan = maxcol - mincol + 1;
		if(store.floatings) {
			for(var p in store.floatings) {
				if(store.floatings.hasOwnProperty(p)) {
					var it = store.floatings[p];
					if("dynamicRange" === it.ftype) {
						var jsonObj = it.jsonObj,
							sid = it.sheet,
							arr = jsonObj.span,
							type = jsonObj.type;
						if(sheetId === sid && jsonObj.span && this._curProcessingDynamicRange !== it.name) {
							var changed = false;
							var oldEndCol = arr[4];
							if(mincol < arr[2]) {
								if(maxcol >= arr[2]) {
									arr[2] = mincol
								} else {
									arr[2] -= dspan
								}
								if(0 !== arr[4]) {
									arr[4] -= dspan
								}
								changed = true
							} else {
								if(mincol <= arr[4]) {
									if(maxcol > arr[4]) {
										arr[4] = mincol - 1
									} else {
										arr[4] -= dspan
									}
									changed = true
								}
							}
							if(changed) {
								if(arr[2] > arr[4] && 0 !== oldEndCol) {
									arr[2] = arr[4]
								}
								store.setFloatingItem(sheetId, it.name, it.ftype, Ext.encode(jsonObj))
							}
						}
					}
				}
			}
		}
	},
	holdRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			colSpan = maxcol - mincol + 1,
			rowSpan = maxrow - minrow + 1;
		if(store.floatings) {
			for(var p in store.floatings) {
				if(store.floatings.hasOwnProperty(p)) {
					var it = store.floatings[p];
					if("dynamicRange" === it.ftype) {
						var jsonObj = it.jsonObj,
							sid = it.sheet,
							arr = jsonObj.span,
							type = jsonObj.type;
						var oldSpan = [].concat(arr);
						if(sheetId === sid && jsonObj.span && this._curProcessingDynamicRange !== it.name) {
							var changed = false;
							var oldEndRow = arr[3],
								oldEndCol = arr[4];
							if("left" == moveDir) {
								if(minrow <= arr[1] && arr[3] <= maxrow) {
									if(mincol < arr[2]) {
										if(maxcol >= arr[2]) {
											arr[2] = mincol
										} else {
											arr[2] -= colSpan
										}
										if(0 !== arr[4]) {
											arr[4] -= colSpan
										}
										changed = true
									} else {
										if(mincol <= arr[4]) {
											if(maxcol > arr[4]) {
												arr[4] = mincol - 1
											} else {
												arr[4] -= colSpan
											}
											changed = true
										}
									}
								}
							} else {
								if(mincol <= arr[2] && arr[4] <= maxcol) {
									if(minrow < arr[1]) {
										if(maxrow >= arr[1]) {
											arr[1] = minrow
										} else {
											arr[1] -= rowSpan
										}
										if(0 !== arr[3]) {
											arr[3] -= rowSpan
										}
										changed = true
									} else {
										if(minrow <= arr[3]) {
											if(maxrow > arr[3]) {
												arr[3] = minrow - 1
											} else {
												arr[3] -= rowSpan
											}
											changed = true
										}
									}
								}
							}
							if(changed) {
								if(arr[2] > arr[4] && 0 !== oldEndCol) {
									arr[4]++;
									arr[2] = arr[4];
									if(arr[2] === oldSpan[2] && arr[4] === oldSpan[4]) {
										changed = false
									}
								} else {
									if(arr[1] > arr[3] && 0 !== oldEndRow) {
										arr[3]++;
										arr[1] = arr[3];
										if(arr[1] === oldSpan[1] && arr[3] === oldSpan[3]) {
											changed = false
										}
									}
								}
								if(changed) {
									store.setFloatingItem(sheetId, it.name, it.ftype, Ext.encode(jsonObj))
								}
							}
						}
					}
				}
			}
		}
	},
	holdInsertRow: function(sheetId, minrow, rowSpan, merged, store, insertCellCache) {
		var sheet = this.sheet,
			store = sheet.getStore();
		if(store.floatings) {
			for(var p in store.floatings) {
				if(store.floatings.hasOwnProperty(p)) {
					var it = store.floatings[p];
					if("dynamicRange" === it.ftype && this._curProcessingDynamicRange !== it.name) {
						var jsonObj = it.jsonObj,
							sid = it.sheet,
							arr = jsonObj.span,
							type = jsonObj.type;
						if(sheetId === sid && jsonObj.span) {
							var changed = false;
							if(minrow <= arr[1]) {
								arr[1] += rowSpan;
								if(0 !== arr[3]) {
									arr[3] += rowSpan
								}
								changed = true
							} else {
								if(minrow <= arr[3]) {
									if(arr[1] == arr[3]) {
										arr[1] += rowSpan
									}
									arr[3] += rowSpan;
									changed = true
								}
							}
							if(changed) {
								store.setFloatingItem(sheetId, it.name, it.ftype, Ext.encode(jsonObj))
							}
						}
					}
				}
			}
		}
	},
	holdInsertColumn: function(sheetId, mincol, colSpan, merged, store, insertCellCache) {
		var sheet = this.sheet,
			store = sheet.getStore();
		if(store.floatings) {
			for(var p in store.floatings) {
				if(store.floatings.hasOwnProperty(p)) {
					var it = store.floatings[p];
					if("dynamicRange" === it.ftype && this._curProcessingDynamicRange !== it.name) {
						var jsonObj = it.jsonObj,
							sid = it.sheet,
							arr = jsonObj.span,
							type = jsonObj.type;
						if(sheetId === sid && jsonObj.span) {
							var changed = false;
							if(mincol <= arr[2]) {
								arr[2] += colSpan;
								if(0 !== arr[4]) {
									arr[4] += colSpan
								}
								changed = true
							} else {
								if(mincol <= arr[4]) {
									if(arr[2] == arr[4]) {
										arr[2] += colSpan
									}
									arr[4] += colSpan;
									changed = true
								}
							}
							if(changed) {
								store.setFloatingItem(sheetId, it.name, it.ftype, Ext.encode(jsonObj))
							}
						}
					}
				}
			}
		}
	},
	holdInsertCell: function(sheetId, minrow, mincol, rowSpan, colSpan, moveDir, merged, store, insertCellCache) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			maxrow = minrow + rowSpan - 1,
			maxcol = mincol + colSpan - 1;
		if(store.floatings) {
			for(var p in store.floatings) {
				if(store.floatings.hasOwnProperty(p)) {
					var it = store.floatings[p];
					if("dynamicRange" === it.ftype && this._curProcessingDynamicRange !== it.name) {
						var jsonObj = it.jsonObj,
							sid = it.sheet,
							arr = jsonObj.span,
							type = jsonObj.type;
						if(sheetId === sid && jsonObj.span) {
							var changed = false;
							if("right" == moveDir) {
								if(minrow <= arr[1] && arr[3] <= maxrow) {
									if(mincol <= arr[2]) {
										arr[2] += colSpan;
										if(0 !== arr[4]) {
											arr[4] += colSpan
										}
										changed = true
									} else {
										if(mincol <= arr[4] || (this._curProcessingDynamicRange && mincol - 1 <= arr[4])) {
											arr[4] += colSpan;
											changed = true
										}
									}
								}
							} else {
								if(mincol <= arr[2] && arr[4] <= maxcol) {
									if(minrow <= arr[1]) {
										arr[1] += rowSpan;
										if(0 !== arr[3]) {
											arr[3] += rowSpan
										}
										changed = true
									} else {
										if(minrow <= arr[3] || (this._curProcessingDynamicRange && minrow - 1 <= arr[3])) {
											arr[3] += rowSpan;
											changed = true
										}
									}
								}
							}
							if(changed) {
								store.setFloatingItem(sheetId, it.name, it.ftype, Ext.encode(jsonObj))
							}
						}
					}
				}
			}
		}
	},
	onPrepareAfterLoad: function() {
		var sheet = this.sheet,
			store = sheet.getStore();
		if(store.floatings) {
			for(var p in store.floatings) {
				if(store.floatings.hasOwnProperty(p)) {
					var it = store.floatings[p];
					if("dynamicRange" === it.ftype) {
						this.processDynamicRange(it)
					}
				}
			}
		}
	},
	processDynamicRange: function(it) {
		var jsonObj = it.jsonObj,
			sheetId = it.sheet,
			name = it.name,
			span = jsonObj.span,
			type = jsonObj.type;
		var sheet = this.sheet,
			store = sheet.getStore();
		var insertCache = null;
		var dynamicFormulaArr = this.getDynamicFormulaResult(jsonObj.formula, jsonObj, sheetId, name);
		if(dynamicFormulaArr == null || !Ext.isArray(dynamicFormulaArr)) {
			return null
		}
		var dynamicRangeResult = dynamicFormulaArr[0];
		if(dynamicRangeResult && dynamicRangeResult.length > 0) {
			this._curProcessingDynamicRange = it.name;
			var newRowColNo = dynamicRangeResult.length;
			if("row" === type) {
				var rowLen = newRowColNo - (span[3] - span[1] + 1);
				insertCache = this.transfer2CellCacheForRows(rowLen, sheetId, span, name);
				sheet.fireEvent("prepareprocessdynamicrange", it, insertCache, this, sheet);
				sheet.insertCellMoveBottom(sheetId, {
					minrow: span[3] + 1,
					mincol: span[2],
					maxrow: span[3] + rowLen,
					maxcol: span[4]
				}, insertCache)
			} else {
				if("column" === type) {
					var colLen = newRowColNo - (span[4] - span[2] + 1);
					insertCache = this.transfer2CellCacheForCols(colLen, sheetId, span, name);
					sheet.fireEvent("prepareprocessdynamicrange", it, insertCache, this, sheet);
					sheet.insertCellMoveRight(sheetId, {
						minrow: span[1],
						mincol: span[4] + 1,
						maxrow: span[3],
						maxcol: span[4] + colLen
					}, insertCache)
				}
			}
			delete(this._curProcessingDynamicRange)
		}
		return insertCache
	},
	transfer2CellCacheForRows: function(rowLen, sheetId, span, name, skipStartRow) {
		var store = this.sheet.getStore(),
			calculate = this.sheet.getCalculate();
		var cache = {};
		var startRow = span[3],
			startCol = span[2],
			endCol = span[4];
		for(var i = 1; i <= rowLen; i++) {
			var rowIndex = startRow + i;
			for(var j = startCol; j <= endCol; j++) {
				var id = [sheetId, rowIndex, j].join(store.separateChar);
				var cell = store.getCell(sheetId, startRow, j, true);
				if(cell.cal) {
					var drparam = cell.drparam;
					if(drparam) {
						drparam = Ext.decode(drparam)
					} else {
						drparam = {}
					}
					var base = drparam[name] || 0;
					drparam[name] = base + i;
					cell.drparam = Ext.encode(drparam);
					Ext.apply(cell, this.sheet.getCalculate().resetData(cell, store, sheetId, rowIndex, j, sheetId, startRow, j))
				}
				delete(cell.value);
				cache[id] = {
					sheetId: sheetId,
					row: rowIndex,
					col: j,
					json: cell
				}
			}
		}
		if(!skipStartRow) {
			for(var j = startCol; j <= endCol; j++) {
				var id = [sheetId, startRow, j].join(store.separateChar);
				var cell = store.getCell(sheetId, startRow, j, true);
				if(cell.cal) {
					var old = Ext.apply({}, cell);
					var id = [sheetId, startRow, j].join(store.separateChar);
					var drparam = cell.drparam;
					if(drparam) {
						drparam = Ext.decode(drparam)
					} else {
						drparam = {}
					}
					drparam[name] = 0;
					delete(cell.value);
					cell.drparam = Ext.encode(drparam);
					cache[id] = {
						sheetId: sheetId,
						row: startRow,
						col: j,
						json: cell,
						oldJson: old
					}
				}
			}
		}
		return cache
	},
	transfer2CellCacheForCols: function(colLen, sheetId, span, name, skipStartCol) {
		var store = this.sheet.getStore();
		var cache = {};
		var startCol = span[4],
			startRow = span[1],
			endRow = span[3];
		for(var i = 1; i <= colLen; i++) {
			var colIndex = startCol + i;
			for(var j = startRow; j <= endRow; j++) {
				var id = [sheetId, j, colIndex].join(store.separateChar);
				var cell = store.getCell(sheetId, j, startCol, true);
				if(cell.cal) {
					var drparam = cell.drparam;
					if(drparam) {
						drparam = Ext.decode(drparam)
					} else {
						drparam = {}
					}
					var base = drparam[name] || 0;
					drparam[name] = base + i;
					cell.drparam = Ext.encode(drparam);
					delete(cell.value);
					Ext.apply(cell, this.sheet.getCalculate().resetData(cell, store, sheetId, j, colIndex, sheetId, j, startCol))
				}
				cache[id] = {
					sheetId: sheetId,
					row: j,
					col: colIndex,
					json: cell
				}
			}
		}
		if(!skipStartCol) {
			for(var j = startRow; j <= endRow; j++) {
				var id = [sheetId, j, colIndex].join(store.separateChar);
				var cell = store.getCell(sheetId, j, startCol, true);
				if(cell.cal) {
					var old = Ext.apply({}, cell);
					var id = [sheetId, j, startCol].join(store.separateChar);
					var drparam = cell.drparam;
					if(drparam) {
						drparam = Ext.decode(drparam)
					} else {
						drparam = {}
					}
					drparam[name] = 0;
					delete(cell.value);
					cell.drparam = Ext.encode(drparam);
					cache[id] = {
						sheetId: sheetId,
						row: j,
						col: startCol,
						json: cell,
						oldJson: old
					}
				}
			}
		}
		return cache
	},
	getDynamicFormulaResult: function(formula, obj, sheetId, name) {
		var sheet = this.sheet,
			store = sheet.getStore();
		return 1
	},
	onInsertDynamicRange: function(drJson, pos) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var sheetId = pos[0],
			row = pos[1],
			col = pos[2];
		var jsonObj = drJson.jsonObj;
		var span = jsonObj.span,
			drname = drJson.name,
			cache;
		if("row" === jsonObj.type && span[2] === col) {
			var drcells = {},
				reCals = {};
			store.each(function(rec, internalId) {
				var r = rec.data.row,
					c = rec.data.col;
				if(sheetId === rec.data.sheet && span[2] <= c && c <= span[4] && row < r) {
					var json = rec.data.json;
					if(json.drparam) {
						var drparam = Ext.decode(json.drparam);
						if(drparam[drname]) {
							var old = Ext.apply({}, json);
							drparam[drname]++;
							var cur = Ext.apply({}, json);
							cur.drparam = Ext.encode(drparam);
							drcells[internalId] = {
								sheetId: sheetId,
								row: r,
								col: c,
								oldJson: old,
								json: cur
							};
							reCals[internalId] = [sheetId, r, c]
						}
					}
				}
			}, this);
			sheet.fireEvent("prepareinsertdynamicrangerow", pos, drcells, reCals, sheet);
			for(var p in drcells) {
				if(drcells.hasOwnProperty(p)) {
					var it = drcells[p];
					store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear")
				}
			}
			sheet.refreshCalCdt(reCals);
			cache = this.transfer2CellCacheForRows(1, sheetId, [span[0], row, span[2], row, span[4]], drname, true);
			row++;
			sheet.insertCellMoveBottom(sheetId, {
				minrow: row,
				maxrow: row,
				mincol: span[2],
				maxcol: span[4]
			}, cache);
			sheet.fireEvent("insertdynamicrangerow", pos, drcells, reCals, sheet)
		} else {
			if("column" === jsonObj.type && span[1] === row) {
				var drcells = {},
					reCals = {};
				store.each(function(rec, internalId) {
					var r = rec.data.row,
						c = rec.data.col;
					if(sheetId === rec.data.sheet && span[1] <= r && r <= span[3] && col < c) {
						var json = rec.data.json;
						if(json.drparam) {
							var drparam = Ext.decode(json.drparam);
							if(drparam[drname]) {
								var old = Ext.apply({}, json);
								drparam[drname]++;
								var cur = Ext.apply({}, json);
								cur.drparam = Ext.encode(drparam);
								drcells[internalId] = {
									sheetId: sheetId,
									row: r,
									col: c,
									oldJson: old,
									json: cur
								};
								reCals[internalId] = [sheetId, r, c]
							}
						}
					}
				}, this);
				sheet.fireEvent("prepareinsertdynamicrangecol", pos, drcells, reCals, sheet);
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear")
					}
				}
				sheet.refreshCalCdt(reCals);
				cache = this.transfer2CellCacheForCols(1, sheetId, [span[0], span[1], col, span[3], col], drname, true);
				col++;
				sheet.insertCellMoveRight(sheetId, {
					minrow: span[1],
					maxrow: span[3],
					mincol: col,
					maxcol: col
				}, cache);
				sheet.fireEvent("insertdynamicrangecol", pos, drcells, reCals, sheet)
			}
		}
		var drIndex;
		for(var p in cache) {
			if(cache.hasOwnProperty(p)) {
				var cell = cache[p];
				var drparam = cell.json.drparam;
				if(drparam) {
					drparam = Ext.decode(drparam);
					if(!SCOM.isEmptyValue(drparam[drname])) {
						drIndex = drparam[drname];
						break
					}
				}
			}
		}
		sheet.fireEvent("afterinsertdynamicrange", drJson, pos, drIndex, sheet)
	},
	onDeleteDynamicRange: function(drJson, pos) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var sheetId = pos[0],
			row = pos[1],
			col = pos[2];
		var jsonObj = drJson.jsonObj;
		var span = jsonObj.span,
			drname = drJson.name,
			drIndex = undefined;
		if("row" === jsonObj.type && span[2] === col) {
			var drcells = {},
				reCals = {};
			store.each(function(rec, internalId) {
				var r = rec.data.row,
					c = rec.data.col;
				if(sheetId === rec.data.sheet && span[2] <= c && c <= span[4]) {
					if(row < r) {
						var json = rec.data.json;
						if(json.drparam) {
							var drparam = Ext.decode(json.drparam);
							if(drparam[drname]) {
								var old = Ext.apply({}, json);
								drparam[drname]--;
								var cur = Ext.apply({}, json);
								cur.drparam = Ext.encode(drparam);
								drcells[internalId] = {
									sheetId: sheetId,
									row: r,
									col: c,
									oldJson: old,
									json: cur
								};
								reCals[internalId] = [sheetId, r, c]
							}
						}
					} else {
						if(row === r) {
							if(undefined === drIndex) {
								var json = rec.data.json;
								if(json.drparam) {
									var drparam = Ext.decode(json.drparam);
									if(drparam.hasOwnProperty(drname)) {
										drIndex = drparam[drname]
									}
								}
							}
						}
					}
				}
			}, this);
			sheet.fireEvent("preparedeletedynamicrangerow", pos, drcells, reCals, sheet);
			for(var p in drcells) {
				if(drcells.hasOwnProperty(p)) {
					var it = drcells[p];
					store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear")
				}
			}
			sheet.refreshCalCdt(reCals);
			this.sheet.deleteCellMoveTop(sheetId, {
				minrow: row,
				maxrow: row,
				mincol: span[2],
				maxcol: span[4]
			});
			sheet.fireEvent("deletedynamicrangerow", pos, drcells, reCals, sheet)
		} else {
			if("column" === jsonObj.type && span[1] === row) {
				var drcells = {},
					reCals = {};
				store.each(function(rec, internalId) {
					var r = rec.data.row,
						c = rec.data.col;
					if(sheetId === rec.data.sheet && span[1] <= r && r <= span[3]) {
						if(col < c) {
							var json = rec.data.json;
							if(json.drparam) {
								var drparam = Ext.decode(json.drparam);
								if(drparam[drname]) {
									var old = Ext.apply({}, json);
									drparam[drname]--;
									var cur = Ext.apply({}, json);
									cur.drparam = Ext.encode(drparam);
									drcells[internalId] = {
										sheetId: sheetId,
										row: r,
										col: c,
										oldJson: old,
										json: cur
									};
									reCals[internalId] = [sheetId, r, c]
								}
							}
						} else {
							if(col === c) {
								if(undefined === drIndex) {
									var json = rec.data.json;
									if(json.drparam) {
										var drparam = Ext.decode(json.drparam);
										if(drparam.hasOwnProperty(drname)) {
											drIndex = drparam[drname]
										}
									}
								}
							}
						}
					}
				}, this);
				sheet.fireEvent("preparedeletedynamicrangecol", pos, drcells, reCals, sheet);
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear")
					}
				}
				sheet.refreshCalCdt(reCals);
				this.sheet.deleteCellMoveLeft(sheetId, {
					minrow: span[1],
					maxrow: span[3],
					mincol: col,
					maxcol: col
				});
				sheet.fireEvent("deletedynamicrangecol", pos, drcells, reCals, sheet)
			}
		}
		sheet.fireEvent("afterdeletedynamicrange", drJson, pos, drIndex, sheet)
	}
}, function() {
	var pro = EnterpriseSheet.pure.sheet.data.DynamicRange.prototype;
	pro.dynamicFormulaLookup = {};
	pro.addDynamicFormula = function(name, fn) {
		pro.dynamicFormulaLookup[name] = fn
	};
	EnterpriseSheet.pure.sheet.data.Store.prototype.avoidPropertiesForApply.drheader = true
});

Ext.define("EnterpriseSheet.pure.sheet.data.PullingStore", {
	extend: "EnterpriseSheet.pure.sheet.data.Store",
	pullingBuffer: 500,
	repullingDefer: 1000,
	limitActionNum: 1000,
	constructor: function() {
		var avoidProperty = ["ow", "oah", "oh", "owf", "ohf", "ofz", "hidden", "plain", "pending", "value", "valId", "arg", "cdt", "mid", "minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol", "display", "refs", "cdtVal", "lastVal", "timestamp"].concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.styles).concat(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.calGeneratedStyles);
		var o = {};
		for(var i = 0, len = avoidProperty.length; i < len; i++) {
			o[avoidProperty[i]] = true;
		}
		this.avoidSaveProperty = o;
		this.initActionQueue();
		EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.constructor.apply(this, arguments);
		this.on("pullingaction", this.doPulling, this, {
			buffer: this.pullingBuffer
		});
		this.on({
			scope: this,
			beforeholdremovecolumn: this.onRemoveColumn,
			beforeholdinsertcolumn: this.onInsertColumn,
			beforeholdremoverow: this.onRemoveRow,
			beforeholdinsertrow: this.onInsertRow,
			beforeholdremovecell: this.onRemoveCell,
			beforeholdinsertcell: this.onInsertCell,
			createfloatingitem: this.createFloatingItem,
			updatefloatingitem: this.updateFloatingItem,
			removefloatingitem: this.removeFloatingItem,
			createfileconfig: this.createFileConfig,
			updatefileconfig: this.updateFileConfig,
			removefileconfig: this.removeFileConfig,
			savejsonfile: this.afterSaveJsonFile
		});
	},
	afterSaveJsonFile: function() {
		this.initActionQueue(true);
	},
	initActionQueue: function(skipCheck) {
		if(this.actionQueue && !skipCheck) {
			this.checkSortOrMoveActions(this.actionQueue);
		}
		this.actionQueue = [];
	},
	checkSortOrMoveActions: function(tmp) {
		for(var i = 0, len = tmp.length; i < len; i++) {
			var it = tmp[i],
				action = it.action;
			if("sortSpan" === action || "moveRows" === action) {
				this.fireEvent("pullsortormove", it, this);
				return;
			}
		}
	},
	shiftActionQueue: function() {
		var len = this.actionQueue.length,
			lookup = {},
			sep = this.separateChar,
			startIndex = endIndex = false;
		for(var i = index = 0; i < len; i++) {
			var it = this.actionQueue[index];
			if("setCell" === it.action) {
				if(false === startIndex) {
					startIndex = index;
				}
				endIndex = index;
				var id = [it.sheetId, it.row, it.col].join(sep);
				lookup[id] = it;
			} else if(false !== startIndex) {
				var count = endIndex - startIndex + 1;
				this.actionQueue.splice(startIndex, count);
				for(var p in lookup) {
					if(lookup.hasOwnProperty(p)) {
						count--;
						this.actionQueue.splice(startIndex, 0, lookup[p]);
						startIndex++;
					}
				}
				index -= count;
				startIndex = false;
			}
			index++;
		}
		if(false !== startIndex) {
			var count = endIndex - startIndex + 1;
			this.actionQueue.splice(startIndex, count);
			for(var p in lookup) {
				if(lookup.hasOwnProperty(p)) {
					this.actionQueue.splice(startIndex, 0, lookup[p]);
					startIndex++;
				}
			}
		}
		len = this.actionQueue.length;
		if(len <= this.limitActionNum) {
			var tmp = this.actionQueue;
			this.initActionQueue(true);
			return tmp;
		} else {
			var tmp = this.actionQueue.splice(0, this.limitActionNum);
			return tmp;
		}
	},
	unshiftActionQueue: function(arr) {
		this.actionQueue.unshift.apply(this.actionQueue, arr);
	},
	doPulling: function(store) {
		this.pullingAction();
	},
	isPulling: function() {
		return this._pullingFlag;
	},
	lockPulling: function() {
		this._pullingFlag = true;
	},
	unlockPulling: function() {
		delete this._pullingFlag;
	},
	isEmptyQueue: function() {
		return 0 === this.actionQueue.length || this.isDisabledPulling();
	},
	isDisabledPulling: function() {
		return this.disabledPulling || SCOM.nullOrUndefined(this.fileId);
	},
	pullingAction: function(callback, scope) {
		var me = this;
		if(this.isDisabledPulling()) {
			this.initActionQueue();
			if(callback) {
				callback.call(scope || me);
			}
			return;
		}
		var isEmpty = this.isEmptyQueue();
		if(this.isPulling()) {
			if(!isEmpty) {
				Ext.Function.defer(function() {
					me.pullingAction(callback, scope);
				}, me.repullingDefer, me);
			}
		} else {
			if(!isEmpty) {
				if(this.isViewOnlyFile()) {
					this.initActionQueue();
					return;
				}
				this.lockPulling();
				var afterPulled = function() {
					me.checkSeverStatus();
					me.fireEvent("pull", me);
					if(callback) {
						callback.call(scope || me);
					}
					me.unlockPulling();
					if(!me.isEmptyQueue()) {
						me.fireEvent("pullingaction", me);
					} else {
						me.fireEvent("pullover", me);
					}
				};
				var pendingActions = this.shiftActionQueue();
				var requestPullFn = function() {
					me.fireEvent("preparepull", me, pendingActions);
					var actions = Ext.encode(pendingActions);
					var params = {
						fileId: me.fileId,
						actions: actions
					};
					Ext.Ajax.request({
						url: SCONFIG.urls.update,
						params: params,
						success: function(response, options) {
							var json = Ext.decode(response.responseText),
								success = json.success;
							if(true == success || "true" == success) {
								me.checkSortOrMoveActions(pendingActions);
								me.fireEvent("pullsaved", pendingActions, me);
								afterPulled();
							} else {
								me.serverFailureAction = {
									action: "pullAction",
									pendingActions: pendingActions
								};
								me.processServerFailure(response);
							}
						},
						failure: function(response) {
							me.serverFailureAction = {
								action: "pullAction",
								pendingActions: pendingActions
							};
							if("disconnected" !== me.processServerFailure(response)) {
								afterPulled();
							}
						},
						scope: scope || me
					});
				};
				if(false !== this.fireEvent("beforepull", pendingActions, requestPullFn, this)) {
					requestPullFn();
				}
			} else if(callback) {
				callback.call(scope || me);
			}
		}
	},
	getActionQueue: function() {
		return this.actionQueue;
	},
	merge2ActionQueue: function(arr) {
		if(!this.actionQueue) {
			this.actionQueue = [];
		}
		this.actionQueue = arr.concat(this.actionQueue);
	},
	addAction2Queue: function(act, suspendAddEvent) {
		if(this.suspendAddActionFlag) {
			return true;
		}
		var len = this.actionQueue.length;
		var skip = false,
			repeated = false;
		if(0 < len) {
			var i = len - 1;
			var last = this.actionQueue[i],
				lastAction = last.action;
			if("removeRow" == lastAction || "insertRow" == lastAction || "removeColumn" == lastAction || "insertColumn" == lastAction || "removeCell" == lastAction || "insertCell" == lastAction || "sortSpan" == lastAction || "moveRows" == lastAction) {} else if("setCell" == act.action) {
				if(last.action == act.action && last.sheetId == act.sheetId && last.row == act.row && last.col == act.col) {
					this.actionQueue.splice(i, 1);
					repeated = true;
				}
			} else if("updateFloatingItem" == act.action) {
				if(last.sheetId == act.sheetId && last.name == act.name) {
					if(last.action == act.action) {
						this.actionQueue.splice(i, 1);
						repeated = true;
					} else if("createFloatingItem" == last.action && last.json === act.json) {
						skip = true;
					}
				}
			} else if("updateHiddens" == act.action) {
				if(last.sheetId == act.sheetId && last.name == act.name) {
					if(last.action == act.action) {
						this.actionQueue.splice(i, 1);
						repeated = true;
					}
				}
			}
		}
		if(!skip) {
			if(SCOM.isEmptyValue(act.actionId)) {
				act.actionId = this.getUUStamp().join("-");
			}
			this.actionQueue.push(act);
		}
		if(!suspendAddEvent) {
			this.fireEvent("afteraddaction", act, {
				skip: skip,
				repeated: repeated
			}, this);
		}
		this.fireEvent("pullingaction", this);
		return skip;
	},
	premarkActionPos: function() {
		this._premarkPos = this.actionQueue.length;
	},
	getAffectedAction: function() {
		if(Ext.isNumber(this._premarkPos)) {
			var cells = [],
				floatings = [],
				fileConfigs = [];
			for(var i = this._premarkPos, len = this.actionQueue.length; i < len; i++) {
				var it = this.actionQueue[i];
				if("setCell" === it.action) {
					cells.push({
						sheetId: it.sheetId,
						row: it.row,
						col: it.col,
						json: it.json,
						jsonObj: Ext.decode(it.json)
					});
				} else if("updateFloatingItem" === it.action || "createFloatingItem" === it.action || "removeFloatingItem" === it.action) {
					var obj = Ext.apply({}, it);
					obj.jsonObj = Ext.decode(obj.json);
					floatings.push(obj);
				} else if("updateFileConfig" === it.action || "createFileConfig" === it.action || "removeFileConfig" === it.action) {
					var obj = Ext.apply({}, it);
					obj.jsonObj = Ext.decode(obj.json);
					fileConfigs.push(obj);
				}
			}
			delete this._premarkPos;
			return {
				cells: cells,
				floatings: floatings,
				fileConfigs: fileConfigs
			};
		}
	},
	hideRow: function(sheet, minrow, maxrow, suspendEvent, suspendPull) {
		var res = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.hideRow.apply(this, arguments);
		if(!suspendPull) {
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheet,
				name: "rowHiddens",
				ftype: "row",
				json: Ext.encode(this.getRowHiddens(sheet))
			});
		}
		return res;
	},
	showRow: function(sheet, minrow, maxrow, suspendEvent, suspendPull) {
		var res = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.showRow.apply(this, arguments);
		if(!suspendPull) {
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheet,
				name: "rowHiddens",
				ftype: "row",
				json: Ext.encode(this.getRowHiddens(sheet))
			});
		}
		return res;
	},
	hideColumn: function(sheet, mincol, maxcol, suspendEvent, suspendPull) {
		var res = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.hideColumn.apply(this, arguments);
		if(!suspendPull) {
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheet,
				name: "colHiddens",
				ftype: "col",
				json: Ext.encode(this.getColHiddens(sheet))
			});
		}
		return res;
	},
	showColumn: function(sheet, mincol, maxcol, suspendEvent, suspendPull) {
		var res = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.showColumn.apply(this, arguments);
		if(!suspendPull) {
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheet,
				name: "colHiddens",
				ftype: "col",
				json: Ext.encode(this.getColHiddens(sheet))
			});
		}
		return res;
	},
	syncRowHiddens: function(sheetId, json, suspendPull) {
		var res = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.syncRowHiddens.apply(this, arguments);
		if(!suspendPull) {
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheetId,
				name: "rowHiddens",
				ftype: "row",
				json: Ext.encode(this.getRowHiddens(sheetId))
			});
		}
		return res;
	},
	syncColHiddens: function(sheetId, json, suspendPull) {
		var res = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.syncColHiddens.apply(this, arguments);
		if(!suspendPull) {
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheetId,
				name: "colHiddens",
				ftype: "col",
				json: Ext.encode(this.getColHiddens(sheetId))
			});
		}
		return res;
	},
	setCell: function(sheet, row, col, modified, deleted, suspendEvent, applyWay, skipPulling) {
		row = Number(row);
		col = Number(col);
		var res = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.setCell.apply(this, arguments);
		if(res) {
			var origin = res[0] || {},
				current = res[1] || {};
			var raw = current.data;
			if(SCOM.nullOrUndefined(raw)) {
				raw = "";
			}
			if(!skipPulling) {
				this.checkMergeProperty(sheet, row, col, origin, current, skipPulling);
			}
			for(var p in origin) {
				if(origin.hasOwnProperty(p) && this.avoidSaveProperty.hasOwnProperty(p)) {
					delete origin[p];
				}
			}
			if(origin.tpl) {
				var tpl = Ext.decode(origin.tpl);
				if(tpl.span[1] !== row || tpl.span[2] !== col) {
					delete origin.tpl;
				}
			}
			for(var p in current) {
				if(current.hasOwnProperty(p) && this.avoidSaveProperty.hasOwnProperty(p)) {
					delete current[p];
				}
			}
			if(current.tpl) {
				var tpl = Ext.decode(current.tpl);
				if(tpl.span[1] !== row || tpl.span[2] !== col) {
					delete current.tpl;
				}
			}
			var originStr = Ext.encode(origin),
				currentStr = Ext.encode(current),
				add2Pull;
				
			if(originStr !== currentStr) {
				if(!skipPulling) {
					var obj = this.prepareBorderPropertyForSave(current);
					this.avoidEmptyAndDefaultProperty(obj);
					var objStr = Ext.encode(obj);
					if(objStr !== originStr) {
						//2018 3.30 zdw 增加公式结算的结果到上传数据中
						var store =SHEET_API_HD.sheet.getStore();
						var cell =  store.getCellData(sheet, row, col);
						var calvalue  = cell.value;
						this.addAction2Queue({
							action: "setCell",
							sheetId: sheet,
							row: row,
							col: col,
							cal: current.cal || false,
							data: raw,
							json: objStr,
							calvalue:calvalue
						});
						this.fireEvent("setcell2update", origin, current, this, sheet, row, col);
						add2Pull = true;
					}
				}
				this.fireEvent("aftercellchange", modified, deleted, origin, current, this, sheet, row, col);
			}
			res.push(add2Pull);
			if(originStr !== currentStr || res[3]) {
				this.fireEvent("aftersetcellforpull", sheet, row, col, res, this);
			}
			return res;
		}
	},
	checkMergeProperty: function(sheet, row, col, origin, current) {
		var sep = this.separateChar,
			abMinRow, abMinCol, abMaxRow, abMaxCol;
		var isCurMerged = !SCOM.isEmptyValue(current.minrow),
			isOrgMerged = !SCOM.isEmptyValue(origin.minrow);
		if(isCurMerged) {
			abMinRow = current.minrow + row;
			abMaxRow = current.maxrow + row;
			abMinCol = current.mincol + col;
			abMaxCol = current.maxcol + col;
		}
		if((isCurMerged || isOrgMerged) && (origin.abminrow !== abMinRow || origin.abmincol !== abMinCol || origin.abmaxrow !== abMaxRow || origin.abmaxcol !== abMaxCol)) {
			if(!SCOM.isEmptyValue(origin.abminrow)) {
				var minrow = origin.abminrow;
				var mincol = origin.abmincol;
				var maxrow = origin.abmaxrow;
				var maxcol = origin.abmaxcol;
				var oid = [sheet, minrow, mincol, maxrow, maxcol].join(sep);
				this.setFloatingItem(sheet, oid, "meg");
			}
			if(!SCOM.isEmptyValue(current.minrow)) {
				var oid = [sheet, abMinRow, abMinCol, abMaxRow, abMaxCol].join(sep);
				if(!this.getFloatingById(oid, sheet)) {
					var merge = [abMinRow, abMinCol, abMaxRow, abMaxCol];
					this.setFloatingItem(sheet, oid, "meg", Ext.encode(merge));
				}
			}
		}
		if(isCurMerged) {
			var json = this.getCell(sheet, row, col);
			Ext.apply(json, {
				abminrow: abMinRow,
				abmincol: abMinCol,
				abmaxrow: abMaxRow,
				abmaxcol: abMaxCol
			});
		}
	},
	load: function() {
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.load;
		if(0 < this.actionQueue.length) {
			var args = arguments;
			this.pullingAction(function() {
				callParent.apply(this, args);
			}, this);
		} else {
			return callParent.apply(this, arguments);
		}
	},
	afterLoad: function() {
		this.initActionQueue();
		return EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.afterLoad.apply(this, arguments);
	},
	onRemoveColumn: function(sheetId, mincol, maxcol, deleted, merged) {
		this.addAction2Queue({
			action: "removeColumn",
			fileId: this.fileId,
			sheetId: sheetId,
			mincol: mincol,
			maxcol: maxcol
		});
		this.checkMergedAfterDelete(merged, [sheetId, 0, mincol, 0, maxcol]);
		this.addAction2Queue({
			action: "updateHiddens",
			fileId: this.fileId,
			sheetId: sheetId,
			name: "colHiddens",
			ftype: "col",
			from: "removeColumn",
			json: Ext.encode(this.getColHiddens(sheetId))
		});
	},
	onInsertColumn: function(sheetId, col, colSpan) {
		this.addAction2Queue({
			action: "insertColumn",
			fileId: this.fileId,
			sheetId: sheetId,
			col: col,
			colSpan: colSpan
		});
		this.addAction2Queue({
			action: "updateHiddens",
			fileId: this.fileId,
			sheetId: sheetId,
			name: "colHiddens",
			ftype: "col",
			from: "insertColumn",
			json: Ext.encode(this.getColHiddens(sheetId))
		});
	},
	onRemoveRow: function(sheetId, minrow, maxrow, deleted, merged) {
		this.addAction2Queue({
			action: "removeRow",
			fileId: this.fileId,
			sheetId: sheetId,
			minrow: minrow,
			maxrow: maxrow
		});
		this.checkMergedAfterDelete(merged, [sheetId, minrow, 0, maxrow, 0]);
		this.addAction2Queue({
			action: "updateHiddens",
			fileId: this.fileId,
			sheetId: sheetId,
			name: "rowHiddens",
			ftype: "row",
			from: "removeRow",
			json: Ext.encode(this.getRowHiddens(sheetId))
		});
	},
	onInsertRow: function(sheetId, row, rowSpan) {
		this.addAction2Queue({
			action: "insertRow",
			fileId: this.fileId,
			sheetId: sheetId,
			row: row,
			rowSpan: rowSpan
		});
		this.addAction2Queue({
			action: "updateHiddens",
			fileId: this.fileId,
			sheetId: sheetId,
			name: "rowHiddens",
			ftype: "row",
			from: "insertRow",
			json: Ext.encode(this.getRowHiddens(sheetId))
		});
	},
	onRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged) {
		this.addAction2Queue({
			action: "removeCell",
			fileId: this.fileId,
			sheetId: sheetId,
			minrow: minrow,
			maxrow: maxrow,
			mincol: mincol,
			maxcol: maxcol,
			moveDir: moveDir
		});
		this.checkMergedAfterDelete(merged, [sheetId, minrow, mincol, maxrow, maxcol]);
	},
	checkMergedAfterDelete: function(merged, span) {
		var sep = this.separateChar;
		var deleted = [],
			sheetId = span[0];
		for(var p in merged) {
			if(merged.hasOwnProperty(p)) {
				var it = merged[p];
				if((0 === span[3] || span[1] <= it.minrow && span[3] >= it.minrow && span[1] <= it.maxrow && span[3] >= it.maxrow) && (0 === span[4] || span[2] <= it.mincol && span[4] >= it.mincol && span[2] <= it.maxcol && span[4] >= it.maxcol)) {
					deleted.push([sheetId, it.minrow, it.mincol, it.maxrow, it.maxcol].join(sep));
				}
			}
		}
		for(var i = 0, len = deleted.length; i < len; i++) {
			this.setFloatingItem(sheetId, deleted[i], "meg");
		}
	},
	onInsertCell: function(sheetId, row, col, rowSpan, colSpan, moveDir) {
		this.addAction2Queue({
			action: "insertCell",
			fileId: this.fileId,
			sheetId: sheetId,
			row: row,
			rowSpan: rowSpan,
			col: col,
			colSpan: colSpan,
			moveDir: moveDir
		});
	},
	sortSpan: function(span, keys, dir, sortOn, expand, allString, suspendEvent, suspendPull) {
		sortOn = sortOn || "col";
		var diff = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.sortSpan.apply(this, arguments);
		if(diff && !suspendPull) {
			var it = {
				action: "sortSpan",
				fileId: this.fileId,
				span: span,
				diff: diff,
				sortOn: sortOn,
				expand: expand,
				allString: allString
			};
			this.addAction2Queue(it);
			this.fireEvent("addsortormove", it, this);
			var sheetId = span[0];
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheetId,
				name: "rowHiddens",
				ftype: "row",
				json: Ext.encode(this.getRowHiddens(sheetId))
			});
		}
		return diff;
	},
	moveRows: function(sheetId, diff, mincol, maxcol, keyAsSource, suspendPull) {
		EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.moveRows.apply(this, arguments);
		if(!suspendPull) {
			var it = {
				action: "moveRows",
				fileId: this.fileId,
				sheetId: sheetId,
				diff: diff,
				mincol: mincol,
				maxcol: maxcol,
				keyAsSource: keyAsSource
			};
			this.addAction2Queue(it);
			this.fireEvent("addsortormove", it, this);
			this.addAction2Queue({
				action: "updateHiddens",
				fileId: this.fileId,
				sheetId: sheetId,
				name: "rowHiddens",
				ftype: "row",
				json: Ext.encode(this.getRowHiddens(sheetId))
			});
		}
	},
	createFloatingItem: function(floatingItem) {
		this.addAction2Queue({
			action: "createFloatingItem",
			fileId: this.fileId,
			sheetId: floatingItem.sheet,
			name: floatingItem.name,
			ftype: floatingItem.ftype,
			json: floatingItem.json
		});
	},
	updateFloatingItem: function(floatingItem) {
		this.addAction2Queue({
			action: "updateFloatingItem",
			fileId: this.fileId,
			sheetId: floatingItem.sheet,
			name: floatingItem.name,
			ftype: floatingItem.ftype,
			json: floatingItem.json
		});
	},
	removeFloatingItem: function(floatingItem) {
		this.addAction2Queue({
			action: "removeFloatingItem",
			fileId: this.fileId,
			sheetId: floatingItem.sheet,
			name: floatingItem.name,
			ftype: floatingItem.ftype
		});
	},
	setActivedSheetId: function(sheetId) {
		var ret = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.setActivedSheetId.apply(this, arguments);
		var oldActivedId, activedId;
		if(ret[0]) {
			oldActivedId = ret[0].id;
		}
		if(ret[1]) {
			activedId = ret[1].id;
		}
		var obj = {
			action: "setActivedSheet",
			fileId: this.fileId,
			activedSheetId: activedId
		};
		if(oldActivedId) {
			obj.preActivedSheetId = oldActivedId;
		}
		this.addAction2Queue(obj);
		return ret;
	},
	hideSheet: function(sheetId, callback, scope, skipPull, suspendEvent) {
		if(!suspendEvent) {
			this.fireEvent("beforehidesheet", sheetId, this);
		}
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.superclass.hideSheet;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.updateSheetTab,
			params: {
				sheetId: sheetId,
				hidden: true
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(true === json.success || "true" === json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "hideSheet",
						sheetId: sheetId,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					Ext.Msg.alert(SLANG.hint, json.info);
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "hideSheet",
					sheetId: sheetId,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	showSheet: function(sheetId, callback, scope, skipPull, suspendEvent) {
		if(!suspendEvent) {
			this.fireEvent("beforeshowsheet", sheetId, this);
		}
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.superclass.showSheet;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.updateSheetTab,
			params: {
				sheetId: sheetId,
				hidden: false
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(true === json.success || "true" === json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "showSheet",
						sheetId: sheetId,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					Ext.Msg.alert(SLANG.hint, json.info);
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "showSheet",
					sheetId: sheetId,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	addSheet: function(tabConfig, callback, scope, skipPull) {
		tabConfig = tabConfig || {};
		var tabName = tabConfig.name,
			position = tabConfig.position;
		if(tabName == undefined || tabName == null) {
			var len = this.sheets.length;
			tabName = SLANG.sheet + len;
			while(this.isExistedSheetName(tabName)) {
				len++;
				tabName = SLANG.sheet + len;
			}
			tabConfig.name = tabName;
		} else if(this.isExistedSheetName(tabName)) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.tab_name_existed);
			}
			return "name_existed";
		}
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.addSheet;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, [tabConfig, callback, scope, true]);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.createSheet,
			params: Ext.apply({
				fileId: this.fileId,
				position: this.sheets.length
			}, tabConfig),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				var sheetId = json.id;
				if(true == json.success || "true" == json.success) {
					var obj = Ext.applyIf({
						id: sheetId,
						actived: false
					}, tabConfig);
					if(Ext.isNumber(position)) {
						this.sheets.splice(position, 0, obj);
					} else {
						this.sheets.push(obj);
					}
					this.syncSheetLookup();
					if(callback) {
						callback.call(scope, obj);
					}
					this.fireEvent("addsheet", sheetId, name, this);
				} else {
					this.serverFailureAction = {
						action: "addSheet",
						tabConfig: tabConfig,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "addSheet",
					tabConfig: tabConfig,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	deleteSheet: function(sheetId, callback, scope, skipPull, suspendEvent, exParams) {
		if(!suspendEvent) {
			this.fireEvent("beforedeletesheet", sheetId, this);
		}
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.deleteSheet;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.deleteSheet,
			params: Ext.apply({
				fileId: this.fileId,
				sheetId: sheetId
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(true === json.success || "true" === json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "deleteSheet",
						sheetId: sheetId,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(callback) {
						callback.call(scope, null, false);
					}
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "deleteSheet",
					sheetId: sheetId,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
				if(callback) {
					callback.call(scope, null, false);
				}
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	renameSheet: function(sheetId, newName, callback, scope, skipPull, exParams) {
		var sheetTab = this.getSheetById(sheetId);
		if(Ext.isDefined(newName) && this.isExistedSheetName(newName) && newName !== sheetTab.name) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.cannot_rename_existed_tabname);
			}
			return "name_existed";
		}
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.renameSheet;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.renameSheet,
			params: Ext.apply({
				fileId: this.fileId,
				sheetId: sheetId,
				name: newName
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "renameSheet",
						sheetId: sheetId,
						newName: newName,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "renameSheet",
					sheetId: sheetId,
					newName: newName,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	changeSheetColor: function(sheetId, color, callback, scope, skipPull, exParams) {
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.changeSheetColor;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.changeSheetColor,
			params: Ext.apply({
				fileId: this.fileId,
				sheetId: sheetId,
				color: color
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "changeSheetColor",
						sheetId: sheetId,
						color: color,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "changeSheetColor",
					sheetId: sheetId,
					color: color,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	changeSheetWidth: function(sheetId, width, callback, scope, skipPull, exParams) {
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.changeSheetWidth;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.changeSheetWidth,
			params: Ext.apply({
				fileId: this.fileId,
				sheetId: sheetId,
				width: width
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "changeSheetWidth",
						sheetId: sheetId,
						width: width,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "changeSheetWidth",
					sheetId: sheetId,
					width: width,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	updateSheetTab: function(sheetId, config, callback, scope, skipPull) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getActivedSheetId();
		}
		var sheetTab = this.getSheetById(sheetId);
		config = config || {};
		var name = config.name;
		if(Ext.isDefined(name) && this.isExistedSheetName(name) && name !== sheetTab.name) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.cannot_rename_existed_tabname);
			}
			return "name_existed";
		}
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.updateSheetTab;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.updateSheetTab,
			params: Ext.applyIf({
				fileId: this.fileId,
				sheetId: sheetId
			}, config),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "updateSheetTab",
						sheetId: sheetId,
						config: config,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "updateSheetTab",
					sheetId: sheetId,
					config: config,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	changeSheetOrder: function(preIndex, curIndex, callback, scope, skipPull, exParams) {
		var sheet = this.getSheets()[preIndex];
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.changeSheetOrder;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.changeSheetOrder,
			params: Ext.apply({
				fileId: this.fileId,
				sheetId: sheet.id,
				prePos: preIndex,
				curPos: curIndex
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(json.success) {
					callParent.apply(this, args);
				} else {
					this.serverFailureAction = {
						action: "changeSheetOrder",
						preIndex: preIndex,
						curIndex: curIndex,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
					if(callback) {
						callback.call(scope, false);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "changeSheetOrder",
					preIndex: preIndex,
					curIndex: curIndex,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
				if(callback) {
					callback.call(scope, false);
				}
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	changeFileName: function(fileObj, callback, scope, suspendEvent, skipPull, exParams) {
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.changeFileName;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, arguments);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.changeFileName,
			params: Ext.apply({
				id: this.fileId,
				name: fileObj.fileName,
				description: fileObj.description,
				isTpl:isTplfile
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				var success = "true" == json.success || true === json.success;
				if(!success) {
					this.serverFailureAction = {
						action: "changeFileName",
						fileName: fileObj.fileName,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
					if(callback) {
						callback.call(scope, success);
					}
				} else {
					callParent.apply(this, args);
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "changeFileName",
					fileName: fileObj.fileName,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
				if(callback) {
					callback.call(scope, false);
				}
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	changeFileColor: function(fileObj, callback, scope, suspendEvent, skipPull, exParams) {
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.changeFileColor;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.changeFileColor,
			params: Ext.apply({
				id: this.fileId,
				color: fileObj.color
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				var success = "true" == json.success || true === json.success;
				if(!success) {
					this.serverFailureAction = {
						action: "changeFileColor",
						fileColor: fileObj.color,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
					if(callback) {
						callback.call(scope, success);
					}
				} else {
					callParent.apply(this, args);
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "changeFileColor",
					fileColor: fileObj.color,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
				if(callback) {
					callback.call(scope, false);
				}
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	changeFileStared: function(fileStared, callback, scope, suspendEvent, skipPull, exParams) {
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.changeFileStared;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, arguments);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.changeFileStared,
			params: Ext.apply({
				fileId: this.fileId,
				fileStared: fileStared
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				var success = "true" == json.success || true === json.success;
				if(!success) {
					this.serverFailureAction = {
						action: "changeFileStared",
						fileStared: fileStared,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
					if(callback) {
						callback.call(scope, success);
					}
				} else {
					callParent.apply(this, args);
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "changeFileStared",
					fileStared: fileStared,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
				if(callback) {
					callback.call(scope, false);
				}
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	copySheet: function(oldSheetId, newSheetName, callback, scope, newSheetId, skipPull, exParams) {
		if(this.isExistedSheetName(newSheetName)) {
			if(Ext.Msg) {
				Ext.Msg.alert(SLANG.error, SLANG.cannot_rename_existed_tabname);
			}
			return "name_existed";
		}
		var callParent = EnterpriseSheet.pure.sheet.data.PullingStore.prototype.superclass.copySheet;
		var args = arguments;
		if(this.disabledPulling || !Ext.isDefined(this.fileId) || skipPull) {
			callParent.apply(this, args);
			return;
		}
		this.lockPulling();
		Ext.Ajax.request({
			url: SCONFIG.urls.copySheet,
			params: Ext.apply({
				fileId: this.fileId,
				oldSheetId: oldSheetId,
				newSheetName: newSheetName,
				pos: this.sheets.length
			}, exParams),
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(json.success) {
					var sheetId = Number(json.id);
					var oldSheet = this.getSheetById(oldSheetId);
					var obj = Ext.applyIf({
						actived: false,
						id: sheetId,
						name: newSheetName
					}, oldSheet);
					delete obj.loadedEmptyCells;
					this.sheets.push(obj);
					this.each(function(rd) {
						if(oldSheetId == rd.data.sheet) {
							this.newRecord(sheetId, rd.data.row, rd.data.col, rd.data.json);
						}
					}, this);
					this.copyFloatings(oldSheetId, sheetId);
					this.refreshCalLookup();
					if(callback) {
						callback.call(scope, obj, this);
					}
					this.fireEvent("copysheet", sheetId, newSheetName, this);
				} else {
					this.serverFailureAction = {
						action: "copySheet",
						oldSheetId: oldSheetId,
						newSheetName: newSheetName,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					if(Ext.Msg) {
						Ext.Msg.alert(SLANG.hint, json.info);
					}
				}
				this.checkSeverStatus();
			},
			failure: function(response) {
				this.serverFailureAction = {
					action: "copySheet",
					oldSheetId: oldSheetId,
					newSheetName: newSheetName,
					callback: callback,
					scope: scope
				};
				this.processServerFailure(response);
			},
			callback: function() {
				this.unlockPulling();
			},
			scope: this
		});
	},
	createFileConfig: function(config) {
		if("tpl" !== config.source) {
			this.addAction2Queue({
				action: "createFileConfig",
				fileId: this.fileId,
				ctype: config.ctype,
				name: config.name,
				json: config.json
			});
		}
	},
	updateFileConfig: function(config) {
		if("tpl" !== config.source) {
			this.addAction2Queue({
				action: "updateFileConfig",
				fileId: this.fileId,
				ctype: config.ctype,
				name: config.name,
				json: config.json
			});
		}
	},
	removeFileConfig: function(config) {
		if("tpl" !== config.source) {
			this.addAction2Queue({
				action: "removeFileConfig",
				fileId: this.fileId,
				ctype: config.ctype,
				name: config.name
			});
		}
	},
	processServerFailure: function(response) {
		var status = response.status,
			serverFailure = this.serverFailureAction;
		if(response.request && response.request.options) {
			serverFailure.params = response.request.options.params;
		}
		if(300 <= status || 0 == status) {
			if("pullAction" == serverFailure.action) {
				this.unshiftActionQueue(serverFailure.pendingActions);
			}
			this.fireEvent("disconnectserver", this);
			if("disconnected" !== this.serverStatus) {
				this.serverStatus = "disconnected";
			}
			Ext.Function.defer(function() {
				this.reconnectServer();
			}, SCONST.RECONNECT_SERVER_INTERVAL, this);
			return "disconnected";
		} else {
			var json = Ext.decode(response.responseText);
			if("relogin" === json.success) {
				if("pullAction" == serverFailure.action) {
					this.unshiftActionQueue(serverFailure.pendingActions);
				}
				return;
			}
			this.fireEvent("reportservererror", this.serverFailureAction, this);
		}
	},
	reconnectServer: function() {
		if(this.serverFailureAction) {
			var serverFailure = this.serverFailureAction,
				actionName = serverFailure.action;
			if("pullAction" == actionName) {
				this.unlockPulling();
				this.pullingAction();
			} else if("addSheet" == actionName) {
				this.addSheet(serverFailure.tabConfig, serverFailure.callback, serverFailure.scope);
			} else if("deleteSheet" == actionName) {
				this.deleteSheet(serverFailure.sheetId, serverFailure.callback, serverFailure.scope);
			} else if("hideSheet" == actionName) {
				this.hideSheet(serverFailure.sheetId, serverFailure.callback, serverFailure.scope);
			} else if("showSheet" == actionName) {
				this.showSheet(serverFailure.sheetId, serverFailure.callback, serverFailure.scope);
			} else if("renameSheet" == actionName) {
				this.renameSheet(serverFailure.sheetId, serverFailure.newName, serverFailure.callback, serverFailure.scope);
			} else if("changeSheetColor" == actionName) {
				this.changeSheetColor(serverFailure.sheetId, serverFailure.color, serverFailure.callback, serverFailure.scope);
			} else if("copySheet" == actionName) {
				this.copySheet(serverFailure.oldSheetId, serverFailure.newSheetName, serverFailure.callback, serverFailure.scope);
			} else if("updateSheetTab" == actionName) {
				this.updateSheetTab(serverFailure.sheetId, serverFailure.config, serverFailure.callback, serverFailure.scope);
			} else if("changeSheetOrder" == actionName) {
				this.changeSheetOrder(serverFailure.preIndex, serverFailure.curIndex, serverFailure.callback, serverFailure.scope);
			} else if("changeFileName" == actionName) {
				this.changeFileName({
					filename: serverFailure.fileName
				}, serverFailure.callback, serverFailure.scope);
			} else if("changeFileColor" == actionName) {
				this.changeFileColor({
					filecolor: serverFailure.fileColor
				}, serverFailure.callback, serverFailure.scope);
			} else if("changeFileStared" == actionName) {
				this.changeFileStared(serverFailure.fileStared, serverFailure.callback, serverFailure.scope);
			}
		}
	},
	checkSeverStatus: function() {
		if("disconnected" === this.serverStatus) {
			delete this.serverStatus;
			delete this.serverFailureAction;
			this.fireEvent("connectserver", this);
		}
	}
});

Ext.define("EnterpriseSheet.pure.sheet.data.SheetStore", {
	extend: "EnterpriseSheet.pure.sheet.data.PullingStore",
	pageSize: 1000,
	constructor: function(config) {
		Ext.apply(this, config);
		Ext.applyIf(this, {
			loadSheetUrl: SCONFIG.urls.loadSheet,
			loadRangeUrl: SCONFIG.urls.loadRange2
		});
		EnterpriseSheet.pure.sheet.data.SheetStore.prototype.superclass.constructor.apply(this, arguments);
	},
	readSheets: function(sheets) {
		EnterpriseSheet.pure.sheet.data.SheetStore.prototype.superclass.readSheets.apply(this, arguments);
		for(var i = 0, len = this.sheets.length; i < len; i++) {
			var it = this.sheets[i];
			if(it.actived) {
				it.loaded = true;
			}
		}
	},
	updateSheetObjAfterLoadSheet: function(sheetObj, json, sheetId) {},
	loadSheet: function(sheetId, callback, scope, notActiveTabFlag, forceReload) {
		var loaded = this.isLoadedSheet(sheetId),
			allCellLoaded = this.isAllCellLoadedInSheet(sheetId);
		var me = this;
		if(loaded && !forceReload) {
			this.resetRowHeightColWidthCache(sheetId);
			if(callback) {
				callback.call(scope, true);
			}
		} else if(allCellLoaded && !forceReload) {
			me.loadFloatingsBySheetId(sheetId, function(success, floatings) {
				if(floatings && 0 < floatings.length) {
					me.appendFloatings(floatings);
				}
				me.checkSeverStatus();
				me.resetRowHeightColWidthCache(sheetId);
				var sheetObj = me.getSheetById(sheetId);
				sheetObj.loaded = true;
				if(callback) {
					callback.call(scope, true);
				}
			}, me);
		} else {
			Ext.Ajax.request({
				url: this.loadSheetUrl,
				params: {
					fileId: this.fileId,
					sheetId: sheetId,
					size: this.limitCellNumAtSingleLoad,
					notActiveTabFlag: notActiveTabFlag || false,
					throttleOfBigFile: this.throttleOfBigFile
				},
				success: function(response, options) {
					var json = Ext.decode(response.responseText);
					var separateChar = this.separateChar,
						dataMap = this.getData(),
						records = me.reader.read(json.results),
						startCellId = json.startCellId;
					if(true === json.success || "true" === json.success) {
						var newRecs = [],
							recLen = records.length;
						for(var i = 0; i < recLen; i++) {
							var it = records[i];
							if(!it[3].cal) {
								var cid = [it[0], it[1], it[2]].join(separateChar);
								if(!dataMap[cid]) {
									dataMap[cid] = it;
								}
							}
						}
						var sheetObj = me.getSheetById(sheetId);
						//2018 4.11 zdw 解决复制sheet后拿不到sheetObj的bug
						if (typeof(sheetObj) != "undefined") {
							sheetObj.loaded = true;
							sheetObj.currentFloatingCount = 0;
							sheetObj.totalFloatingCount = json.floatingTotal;
							sheetObj.totalCellCount = json.total;
							sheetObj.currentCellCount = recLen;
							me.updateSheetObjAfterLoadSheet(sheetObj, json, sheetId);
							if(startCellId != 0 && !SCOM.isEmptyValue(startCellId)) {
								me.loadMore(sheetId, startCellId, me.limitCellNumAtSingleLoad, function() {
									me.loadFloatingsBySheetId(sheetId, function(success, floatings) {
										if(floatings && 0 < floatings.length) {
											me.appendFloatings(floatings);
										}
										this.presetTplForCells();
										if(callback) {
											callback.call(scope, true);
										}
									}, me);
								}, me, true, json);
								return;
							}
						}else{
					        SHEET_API_HD.store.loadFile({
								        fileId: SHEET_API_HD.store.fileId
						    });
						    return;
						}
					} else {
						this.serverFailureAction = {
							action: "loadSheet",
							sheetId: sheetId,
							callback: callback,
							scope: scope
						};
						this.processServerFailure(response);
					}
					me.loadFloatingsBySheetId(sheetId, function(success, floatings) {
						if(floatings && 0 < floatings.length) {
							me.appendFloatings(floatings);
						}
						this.presetTplForCells();
						me.checkSeverStatus();
						me.resetRowHeightColWidthCache(sheetId);
						if(callback) {
							callback.call(scope, true);
						}
					}, me);
				},
				failure: function(response, options) {
					this.serverFailureAction = {
						action: "loadSheet",
						sheetId: sheetId,
						callback: callback,
						scope: scope
					};
					this.processServerFailure(response);
					this.resetRowHeightColWidthCache(sheetId);
					if(callback) {
						callback.call(scope, false);
					}
				},
				scope: this
			});
		}
	},
	isLoadedCell: function(sheetId, row, col, sheet) {
		var sep = this.separateChar;
		sheet = sheet || this.getSheetById(sheetId);
		var data = this.getData();
		if(!sheet.allCellDataLoaded) {
			var loadedEmptyCells = sheet.loadedEmptyCells || {};
			var p = [sheetId, row, col].join(sep);
			if(!data[p]) {
				if(loadedEmptyCells[p]) {
					return true;
				} else if(0 !== row && 0 !== col) {
					var a = [sheetId, 0, 0].join(sep);
					if(!loadedEmptyCells[a]) {
						var r = [sheetId, row, 0].join(sep);
						if(!loadedEmptyCells[r]) {
							var c = [sheetId, 0, col].join(sep);
							if(!loadedEmptyCells[c]) {
								return this.checkIsLoadedCell(sheetId, row, col, sheet) || false;
							}
						}
					}
				} else {
					return false;
				}
			}
			if(0 === row || 0 === col) {
				if(loadedEmptyCells[p]) {
					return true;
				}
				return false;
			}
		}
		return true;
	},
	checkIsLoadedCell: function() {},
	getMergedRanges: function(cells) {
		var sep = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.separator;
		var tabs = {};
		for(var p in cells) {
			if(cells.hasOwnProperty(p)) {
				var it = cells[p],
					s = it[0],
					r = it[1],
					c = it[2];
				tabs[s] = tabs[s] || {
					minr: r,
					maxr: r,
					minc: c,
					maxc: c
				};
				var tab = tabs[s];
				if(tab.minr > r) {
					tab.minr = r;
				}
				if(tab.maxr < r) {
					tab.maxr = r;
				}
				if(tab.minc > c) {
					tab.minc = c;
				}
				if(tab.maxc < c) {
					tab.maxc = c;
				}
			}
		}
		var flags = {};
		for(var s in tabs) {
			if(tabs.hasOwnProperty(s)) {
				var tab = tabs[s],
					minr = tab.minr,
					minc = tab.minc,
					maxr = tab.maxr,
					maxc = tab.maxc,
					index = 0;
				for(var j = minc; j <= maxc; j++) {
					for(var i = minr; i <= maxr; i++) {
						var p = [s, i, j].join(sep);
						if(cells[p]) {
							if(minr < i) {
								up = [s, i - 1, j].join(sep);
								flags[p] = flags[up];
							}
							if(!Ext.isDefined(flags[p])) {
								flags[p] = index;
								index++;
							}
						}
					}
				}
			}
		}
		var ranges = {};
		for(var p in flags) {
			if(flags.hasOwnProperty(p)) {
				var index = flags[p],
					pos = cells[p],
					s = pos[0],
					r = pos[1],
					c = pos[2];
				ranges[s] = ranges[s] || {};
				var it = ranges[s];
				it[index] = it[index] || {
					sheet: s,
					minr: r,
					minc: c,
					maxr: r,
					maxc: c
				};
				var range = it[index];
				if(range.minr > r) {
					range.minr = r;
				}
				if(range.maxr < r) {
					range.maxr = r;
				}
				if(range.minc > c) {
					range.minc = c;
				}
				if(range.maxc < c) {
					range.maxc = c;
				}
			}
		}
		var arr = [];
		for(var p in ranges) {
			if(ranges.hasOwnProperty(p)) {
				var it = ranges[p];
				for(var q in it) {
					if(it.hasOwnProperty(q)) {
						var range = it[q];
						arr.push([range.sheet, range.minr, range.minc, range.maxr, range.maxc]);
					}
				}
			}
		}
		return arr;
	},
	getCoverRangesByCell: function(cells) {
		var tabs = {};
		for(var p in cells) {
			if(cells.hasOwnProperty(p)) {
				var it = cells[p],
					s = it[0],
					r = it[1],
					c = it[2];
				tabs[s] = tabs[s] || {
					minr: r,
					maxr: r,
					minc: c,
					maxc: c
				};
				var tab = tabs[s];
				if(tab.minr > r) {
					tab.minr = r;
				}
				if(0 === r || tab.maxr < r && 0 !== tab.maxr) {
					tab.maxr = r;
				}
				if(tab.minc > c) {
					tab.minc = c;
				}
				if(0 === c || tab.maxc < c && 0 !== tab.maxc) {
					tab.maxc = c;
				}
			}
		}
		var arr = [];
		for(var p in tabs) {
			if(tabs.hasOwnProperty(p)) {
				var it = tabs[p];
				arr.push([Number(p), it.minr, it.minc, it.maxr, it.maxc]);
			}
		}
		return arr;
	},
	getCoverRangesBySheet: function(ranges) {
		var lookup = {};
		for(var i = 0, len = ranges.length; i < len; i++) {
			var it = ranges[i];
			var sheet = it[0];
			lookup[sheet] = lookup[sheet] || {};
			var o = lookup[sheet],
				minr = o.minr,
				minc = o.minc,
				maxr = o.maxr,
				maxc = o.maxc;
			if(!Ext.isNumber(minr) || minr > it[1] || 0 === it[1]) {
				if(0 !== minr) {
					minr = it[1];
				}
			}
			if(!Ext.isNumber(minc) || minc > it[2] || 0 === it[2]) {
				if(0 !== minc) {
					minc = it[2];
				}
			}
			if(!Ext.isNumber(maxr) || maxr < it[3] || 0 === it[3]) {
				if(0 !== maxr) {
					maxr = it[3];
				}
			}
			if(!Ext.isNumber(maxc) || maxc < it[4] || 0 === it[4]) {
				if(0 !== maxc) {
					maxc = it[4];
				}
			}
			o.minr = minr;
			o.minc = minc;
			o.maxr = maxr;
			o.maxc = maxc;
		}
		var arr = [];
		for(var p in lookup) {
			if(lookup.hasOwnProperty(p)) {
				var it = lookup[p];
				arr.push([Number(p), it.minr, it.minc, it.maxr, it.maxc]);
			}
		}
		return arr;
	},
	loadCellsByRange: function(ranges, callback, scope) {
		var me = this,
			sheetsLookup = this.getSheetIdLookup(),
			dataMap = this.getData(),
			separateChar = this.separateChar;
		var loadedTabIds = [];
		for(var i = 0, len = ranges.length; i < len; i++) {
			var it = ranges[i];
			if(0 === it[1] && 0 === it[2] && 0 === it[3] && 0 === it[4]) {
				loadedTabIds.push(it[0]);
			}
		}
		var rangeStr = Ext.encode(ranges);
		this._loadingFlag = true;
		var nextCellId = 0;
		var loadFn = function() {
			if(!Ext.isDefined(me.fileId)) {
				delete me._loadingFlag;
				if(callback) {
					callback.call(scope);
				}
			} else {
				Ext.Ajax.request({
					url: me.loadRangeUrl,
					params: {
						range: rangeStr,
						limit: me.limitCellNumAtSingleLoad,
						nextCellId: nextCellId
					},
					success: function(response, options) {
						var json = Ext.decode(response.responseText);
						var records = me.reader.read(json.results);
						if(true === json.success || "true" === json.success) {
							var count = 0;
							for(var i = 0, len = records.length; i < len; i++) {
								var it = records[i];
								if(!it[3].cal) {
									var id = [it[0], it[1], it[2]].join(separateChar);
									if(!dataMap[id]) {
										dataMap[id] = it;
										count++;
									}
								}
							}
							me.totalCount += count;
						}
						if(json.nextCellId) {
							nextCellId = json.nextCellId;
							loadFn();
						} else {
							for(var k = 0, size = loadedTabIds.length; k < size; k++) {
								var tabId = loadedTabIds[k];
								sheetsLookup[tabId].allCellDataLoaded = true;
							}
							delete me._loadingFlag;
							if(callback) {
								callback.call(scope);
							}
							me.fireEvent("loadingrange", [ranges], me);
						}
					},
					failure: function(response, options) {
						delete me._loadingFlag;
						Ext.Msg.alert(SLANG.hint, SLANG.intelnet_error);
					},
					scope: me
				});
			}
		};
		if(false === me.fireEvent("beforeloadingrange", [ranges], me)) {
			return false;
		}
		me.fireEvent("prepareloadingrange", [ranges], me);
		loadFn();
	},
	checkLoadCells: function(lookup, callback, scope, mergeRangeFlag) {
		var unloadeds = [],
			cache = this.getSheetIdLookup(),
			unloadedLookup = {};
		for(var p in lookup) {
			if(lookup.hasOwnProperty(p)) {
				var it = lookup[p];
				var pos = it.pos || it;
				var sheetId = pos[0];
				if(!this.isLoadedCell(sheetId, pos[1], pos[2], cache[sheetId])) {
					unloadedLookup[p] = pos;
				}
			}
		}
		var sep = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.separator,
			tmp = {};
		for(var p in unloadedLookup) {
			if(unloadedLookup.hasOwnProperty(p)) {
				var pos = unloadedLookup[p];
				var s = pos[0],
					r = pos[1],
					c = pos[2];
				if(0 === r && 0 === c) {
					tmp[p] = pos;
				} else if(0 === r || 0 === c) {
					var allId = [s, 0, 0].join(sep);
					if(!unloadedLookup[allId]) {
						tmp[p] = pos;
					}
				} else {
					var allId = [s, 0, 0].join(sep);
					if(!unloadedLookup[allId]) {
						var rowId = [s, r, 0].join(sep);
						if(!unloadedLookup[rowId]) {
							var colId = [s, 0, c].join(sep);
							if(!unloadedLookup[colId]) {
								tmp[p] = pos;
							}
						}
					}
				}
			}
		}
		var ranges;
		if(mergeRangeFlag) {
			ranges = this.getCoverRangesByCell(tmp);
		} else {
			ranges = this.getMergedRanges(tmp);
		}
		var len = ranges.length;
		if(0 < len) {
			this.loadCellsByRange(ranges, function() {
				this.updateLoadedEmptyCells(tmp, cache, ranges);
				if(callback) {
					callback.call(scope, true, unloadedLookup);
				}
			}, this);
			return false;
		} else if(callback) {
			callback.call(scope);
		}
		return true;
	},
	checkLoadCoord: function(coord, callback, scope, mergeRangeFlag) {
		var me = this;
		var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var ranges = [],
			sheetIds = [],
			sheetIdLookup = {},
			cache = this.getSheetIdLookup();
		for(var i = 0, len = coord.length; i < len; i++) {
			var span = coord[i];
			if(span) {
				var sheetId = span[0];
				if(!sheetIdLookup[sheetId]) {
					var it = [].concat(span),
						flag = 0;
					if(500 <= it[3] - it[1]) {
						it[1] = 0;
						it[3] = 0;
						flag++;
					}
					if(100 <= it[4] - it[2]) {
						it[2] = 0;
						it[4] = 0;
						flag++;
					}
					if(2 === flag) {
						sheetIds.push(sheetId);
						sheetIdLookup[sheetId] = true;
					} else {
						ranges.push(it);
					}
				}
			}
		}
		var needLoadSheetLen = sheetIds.length;
		if(0 < needLoadSheetLen) {
			var index = 0;
			var loadFn = function() {
				me.loadSheet(sheetIds[index], function() {
					index++;
					if(index < needLoadSheetLen) {
						loadFn();
					} else {
						var cells = coordPro.transferCoord2CellLookup(ranges);
						me.checkLoadCells(cells, callback, scope, mergeRangeFlag);
					}
				}, me, true);
			};
			loadFn();
		} else {
			var cells = coordPro.transferCoord2CellLookup(ranges);
			this.checkLoadCells(cells, callback, scope, mergeRangeFlag);
		}
	},
	findMatchCells: function(exp, callback, scope, startCellId) {
		var me = this;
		var callParent = EnterpriseSheet.pure.sheet.data.SheetStore.prototype.superclass.findMatchCells;
		var args = arguments;
		var sheets = this.getSheets(),
			loaded = true;
		for(var i = 0, len = sheets.length; i < len; i++) {
			var it = sheets[i];
			if(!it.allCellDataLoaded) {
				loaded = false;
				break;
			}
		}
		if(loaded || !Ext.isDefined(this.fileId)) {
			callParent.apply(me, [exp, callback, scope]);
		} else {
			exp = exp.toString();
			var query = exp.replace(/\*/gi, "");
			if(query.length < 2) {
				if(Ext.Msg) {
					Ext.Msg.alert(SLANG.hint, SLANG.enter2char);
				}
				if(callback) {
					callback.call(scope);
				}
				return;
			}
			var loadFn = function() {
				Ext.Ajax.request({
					url: SCONFIG.urls.findCells2,
					params: {
						fileId: this.fileId,
						query: query,
						limit: this.limitCellNumAtSingleLoad,
						start: startCellId
					},
					success: function(response, options) {
						var json = Ext.decode(response.responseText);
						var me = this,
							records = me.reader.read(json.results);
						if(true === json.success || "true" === json.success) {
							me.totalCount += json.total;
							me.loadRecords(records, {
								addRecords: true,
								notOverwrite: true
							});
						}
						var matchs = [],
							sheetLookup = this.getSheetIdLookup(),
							colLookup = {};
						for(var i = 0, len = records.length; i < len; i++) {
							var it = records[i];
							var colName = colLookup[it[2]];
							if(!colName) {
								colName = this.getColName(it[2]);
								colLookup[it[2]] = colName;
							}
							matchs.push({
								sheet: it[0],
								sheetName: sheetLookup[it[0]].name,
								row: it[1],
								col: it[2],
								cell: colName + it[1],
								data: it[3].data
							});
						}
						if(callback) {
							callback.call(scope, matchs, json.nextCellId);
						}
					},
					failure: function(response, options) {
						if(Ext.Msg) {
							Ext.Msg.alert(SLANG.hint, SLANG.intelnet_error);
						}
						if(callback) {
							callback.call(scope);
						}
					},
					scope: this
				});
			};
			loadFn.call(this);
		}
	},
	reconnectServer: function() {
		EnterpriseSheet.pure.sheet.data.SheetStore.prototype.superclass.reconnectServer.apply(this, arguments);
		if(this.serverFailureAction) {
			var serverFailure = this.serverFailureAction,
				actionName = serverFailure.action;
			if("loadSheet" == actionName) {
				this.loadSheet(serverFailure.sheetId, serverFailure.callback, serverFailure.scope);
			}
		}
	}
});

Ext.define("EnterpriseSheet.pure.sheet.data.RollingStore", {
	extend: "EnterpriseSheet.pure.sheet.data.SheetStore",
	rowBlockCount: 100,
	colBlockCount: 30,
	loadCellRangeBuffer: 100,
	throttleOfBigFile: 10000,
	constructor: function(config) {
		Ext.apply(this, config);
		Ext.applyIf(this, {
			loadUrl: SCONFIG.urls.loadSheetInfo2,
			loadMoreUrl: SCONFIG.urls.loadCellOnDemand4,
			loadSheetUrl: SCONFIG.urls.loadSheet5,
			loadRangeUrl: SCONFIG.urls.loadRange3,
			loadRangeStyleUrl: SCONFIG.urls.loadRange3
		});
		EnterpriseSheet.pure.sheet.data.RollingStore.prototype.superclass.constructor.apply(this, arguments);
		this.on("loadcellrange", this.loadCellRange, this, {
			buffer: this.loadCellRangeBuffer
		});
	},
	loadFile: function(config, callback, scope) {
		config = config || {};
		if(!SCOM.nullOrUndefined(config.fileId)) {
			this.fileId = config.fileId;
		}
		this.load({
			params: {
				fileId: this.fileId,
				startCellId: 0,
				isTpl:isTplfile,
				size: this.limitCellNumAtSingleLoad,
				throttleOfBigFile: this.throttleOfBigFile
			},
			callback: function() {
				if(callback) {
					callback.apply(scope, arguments);
				}
			},
			scope: this
		});
	},
	updateSheetObjAfterLoadSheet: function(sheetObj, json, sheetId) {
		if("tab" === json.loadWay) {
			sheetObj.allCellDataLoaded = true;
			json.loadSheetId = sheetId;
		}
	},
	loadMore: function(activeSheetId, startCellId, total, callback, scope, skipCal, message) {
		if("doc" === message.loadWay) {
			this.loadMoreUrl = SCONFIG.urls.loadCellOnDemand5;
		} else if("tab" === message.loadWay) {
			if(activeSheetId === message.loadSheetId) {
				this.loadMoreUrl = SCONFIG.urls.loadCellOnDemand3;
			} else {
				this.loadMoreUrl = SCONFIG.urls.loadCellOnDemand4;
			}
		} else {
			this.loadMoreUrl = SCONFIG.urls.loadCellOnDemand4;
		}
		EnterpriseSheet.pure.sheet.data.RollingStore.prototype.superclass.loadMore.apply(this, arguments);
	},
	isSpansLoaded: function(spans) {
		var separateChar = this.separateChar,
			sheetId = this.getActivedSheetId();
		if(this.isAllCellLoadedInSheet(sheetId)) {
			return true;
		}
		var tab = this.getSheetById(sheetId);
		var maxRow = tab.maxRow,
			maxCol = tab.maxCol;
		tab.loadedBlocks = tab.loadedBlocks || {};
		var loadedBlocks = tab.loadedBlocks,
			unlodedBlocks = {};
		for(var i = 0, len = spans.length; i < len; i++) {
			var span = spans[i];
			if(0 < span[1] && 0 < span[2] && span[1] <= maxRow && span[2] <= maxCol) {
				var minr = Math.floor((span[1] - 1) / this.rowBlockCount),
					maxr = Math.floor((span[3] - 1) / this.rowBlockCount),
					minc = Math.floor((span[2] - 1) / this.colBlockCount),
					maxc = Math.floor((span[4] - 1) / this.colBlockCount);
				for(var r = minr; r <= maxr; r++) {
					for(var c = minc; c <= maxc; c++) {
						var id = [r, c].join(separateChar);
						if(!loadedBlocks[id]) {
							return false;
						}
					}
				}
			}
		}
		return true;
	},
	checkLoadRange: function(spans, callback, scope) {
		var separateChar = this.separateChar,
			sheetId = this.getActivedSheetId();
		if(this.isAllCellLoadedInSheet(sheetId)) {
			if(callback) {
				callback.call(scope);
			}
			return;
		}
		var tab = this.getSheetById(sheetId);
		var maxRow = tab.maxRow,
			maxCol = tab.maxCol;
		tab.loadedBlocks = tab.loadedBlocks || {};
		var loadedBlocks = tab.loadedBlocks,
			unlodedBlocks = {};
		for(var i = 0, len = spans.length; i < len; i++) {
			var span = spans[i];
			if(0 < span[1] && 0 < span[2] && span[1] <= maxRow && span[2] <= maxCol) {
				var minr = Math.floor((span[1] - 1) / this.rowBlockCount),
					maxr = Math.floor((span[3] - 1) / this.rowBlockCount),
					minc = Math.floor((span[2] - 1) / this.colBlockCount),
					maxc = Math.floor((span[4] - 1) / this.colBlockCount);
				for(var r = minr; r <= maxr; r++) {
					for(var c = minc; c <= maxc; c++) {
						var id = [r, c].join(separateChar);
						if(!loadedBlocks[id]) {
							loadedBlocks[id] = "loading";
							unlodedBlocks[id] = [r, c];
						}
					}
				}
			}
		}
		var coord = [];
		for(var p in unlodedBlocks) {
			if(unlodedBlocks.hasOwnProperty(p)) {
				var it = unlodedBlocks[p],
					r = it[0],
					c = it[1];
				var minr = r * this.rowBlockCount + 1,
					maxr = minr + this.rowBlockCount - 1,
					minc = c * this.colBlockCount + 1,
					maxc = minc + this.colBlockCount - 1;
				coord.push([sheetId, minr, minc, maxr, maxc]);
			}
		}
		if(0 < coord.length) {
			this.loadCellRange(coord, function() {
				for(var p in unlodedBlocks) {
					if(p.hasOwnProperty(p)) {
						loadedBlocks[p] = true;
					}
				}
				if(callback) {
					callback.call(scope);
				}
			}, this);
		} else {
			if(callback) {
				callback.call(scope);
			}
		}
	},
	loadCellRange: function(coord, callback, scope) {
		var sheetId = this.getActivedSheetId(),
			nextCellId = 0,
			separateChar = this.separateChar;
		var dataMap = this.getData();
		if(false === this.fireEvent("beforeloadrange", coord, this)) {
			return;
		}
		var me = this;
		var loadFn = function() {
			me.fireEvent("prepareloadrange", coord, me);
			Ext.Ajax.request({
				url: me.loadRangeStyleUrl,
				params: {
					nextCellId: nextCellId,
					range: Ext.encode(coord),
					limit: me.limitCellNumAtSingleLoad
				},
				success: function(response, options) {
					var json = Ext.decode(response.responseText);
					nextCellId = json.nextCellId;
					if(true === json.success || "true" === json.success) {
						var results = json.results;
						for(var i = 0, len = results.length; i < len; i++) {
							var it = results[i];
							var id = [it[0], it[1], it[2]].join(separateChar);
							var found = dataMap[id];
							if(found) {
								var empty = SCOM.isEmptyValue(found[3].data);
								found[3] = Ext.apply(Ext.decode(it[3]), found[3]);
								if(empty) {
									delete found[3].cdtVal;
								}
							} else {
								it = me.reader.readSingle(it);
								dataMap[id] = it;
							}
						}
					}
					if(nextCellId) {
						loadFn();
					} else {
						this.presetTplForCells();
						if(callback) {
							callback.call(scope);
						}
						me.fireEvent("afterloadrange", coord, me);
					}
				},
				scope: me
			});
		};
		loadFn();
	},
	checkIsLoadedCell: function(sheetId, row, col, sheet) {
		sheet = sheet || this.getSheetById(sheetId);
		if(sheet.loadedBlocks) {
			var r = Math.floor((row - 1) / this.rowBlockCount),
				c = Math.floor((col - 1) / this.colBlockCount);
			var id = [r, c].join(this.separateChar);
			if(sheet.loadedBlocks[id]) {
				return true;
			}
		}
	}
});

Ext.define("EnterpriseSheet.pure.sheet.range.Range", {
	requires: ["EnterpriseSheet.pure.sheet.calculate.Condition"],
	constructor: function(config) {
		Ext.apply(this, config);
		var sheetId = this.sheet.getSheetId();
		var type = SCOM.typeOf(this.coord);
		if("string" == type) {
			this.coord = this.parseCoorString(this.coord);
			var store = this.sheet.getStore();
			for(var i = 0, len = this.coord.length; i < len; i++) {
				if("string" == SCOM.typeOf(this.coord[i][0])) {
					this.coord[i][0] = store.getSheetIdByName(this.coord[i][0]);
				}
			}
		} else if("array" == type) {
			var len = this.coord.length;
			if(0 < len) {
				if("array" == SCOM.typeOf(this.coord[0])) {
					var coord = [];
					for(var i = 0; i < len; i++) {
						coord.push(EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(this.coord[i], sheetId));
					}
					this.coord = coord;
				} else {
					this.coord = [EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.normalizeCoord(this.coord, sheetId)];
				}
			}
		} else if("object" == type) {
			this.coord = [
				[this.sheet.getSheetId(), this.coord.minrow, this.coord.mincol, this.coord.maxrow, this.coord.maxcol]
			];
		}
		EnterpriseSheet.pure.sheet.range.Range.prototype.superclass.constructor.apply(this);
	},
	parseCoorString: function(coordStr) {
		try {
			var coord = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.string2Coord(coordStr);
			var arr = [];
			for(var i = 0, len = coord.length; i < len; i++) {
				arr.push(coord[i].span);
			}
			this.coord = arr;
		} catch(e) {
			this.coord = null;
		}
	}
}, function() {
	Ext.apply(EnterpriseSheet.pure.sheet.range.Range.prototype, {
		setCondition: function(condition, option, suspendRefresh, suspendEvent, cdtId) {
			var coord = this.getCoord();
			if(!this.isInSingleSheet()) {
				if(Ext.Msg) {
					Ext.Msg.alert(SLANG.hint, SLANG.set_condition_only_single_sheet);
				}
				return;
			}
			var ss = this.sheet;
			var store = ss.getStore();
			var sheetId = this.coord[0][0];
			if(SCOM.nullOrUndefined(sheetId) || "" == sheetId) {
				sheetId = ss.getSheetId();
			}
			if(suspendEvent || false !== ss.fireEvent("beforeconditionchange", this, ss)) {
				var id = cdtId || Ext.id() + "-" + SCOM.genTimeStamp();
				var oldCdts = {};
				oldCdts[id] = {
					sheet: sheetId,
					name: id
				};
				var result = ss.getRelatedCdtCoord(coord);
				if(!suspendEvent) {
					ss.fireEvent("prepareconditionchange", this, ss, oldCdts, result.coord);
				}
				var args = {
					name: condition,
					rng: this.getCoordInAbsolute()
				};
				if(option) {
					args.opt = option;
				}
				var argstr = Ext.encode(args);
				args.id = id;
				var found;
				store.eachFloating(function(it) {
					if(it.sheet == sheetId && it.json == argstr) {
						found = it;
						return false;
					}
				});
				if(!found) {
					store.setFloatingItem(sheetId, id, "cdt", Ext.encode(args));
					found = {
						name: id
					};
				}
				var concatCoord = ss.processRelatedCdt(coord, true, result);
				if(!suspendRefresh) {
					if(Ext.isFunction(ss.refreshRange)) {
						ss.refreshRange(concatCoord.concat(this.coord));
					}
				}
				if(!suspendEvent) {
					ss.fireEvent("conditionchange", this, ss, oldCdts, concatCoord);
				}
				return id;
			}
		},
		clearCondition: function(suspendRefresh, suspendEvent) {
			var ss = this.sheet;
			var coord = this.getCoord();
			if(false !== ss.fireEvent("beforeconditionchange", this, ss)) {
				var oldCdts = ss.getCdtsFromCoord(coord);
				var result = ss.getRelatedCdtCoord(coord);
				ss.fireEvent("prepareconditionchange", this, ss, oldCdts, result.coord);
				ss.splitCdt(coord, oldCdts);
				var concatCoord = ss.processRelatedCdt(coord, true, result);
				if(!suspendRefresh) {
					if(Ext.isFunction(ss.refreshRange)) {
						ss.refreshRange(concatCoord.concat(coord));
					}
				}
				ss.fireEvent("conditionchange", this, ss, oldCdts, concatCoord);
			}
		},
		setProperty: function(modified, deleted, suspendRefresh, suspendEvent, walkThrough) {
			var ss = this.sheet;
			var store = ss.getStore();
			var changedHeights = {},
				cdtCoord;
			var expand2Around = modified && modified.bgc || deleted && -1 !== deleted.indexOf("bgc");
			if(modified && modified.dcfg || deleted && -1 !== deleted.indexOf("dcfg")) {
				cdtCoord = [];
				for(var i = 0, len = this.coord.length; i < len; i++) {
					var span = this.coord[i];
					for(var j = span[2]; j <= span[4]; j++) {
						cdtCoord.push([span[0], span[1], j, span[3], j]);
					}
				}
			}
			var deleteDsdFlag;
			if(deleted && -1 !== deleted.indexOf("dsd") || modified && ("" === modified.dsd || false === modified.dsd)) {
				deleteDsdFlag = true;
			}
			if(suspendEvent || false !== ss.fireEvent("beforerangechange", this, modified, deleted, ss)) {
				if(!suspendEvent) {
					ss.fireEvent("preparerangechange", this, modified, deleted, changedHeights, cdtCoord, ss);
				}
				if(walkThrough) {
					store.walkRange(this.coord, function(rec) {
						var pro = store.getCellProperty(rec.data.sheet, rec.data.row, rec.data.col);
						if(deleteDsdFlag || !store.isDisabledForMe(pro.dsd)) {
							store.setCell(rec.data.sheet, rec.data.row, rec.data.col, modified, deleted, true);
						}
					}, this);
				} else {
					for(var i = 0, len = this.coord.length; i < len; i++) {
						var span = this.coord[i];
						var sheetId = span[0];
						if(0 == span[3] && 0 == span[4]) {
							var cell = store.getCell(sheetId, 0, 0);
							if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)) {
								store.setWhole(sheetId, modified, deleted, true);
							}
						} else if(0 == span[3]) {
							for(var col = span[2]; col <= span[4]; col++) {
								var cell = store.getCell(sheetId, 0, col);
								if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)) {
									store.setColumn(sheetId, col, modified, deleted, true, true);
								}
							}
						} else if(0 == span[4]) {
							for(var row = span[1]; row <= span[3]; row++) {
								var cell = store.getCell(sheetId, row, 0);
								if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)) {
									store.setRow(sheetId, row, modified, deleted, true, true);
								}
							}
						} else {
							for(var row = span[1]; row <= span[3]; row++) {
								for(var col = span[2]; col <= span[4]; col++) {
									var cell = store.getCellProperty(sheetId, row, col);
									if(deleteDsdFlag || !store.isDisabledForMe(cell.dsd)) {
										store.setCell(sheetId, row, col, modified, deleted, true);
									}
								}
							}
						}
					}
				}
				Ext.apply(changedHeights, this.checkAutoHeightForChange(modified, deleted, suspendRefresh, true));
				if(!suspendRefresh) {
					this.refresh(undefined, undefined, undefined, expand2Around);
				}
				if(!suspendEvent) {
					ss.fireEvent("rangechange", this, modified, deleted, ss);
				}
			}
		},
		getRelatedRowsForAutoHeight: function(modified, deleted, checkNoWrap) {
			return this.sheet.getRelatedRowsForAutoHeight(this.coord, modified, deleted, checkNoWrap);
		},
		checkAutoHeightForChange: function(modified, deleted, suspendRefresh, checkNoWrap) {
			var store = this.sheet.getStore();
			var relatedRows = this.getRelatedRowsForAutoHeight(modified, deleted, checkNoWrap);
			return this.sheet.checkAutoHeightForRows(relatedRows, suspendRefresh);
		},
		toggleItemCheck: function(osheetId, orow, ocol, suspendRefresh, suspendEvent) {
			var ss = this.sheet;
			var modified = {
					itchk: false
				},
				deleted = null;
			if(suspendEvent || false !== ss.fireEvent("beforerangechange", this, modified, deleted, ss)) {
				if(!suspendEvent) {
					ss.fireEvent("preparerangechange", this, modified, deleted, ss);
				}
				var store = ss.getStore();
				var cell = ss.getCellProperty(osheetId, orow, ocol);
				var itemName = cell.itn;
				if(itemName) {
					for(var i = 0, len = this.coord.length; i < len; i++) {
						var span = this.coord[i];
						var sheetId = span[0];
						if(0 == span[3] && 0 == span[4]) {
							var o = ss.getCellProperty(sheetId, 0, 0);
							if(itemName == o.itn) {
								store.setWhole(sheetId, modified, deleted, true);
							}
						} else if(0 == span[3]) {
							for(var col = span[2]; col <= span[4]; col++) {
								var o = ss.getCellProperty(sheetId, 0, col);
								if(itemName == o.itn) {
									store.setColumn(sheetId, col, modified, deleted, true, true);
								}
							}
						} else if(0 == span[4]) {
							for(var row = span[1]; row <= span[3]; row++) {
								var o = ss.getCellProperty(sheetId, row, 0);
								if(itemName == o.itn) {
									store.setRow(sheetId, row, modified, deleted, true, true);
								}
							}
						} else {
							for(var row = span[1]; row <= span[3]; row++) {
								for(var col = span[2]; col <= span[4]; col++) {
									var o = ss.getCellProperty(sheetId, row, col);
									if(itemName == o.itn) {
										store.setCell(sheetId, row, col, modified, deleted, true);
									}
								}
							}
						}
					}
				}
				store.setCell(osheetId, orow, ocol, {
					itchk: true
				}, null, true);
				if(!suspendRefresh) {
					this.refresh();
				}
				if(!suspendEvent) {
					ss.fireEvent("rangechange", this, modified, deleted, ss);
				}
			}
		},
		moveDecimalPoint: function(digital, suspendRefresh, suspendEvent) {
			this.setProperty({
				dpd: digital
			}, null, suspendRefresh, suspendEvent);
		},
		walk: function(fn, scope, suspendRefresh, suspendEvent) {
			var ss = this.sheet;
			if(suspendEvent || false !== ss.fireEvent("beforerangechange", this, null, null, ss)) {
				if(!suspendEvent) {
					ss.fireEvent("preparerangechange", this, null, null, ss);
				}
				var store = ss.getStore();
				store.walkRange(this.coord, function(rd) {
					if(fn) {
						fn.call(scope, rd);
					}
				}, this);
				if(!suspendRefresh) {
					this.refresh();
				}
				if(!suspendEvent) {
					ss.fireEvent("rangechange", this, null, null, ss);
				}
			}
		},
		setRangeBorder: function(dir, color, width, style, suspendRefresh, suspendEvent) {
			var ss = this.sheet;
			if(suspendEvent || false !== ss.fireEvent("beforeborderchange", this, ss)) {
				if(!suspendEvent) {
					ss.fireEvent("prepareborderchange", this, ss);
				}
				var store = ss.getStore();
				for(var i = 0, len = this.coord.length; i < len; i++) {
					var coord = this.coord[i];
					var sheetId = coord[0],
						minrow = coord[1],
						mincol = coord[2],
						maxrow = coord[3],
						maxcol = coord[4];
					var pos = {
						sheetId: sheetId,
						minrow: minrow,
						mincol: mincol,
						maxrow: maxrow,
						maxcol: maxcol
					};
					if(0 == mincol && 0 == minrow) {
						if("all" == dir) {
							this.setAllBorder(pos, width, style, color);
						}
					} else if(0 == mincol) {
						if("all" == dir) {
							this.setAllBorder(pos, width, style, color);
						} else if("top" == dir) {
							this.setTopBorder(pos, width, style, color);
						} else if("bottom" == dir) {
							this.setBottomBorder(pos, width, style, color);
						} else if("outside" == dir || "topbottom" == dir) {
							this.setTopBorder(pos, width, style, color);
							this.setBottomBorder(pos, width, style, color);
						}
					} else if(0 == minrow) {
						if("all" == dir) {
							this.setAllBorder(pos, width, style, color);
						} else if("left" == dir) {
							this.setLeftBorder(pos, width, style, color);
						} else if("right" == dir) {
							this.setRightBorder(pos, width, style, color);
						} else if("outside" == dir) {
							this.setLeftBorder(pos, width, style, color);
							this.setRightBorder(pos, width, style, color);
						}
					} else {
						if("all" == dir) {
							this.setAllBorder(pos, width, style, color);
						} else if("left" == dir) {
							this.setLeftBorder(pos, width, style, color);
						} else if("right" == dir) {
							this.setRightBorder(pos, width, style, color);
						} else if("top" == dir) {
							this.setTopBorder(pos, width, style, color);
						} else if("bottom" == dir) {
							this.setBottomBorder(pos, width, style, color);
						} else if("outside" == dir) {
							this.setLeftBorder(pos, width, style, color);
							this.setRightBorder(pos, width, style, color);
							this.setTopBorder(pos, width, style, color);
							this.setBottomBorder(pos, width, style, color);
						} else if("topbottom" == dir) {
							this.setTopBorder(pos, width, style, color);
							this.setBottomBorder(pos, width, style, color);
						}
					}
				}
				if(!suspendRefresh) {
					this.refresh(undefined, undefined, undefined, true);
				}
				if(!suspendEvent) {
					ss.fireEvent("borderchange", this, ss);
				}
			}
		},
		setLeftBorder: function(span, width, style, color) {
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol,
				maxcol = span.maxcol,
				minrow = span.minrow,
				maxrow = span.maxrow;
			for(var i = minrow; i <= maxrow; i++) {
				store.setRangeBorder(sheetId, i, mincol, [{
					dir: "l",
					width: width,
					style: style,
					color: color,
					flag: true
				}], true);
			}
			if(1 < mincol) {
				var col = mincol - 1;
				for(var i = minrow; i <= maxrow; i++) {
					store.setRangeBorder(sheetId, i, col, [{
						dir: "r",
						width: width,
						style: style,
						color: color
					}], true);
				}
			}
		},
		setRightBorder: function(span, width, style, color) {
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol,
				maxcol = span.maxcol,
				minrow = span.minrow,
				maxrow = span.maxrow;
			var col = maxcol + 1;
			for(var i = minrow; i <= maxrow; i++) {
				store.setRangeBorder(sheetId, i, maxcol, [{
					dir: "r",
					width: width,
					style: style,
					color: color,
					flag: true
				}], true);
				store.setRangeBorder(sheetId, i, col, [{
					dir: "l",
					width: width,
					style: style,
					color: color
				}], true);
			}
		},
		setTopBorder: function(span, width, style, color) {
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol,
				maxcol = span.maxcol,
				minrow = span.minrow,
				maxrow = span.maxrow;
			for(var j = mincol; j <= maxcol; j++) {
				store.setRangeBorder(sheetId, minrow, j, [{
					dir: "t",
					width: width,
					style: style,
					color: color,
					flag: true
				}], true);
			}
			if(1 < minrow) {
				row = minrow - 1;
				for(var j = mincol; j <= maxcol; j++) {
					store.setRangeBorder(sheetId, row, j, [{
						dir: "b",
						width: width,
						style: style,
						color: color
					}], true);
				}
			}
		},
		setBottomBorder: function(span, width, style, color) {
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol,
				maxcol = span.maxcol,
				minrow = span.minrow,
				maxrow = span.maxrow;
			var row = maxrow + 1;
			for(var j = mincol; j <= maxcol; j++) {
				store.setRangeBorder(sheetId, maxrow, j, [{
					dir: "b",
					width: width,
					style: style,
					color: color,
					flag: true
				}], true);
				store.setRangeBorder(sheetId, row, j, [{
					dir: "t",
					width: width,
					style: style,
					color: color
				}], true);
			}
		},
		setAllBorder: function(span, width, style, color) {
			var sheetId = span.sheetId;
			var store = this.sheet.getStore();
			var mincol = span.mincol,
				maxcol = span.maxcol,
				minrow = span.minrow,
				maxrow = span.maxrow;
			for(var i = minrow; i <= maxrow; i++) {
				for(var j = mincol; j <= maxcol; j++) {
					store.setRangeBorder(sheetId, i, j, [{
						dir: "l",
						width: width,
						style: style,
						color: color,
						flag: true
					}, {
						dir: "t",
						width: width,
						style: style,
						color: color,
						flag: true
					}, {
						dir: "r",
						width: width,
						style: style,
						color: color,
						flag: true
					}, {
						dir: "b",
						width: width,
						style: style,
						color: color,
						flag: true
					}], true);
				}
			}
			if(0 != minrow) {
				var row = maxrow + 1;
				for(var j = mincol; j <= maxcol; j++) {
					store.setRangeBorder(sheetId, row, j, [{
						dir: "t",
						width: width,
						style: style,
						color: color
					}], true);
				}
				if(1 < minrow) {
					var row = minrow - 1;
					for(var j = mincol; j <= maxcol; j++) {
						store.setRangeBorder(sheetId, row, j, [{
							dir: "b",
							width: width,
							style: style,
							color: color
						}], true);
					}
				}
			}
			if(0 != mincol) {
				var col = maxcol + 1;
				for(var i = minrow; i <= maxrow; i++) {
					store.setRangeBorder(sheetId, i, col, [{
						dir: "l",
						width: width,
						style: style,
						color: color
					}], true);
				}
				if(1 < mincol) {
					var col = mincol - 1;
					for(var i = minrow; i <= maxrow; i++) {
						store.setRangeBorder(sheetId, i, col, [{
							dir: "r",
							width: width,
							style: style,
							color: color
						}], true);
					}
				}
			}
		},
		refresh: function(refreshCalCells, refreshAll, concatCoord, expand2Around, checkCdtCoord) {
			var coord = SCOM.copy(this.coord);
			if(concatCoord) {
				coord = coord.concat(concatCoord);
			}
			var store = this.sheet.getStore();
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				if(span[1] == span[3] && span[2] == span[4]) {
					var cd = store.getCell(span[0], span[1], span[2]);
					if(store.isMergedCell(cd, span[0], span[1], span[2])) {
						span[1] += cd.minrow;
						span[2] += cd.mincol;
						span[3] += cd.maxrow;
						span[4] += cd.maxcol;
					}
				}
			}
			refreshCalCells = refreshCalCells || {};
			this.sheet.refreshCalCdt(refreshCalCells, true, undefined, checkCdtCoord, function(ret) {
				if(ret) {
					coord = coord.concat(ret);
				}
				if(Ext.isFunction(this.sheet.refreshRange)) {
					this.sheet.refreshRange(refreshAll ? null : expand2Around ? this.expand2Around(coord) : coord);
				}
			}, this);
		},
		expand2Around: function(coord) {
			return EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.expand2Around(coord);
		},
		includeMergedCell: function() {
			var store = this.sheet.getStore();
			var coord = this.coord;
			var flag = false;
			store.walkRange(coord, function(rd) {
				if(store.isMergedCell(rd.data.json, rd.data.sheet, rd.data.row, rd.data.col)) {
					flag = true;
					return false;
				}
			}, this, true);
			return flag;
		},
		isCellRange: function() {
			var store = this.sheet.getStore();
			var coord = this.coord;
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				if(0 == span[3] || 0 == span[4]) {
					return false;
				}
			}
			return true;
		},
		getCoord: function() {
			return SCOM.copy(this.coord);
		},
		setCoord: function(coord) {
			this.coord = SCOM.copy(coord);
		},
		getCoordInAbsolute: function(coord, asArr) {
			var arr = [];
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = SCOM.copy(coord[i]);
				if(asArr) {
					arr.push(span);
				} else {
					arr.push({
						span: span,
						type: SCONST.ABSOLUTE_COORD
					});
				}
			}
			return arr;
		},
		absolute2Relative: function(coord, sheetId, row, col) {
			var arr = [];
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				span = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.absoluteSpan2Relative(sheetId, row, col, span);
				arr.push({
					span: span,
					type: SCONST.RELATIVE_COORD
				});
			}
			return arr;
		},
		extend2Margin: function(coord) {
			var borders = [];
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				if(1 < span[1]) {
					borders.push([span[0], span[1] - 1, span[2], span[1] - 1, span[4]]);
				}
				if(1 < span[2]) {
					borders.push([span[0], span[1], span[2] - 1, span[3], span[2] - 1]);
				}
				borders.push([span[0], span[3] + 1, span[2], span[3] + 1, span[4]]);
				borders.push([span[0], span[1], span[4] + 1, span[3], span[4] + 1]);
			}
			coord = coord.concat(borders);
			return coord;
		},
		escapeDefaultProperty: function(sheetId, row, col) {
			var sheet = this.sheet,
				store = sheet.getStore();
			var dp = store.defaultProperty;
			var cellPro = store.getCellProperty(sheetId, row, col);
			var obj = {};
			for(var p in cellPro) {
				if(cellPro.hasOwnProperty(p) && dp.hasOwnProperty(p)) {
					obj[p] = dp[p];
				}
			}
			return obj;
		},
		clean: function(suspendEvent, avoidRange, suspendRefresh, skipDisabled) {
			if(false !== skipDisabled) {
				skipDisabled = true;
			}
			var me = this;
			var ss = this.sheet;
			var fn = function(originCdts, reCalCells, changedHeights, concatCoord) {
				var store = ss.getStore();
				var coord = this.coord;
				for(var k = 0, size = coord.length; k < size; k++) {
					var span = coord[k],
						sheetId = span[0];
					var cell = store.getCell(sheetId, 0, 0),
						dsd = cell.dsd;
					if(skipDisabled && store.isDisabledForMe(dsd)) {
						continue;
					}
					if(0 == span[3] && 0 == span[4]) {
						if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, 0)) {
							store.each(function(rd) {
								if(rd.data.sheet == sheetId) {
									var row = rd.data.row,
										col = rd.data.col;
									if(0 != row || 0 != col) {
										if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)) {
											var json = rd.data.json,
												dsd = json.dsd;
											if(!store.isDisabledForMe(dsd) && skipDisabled) {
												var pro = store.getCellProperty(sheetId, row, col);
												dsd = pro.dsd;
											}
											if(!skipDisabled || !store.isDisabledForMe(dsd)) {
												var countMemeber = SCOM.countObjMember(json);
												if(0 < countMemeber) {
													if(json.tpl) {
														if(1 != countMemeber) {
															store.setCell(sheetId, row, col, {
																tpl: json.tpl
															}, null, true, "clear");
														}
													} else {
														store.setCell(sheetId, row, col, null, null, true, "clear");
													}
												}
											}
										}
									}
								}
							}, store);
							var cell = store.getCell(sheetId, 0, 0);
							if(!skipDisabled || !store.isDisabledForMe(cell.dsd)) {
								store.setCell(sheetId, 0, 0, Ext.copyTo({}, store.getCell(sheetId, 0, 0), store.avoidMembers), null, true, "clear");
							}
						}
					} else if(0 == span[3]) {
						for(var j = span[2]; j <= span[4]; j++) {
							if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, j)) {
								var rows = [];
								store.each(function(rd) {
									if(rd.data.sheet == sheetId) {
										var row = rd.data.row,
											col = rd.data.col;
										if(j == col && 0 != row) {
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)) {
												var needDefault = false;
												var rowJson = store.getCell(sheetId, row, 0),
													dsd = rowJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)) {
													var countMemeber = SCOM.countObjMember(rowJson);
													if(1 < countMemeber || 1 == countMemeber && !rowJson.hasOwnProperty("tpl")) {
														needDefault = true;
													}
													var json = rd.data.json;
													dsd = dsd || json.dsd;
													if(!store.isDisabledForMe(dsd) && skipDisabled) {
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}
													if(!skipDisabled || !store.isDisabledForMe(dsd)) {
														if(needDefault) {
															var property = {};
															if(json && json.tpl) {
																property.tpl = json.tpl;
															}
															store.setCell(sheetId, row, col, Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col)), null, true, "clear");
														} else {
															countMemeber = SCOM.countObjMember(json);
															if(0 < countMemeber) {
																if(json.tpl) {
																	if(1 != countMemeber) {
																		store.setCell(sheetId, row, col, {
																			tpl: json.tpl
																		}, null, true, "clear");
																	}
																} else {
																	store.setCell(sheetId, row, col, null, null, true, "clear");
																}
															}
														}
													}
												}
											}
										} else if(0 == col && 0 != row) {
											rows.push(rd);
										}
									}
								}, store);
								for(var i = 0, len = rows.length; i < len; i++) {
									var r = rows[i];
									var row = r.data.row;
									if(!store.getRecord(sheetId, row, j)) {
										var json = store.getCell(sheetId, row, 0),
											dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled) {
											var pro = store.getCell(sheetId, 0, j);
											dsd = pro.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)) {
											var countMemeber = SCOM.countObjMember(json);
											if(0 < countMemeber) {
												if(!json.tpl || 1 != countMemeber) {
													store.setCell(sheetId, row, j, Ext.apply({}, me.escapeDefaultProperty(sheetId, row, j)), null, true, "clear");
												}
											}
										}
									}
								}
								var json = store.getCell(sheetId, 0, j);
								if(!skipDisabled || !store.isDisabledForMe(json.dsd)) {
									var countMemeber = SCOM.countObjMember(json);
									if(0 < countMemeber) {
										if(json.tpl) {
											if(1 != countMemeber) {
												store.setCell(sheetId, 0, j, Ext.copyTo({}, json, ["tpl"]), null, true, "clear");
											}
										} else {
											store.setCell(sheetId, 0, j, null, null, true, "clear");
										}
									}
								}
							}
						}
					} else if(0 == span[4]) {
						for(var i = span[1]; i <= span[3]; i++) {
							if(!avoidRange || !avoidRange.isIncluded(sheetId, i, 0)) {
								var cols = [];
								store.each(function(rd) {
									if(rd.data.sheet == sheetId) {
										var row = rd.data.row,
											col = rd.data.col;
										if(i == row && 0 != col) {
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)) {
												var needDefault = false;
												var colJson = store.getCell(sheetId, 0, col),
													dsd = colJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)) {
													countMemeber = SCOM.countObjMember(colJson);
													if(1 < countMemeber || 1 == countMemeber && !colJson.hasOwnProperty("tpl")) {
														needDefault = true;
													}
													var json = rd.data.json;
													dsd = dsd || json.dsd;
													if(!store.isDisabledForMe(dsd) && skipDisabled) {
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}
													if(!skipDisabled || !store.isDisabledForMe(dsd)) {
														if(needDefault) {
															var property = {};
															if(json && json.tpl) {
																property.tpl = json.tpl;
															}
															store.setCell(sheetId, row, col, Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col)), null, true, "clear");
														} else {
															countMemeber = SCOM.countObjMember(json);
															if(0 < countMemeber) {
																if(json.tpl) {
																	if(1 != countMemeber) {
																		store.setCell(sheetId, row, col, {
																			tpl: json.tpl
																		}, null, true, "clear");
																	}
																} else {
																	store.setCell(sheetId, row, col, null, null, true, "clear");
																}
															}
														}
													}
												}
											}
										} else if(0 == row && 0 != col) {
											cols.push(rd);
										}
									}
								}, store);
								for(var j = 0, len = cols.length; j < len; j++) {
									var c = cols[j];
									var col = c.data.col;
									if(!store.getRecord(sheetId, i, col)) {
										var json = store.getCell(sheetId, 0, col),
											dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled) {
											var cell = store.getCell(sheetId, i, 0);
											dsd = cell.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)) {
											var countMemeber = SCOM.countObjMember(json);
											if(0 < countMemeber) {
												if(!json.tpl || 1 != countMemeber) {
													store.setCell(sheetId, i, col, Ext.apply({}, me.escapeDefaultProperty(sheetId, i, col)), null, true, "clear");
												}
											}
										}
									}
								}
								var json = store.getCell(sheetId, i, 0);
								if(!skipDisabled || !store.isDisabledForMe(json.dsd)) {
									var countMemeber = SCOM.countObjMember(json);
									if(0 < countMemeber) {
										if(json.tpl) {
											if(1 != countMemeber) {
												store.setCell(sheetId, i, 0, Ext.copyTo({}, json, ["tpl"]), null, true, "clear");
											}
										} else {
											store.setCell(sheetId, i, 0, null, null, true, "clear");
										}
									}
								}
							}
						}
					} else {
						for(var i = span[1]; i <= span[3]; i++) {
							for(var j = span[2]; j <= span[4]; j++) {
								if(!avoidRange || !avoidRange.isIncluded(sheetId, i, j)) {
									var needDefault = false;
									var rowJson = store.getCell(sheetId, i, 0);
									var dsd = rowJson.dsd;
									if(!skipDisabled || !store.isDisabledForMe(dsd)) {
										var colJson = store.getCell(sheetId, 0, j);
										dsd = dsd || colJson.dsd;
										if(!skipDisabled || !store.isDisabledForMe(dsd)) {
											var countMemeber = SCOM.countObjMember(rowJson);
											if(1 < countMemeber || 1 == countMemeber && !rowJson.hasOwnProperty("tpl")) {
												needDefault = true;
											} else {
												countMemeber = SCOM.countObjMember(colJson);
												if(1 < countMemeber || 1 == countMemeber && !colJson.hasOwnProperty("tpl")) {
													needDefault = true;
												}
											}
											var rd = store.getRecord(sheetId, i, j);
											var json = rd ? rd.data.json : {};
											dsd = dsd || json.dsd;
											if(!skipDisabled || !store.isDisabledForMe(dsd)) {
												if(needDefault) {
													var property = {};
													if(json && json.tpl) {
														property.tpl = json.tpl;
													}
													store.setCell(sheetId, i, j, Ext.apply(property, me.escapeDefaultProperty(sheetId, i, j)), null, true, "clear");
												} else {
													if(rd) {
														countMemeber = SCOM.countObjMember(json);
														if(0 < countMemeber) {
															if(json.tpl) {
																if(1 != countMemeber) {
																	store.setCell(sheetId, i, j, Ext.copyTo({}, json, ["tpl"]), null, true, "clear");
																}
															} else {
																store.setCell(sheetId, i, j, null, null, true, "clear");
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				ss.splitCdt(this.getCoord(), originCdts);
				if(!suspendRefresh) {
					if(this.isCellCoord()) {
						Ext.apply(changedHeights, ss.checkAutoHeightForCoord(undefined, this.coord, false, true));
					}
					this.refresh(reCalCells, undefined, concatCoord);
				}
			};
			var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
			if(!suspendEvent) {
				if(false !== ss.fireEvent("beforecleanrange", this, null, ss)) {
					var originCdts = ss.getCdtsFromCoord(this.coord);
					var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
					var result = ss.getRelatedCdtCoord(this.coord);
					var changedHeights = {};
					ss.fireEvent("preparecleanrange", this, null, ss, originCdts, reCalCells, changedHeights, result.coord);
					var concatCoord = ss.processRelatedCdt(this.coord, true, result);
					fn.call(this, originCdts, reCalCells, changedHeights, concatCoord);
					ss.fireEvent("cleanrange", this, null, ss, originCdts, reCalCells);
				}
			} else {
				var originCdts = ss.getCdtsFromCoord(this.coord);
				var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
				var result = ss.getRelatedCdtCoord(this.coord);
				var concatCoord = ss.processRelatedCdt(this.coord, true, result);
				fn.call(this, originCdts, reCalCells, undefined, concatCoord);
			}
		},
		cleanContent: function(suspendEvent, avoidRange, suspendRefresh) {
			var ss = this.sheet;
			var fn = function(reCalCells, changedHeights, concatCoord) {
				var store = ss.getStore();
				var deleted = EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.contentRelatedProperty.concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.stylesWithoutMini);
				store.walkRange(this.coord, function(rd) {
					if(rd.data.row || rd.data.col) {
						if(!SCOM.isEmptyObj(rd.data.json) && !store.isDisabledCell(rd.data.sheet, rd.data.row, rd.data.col)) {
							if(!avoidRange || !avoidRange.isIncluded(rd.data.sheet, rd.data.row, rd.data.col)) {
								store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, deleted, true);
							}
						}
					}
				}, this);
				if(this.isCellCoord()) {
					Ext.apply(changedHeights, ss.checkAutoHeightForCoord(undefined, this.coord, false, true));
				}
				if(!suspendRefresh) {
					this.refresh(reCalCells, undefined, concatCoord);
				}
			};
			var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
			if(!suspendEvent) {
				if(false !== ss.fireEvent("beforecleanrange", this, "content", ss)) {
					var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
					var result = ss.getRelatedCdtCoord(this.coord);
					var changedHeights = {};
					ss.fireEvent("preparecleanrange", this, "content", ss, undefined, reCalCells, changedHeights, result.coord);
					var concatCoord = ss.processRelatedCdt(this.coord, true, result);
					fn.call(this, reCalCells, changedHeights, concatCoord);
					ss.fireEvent("cleanrange", this, "content", ss, undefined, reCalCells);
				}
			} else {
				var reCalCells = ss.getRecalculateCellsByCoord(this.coord);
				var result = ss.getRelatedCdtCoord(this.coord);
				var concatCoord = ss.processRelatedCdt(this.coord, true, result);
				fn.call(this, reCalCells, undefined, concatCoord);
			}
		},
		cleanStyle: function(suspendEvent, avoidRange, suspendRefresh, skipDisabled) {
			if(false !== skipDisabled) {
				skipDisabled = true;
			}
			var me = this;
			var ss = this.sheet;
			var fn = function() {
				var store = ss.getStore();
				var keepProperties = ["data", "display", "cal", "arg", "value", "timestamp", "afrow", "afcol", "aerow", "aecol", "cdt", "tpl", "width", "woff", "height", "hoff"].concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.styles);
				var coord = this.coord;
				for(var k = 0, size = coord.length; k < size; k++) {
					var span = coord[k],
						sheetId = span[0];
					var cell = store.getCell(sheetId, 0, 0),
						dsd = cell.dsd;
					if(skipDisabled && store.isDisabledForMe(dsd)) {
						continue;
					}
					if(0 == span[3] && 0 == span[4]) {
						if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, 0)) {
							store.each(function(rd) {
								if(rd.data.sheet == sheetId) {
									var row = rd.data.row,
										col = rd.data.col;
									if(0 != row || 0 != col) {
										if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)) {
											var json = rd.data.json,
												dsd = json.dsd;
											if(!store.isDisabledForMe(dsd)) {
												var pro = store.getCellProperty(sheetId, row, col);
												dsd = pro.dsd;
											}
											if(!skipDisabled || !store.isDisabledForMe(dsd)) {
												var md = Ext.copyTo({}, json, keepProperties);
												store.setCell(sheetId, row, col, md, null, true, "clear");
											}
										}
									}
								}
							}, store);
							var cell = store.getCell(sheetId, 0, 0);
							if(!skipDisabled || !store.isDisabledForMe(cell.dsd)) {
								store.setCell(sheetId, 0, 0, Ext.copyTo({}, store.getCell(sheetId, 0, 0), keepProperties.concat(store.avoidMembers)), null, true, "clear");
							}
						}
					} else if(0 == span[3]) {
						for(var j = span[2]; j <= span[4]; j++) {
							if(!avoidRange || !avoidRange.isIncluded(sheetId, 0, j)) {
								var rows = [];
								store.each(function(rd) {
									if(rd.data.sheet == sheetId) {
										var row = rd.data.row,
											col = rd.data.col;
										if(j == col && 0 != row) {
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)) {
												var rowJson = store.getCell(sheetId, row, 0),
													dsd = rowJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)) {
													var needDefault = store.withStyleProperty(rowJson);
													var json = rd.data.json;
													if(!dsd && skipDisabled) {
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}
													if(!skipDisabled || !store.isDisabledForMe(dsd)) {
														var property = {};
														if(json) {
															Ext.copyTo(property, json, keepProperties);
														}
														if(needDefault) {
															Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col));
														}
														store.setCell(sheetId, row, col, property, null, true, "clear");
													}
												}
											}
										} else if(0 == col && 0 != row) {
											rows.push(rd);
										}
									}
								}, store);
								for(var i = 0, len = rows.length; i < len; i++) {
									var r = rows[i];
									var row = r.data.row;
									if(!store.getRecord(sheetId, row, j)) {
										var json = store.getCell(sheetId, row, 0),
											dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled) {
											var cell = store.getCell(sheetId, 0, j);
											dsd = cell.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)) {
											if(store.withStyleProperty(json)) {
												store.setCell(sheetId, row, j, Ext.apply({}, me.escapeDefaultProperty(sheetId, row, j)), null, true, "clear");
											}
										}
									}
								}
								var json = store.getCell(sheetId, 0, j);
								if(!skipDisabled || !store.isDisabledForMe(json.dsd)) {
									if(store.withStyleProperty(json)) {
										var property = Ext.copyTo({}, json, keepProperties);
										store.setCell(sheetId, 0, j, property, null, true, "clear");
									}
								}
							}
						}
					} else if(0 == span[4]) {
						for(var i = span[1]; i <= span[3]; i++) {
							if(!avoidRange || !avoidRange.isIncluded(sheetId, i, 0)) {
								var cols = [];
								store.each(function(rd) {
									if(rd.data.sheet == sheetId) {
										var row = rd.data.row,
											col = rd.data.col;
										if(i == row && 0 != col) {
											if(!avoidRange || !avoidRange.isIncluded(sheetId, row, col)) {
												var colJson = store.getCell(sheetId, 0, col),
													dsd = colJson.dsd;
												if(!skipDisabled || !store.isDisabledForMe(dsd)) {
													var needDefault = store.withStyleProperty(colJson);
													var json = rd.data.json,
														dsd = json.dsd;
													if(!store.isDisabledForMe(dsd) && skipDisabled) {
														var pro = store.getCellProperty(sheetId, row, col);
														dsd = pro.dsd;
													}
													if(!skipDisabled || !store.isDisabledForMe(dsd)) {
														var property = {};
														if(json) {
															Ext.copyTo(property, json, keepProperties);
														}
														if(needDefault) {
															Ext.apply(property, me.escapeDefaultProperty(sheetId, row, col));
														}
														store.setCell(sheetId, row, col, property, null, true, "clear");
													}
												}
											}
										} else if(0 == row && 0 != col) {
											cols.push(rd);
										}
									}
								}, store);
								for(var j = 0, len = cols.length; j < len; j++) {
									var c = cols[j];
									var col = c.data.col;
									if(!store.getRecord(sheetId, i, col)) {
										var json = store.getCell(sheetId, 0, col),
											dsd = json.dsd;
										if(!store.isDisabledForMe(dsd) && skipDisabled) {
											var cell = store.getCell(sheetId, i, 0);
											dsd = cell.dsd;
										}
										if(!skipDisabled || !store.isDisabledForMe(dsd)) {
											if(store.withStyleProperty(json)) {
												store.setCell(sheetId, i, col, Ext.apply({}, me.escapeDefaultProperty(sheetId, i, col)), null, true, "clear");
											}
										}
									}
								}
								var json = store.getCell(sheetId, i, 0),
									dsd = json.dsd;
								if(!skipDisabled || !store.isDisabledForMe(dsd)) {
									if(store.withStyleProperty(json)) {
										var property = Ext.copyTo({}, json, keepProperties);
										store.setCell(sheetId, i, 0, property, null, true, "clear");
									}
								}
							}
						}
					} else {
						for(var i = span[1]; i <= span[3]; i++) {
							for(var j = span[2]; j <= span[4]; j++) {
								if(!avoidRange || !avoidRange.isIncluded(sheetId, i, j)) {
									var rowJson = store.getCell(sheetId, i, 0),
										dsd = rowJson.dsd;
									if(!skipDisabled || !store.isDisabledForMe(dsd)) {
										var needDefault = store.withStyleProperty(rowJson);
										var colJson = store.getCell(sheetId, 0, j);
										dsd = dsd || colJson.dsd;
										if(!skipDisabled || !store.isDisabledForMe(dsd)) {
											if(!needDefault) {
												needDefault = store.withStyleProperty(colJson);
											}
											var rd = store.getRecord(sheetId, i, j);
											var json = rd ? rd.data.json : null;
											var property = {};
											if(json) {
												dsd = dsd || json.dsd;
												Ext.copyTo(property, json, keepProperties);
											}
											if(!skipDisabled || !store.isDisabledForMe(dsd)) {
												if(needDefault) {
													Ext.apply(property, me.escapeDefaultProperty(sheetId, i, j));
												}
												store.setCell(sheetId, i, j, property, null, true, "clear");
											}
										}
									}
								}
							}
						}
					}
				}
				if(this.isCellCoord()) {
					ss.checkAutoHeightForCoord(undefined, this.coord, false, true);
				}
				if(!suspendRefresh) {
					this.refresh();
				}
			};
			if(!suspendEvent) {
				if(false !== ss.fireEvent("beforecleanrange", this, "style", ss)) {
					ss.fireEvent("preparecleanrange", this, "style", ss);
					fn.call(this);
					ss.fireEvent("cleanrange", this, "style", ss);
				}
			} else {
				fn.call(this);
			}
		},
		isInSingleSheet: function() {
			var sheet = null;
			for(var i = 0, len = this.coord.length; i < len; i++) {
				var span = this.coord[i];
				if(null === sheet) {
					sheet = span[0];
				} else if(sheet != span[0]) {
					return false;
				}
			}
			return true;
		},
		getMinPos: function(skipHidden) {
			var ss = this.sheet,
				store = ss.getStore();
			var minrow = null,
				mincol = null;
			for(var i = 0, len = this.coord.length; i < len; i++) {
				var span = this.coord[i],
					sheetId = span[0];
				if(null === minrow) {
					if(!skipHidden || store.isVisibleRow(sheetId, span[1])) {
						minrow = span[1];
					}
				} else if(minrow > span[1]) {
					if(!skipHidden || store.isVisibleRow(sheetId, span[1])) {
						minrow = span[1];
					}
				}
				if(null === mincol) {
					if(!skipHidden || store.isVisibleColumn(sheetId, span[2])) {
						mincol = span[2];
					}
				} else if(mincol > span[2]) {
					if(!skipHidden || store.isVisibleColumn(sheetId, span[2])) {
						mincol = span[2];
					}
				}
			}
			return {
				row: minrow,
				col: mincol
			};
		},
		getMaxPos: function() {
			var maxrow = null,
				maxcol = null;
			for(var i = 0, len = this.coord.length; i < len; i++) {
				var span = this.coord[i];
				if(null === maxrow) {
					maxrow = span[3];
				} else if(maxrow < span[3]) {
					maxrow = span[3];
				}
				if(null === maxcol) {
					maxcol = span[4];
				} else if(maxcol < span[4]) {
					maxcol = span[4];
				}
			}
			return {
				row: maxrow,
				col: maxcol
			};
		},
		moveCoord: function(sheetId, rowOffset, colOffset) {
			for(var i = 0, len = this.coord.length; i < len; i++) {
				var span = this.coord[i];
				if(false !== sheetId) {
					span[0] = sheetId;
				}
				span[1] = span[1] + rowOffset;
				span[2] = span[2] + colOffset;
				span[3] = span[3] + rowOffset;
				span[4] = span[4] + colOffset;
			}
		},
		reverseCoord: function() {
			for(var i = 0, len = this.coord.length; i < len; i++) {
				var span = this.coord[i];
				var tmp = span[3] - span[1];
				span[3] = span[1] + span[4] - span[2];
				span[4] = span[2] + tmp;
			}
		},
		select: function() {
			if(Ext.isFunction(this.sheet.getSelectionModel)) {
				if(0 < this.coord.length) {
					var span = this.coord[0];
					if(span[0] == this.sheet.getSheetId()) {
						this.sheet.getSelectionModel().selectRange({
							row: span[1],
							col: span[2]
						}, {
							row: span[3],
							col: span[4]
						});
					}
				}
			}
		},
		clone: function() {
			return new EnterpriseSheet.pure.sheet.range.Range({
				sheet: this.sheet,
				coord: this.getCoord()
			});
		},
		mergeCoord: function(coord, suspendRefresh) {
			this.coord = this.coord || [];
			for(var i = 0, len = coord.length; i < len; i++) {
				this.coord.push([].concat(coord[i]));
			}
			if(!suspendRefresh) {
				this.refresh();
			}
		},
		isIncluded: function(sheet, row, col, coord) {
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++) {
				var it = coord[i];
				var span = it.span ? it.span : it;
				if(sheet == span[0] && ((row <= span[3] || 0 === span[3]) && row >= span[1]) && (col <= span[4] || 0 === span[4]) && col >= span[2]) {
					return true;
				}
			}
			return false;
		},
		findIncludedSpan: function(sheet, row, col, coord) {
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++) {
				var it = coord[i];
				var span = it.span ? it.span : it;
				if(sheet == span[0] && ((row <= span[3] || 0 === span[3]) && row >= span[1]) && (col <= span[4] || 0 === span[4]) && col >= span[2]) {
					return {
						span: span,
						index: i
					};
				}
			}
		},
		isCoordIncludeSpan: function(coord, span) {
			for(var i = 0, len = coord.length; i < len; i++) {
				var it = coord[i];
				if(it[0] === span[0] && it[1] <= span[1] && it[2] <= span[2] && (0 === it[3] || it[3] >= span[3]) && (0 === it[4] || it[4] >= span[4])) {
					return true;
				}
			}
			return false;
		},
		isCoordAIncludeCoordB: function(a, b) {
			var pro = EnterpriseSheet.pure.sheet.range.Range.prototype;
			for(var i = 0, len = b.length; i < len; i++) {
				var span = b[i];
				if(!pro.isCoordIncludeSpan(a, span)) {
					return false;
				}
			}
			return true;
		},
		isCellCoord: function(coord) {
			coord = coord || this.coord;
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				if(0 !== span[3] && 0 !== span[4]) {
					return true;
				}
			}
			return false;
		},
		expandSpanWithContent: function(span, sheet) {
			var sheetId = span[0],
				minrow = span[1],
				mincol = span[2],
				maxrow = span[3],
				maxcol = span[4];
			var store = sheet.getStore();
			if(0 === maxrow && 0 === maxcol) {
				store.each(function(rd) {
					var row = rd.data.row,
						col = rd.data.col;
					if(rd.data.sheet === sheetId && 0 !== row && 0 !== col) {
						var data = rd.data.json.data;
						if(!SCOM.nullOrUndefined(data) && "" !== data) {
							if(row < minrow || 0 === minrow) {
								minrow = row;
							}
							if(row > maxrow || 0 === maxrow) {
								maxrow = row;
							}
							if(col < mincol || 0 === mincol) {
								mincol = col;
							}
							if(col > maxcol || 0 === maxcol) {
								maxcol = col;
							}
						}
					}
				});
				return [sheetId, minrow, mincol, maxrow, maxcol];
			} else if(0 === maxrow) {
				store.walkRange([span], function(rd) {
					var row = rd.data.row,
						col = rd.data.col;
					if(rd.data.sheet === sheetId && 0 !== row && 0 !== col) {
						var data = rd.data.json.data;
						if(!SCOM.nullOrUndefined(data) && "" !== data) {
							if(row < minrow || 0 === minrow) {
								minrow = row;
							}
							if(col < mincol) {
								mincol = col;
							}
							if(col > maxcol) {
								maxcol = col;
							}
						}
					}
				});
				return [sheetId, minrow, mincol, maxrow, maxcol];
			} else if(0 === maxcol) {
				store.walkRange([span], function(rd) {
					var row = rd.data.row,
						col = rd.data.col;
					if(rd.data.sheet === sheetId && 0 !== row && 0 !== col) {
						var data = rd.data.json.data;
						if(!SCOM.nullOrUndefined(data) && "" !== data) {
							if(col < mincol || 0 === mincol) {
								mincol = col;
							}
							if(col > maxcol || 0 === maxcol) {
								maxcol = col;
							}
							if(row < minrow) {
								minrow = row;
							}
							if(row > maxrow) {
								maxrow = row;
							}
						}
					}
				});
				if(span[1] === span[3]) {
					maxrow = 0;
				}
				return [sheetId, minrow, mincol, maxrow, maxcol];
			} else {
				if(minrow === maxrow) {
					return [sheetId, minrow, mincol, 0, maxcol];
				} else {
					return span;
				}
			}
		},
		expandCell2Around: function(sheetId, row, col, sheet) {
			var separateChar = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar;
			var store = sheet.getStore();
			var minrow = row,
				maxrow = row,
				mincol = col,
				maxcol = col;
			var arr = [sheetId, row, col];
			var id = arr.join(separateChar);
			var lookup = {
					id: arr
				},
				visited = {
					id: true
				};
			var extend = function() {
				for(var p in lookup) {
					if(lookup.hasOwnProperty(p)) {
						var it = lookup[p];
						var s = it[0],
							r = it[1],
							c = it[2];
						var sr = r,
							er = r + 1,
							sc = c,
							ec = c + 1;
						if(1 < r) {
							sr--;
						}
						if(1 < c) {
							sc--;
						}
						for(var i = sr; i <= er; i++) {
							for(var j = sc; j <= ec; j++) {
								var arr = [s, i, j];
								var id = arr.join(separateChar);
								if(!visited[id]) {
									visited[id] = true;
									var cell = store.getCell(s, i, j);
									var merged = store.isMergedCell(cell, s, i, j),
										wminrow, wmincol, wmaxrow, wmaxcol;
									if(merged) {
										wminrow = i + cell.minrow;
										wmincol = j + cell.mincol;
										wmaxrow = i + cell.maxrow;
										wmaxcol = j + cell.maxcol;
										cell = store.getCell(s, wminrow, wmincol);
									}
									if(!SCOM.nullOrUndefined(cell.data) && "" !== cell.data) {
										lookup[id] = arr;
										if(merged) {
											for(var x = wminrow; x <= wmaxrow; x++) {
												for(var y = wmincol; y <= wmaxcol; y++) {
													var tmp = [s, x, y];
													var wid = tmp.join(separateChar);
													if(!visited[wid]) {
														lookup[wid] = tmp;
													}
												}
											}
										}
										if(i < minrow) {
											minrow = i;
										}
										if(i > maxrow) {
											maxrow = i;
										}
										if(j < mincol) {
											mincol = j;
										}
										if(j > maxcol) {
											maxcol = j;
										}
									}
								}
							}
						}
						delete lookup[p];
						break;
					}
				}
				if(!SCOM.isEmptyObj(lookup)) {
					extend();
				}
			};
			extend();
			return [sheetId, minrow, mincol, maxrow, maxcol];
		}
	});
});

Ext.define("EnterpriseSheet.pure.sheet.Basic", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.pure.common.CONST", "EnterpriseSheet.pure.common.Common", "EnterpriseSheet.pure.sheet.data.Format", "EnterpriseSheet.pure.sheet.range.Range", "EnterpriseSheet.pure.sheet.data.RollingStore"],
	processingDataChangeBuffer: 50,
	isSheetUI: function() {
		return this.sheetUIFlag;
	},
	beforeConstructor: function() {
		this.store = this.store || new EnterpriseSheet.pure.sheet.data.RollingStore({
			url: this.url
		});
	},
	afterConstructor: function() {
		this.prepareCalculate();
		if(!this.disableDynamicRange) {
			this.dynamicRange = new EnterpriseSheet.pure.sheet.data.DynamicRange({
				sheet: this
			});
		}
		this.store.relayEvents(this, ["freezechange", "splitchange", "afterloadsheet"]);
		this.relayEvents(this.store, ["beforesortspan", "preparesortspan", "sortspan", "valuechange"]);
	},
	constructor: function(config) {
		Ext.apply(this, config);
		this.beforeConstructor();
		EnterpriseSheet.pure.sheet.Basic.prototype.superclass.constructor.apply(this, arguments);
		this.afterConstructor();
		this.bindListeners();
	},
	getSheetId: function() {
		return this.sheetId;
	},
	prepareCalculate: function() {
		if(!this.disableCalculate) {
			this.calculate = new EnterpriseSheet.pure.sheet.calculate.Calculate;
			this.calculate.init(this);
		}
		if(!this.disableCondition) {
			this.condition = new EnterpriseSheet.pure.sheet.calculate.Condition;
			this.condition.init(this);
		}
	},
	bindListeners: function() {
		this.store.on({
			scope: this,
			beforeafterload: this.beforeAfterLoad,
			afterload: this.afterLoad,
			beforeremovecell: this.beforeRemoveCell,
			beforeinsertcell: this.beforeInsertCell,
			beforeremoverow: this.beforeRemoveRow,
			beforeinsertrow: this.beforeInsertRow,
			beforeremovecolumn: this.beforeRemoveColumn,
			beforeinsertcolumn: this.beforeInsertColumn,
			holdremoverow: this.holdRemoveRow,
			holdremovecolumn: this.holdRemoveColumn,
			holdremovecell: this.holdRemoveCell,
			holdinsertrow: this.holdInsertRow,
			holdinsertcolumn: this.holdInsertColumn,
			holdinsertcell: this.holdInsertCell,
			renamesheet: this.afterRenameSheet,
			deletesheet: this.afterDeleteSheet,
			namedfuncconfigchange: this.onNameFuncConfigChange,
			setcell2update: this.onSetCell2Update,
			disconnectserver: this.onLostConnection,
			connectserver: this.onConnectServer
		});
		if(this.enableRowColGroup) {
			this.store.on({
				scope: this,
				processcolumngroup: this.processColumnGroup,
				processrowgroup: this.processRowGroup
			});
		}
		this.store.on("datachange", this.onDataChange, this);
	},
	onLostConnection: function() {
		if(!Ext.isDefined(this.originReadOnly)) {
			this.originReadOnly = this.readOnly || false;
		}
		this.setReadOnly(true);
	},
	onConnectServer: function() {
		this.setReadOnly(this.originReadOnly);
	},
	setReadOnly: function(readOnly) {
		this.readOnly = readOnly;
		this.fireEvent("changereadonly", readOnly, this);
	},
	onSetCell2Update: function(origin, current, store, sheetId, row, col) {
		var originData = origin.data,
			currentData = current.data;
		if(!Ext.isDefined(originData)) {
			originData = "";
		}
		if(!Ext.isDefined(currentData)) {
			currentData = "";
		}
		if(origin.vname === current.vname) {
			if(current.vname && originData !== currentData) {
				var cell = this.getCellValue(sheetId, row, col);
				store.setFileConfig("var", current.vname, cell.data);
			}
		} else {
			if(origin.vname) {
				store.setFileConfig("var", origin.vname);
			}
			if(current.vname) {
				var cell = this.getCellValue(sheetId, row, col);
				store.setFileConfig("var", current.vname, cell.data);
			}
		}
	},
	onNameFuncConfigChange: function(refStr, store, changed, cdts) {
		var cellCoord = [];
		for(var p in changed) {
			if(changed.hasOwnProperty(p) && "deleted" !== changed[p]) {
				var it = cdts[p];
				if(it.refs) {
					cellCoord = cellCoord.concat(it.refs);
				}
				var arr = it.jsonArr;
				for(var i = 0, len = arr.length; i < len; i++) {
					var obj = arr[i];
					delete obj.value;
				}
			}
		}
		store.checkLoadCoord(cellCoord, function() {
			this.refreshCalCdt(this.findNameRefCells(changed) || {});
		}, this);
	},
	afterRenameSheet: function(sheetId, newName) {
		if(this.loadMask) {
			this.loadMask.show();
		}
		Ext.Function.defer(function() {
			var tab = this.store.getSheetById(sheetId);
			this.resetAllCalculates(tab, undefined, function() {
				if(this.loadMask) {
					this.loadMask.hide();
				}
			}, this);
		}, 1, this);
	},
	afterDeleteSheet: function(sheetId, deletedSheet) {
		if(this.loadMask) {
			this.loadMask.show();
		}
		Ext.Function.defer(function() {
			this.resetAllCalculates(undefined, deletedSheet.name, function() {
				if(this.loadMask) {
					this.loadMask.hide();
				}
			}, this);
		}, 1, this);
	},
	deleteSheet: function() {
		var store = this.getStore();
		store.deleteSheet.apply(store, arguments);
	},
	resetAllCalculates: function(changedTab, deletedTabName, callback, scope) {
		var changedTabName, oldTabName;
		if(changedTab) {
			changedTabName = changedTab.name;
			oldTabName = changedTab.lastOldName;
		}
		var me = this,
			store = this.getStore();
		var changed = {},
			needCheckNamedFunc = {};
		if(this.calculate) {
			store.eachCalAndNamedFunc(function(rd, internalId) {
				var json = rd.data.json;
				if(json.cal && json.data) {
					var flag = !oldTabName && !deletedTabName,
						data = json.data;
					if(!flag && oldTabName && -1 !== data.indexOf(oldTabName)) {
						flag = true;
					}
					if(!flag && deletedTabName && -1 !== data.indexOf(deletedTabName)) {
						flag = true;
					}
					if(flag) {
						if(rd.named_func) {
							var id = rd.named_func;
							var old = Ext.apply({}, json);
							old.data = "=beval(" + old.data + ")";
							var modified = me.resetCalculateCellData(old, rd.data.sheet, rd.data.row, rd.data.col, undefined, undefined, undefined, true, undefined, changedTabName);
							var data = modified.data;
							if(data != old.data || modified.arg != old.arg) {
								modified.data = data.slice(7, -1);
								needCheckNamedFunc[id] = needCheckNamedFunc[id] || {
									jsonArr: []
								};
								var tmp = {
									cal: modified.data,
									arg: modified.arg,
									refs: modified.refs,
									scope: old.scope
								};
								needCheckNamedFunc[id].jsonArr.push(tmp);
								if(modified.arg != old.arg) {
									changed[id] = "named_func";
								}
							}
						} else {
							var old = Ext.apply({}, json);
							var modified = me.resetCalculateCellData(old, rd.data.sheet, rd.data.row, rd.data.col, undefined, undefined, undefined, true, undefined, changedTabName);
							var data = modified.data;
							if(data != old.data || modified.arg != old.arg) {
								store.setCell(rd.data.sheet, rd.data.row, rd.data.col, modified, null, true);
								if(modified.arg != old.arg) {
									changed[internalId] = [rd.data.sheet, rd.data.row, rd.data.col];
								}
							}
						}
					}
				}
			});
		}
		if(!SCOM.isEmptyObj(needCheckNamedFunc)) {
			for(var p in needCheckNamedFunc) {
				if(needCheckNamedFunc.hasOwnProperty(p)) {
					var nfConfig = store.mergeNamedFuncConfig(p, needCheckNamedFunc[p]);
					store.setNamedFuncConfig(p, nfConfig, undefined, true);
				}
			}
			store.checkReferenceString();
		}
		if(changed) {
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange(null, changed);
			} else {
				this.refreshCalCdt(changed, true);
			}
			if(callback) {
				callback.call(scope);
			}
		} else {
			if(callback) {
				callback.call(scope);
			}
		}
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	beforeAfterLoad: function(store) {
		var calculate = this.calculate,
			lookup = [];
		calculate.calCacheMap.empty();
		store.eachCal(function(rec) {
			var json = rec.data.json;
			if(json.cal) {
				calculate.transferCalculate(json, store, rec.data.sheet, rec.data.row, rec.data.col);
				if(json.refs) {
					lookup = lookup.concat(json.refs);
				}
			}
		}, this);
		var nameRefs = store.getNamedFuncConfigLookup();
		for(var p in nameRefs) {
			if(nameRefs.hasOwnProperty(p)) {
				var it = nameRefs[p];
				if(it.refs) {
					lookup = lookup.concat(it.refs);
				}
			}
		}
		store.checkLoadCoord(lookup, function() {
			store.afterLoad();
		}, this, true);
		return false;
	},
	afterLoad: function() {
		var store = this.getStore();
		var sheetId = store.getActivedSheetId();
		this.sheetId = sheetId;
		this.fireEvent("afterloadsheet", this.store, this);
	},
	onDataChange: function(timestamp, sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh) {
		var reCalCells = {};
		this.fireEvent("datachange", timestamp, sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh, reCalCells);
		var res = this.processDataChange(sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh, undefined, reCalCells);
		if(this.afterDataChange) {
			this.afterDataChange.apply(this, arguments);
		}
		return res;
	},
	findNameRefCellsByCoord: function(coord) {
		var store = this.getStore();
		var nameRefs = store.getNamedFuncConfigLookup();
		var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var changed = {},
			names = {};
		for(var p in nameRefs) {
			if(nameRefs.hasOwnProperty(p)) {
				var it = nameRefs[p];
				var refs = it.refs;
				if(refs && coordPro.isOverlappedCoord(coord, refs)) {
					changed[p] = it;
					names[p] = it;
				}
			}
		}
		for(var p in nameRefs) {
			if(nameRefs.hasOwnProperty(p)) {
				var it = nameRefs[p];
				if("named_func" === it.ctype) {
					for(var q in names) {
						if(names.hasOwnProperty(q)) {
							if(this.isCalIncludedName(it.json, q)) {
								changed[p] = it;
							}
						}
					}
				}
			}
		}
		var obj = {};
		if(!SCOM.isEmptyObj(changed)) {
			store.eachCal(function(rd, internalId) {
				var json = rd.data.json;
				if(json.cal) {
					for(var p in changed) {
						if(changed.hasOwnProperty(p)) {
							if(this.isCalIncludedName(json.data, p)) {
								obj[internalId] = [rd.data.sheet, rd.data.row, rd.data.col];
								break;
							}
						}
					}
				}
			}, this);
		}
		return obj;
	},
	findNameRefCells: function(changed) {
		var store = this.getStore();
		var calPro = EnterpriseSheet.pure.sheet.calculate.Calculate.prototype;
		var obj = {};
		if(!SCOM.isEmptyObj(changed)) {
			store.eachCal(function(rd, internalId) {
				var json = rd.data.json;
				if(json.cal) {
					for(var p in changed) {
						if(changed.hasOwnProperty(p)) {
							if(this.isCalIncludedName(json.data, p)) {
								obj[internalId] = [rd.data.sheet, rd.data.row, rd.data.col];
								break;
							}
						}
					}
				}
			}, this);
		}
		return obj;
	},
	isCalIncludedName: function(cal, name) {
		if(-1 !== cal.indexOf(name)) {
			return true;
		}
	},
	getRelatedCdtCoord: function(coords) {
		return this.getStore().getRelatedCdtCoord(coords);
	},
	processRelatedCdt: function(coords, skipReCal, relatedCdtResults, callback, scope) {
		var sep = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.separator;
		var result = relatedCdtResults || this.getRelatedCdtCoord(coords),
			store = this.getStore(),
			visited = {},
			mergeds = [];
		var cdtCoord = result.coord,
			spanCdtMap = result.spanCdtMap;
		this.clearCdtValueForCoord(coords);
		if(0 < cdtCoord.length) {
			this.clearCdtValForSpanCdt(spanCdtMap);
			var cells = {};
			store.walkRange(cdtCoord.concat(coords), function(rec, walkSpan, store, internalId) {
				var id = internalId;
				if(!cells[id]) {
					cells[id] = rec;
					var json = rec.data.json,
						s = rec.data.sheet;
					if(Ext.isNumber(json.abminrow)) {
						var abMinRow = json.abminrow,
							abMinCol = json.abmincol,
							abMaxRow = json.abmaxrow,
							abMaxCol = json.abmaxcol;
						var span = [s, abMinRow, abMinCol, abMaxRow, abMaxCol];
						var mid = span.join("sep");
						if(!visited[mid]) {
							visited[mid] = true;
							mergeds.push(span);
						}
					}
				}
			}, this, true);
			if(!skipReCal) {
				var timestamp = SCOM.genTimeStamp();
				SCOM.eachLimitDefer(SCOM.transferObj2Arr(cells), function(rec) {
					var s = rec.data.sheet,
						r = rec.data.row,
						c = rec.data.col;
					store.setCell(s, r, c, {
						timestamp: timestamp
					}, undefined, true);
					this.processCalCdtData(s, r, c);
				}, this, function() {
					if(callback) {
						callback.call(scope);
					}
				}, this, 1000, 5);
			}
		}
		return cdtCoord.concat(mergeds);
	},
	clearValueForCalCells: function(cells) {
		if(!SCOM.isEmptyObj(cells)) {
			var store = this.getStore(),
				lookup = {},
				timestamp = SCOM.genTimeStamp();
			for(var p in cells) {
				if(cells.hasOwnProperty(p)) {
					if("named_func" === cells[p]) {
						store.clearValueForNamedFunc(p);
					} else {
						var cell = store.getRecord(p);
						if(cell) {
							var json = cell.data.json;
							if(json.cal) {
								store.setCell(cell.data.sheet, cell.data.row, cell.data.col, {
									timestamp: timestamp,
									lastVal: json.value
								}, ["value"], true);
							}
						}
					}
				}
			}
		}
	},
	clearCdtValueForCoord: function(coord) {
		this.getStore().clearCdtForCoord(coord);
	},
	clearCdtValForSpanCdt: function(spanCdtMap) {
		var store = this.getStore(),
			timestamp = SCOM.genTimeStamp();
		for(var p in spanCdtMap) {
			if(spanCdtMap.hasOwnProperty(p)) {
				var it = spanCdtMap[p];
				var span = it.span,
					cdtIds = it.cdtIds;
				store.walkRange([span], function(rec, walkSpan, store, internalId) {
					var cdtVal = rec.data.json.cdtVal;
					if(cdtVal) {
						for(var q in cdtIds) {
							if(cdtIds.hasOwnProperty(q)) {
								delete cdtVal[q];
							}
						}
					}
					store.setCell(rec.data.sheet, rec.data.row, rec.data.col, {
						timestamp: timestamp,
						cdtVal: cdtVal
					}, undefined, true);
				}, this, true);
			}
		}
	},
	clearValueForCoord: function(coord) {
		var deleteStyles = ["value"];
		var store = this.getStore(),
			timestamp = SCOM.genTimeStamp(),
			lookup = {};
		store.walkRange(coord, function(rec, walkSpan, store, internalId) {
			lookup[internalId] = rec;
		}, this, true);
		for(var p in lookup) {
			if(lookup.hasOwnProperty(p)) {
				var rec = lookup[p],
					json = rec.data.json;
				store.setCell(rec.data.sheet, rec.data.row, rec.data.col, {
					timestamp: timestamp,
					lastVal: json.value
				}, deleteStyles, true);
			}
		}
	},
	getChangedLoadedCells: function(cells) {
		var store = this.getStore(),
			lookup = {};
		for(var p in cells) {
			if(cells.hasOwnProperty(p)) {
				var cell = store.getRecord(p);
				if(cell) {
					var json = cell.data.json;
					if(!SCOM.isEmptyValue(json.data)) {
						lookup[p] = cells[p];
					}
				}
			}
		}
		return lookup;
	},
	cacheLastTimeStamp: function(timestamp) {
		this.lastTimestamp = timestamp;
	},
	getLastTimestamp: function() {
		return this.lastTimestamp;
	},
	reprocessAllCalCdtCells: function(skipUpdateValue, callback, scope) {
		var deleteCdtStyles = ["cdtVal"].concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.styles);
		var deleteCalCdtStyles = ["value"].concat(deleteCdtStyles);
		var store = this.getStore(),
			me = this,
			sep = store.separateChar;
		var sid = this.getSheetId();
		var arr = [],
			visited = {};
		store.eachCal(function(rd, cid) {
			var s = rd.data.sheet,
				r = rd.data.row,
				c = rd.data.col,
				cell = rd.data.json;
			if(0 != r && 0 != c && cell.data) {
				var cal = me.isCalculateCell(cell);
				if(cal) {
					visited[cid] = {
						pos: [s, r, c],
						cal: true
					};
				}
			}
		}, this);
		var cdts = store.getConditionBySheet(sid);
		for(var i = 0, len = cdts.length; i < len; i++) {
			var cdt = cdts[i],
				rng = cdt.rng;
			for(var j = 0, count = rng.length; j < count; j++) {
				var span = rng[j].span;
				if(sid === span[0]) {
					for(var r = span[1]; r <= span[3]; r++) {
						for(var c = span[2]; c <= span[4]; c++) {
							var pos = [sid, r, c],
								cid = pos.join(sep);
							if(visited[cid]) {
								visited[cid].cdt = true;
							} else {
								visited[cid] = {
									pos: pos,
									cdt: true
								};
							}
						}
					}
				}
			}
		}
		var items = [];
		for(var p in visited) {
			if(visited.hasOwnProperty(p)) {
				items.push(visited[p]);
			}
		}
		SCOM.eachLimitDefer(items, function(it) {
			var pos = it.pos,
				cal = it.cal,
				cdt = it.cdt;
			var s = pos[0],
				r = pos[1],
				c = pos[2];
			cell = store.getCell(s, r, c, true);
			var scope = {
				store: store,
				sheet: s,
				row: r,
				col: c,
				timestamp: cell.timestamp
			};
			var md, deleted;
			if(cal) {
				md = {
					lastVal: cell.value
				};
				if(cdt) {
					deleted = deleteCalCdtStyles;
					store.setCell(s, r, c, md, deleted, true);
					me.processCalculate(cell, scope, skipUpdateValue);
					me.processCondition(cell, scope, skipUpdateValue);
				} else {
					deleted = ["value"];
					store.setCell(s, r, c, md, deleted, true);
					me.processCalculate(cell, scope, skipUpdateValue);
				}
			} else {
				deleted = deleteCdtStyles;
				store.setCell(s, r, c, md, deleted, true);
				me.processCondition(cell, scope, skipUpdateValue);
			}
			if(sid === s) {
				arr.push([s, r, c, r, c]);
			}
		}, this, function() {
			if(callback) {
				callback.call(scope, arr);
			}
		}, this, 1000, 5);
	},
	getherCells: function(s, r, c, myReCals, visitedCals, id, skipUpdateValue) {
		var store = this.getStore(),
			me = this,
			scope = {};
		var cell, namedFunc;
		if("named_func" === r) {
			namedFunc = c;
			cell = {
				cal: true,
				data: namedFunc.cal,
				arg: namedFunc.arg,
				refs: namedFunc.refs,
				lastVal: namedFunc.lastVal,
				value: namedFunc.value
			};
			r = -1;
			c = -1;
			skipUpdateValue = "named_func";
			scope.from = "named_func";
		} else {
			cell = store.getCell(s, r, c, true);
		}
		Ext.apply(scope, {
			store: store,
			sheet: s,
			row: r,
			col: c,
			timestamp: cell.timestamp
		});
		var cal = me.isCalculateCell(cell);
		if(cal) {
			var oldVal = cell.lastVal;
			var curVal;
			if(Ext.isDefined(cell.value)) {
				curVal = cell.value;
			} else {
				if(store.isMergedCell(cell, s, r, c)) {
					scope.row += cell.minrow;
					scope.col += cell.mincol;
				}
				var obj = me.calculate.processCalculate(cell, scope, skipUpdateValue);
				curVal = obj.value;
			}
			if(!SCOM.compareValue(oldVal, curVal)) {
				me.fireEvent("checkvaluechange", s, r, c, me, oldVal, curVal);
				var changedCalCells;
				if("named_func" === skipUpdateValue) {
					changedCalCells = me.findDirectRecalculateCellsOfCell(id);
				} else {
					changedCalCells = me.findDirectRecalculateCellsOfCell(s, r, c);
				}
				if(!SCOM.isEmptyObj(changedCalCells)) {
					var tmp = {};
					for(var p in changedCalCells) {
						if(changedCalCells.hasOwnProperty(p)) {
							if(!visitedCals.hasOwnProperty(p)) {
								tmp[p] = changedCalCells[p];
								visitedCals[p] = tmp[p];
							}
						}
					}
					me.clearValueForCalCells(tmp);
					Ext.apply(myReCals, tmp);
				}
			}
			false;
		}
	},
	reprocessCalCells: function(reCals, skipUpdateValue, callback, cbScope) {
		var me = this,
			sep = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.separator;
		var arr = [];
		var store = me.getStore();
		var sid = me.getSheetId();
		var newReCals = {};
		var checkFn = function() {
			if(!SCOM.isEmptyObj(newReCals)) {
				reCals = newReCals;
				newReCals = {};
				loopFn(checkFn, me);
			} else {
				if(callback) {
					callback.call(cbScope, arr);
				}
			}
		};
		var loopFn = function(fn, fnScope) {
			var cells = [];
			for(var p in reCals) {
				if(reCals.hasOwnProperty(p)) {
					var pos = reCals[p];
					if("named_func" === pos) {
						cells.push(p);
						arr.push(p);
					} else {
						var s = pos[0],
							r = pos[1],
							c = pos[2];
						if(0 != r && 0 != c) {
							cells.push([s, r, c, p]);
							arr.push([s, r, c, r, c]);
						} else {
							store.walkRange([
								[s, r, c, r, c]
							], function(rd, walkSpan, store, internalId) {
								var iRow = rd.data.row,
									iCol = rd.data.col,
									cell = rd.data.json;
								if(iRow && iCol) {
									cells.push([s, iRow, iCol, internalId]);
									arr.push([s, iRow, iCol, iRow, iCol]);
								}
							}, me, true);
						}
					}
				}
			}
			SCOM.eachLimitDefer(cells, function(it) {
				if(Ext.isString(it)) {
					var nf = store.getNamedFuncConfigByName(it);
					if(nf) {
						var jsonArr = nf.jsonArr;
						for(var i = 0, len = jsonArr.length; i < len; i++) {
							var json = jsonArr[i];
							me.getherCells.call(me, json.scope, "named_func", json, newReCals, reCals, it, skipUpdateValue);
						}
					}
				} else {
					me.getherCells.call(me, it[0], it[1], it[2], newReCals, reCals, it[3], skipUpdateValue);
				}
			}, me, fn, fnScope, 1000, 5);
		};
		loopFn(checkFn, this);
	},
	findDirectRecalculateCellsOfCell: function() {
		var store = this.getStore();
		var cells = store.getDirectRelatedCells.apply(store, arguments);
		return cells;
	},
	findAllRecalculateCellsOfCell: function(sheet, row, col) {
		var store = this.getStore();
		return store.getAllRelatedCells(sheet, row, col);
	},
	findDirectRecalculateCellsForCells: function(cells) {
		var reCalCells = {};
		for(var p in cells) {
			if(cells.hasOwnProperty(p)) {
				var pos = cells[p];
				Ext.apply(reCalCells, this.findDirectRecalculateCellsOfCell(pos[0], pos[1], pos[2]));
			}
		}
		return reCalCells;
	},
	getRecalculateCellsByCoord: function(coord) {
		var store = this.getStore();
		var found = store.getDirectRelatedCellsForCoord(coord);
		return found;
	},
	recalculateCalCdtCells: function(reCals, skipUpdateValue, callback, scope) {
		this.reprocessCalCells(reCals, skipUpdateValue, function(ret) {
			if(reCals && this.highlightCellsAfterCalculate) {
				this.fireEvent("highlightcells", ret, this);
			}
			if(callback) {
				callback.call(scope, ret);
			}
		}, this);
	},
	//2018 3.30 zdw 增加关联公式格子实际数据更新到后台的方法
	updateReCalCells:function(reCalCells){
		var store = this.getStore();
		var array = new Array();
		for (var p in reCalCells) {
			var cell = store.getRecord(p);
			if (cell && cell.data.json.cal) {
				
				var o = {
					action: "updateReCalCell",
					sheetId: cell.data.sheet,
					row: cell.data.row,
					col: cell.data.col,
					calvalue:cell.data.json.value
				};
				array.push(o);
			}
		}
		
		if (array.length>0) {
			Ext.Ajax.request({
				url: SCONFIG.urls.update,
				params: {
					fileId:store.fileId,
					actions:Ext.JSON.encode(array)
				},
				success: function(response, options) {
	
				}
			});
		}
	},
	processDataChange: function(sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh, skipUpdateValue, reCalCells) {
		originJson = originJson || {};
		currentJson = currentJson || {};
		var timestamp = SCOM.genTimeStamp();
		var scope = {
			store: store,
			sheet: sheet,
			row: row,
			col: col,
			timestamp: timestamp
		};
		var coord = [
			[sheet, row, col, row, col]
		];
		var cell = store.getCellData(sheet, row, col),
			me = this;
		var oldVal = originJson.cal ? originJson.value : originJson.data,
			oldItchk = originJson.itchk;
		if(!SCOM.isEmptyValue(oldVal)) {
			oldVal = oldVal.toString();
		}
		var isCal = me.isCalculateCell(cell);
		var updateFn = function() {
			me.clearValueForCalCells(reCalCells);
			me.recalculateCalCdtCells(reCalCells, skipUpdateValue, function(ret) {
				var curPos = [sheet, row, col],
					curCellId = curPos.join(store.separateChar);
				reCalCells[curCellId] = curPos;
				if(ret) {
					ret = ret.concat(coord);
				} else {
					ret = coord;
				}
				var cdtCoord = me.processRelatedCdt(ret);
				var expandedCoord = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.expand2Around(cdtCoord);
				if(expandedCoord) {
					ret = ret.concat(expandedCoord);
				} else {
					ret = null;
				}
				if(me.refreshAfterDataChange) {
					me.refreshAfterDataChange(ret);
				}
			}, this);
			//2018 3.30 zdw 增加关联公式格子实际数据更新到后台的方法
			me.updateReCalCells(reCalCells);
			
		};
		var checkRelatedFn = function() {
			var reCals = me.findDirectRecalculateCellsOfCell(sheet, row, col);
			if(reCalCells) {
				Ext.apply(reCalCells, reCals);
			} else {
				reCalCells = reCals;
			}
			if(me.maskBeforeCalculating) {
				Ext.Function.defer(updateFn, 5, me);
				me.maskBeforeCalculating(SLANG.calculating, 10 > SCOM.countObjMember(reCalCells) ? me.calMaskDelayTime : false);
			} else {
				updateFn();
			}
		};
		var fn = function() {
			delete cell.value;
			cell = me.processCalculate(cell, scope);
			var curVal = cell.value;
			if(!SCOM.isEmptyValue(curVal)) {
				curVal = curVal.toString();
			}
			if(curVal !== oldVal) {
				checkRelatedFn();
			} else {
				if(me.refreshAfterDataChange) {
					me.refreshAfterDataChange(coord);
				}
			}
		};
		if(isCal) {
			var refs = cell.refs;
			if(refs) {
				if(me.maskBeforeCalculating) {
					me.maskBeforeCalculating(SLANG.calculating, me.calMaskDelayTime);
				}
				store.checkLoadCoord(refs, fn, this);
			} else {
				fn();
			}
		} else if(currentJson.data !== oldVal || currentJson.itchk !== oldItchk) {
			checkRelatedFn();
		}
	},
	getCalculate: function() {
		return this.calculate;
	},
	getCondition: function() {
		return this.condition;
	},
	isCalculateCell: function(cell, sheetId, row, col) {
		if(this.calculate) {
			if(!cell) {
				cell = this.getStore().getCell(sheetId, row, col);
			}
			return false !== SCOM.typeOf(cell.cal);
		}
		return false;
	},
	isConditionCell: function(cell, sheetId, row, col) {
		if(this.condition) {
			return cell.cdtVal || cell.dcfg || this.getStore().isConditionCell(sheetId, row, col);
		}
		return false;
	},
	processCalculate: function(cell, scope, skipUpdateValue) {
		var store = this.getStore();
		try {
			if(this.calculate && this.isCalculateCell(cell)) {
				if(store.isLoadingCells() || false != SCOM.typeOf(cell.value)) {
					cell.data = cell.value;
				} else {
					if(store.isMergedCell(cell, scope.sheet, scope.row, scope.col)) {
						scope.row += cell.minrow;
						scope.col += cell.mincol;
					}
					cell = this.calculate.processCalculate(cell, scope, skipUpdateValue);
				}
				var data = cell.data;
				if(Ext.isNumber(data)) {
					var digitalLen = HELPER.getDigitalLen(data);
					if(digitalLen > 13) {
						data = HELPER.roundUpNonZero(data);
					}
					cell.data = data;
				}
				if(Ext.isObject(data) && data._isExp) {
					if(this.processCalculateException) {
						var exp = this.processCalculateException(data, scope);
						delete exp.expTip;
						Ext.apply(cell, exp);
					}
				} else if(Ext.isString(cell.data)) {
					cell.data = "html" === cell.datatype ? cell.data : Ext.htmlEncode(cell.data);
				}
				if(!cell.fm) {
					cell.fm = "regular";
				}
			} else {
				cell.data = "html" === cell.datatype ? cell.data : Ext.htmlEncode(cell.data);
			}
			if(Ext.isString(cell.data)) {
				cell.data = cell.data.replace(/\n/gi, "<br/>");
			}
			return cell;
		} catch(e) {
			if(Ext.isObject(e) && e._isExp) {
				if(this.processCalculateException) {
					var exp = this.processCalculateException(e, scope);
					delete exp.expTip;
					Ext.apply(cell, exp);
				}
			} else {
				cell.data = e;
			}
			return cell;
		}
	},
	processCondition: function(cell, scope, skipUpdateValue) {
		var store = this.getStore();
		try {
			if(this.isConditionCell(cell, scope.sheet, scope.row, scope.col)) {
				if(store.isLoadingCells()) {
					cell = this.applyCondition(cell);
				} else {
					if(store.isMergedCell(cell, scope.sheet, scope.row, scope.col)) {
						if(0 === cell.minrow && 0 === cell.mincol) {
							cell = this.condition.processCondition(cell, scope, skipUpdateValue);
							cell = this.applyCondition(cell);
						} else {
							scope.row += cell.minrow;
							scope.col += cell.mincol;
							var leftTopCell = store.getCell(scope.sheet, scope.row, scope.col);
							if(leftTopCell.cdtVal) {
								cell.cdtVal = SCOM.copy(leftTopCell.cdtVal);
								cell = this.applyCondition(cell);
							}
						}
					} else {
						cell = this.condition.processCondition(cell, scope, skipUpdateValue);
						cell = this.applyCondition(cell);
					}
				}
			}
			if(!SCOM.nullOrUndefined(cell.allow)) {
				cell.data = cell.allow;
			}
			return cell;
		} catch(e) {
			cell.data = e;
			return cell;
		}
	},
	refreshCalCdt: function(reCalCells, suspendRefresh, skipUpdateValue, coord, callback, scope, skipClearValue) {
		var me = this;
		var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		if(Ext.isObject(reCalCells)) {
			var ret = [];
			if(!SCOM.isEmptyObj(reCalCells)) {
				if(!skipClearValue) {
					this.clearValueForCalCells(reCalCells);
				}
				this.recalculateCalCdtCells(reCalCells, skipUpdateValue, function(ret) {
					if(Ext.isArray(coord)) {
						ret = ret.concat(coord);
					}
					var cdtCoord = me.processRelatedCdt(ret);
					ret = ret.concat(cdtCoord);
					if(!suspendRefresh) {
						if(Ext.isFunction(me.refreshRange)) {
							me.refreshRange(ret);
						}
					}
					if(callback) {
						callback.call(scope, ret);
					}
				}, this);
			} else {
				if(Ext.isArray(coord)) {
					ret = ret.concat(coord);
					var cdtCoord = me.processRelatedCdt(ret);
					ret = ret.concat(cdtCoord);
					if(!suspendRefresh) {
						if(Ext.isFunction(me.refreshRange)) {
							me.refreshRange(ret);
						}
					}
				}
				if(callback) {
					callback.call(scope, ret);
				}
			}
		} else {
			this.reprocessAllCalCdtCells(undefined, function(ret) {
				if(!suspendRefresh) {
					if(Ext.isFunction(this.refreshRange)) {
						this.refreshRange(ret);
					}
				}
				if(callback) {
					callback.call(scope, ret);
				}
			}, this);
		}
	},
	processCalCdtData: function(sheetId, row, col, cell, skipUpdateValue, region) {
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		if(!cell) {
			cell = store.getCellData(sheetId, row, col);
		}
		var scope = {
			store: store,
			sheet: sheetId,
			row: row,
			col: col,
			timestamp: cell.timestamp
		};
		cell = this.processCalculate(cell, scope, skipUpdateValue);
		cell = this.processCondition(cell, scope, skipUpdateValue);
		return cell;
	},
	getCellValue: function(sheetId, row, col, timestamp, withFormat) {
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var cell = store.getCellData(sheetId, row, col);
		var scope = {
			store: store,
			sheet: sheetId,
			row: row,
			col: col,
			timestamp: cell.timestamp
		};
		if(Ext.isFunction(this.processCellDataConfig)) {
			cell = this.processCellDataConfig(cell, scope);
		}
		cell = this.processCalculate(cell, scope);
		if(withFormat && 0 !== row && 0 !== col) {
			cell = SFORMAT.transferFormat(cell, cell.fm);
		}
		return cell;
	},
	mergeCell: function(span, suspendEvent, suspendRefresh) {
		this.doMergeCell(span, suspendEvent, suspendRefresh);
	},
	doMergeCell: function(span, suspendEvent, suspendRefresh) {
		var s = this.getStore();
		var sheetId = span[0],
			minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4];
		if(false == SCOM.typeOf(sheetId)) {
			span[0] = sheetId = this.getSheetId();
		}
		if(minrow != maxrow || mincol != maxcol) {
			var reCalCells = this.getRecalculateCellsByCoord([span]);
			for(var i = minrow; i <= maxrow; i++) {
				for(var j = mincol; j <= maxcol; j++) {
					s.setCell(sheetId, i, j, {
						minrow: minrow - i,
						mincol: mincol - j,
						maxrow: maxrow - i,
						maxcol: maxcol - j
					}, null, true, undefined, i === maxrow && j === maxcol ? false : true);
				}
			}
			if(!suspendRefresh) {
				if(Ext.isFunction(this.refreshRange)) {
					this.refreshRange([span], reCalCells);
				}
			}
			if(!suspendEvent) {
				this.fireEvent("mergecell", [].concat(span), this, reCalCells);
			}
		}
		if(Ext.isFunction(this.focus)) {
			this.focus(this.focusDelayTime);
		}
	},
	unmergeCell: function(span, suspendEvent, suspendRefresh) {
		this.doUnmergeCell(span, suspendEvent, suspendRefresh);
	},
	doUnmergeCell: function(span, suspendEvent, suspendRefresh) {
		var s = this.getStore();
		var sheetId = span[0],
			minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4];
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
			span[0] = sheetId;
		}
		var merges = {};
		var reCalCells = this.getRecalculateCellsByCoord([span]);
		for(var i = minrow; i <= maxrow; i++) {
			for(var j = mincol; j <= maxcol; j++) {
				var o = s.getCell(sheetId, i, j);
				if(s.isMergedCell(o, sheetId, i, j)) {
					var arr = [sheetId, i + o.minrow, j + o.mincol, i + o.maxrow, j + o.maxcol];
					merges[arr.join("$")] = arr;
					s.setCell(sheetId, i, j, null, ["minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol"], true, undefined, i === maxrow && j === maxcol ? false : true);
				}
			}
		}
		if(!SCOM.isEmptyObj(merges)) {
			if(!suspendRefresh) {
				if(this.refreshRange) {
					this.refreshRange([
						[sheetId, minrow, mincol, maxrow, maxcol]
					], reCalCells);
				}
			}
			if(!suspendEvent) {
				this.fireEvent("unmergecell", [sheetId, minrow, mincol, maxrow, maxcol], merges, this, reCalCells);
			}
		}
		if(Ext.isFunction(this.focus)) {
			this.focus(this.focusDelayTime);
		}
	},
	getStore: function() {
		return this.store;
	},
	transferCalCdt2ObjArr: function(calObj, cdtObj) {
		var store = this.getStore();
		var obj = {};
		if(calObj) {
			var tmp = [];
			for(var p in calObj) {
				if(calObj.hasOwnProperty(p)) {
					var it = calObj[p];
					if(!it.json && !it.jsonArr) {
						tmp.push(p);
					}
					if(Ext.isDefined(it.sheet)) {
						obj[p] = [it.sheet, it.row, it.col];
					} else if("named_func" === it.ctype) {
						obj[p] = "named_func";
					}
				}
			}
			for(var i = 0, len = tmp.length; i < len; i++) {
				delete calObj[tmp[i]];
			}
		}
		if(cdtObj) {
			for(var p in cdtObj) {
				if(cdtObj.hasOwnProperty(p)) {
					var it = cdtObj[p];
					var cdt = Ext.decode(it.json);
					if(cdt) {
						var rng = cdt.rng,
							coord;
						coord = [];
						for(var i = 0, len = rng.length; i < len; i++) {
							coord.push(rng[i].span);
						}
						store.walkRange(coord, function(rd, walkSpan, store, internalId) {
							var row = rd.data.row,
								col = rd.data.col;
							if(0 !== row && 0 !== col) {
								var id = internalId;
								if(!obj[id]) {
									obj[id] = [rd.data.sheet, row, col];
								}
							}
						}, this);
					}
				}
			}
		}
		return obj;
	},
	beforeRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store) {
		var brokens = store.getBrokenMergedCells(sheetId, minrow, maxrow, mincol, maxcol, "up" == moveDir ? "row" : "col");
		if(SCOM.countObjMember(brokens)) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.action_broken_merged);
			}
			return false;
		}
		if(store.isBrokenArrayFormulaCells(sheetId, minrow, maxrow, mincol, maxcol, "up" == moveDir ? "row" : "col")) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.can_not_only_change_part_of_array_formula);
			}
			return false;
		}
	},
	beforeInsertCell: function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store) {
		var brokens = store.getBrokenMergedCells(sheetId, row, row + rowSpan - 1, col, col + colSpan - 1, "down" == moveDir ? "row" : "col");
		if(SCOM.countObjMember(brokens)) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.action_broken_merged);
			}
			return false;
		}
		if(store.isBrokenArrayFormulaCells(sheetId, row, row + rowSpan - 1, col, col + colSpan - 1, "down" == moveDir ? "row" : "col")) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.can_not_only_change_part_of_array_formula);
			}
			return false;
		}
	},
	beforeRemoveRow: function(sheetId, minrow, maxrow, deleted, merged, store) {
		if(store.isBrokenArrayFormulaCells(sheetId, minrow, maxrow, 0, 0, "row")) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.can_not_only_change_part_of_array_formula);
			}
			return false;
		}
	},
	beforeRemoveColumn: function(sheetId, mincol, maxcol, deleted, merged, store) {
		if(store.isBrokenArrayFormulaCells(sheetId, 0, 0, mincol, maxcol, "col")) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.can_not_only_change_part_of_array_formula);
			}
			return false;
		}
	},
	beforeInsertRow: function(sheetId, row, rowSpan, merged, store) {
		if(store.isBrokenArrayFormulaCells(sheetId, row, row + rowSpan - 1, 0, 0, "row")) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.can_not_only_change_part_of_array_formula);
			}
			return false;
		}
	},
	beforeInsertColumn: function(sheetId, col, colSpan, merged, store) {
		if(store.isBrokenArrayFormulaCells(sheetId, 0, 0, col, col + colSpan - 1, "col")) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.can_not_only_change_part_of_array_formula);
			}
			return false;
		}
	},
	syncPageBreakForRemoveRow: function(sheetId, minrow, maxrow) {
		var store = this.getStore();
		var floatings = store.floatings,
			span = maxrow - minrow + 1,
			deleted = [],
			updated = [];
		for(var p in floatings) {
			if(floatings.hasOwnProperty(p)) {
				var it = floatings[p],
					jsonObj = it.jsonObj;
				if("pb" === it.ftype && sheetId === it.sheet) {
					var r = jsonObj.r,
						c = jsonObj.c;
					if(maxrow < r) {
						jsonObj.r -= span;
						updated.push(Ext.apply({}, it));
					} else if(minrow <= r) {
						deleted.push(Ext.apply({}, it));
					}
				}
			}
		}
		var config = {
			updated: updated,
			deleted: deleted
		};
		this.updatePageBreaks(config);
		return config;
	},
	updatePageBreaks: function(config, recoverFlag) {
		if(config) {
			var store = this.getStore();
			var updated = config.updated || [],
				deleted = config.deleted || [];
			if(recoverFlag) {
				for(var i = 0, len = updated.length; i < len; i++) {
					var it = updated[i];
					var name = ["pb", it.jsonObj.r, it.jsonObj.c].join("-");
					store.setFloatingItem(it.sheet, name, it.ftype);
					store.setFloatingItem(it.sheet, it.name, it.ftype, it.json);
				}
				for(var i = 0, len = deleted.length; i < len; i++) {
					var it = deleted[i];
					store.setFloatingItem(it.sheet, it.name, it.ftype, it.json);
				}
			} else {
				for(var i = 0, len = updated.length; i < len; i++) {
					var it = updated[i];
					var name = ["pb", it.jsonObj.r, it.jsonObj.c].join("-");
					store.setFloatingItem(it.sheet, it.name, it.ftype);
					store.setFloatingItem(it.sheet, name, it.ftype, Ext.encode(it.jsonObj));
				}
				for(var i = 0, len = deleted.length; i < len; i++) {
					var it = deleted[i];
					store.setFloatingItem(it.sheet, it.name, it.ftype);
				}
			}
		}
	},
	holdRemoveRow: function(sheetId, minrow, maxrow, deleted, merged, store) {
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate) {
			var obj = this.calculate.beforeRemoveRow(sheetId, minrow, maxrow);
			if(obj) {
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition) {
			var obj = this.condition.beforeRemoveRow(sheetId, minrow, maxrow);
			if(obj) {
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		var e = {};
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		var changedPbs = this.syncPageBreakForRemoveRow(sheetId, minrow, maxrow);
		this.fireEvent("holdremoverow", sheetId, minrow, maxrow, deleted, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, changedPbs);
		var needRefresh = Ext.isFunction(this.onRemoveRow) ? this.onRemoveRow(sheetId, minrow, maxrow) : false,
			refreshed;
		if(e.calCdt || needCalCdt) {
			this.refreshCalCdt(reCalCells, true);
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
				refreshed = true;
			}
		}
		if(Ext.isFunction(this.syncPageBreak)) {
			this.syncPageBreak();
		}
		if(refreshed) {
			return false;
		} else if(e.refresh && false !== needRefresh || true === needRefresh) {
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
			}
			return false;
		}
		if(e.stop || false === needRefresh) {
			return false;
		}
	},
	syncPageBreakForRemoveColumn: function(sheetId, mincol, maxcol) {
		var store = this.getStore();
		var floatings = store.floatings,
			span = maxcol - mincol + 1,
			deleted = [],
			updated = [];
		for(var p in floatings) {
			if(floatings.hasOwnProperty(p)) {
				var it = floatings[p],
					jsonObj = it.jsonObj;
				if("pb" === it.ftype && sheetId === it.sheet) {
					var r = jsonObj.r,
						c = jsonObj.c;
					if(maxcol < c) {
						jsonObj.c -= span;
						updated.push(Ext.apply({}, it));
					} else if(mincol <= c) {
						deleted.push(Ext.apply({}, it));
					}
				}
			}
		}
		var config = {
			updated: updated,
			deleted: deleted
		};
		this.updatePageBreaks(config);
		return config;
	},
	holdRemoveColumn: function(sheetId, mincol, maxcol, deleted, merged, store) {
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate) {
			var obj = this.calculate.beforeRemoveColumn(sheetId, mincol, maxcol);
			if(obj) {
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition) {
			var obj = this.condition.beforeRemoveColumn(sheetId, mincol, maxcol);
			if(obj) {
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		var e = {};
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		var changedPbs = this.syncPageBreakForRemoveColumn(sheetId, mincol, maxcol);
		this.fireEvent("holdremovecolumn", sheetId, mincol, maxcol, deleted, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, changedPbs);
		var needRefresh = Ext.isFunction(this.onRemoveColumn) ? this.onRemoveColumn(sheetId, mincol, maxcol) : false,
			refreshed;
		if(e.calCdt || needCalCdt) {
			this.refreshCalCdt(reCalCells, true);
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
				refreshed = true;
			}
		}
		if(Ext.isFunction(this.syncPageBreak)) {
			this.syncPageBreak();
		}
		if(refreshed) {
			return false;
		} else if(e.refresh && false !== needRefresh || true === needRefresh) {
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
			}
			return false;
		}
		if(e.stop || false === needRefresh) {
			return false;
		}
	},
	holdRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store) {
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt, deletedNameRef;
		if(this.calculate) {
			var obj = this.calculate.beforeRemoveCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir);
			if(obj) {
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
				deletedNameRef = obj.deletedNameRef;
			}
		}
		if(this.condition) {
			var obj = this.condition.beforeRemoveCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir);
			if(obj) {
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		var e = {};
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		this.fireEvent("holdremovecell", sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, deletedNameRef);
		var refreshed;
		if(e.calCdt || needCalCdt) {
			this.refreshCalCdt(reCalCells, true);
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
				refreshed = true;
			}
		}
		if(refreshed) {
			return false;
		} else if(e.refresh) {
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
			}
			return false;
		}
		if(e.stop) {
			return false;
		}
	},
	syncPageBreakForInsertRow: function(sheetId, row, rowSpan) {
		var store = this.getStore();
		var floatings = store.floatings,
			updated = [];
		for(var p in floatings) {
			if(floatings.hasOwnProperty(p)) {
				var it = floatings[p],
					jsonObj = it.jsonObj;
				if("pb" === it.ftype && sheetId === it.sheet) {
					var r = jsonObj.r,
						c = jsonObj.c;
					if(row <= r) {
						jsonObj.r += rowSpan;
						updated.push(Ext.apply({}, it));
					}
				}
			}
		}
		var config = {
			updated: updated
		};
		this.updatePageBreaks(config);
		return config;
	},
	holdInsertRow: function(sheetId, row, span, merged, store, insertCellCache, expandCalInNext) {
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate) {
			var obj = this.calculate.beforeInsertRow(sheetId, row, span, undefined, undefined, expandCalInNext);
			if(obj) {
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition) {
			var obj = this.condition.beforeInsertRow(sheetId, row, span);
			if(obj) {
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		var e = {};
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		var changedPbs = this.syncPageBreakForInsertRow(sheetId, row, span);
		this.fireEvent("holdinsertrow", sheetId, row, span, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, insertCellCache, changedPbs);
		var needRefresh = Ext.isFunction(this.onInsertRow) ? this.onInsertRow(sheetId, row, span) : false,
			refreshed;
		if(e.calCdt || needCalCdt) {
			this.refreshCalCdt(reCalCells, true);
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
				refreshed = true;
			}
		}
		if(Ext.isFunction(this.syncPageBreak)) {
			this.syncPageBreak();
		}
		if(refreshed) {
			return false;
		} else if(e.refresh && false !== needRefresh || true === needRefresh) {
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
			}
			return false;
		}
		if(e.stop || false === needRefresh) {
			return false;
		}
	},
	syncPageBreakForInsertColumn: function(sheetId, col, colSpan) {
		var store = this.getStore();
		var floatings = store.floatings,
			updated = [];
		for(var p in floatings) {
			if(floatings.hasOwnProperty(p)) {
				var it = floatings[p],
					jsonObj = it.jsonObj;
				if("pb" === it.ftype && sheetId === it.sheet) {
					var r = jsonObj.r,
						c = jsonObj.c;
					if(col <= c) {
						jsonObj.c += colSpan;
						updated.push(Ext.apply({}, it));
					}
				}
			}
		}
		var config = {
			updated: updated
		};
		this.updatePageBreaks(config);
		return config;
	},
	holdInsertColumn: function(sheetId, col, span, merged, store, insertCellCache) {
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate) {
			var obj = this.calculate.beforeInsertColumn(sheetId, col, span);
			if(obj) {
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition) {
			var obj = this.condition.beforeInsertColumn(sheetId, col, span);
			if(obj) {
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCdt;
			}
		}
		var e = {};
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		var changedPbs = this.syncPageBreakForInsertColumn(sheetId, col, span);
		this.fireEvent("holdinsertcolumn", sheetId, col, span, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, insertCellCache, changedPbs);
		var needRefresh = Ext.isFunction(this.onInsertColumn) ? this.onInsertColumn(sheetId, col, span) : false,
			refreshed;
		if(e.calCdt || needCalCdt) {
			this.refreshCalCdt(reCalCells, true);
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
				refreshed = true;
			}
		}
		if(Ext.isFunction(this.syncPageBreak)) {
			this.syncPageBreak();
		}
		if(refreshed) {
			return false;
		} else if(e.refresh && false !== needRefresh || true === needRefresh) {
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
			}
			return false;
		}
		if(e.stop || false === needRefresh) {
			return false;
		}
	},
	holdInsertCell: function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store, insertCellCache, expandCalInNext) {
		var oldCal, curCal, oldCdt, curCdt, oldCells, curCells, needCalCdt;
		if(this.calculate) {
			var obj = this.calculate.beforeInsertCell(sheetId, row, col, rowSpan, colSpan, moveDir, expandCalInNext);
			if(obj) {
				oldCal = obj.oldCal;
				curCal = obj.curCal;
				needCalCdt = obj.needRefreshCal;
			}
		}
		if(this.condition) {
			var obj = this.condition.beforeInsertCell(sheetId, row, col, rowSpan, colSpan, moveDir);
			if(obj) {
				oldCdt = obj.oldCdt;
				curCdt = obj.curCdt;
				oldCells = obj.oldCells;
				curCells = obj.curCells;
				needCalCdt = needCalCdt || obj.needRefreshCal;
			}
		}
		var e = {};
		var oldReCalCells = this.transferCalCdt2ObjArr(oldCal, oldCdt);
		var maxrow = row + rowSpan - 1,
			maxcol = col + colSpan - 1;
		var reCalCells = this.transferCalCdt2ObjArr(curCal, curCdt);
		this.fireEvent("holdinsertcell", sheetId, row, col, rowSpan, colSpan, moveDir, merged, e, this, oldCal, curCal, oldCdt, curCdt, oldCells, curCells, oldReCalCells, reCalCells, insertCellCache);
		var refreshed;
		if(e.calCdt || needCalCdt) {
			this.refreshCalCdt(reCalCells, true);
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
				refreshed = true;
			}
		}
		if(refreshed) {
			return false;
		} else if(e.refresh) {
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange();
			}
			return false;
		}
		if(e.stop) {
			return false;
		}
	},
	doCheckSortSpan: function(span, keys, dir, expand, allString, callback, scope) {
		if(span[1] === span[3] && span[2] === span[4] && 0 !== span[1] && 0 !== span[2] || 0 === span[1] && 0 === span[2]) {
			if(this.isSheetUI()) {
				Ext.Msg.show({
					title: SLANG.hint,
					msg: SLANG.can_not_sort_range,
					icon: Ext.Msg.INFO,
					buttons: Ext.Msg.OK
				});
			}
			return false;
		} else {
			allString = allString || false;
			expand = expand || false;
			dir = dir || "asc";
			var store = this.getStore(),
				withMerged = false;
			var tmpSpan = [].concat(span);
			if(expand) {
				tmpSpan[2] = tmpSpan[4] = 0;
			}
			store.walkRange([tmpSpan], function(rd) {
				var json = rd.data.json;
				if(store.isMergedCell(json, rd.data.sheet, rd.data.row, rd.data.col) || json.tpl) {
					withMerged = true;
					return false;
				}
			}, this, true);
			if(withMerged) {
				if(this.isSheetUI()) {
					Ext.Msg.show({
						title: SLANG.hint,
						msg: SLANG.can_not_sort_merged_or_table_tpl,
						icon: Ext.Msg.INFO,
						buttons: Ext.Msg.OK
					});
				}
				return false;
			} else {
				store.checkLoadCoord([span], function() {
					span = EnterpriseSheet.pure.sheet.range.Range.prototype.expandSpanWithContent(span, this);
					this.sortSpan(span, keys, dir, "col", expand, allString);
					if(callback) {
						callback.call(scope);
					}
				}, this);
			}
		}
	},
	sortSpan: function(span, keys, dir, sortOn, expand, allString, suspendRefresh, suspendEvent) {
		var store = this.getStore();
		var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var relatedRows;
		if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
			relatedRows = this.getRelatedRowsForAutoHeight([span], undefined, undefined, true);
		}
		var coord;
		if(expand) {
			coord = [
				[span[0], span[1], 0, span[3], 0]
			];
		} else {
			coord = [span];
		}
		var reCalCells = this.getRecalculateCellsByCoord(coord);
		var oldCals = {},
			newCals = {};
		var diff = store.sortSpan(span, keys, dir, sortOn, expand, allString, suspendEvent);
		store.walkRange(coord, function(rd, walkSpan, store, internalId) {
			var sid = rd.data.sheet,
				row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			var isCal = this.isCalculateCell(json);
			if(isCal) {
				var oldRow, oldCol;
				if("row" == sortOn) {
					oldCol = diff[rd.data.col];
				} else {
					oldRow = diff[rd.data.row];
				}
				if(SCOM.nullOrUndefined(oldRow)) {
					oldRow = row;
				}
				if(SCOM.nullOrUndefined(oldCol)) {
					oldCol = col;
				}
				var oldId = store.getIdBasedData({
					sheet: sid,
					row: oldRow,
					col: oldCol
				});
				var id = internalId;
				if(isCal) {
					if(oldRow !== row || oldCol !== col) {
						if(!oldCals[oldId]) {
							oldCals[oldId] = {
								sheet: sid,
								row: oldRow,
								col: oldCol,
								json: store.getCell(sid, row, col, true)
							};
						}
						var o = this.resetCalculateCellData(json, sid, row, col, undefined, oldRow, oldCol);
						store.setCell(sid, row, col, o, null, true);
						newCals[id] = {
							sheet: sid,
							row: row,
							col: col,
							json: store.getCell(sid, row, col, true)
						};
					}
				}
				if(!reCalCells[id]) {
					reCalCells[id] = [rd.data.sheet, rd.data.row, rd.data.col];
				}
			}
		}, this, true);
		if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
			Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([span]));
		}
		var changedHeights = {};
		if(Ext.isFunction(this.checkAutoHeightForRows)) {}
		if(!suspendEvent) {
			this.fireEvent("spansorted", span, keys, dir, null, expand, allString, reCalCells, oldCals, newCals, changedHeights, store, this);
		}
		if(!suspendRefresh) {
			this.refreshCalCdt(reCalCells, true);
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange(expand ? null : [span]);
			}
		}
		return diff;
	},
	autoExtendCondtion: function(sheetId, row, col) {
		var store = this.getStore();
		var changedCdt = {};
		if(1 < row) {
			var lastRow = row - 1;
			var cdt = this.getConditionOfCell(sheetId, lastRow, col);
			if(0 < cdt.length) {
				var changed = false;
				for(var i = 0, len = cdt.length; i < len; i++) {
					var condition = cdt[i];
					if(this.condition.isAutoExtendType(condition.name)) {
						var rng = condition.rng;
						for(var j = 0, size = rng.length; j < size; j++) {
							var it = rng[j];
							var span, stype;
							if(Ext.isArray(it)) {
								span = it;
								stype = SCONST.ABSOLUTE_COORD;
							} else {
								span = it.span;
								stype = it.type;
							}
							if(SCONST.RELATIVE_COORD == stype) {
								span[1] += lastRow;
								span[3] += lastRow;
								span[2] += col;
								span[4] += col;
							}
							if(0 != span[3] && 0 != span[4]) {
								if(span[3] + 1 == row && span[2] == col && span[4] == col) {
									span[3]++;
									changed = true;
									changedCdt[condition.id] = condition;
								}
							}
						}
					}
				}
				if(changed) {
					return changedCdt;
				}
			}
		}
		if(1 < col) {
			var lastCol = col - 1;
			var cdt = this.getConditionOfCell(sheetId, row, lastCol);
			if(0 < cdt.length) {
				var changed = false;
				for(var i = 0, len = cdt.length; i < len; i++) {
					var condition = cdt[i];
					if(this.condition.isAutoExtendType(condition.name)) {
						var rng = condition.rng;
						for(var j = 0, size = rng.length; j < size; j++) {
							var it = rng[j];
							var span, stype;
							if(Ext.isArray(it)) {
								span = it;
								stype = SCONST.ABSOLUTE_COORD;
							} else {
								span = it.span;
								stype = it.type;
							}
							if(SCONST.RELATIVE_COORD == stype) {
								span[1] += row;
								span[3] += row;
								span[2] += lastCol;
								span[4] += lastCol;
							}
							if(0 != span[3] && 0 != span[4]) {
								if(span[4] + 1 == col && span[1] == row && span[3] == row) {
									span[4]++;
									changed = true;
									changedCdt[condition.id] = condition;
								}
							}
						}
					}
				}
				if(changed) {
					return changedCdt;
				}
			}
		}
	},
	setCell: function(sheetId, row, col, modified, deleted, suspendRefresh) {
		var separateChar = EnterpriseSheet.pure.sheet.data.reader.CellReader.prototype.separateChar;
		var store = this.getStore();
		var cell = store.getCell(sheetId, row, col, true);
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
		}
		var isSameSheet = sheetId === this.getSheetId();
		deleted = deleted || [];
		deleted = deleted.concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.stylesWithoutMini);
		if(this.calculate && modified) {
			modified = this.calculate.transferCalculate(modified, store, sheetId, row, col);
			if(!this.isCalculateCell(modified)) {
				deleted = deleted.concat(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.calculateRelatedProperty);
			}
		}
		if(store.isMergedCell(cell, sheetId, row, col)) {
			var minrow = row + cell.minrow;
			var mincol = col + cell.mincol;
			store.setCell(sheetId, minrow, mincol, modified, deleted, suspendRefresh || !isSameSheet);
			if(Ext.isFunction(this.isTableTplHeader)) {
				if(this.isTableTplHeader(undefined, sheetId, minrow, mincol)) {
					this.processPlainForTplCell(sheetId, minrow, mincol);
				}
			}
		} else {
			var cdtChanged = false;
			var cellPro = store.getCellProperty(sheetId, row, col);
			if(deleted) {
				for(var i = 0, len = deleted.length; i < len; i++) {
					delete cellPro[deleted[i]];
				}
			}
			cellPro = Ext.apply(cellPro, modified);
			var reCalCells;
			if(modified && modified.data) {
				if(!modified.fm) {
					var fm = SFORMAT.decideFormat(modified.data);
					if(fm) {
						Ext.apply(modified, fm);
					}
				}
				var num = Number(modified.data);
				if(Ext.isNumber(num)) {
					var extendCdt = this.autoExtendCondtion(sheetId, row, col);
					if(extendCdt) {
						var changedCdt = extendCdt;
						reCalCells = this.getRecalculateCellsByCoord([
							[sheetId, row, col, row, col]
						]);
						this.fireEvent("prepareautoextendcdt", sheetId, row, col, changedCdt, this, reCalCells);
						for(var p in changedCdt) {
							if(changedCdt.hasOwnProperty(p)) {
								var it = changedCdt[p];
								store.setFloatingItem(sheetId, it.id, "cdt", Ext.encode(it));
							}
						}
						cdtChanged = true;
					}
				}
			}
			var suspendFlag = suspendRefresh;
			if(cdtChanged) {
				store.setCell(sheetId, row, col, modified, deleted, true);
				Ext.applyIf(reCalCells, this.getCalCdtCellsFromCoord([
					[sheetId, row, col, row, col]
				]));
				this.refreshCalCdt(reCalCells);
				this.fireEvent("autoextendcdt", sheetId, row, col, modified, deleted, this, reCalCells);
			} else {
				store.setCell(sheetId, row, col, modified, deleted, suspendFlag);
			}
			if(Ext.isFunction(this.isTableTplHeader)) {
				if(this.isTableTplHeader(undefined, sheetId, row, col)) {
					this.processPlainForTplCell(sheetId, row, col);
				}
			}
			if(!suspendFlag && Ext.isFunction(this.checkRowHeight)) {
				this.checkRowHeight(sheetId, row);
			}
		}
	},
	doInsertRow: function(sheetId, row, span, suspendEvent, insertCellCache) {
		var store = this.getStore();
		store.insertRow(sheetId, row, span, suspendEvent, insertCellCache);
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	doInsertColumn: function(sheetId, col, span, suspendEvent, insertCellCache) {
		var store = this.getStore();
		store.insertColumn(sheetId, col, span, suspendEvent, insertCellCache);
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	deleteCellMoveLeft: function(sheetId, pos) {
		var dir = "left";
		if(SCOM.nullOrUndefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var brokenMergeFlag = store.withBrokenMergedCell([
			[sheetId, minrow, mincol, maxrow, 0]
		]);
		if(!brokenMergeFlag) {
			var brokenTplFlag = store.withBrokenTplCell([
				[sheetId, minrow, mincol, maxrow, 0]
			]);
			if(!brokenTplFlag) {
				this.doDeleteCellMoveLeft(sheetId, minrow, maxrow, mincol, maxcol);
			} else {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.broken_tpl_cell_hint);
				}
			}
		} else {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.broken_merge_cell_hint);
			}
		}
	},
	doDeleteCellMoveLeft: function(sheetId, minrow, maxrow, mincol, maxcol, skipHidden) {
		var dir = "left";
		var store = this.getStore(),
			flag = false;
		if(skipHidden) {
			var ranges = [],
				start = false,
				end;
			for(var i = mincol; i <= maxcol; i++) {
				if(store.isVisibleColumn(sheetId, i)) {
					if(false === start) {
						start = i;
					}
					end = i;
				} else {
					flag = true;
					ranges.push({
						mincol: start,
						maxcol: end,
						minrow: minrow,
						maxrow: maxrow
					});
					start = false;
				}
			}
			if(false !== start) {
				ranges.push({
					mincol: start,
					maxcol: end,
					minrow: minrow,
					maxrow: maxrow
				});
			}
			if(flag) {
				this.processDeleteCellRangesMoveLeft(ranges);
			}
		}
		if(!flag) {
			var relatedRows;
			if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
				relatedRows = this.getRelatedRowsForAutoHeight([
					[sheetId, minrow, mincol, maxrow, 0]
				], undefined, undefined, true);
			}
			store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, dir);
			var changedHeights;
			if(Ext.isFunction(this.checkAutoHeightForRows)) {
				changedHeights = this.checkAutoHeightForRows(relatedRows);
			}
			this.fireEvent("cellremoved", sheetId, minrow, mincol, maxrow, maxcol, dir, changedHeights, this);
			if(Ext.isFunction(this.refreshFocus)) {
				this.refreshFocus();
			}
		}
	},
	deleteCellMoveTop: function(sheetId, pos) {
		var dir = "top";
		if(SCOM.nullOrUndefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var brokenMergeFlag = store.withBrokenMergedCell([
			[sheetId, minrow, mincol, 0, maxcol]
		]);
		if(!brokenMergeFlag) {
			var brokenTplFlag = store.withBrokenTplCell([
				[sheetId, minrow, mincol, 0, maxcol]
			]);
			if(!brokenTplFlag) {
				this.doDeleteCellMoveTop(sheetId, minrow, maxrow, mincol, maxcol);
			} else {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.broken_tpl_cell_hint);
				}
			}
		} else {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.broken_merge_cell_hint);
			}
		}
	},
	doDeleteCellMoveTop: function(sheetId, minrow, maxrow, mincol, maxcol, skipHidden) {
		var dir = "top";
		var store = this.getStore(),
			flag = false;
		if(skipHidden) {
			var ranges = [],
				start = false,
				end;
			for(var i = minrow; i <= maxrow; i++) {
				if(store.isVisibleRow(sheetId, i)) {
					if(false === start) {
						start = i;
					}
					end = i;
				} else {
					flag = true;
					ranges.push({
						minrow: start,
						maxrow: end,
						mincol: mincol,
						maxcol: maxcol
					});
					start = false;
				}
			}
			if(false !== start) {
				ranges.push({
					minrow: start,
					maxrow: end,
					mincol: mincol,
					maxcol: maxcol
				});
			}
			if(flag) {
				this.processDeleteCellRangesMoveTop(ranges);
			}
		}
		if(!flag) {
			var relatedRows;
			if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
				relatedRows = this.getRelatedRowsForAutoHeight([
					[sheetId, minrow, mincol, 0, maxcol]
				], undefined, undefined, true);
			}
			store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, dir);
			if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
				Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([
					[sheetId, minrow, mincol, 0, maxcol]
				], undefined, undefined, true));
			}
			var changedHeights;
			if(Ext.isFunction(this.checkAutoHeightForRows)) {
				changedHeights = this.checkAutoHeightForRows(relatedRows);
			}
			this.fireEvent("cellremoved", sheetId, minrow, mincol, maxrow, maxcol, dir, changedHeights, this);
			if(Ext.isFunction(this.refreshFocus)) {
				this.refreshFocus();
			}
		}
	},
	deleteCellRangesMoveTop: function(ranges) {
		var dir = "top";
		var sheetId = this.getSheetId();
		var store = this.getStore();
		for(var i = 0, len = ranges.length; i < len; i++) {
			var pos = ranges[i];
			var minrow = pos.minrow,
				maxrow = pos.maxrow,
				mincol = pos.mincol,
				maxcol = pos.maxcol;
			if(store.withBrokenMergedCell([
					[sheetId, minrow, mincol, 0, maxcol]
				])) {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.broken_merge_cell_hint);
				}
				return false;
			}
			if(store.withBrokenTplCell([
					[sheetId, minrow, mincol, 0, maxcol]
				])) {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.broken_tpl_cell_hint);
				}
				return false;
			}
		}
		this.doDeleteCellRangesMoveTop(ranges);
	},
	doDeleteCellRangesMoveTop: function(ranges) {
		this.processDeleteCellRangesMoveTop(ranges);
	},
	processDeleteCellRangesMoveTop: function(ranges) {
		var dir = "up";
		var sheetId = this.getSheetId();
		var store = this.getStore();
		if(false !== this.fireEvent("beforedeletecellrangemovetop", ranges, this)) {
			this.fireEvent("preparedeletecellrangemovetop", ranges, this);
			var count = 0;
			for(var i = 0, len = ranges.length; i < len; i++) {
				var pos = ranges[i];
				var minrow = pos.minrow - count,
					maxrow = pos.maxrow - count,
					mincol = pos.mincol,
					maxcol = pos.maxcol;
				var relatedRows;
				if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
					relatedRows = this.getRelatedRowsForAutoHeight([
						[sheetId, minrow, mincol, 0, maxcol]
					], undefined, undefined, true);
				}
				store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, dir);
				if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
					Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([
						[sheetId, minrow, mincol, 0, maxcol]
					], undefined, undefined, true));
				}
				var changedHeights;
				if(Ext.isFunction(this.checkAutoHeightForRows)) {
					changedHeights = this.checkAutoHeightForRows(relatedRows);
				}
				this.fireEvent("cellremoved", sheetId, minrow, mincol, maxrow, maxcol, dir, changedHeights, this);
				count += (maxrow - minrow + 1);
			}
			this.fireEvent("deletecellrangemovetop", ranges, this);
		}
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	processDeleteCellRangesMoveLeft: function(ranges) {
		var dir = "left";
		var sheetId = this.getSheetId();
		var store = this.getStore();
		if(false !== this.fireEvent("beforedeletecellrangemoveleft", ranges, this)) {
			this.fireEvent("preparedeletecellrangemoveleft", ranges, this);
			var count = 0;
			for(var i = 0, len = ranges.length; i < len; i++) {
				var pos = ranges[i];
				var minrow = pos.minrow,
					maxrow = pos.maxrow,
					mincol = pos.mincol - count,
					maxcol = pos.maxcol - count;
				var relatedRows;
				if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
					relatedRows = this.getRelatedRowsForAutoHeight([
						[sheetId, minrow, mincol, maxrow, maxcol]
					], undefined, undefined, true);
				}
				store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, dir);
				if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
					Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([
						[sheetId, minrow, mincol, maxrow, maxcol]
					], undefined, undefined, true));
				}
				var changedHeights;
				if(Ext.isFunction(this.checkAutoHeightForRows)) {
					changedHeights = this.checkAutoHeightForRows(relatedRows);
				}
				this.fireEvent("cellremoved", sheetId, minrow, mincol, maxrow, maxcol, dir, changedHeights, this);
				count += (maxcol - mincol + 1);
			}
			this.fireEvent("deletecellrangemoveleft", ranges, this);
		}
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	doDeleteRow: function(sheetId, minrow, maxrow, skipHidden) {
		var store = this.getStore();
		if(skipHidden) {
			var deleted = [];
			for(var i = minrow; i <= maxrow; i++) {
				if(store.isVisibleRow(sheetId, i)) {
					deleted.push(i);
				}
			}
			var dlen = deleted.length;
			if(dlen < maxrow - minrow + 1) {
				if(0 < dlen) {
					this.doDeleteRows(deleted, sheetId);
				}
			} else {
				store.removeRow(sheetId, minrow, maxrow);
			}
		} else {
			store.removeRow(sheetId, minrow, maxrow);
		}
	},
	deleteRows: function(deleted, sheetId) {
		this.doDeleteRows(deleted, sheetId);
	},
	doDeleteRows: function(deleted, sheetId) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		if(false !== this.fireEvent("beforedeleterows", deleted, this, sheetId)) {
			this.fireEvent("preparedeleterows", deleted, this);
			var store = this.getStore();
			for(var i = 0, len = deleted.length; i < len; i++) {
				var r = deleted[i] - i;
				store.removeRow(sheetId, r, r);
			}
			this.fireEvent("deleterows", deleted, this, sheetId);
		}
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	doDeleteColumn: function(sheetId, mincol, maxcol) {
		var store = this.getStore();
		var relatedRows;
		if(Ext.isFunction(this.getRelatedRowsForAutoHeight)) {
			relatedRows = this.getRelatedRowsForAutoHeight([
				[sheetId, 0, mincol, 0, maxcol]
			], undefined, undefined, true, true);
		}
		store.removeColumn(sheetId, mincol, maxcol);
		var changedHeights;
		if(Ext.isFunction(this.checkAutoHeightForRows)) {
			changedHeights = this.checkAutoHeightForRows(relatedRows);
		}
		this.fireEvent("columnremoved", sheetId, mincol, maxcol, changedHeights, this);
	},
	resetCalculateCellData: function(obj, sheetId, row, col, oldSheetId, oldRow, oldCol, force2Reset, reverse, changedTabName) {
		if(!Ext.isDefined(oldSheetId)) {
			oldSheetId = sheetId;
		}
		if(SCOM.nullOrUndefined(oldRow)) {
			oldRow = row;
		}
		if(SCOM.nullOrUndefined(oldCol)) {
			oldCol = col;
		}
		if(this.calculate) {
			if(force2Reset || !(oldRow === row && oldCol === col) || reverse) {
				var o = this.calculate.resetData(obj, this.getStore(), sheetId, row, col, oldSheetId, oldRow, oldCol, reverse, changedTabName);
				return o;
			}
		}
		return obj;
	},
	resetConditionCellData: function(obj, sheetId, row, col, oldSheetId, oldRow, oldCol) {
		if(!Ext.isDefined(oldSheetId)) {
			oldSheetId = sheetId;
		}
		if(!Ext.isDefined(oldRow)) {
			oldRow = row;
		}
		if(!Ext.isDefined(oldCol)) {
			oldCol = col;
		}
		if(this.condition) {
			return this.condition.resetConditionData(obj, this.getStore(), sheetId, row, col, oldSheetId, oldRow, oldCol);
		}
	},
	syncConditonForCoord: function(coord, cdts, cdtMap, oldCellCdtLookup) {
		var me = this;
		var store = this.getStore();
		var lookup = {};
		for(var p in cdts) {
			if(cdts.hasOwnProperty(p)) {
				lookup[p] = {
					rng: []
				};
			}
		}
		store.walkRange(coord, function(rd, walkSpan, store, internalId) {
			var sheetId = rd.data.sheet,
				row = rd.data.row,
				col = rd.data.col;
			var cdt = oldCellCdtLookup[internalId];
			if(cdt && 0 < cdt.length) {
				for(var i = 0, len = cdt.length; i < len; i++) {
					var it = cdt[i];
					var id = it.id;
					var newId = cdtMap[id].id;
					if(lookup[newId]) {
						lookup[newId].oldId = id;
						var rng = lookup[newId].rng;
						rng.push({
							span: [sheetId, row, col, row, col],
							type: SCONST.ABSOLUTE_COORD
						});
					}
				}
			}
		}, me);
		var needRefreshCdt;
		for(var p in lookup) {
			if(lookup.hasOwnProperty(p)) {
				var rng = lookup[p].rng,
					oldId = lookup[p].oldId;
				this.connectSpan(rng);
				if(cdtMap[oldId]) {
					var json = cdtMap[oldId].cdt,
						sheetId = cdtMap[oldId].sheet;
					json.rng = rng;
					json.id = p;
					store.setFloatingItem(sheetId, p, "cdt", Ext.encode(json));
					needRefreshCdt = true;
					break;
				}
			}
		}
		return needRefreshCdt;
	},
	getCdtsFromCoord: function(coord, decode) {
		var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
		var store = this.getStore();
		var lookup = {},
			cdts = store.getConditionLookup();
		store.walkRange(coord, function(rec) {
			var sheetId = rec.data.sheet,
				row = rec.data.row,
				col = rec.data.col;
			var cellCoord = [sheetId, row, col];
			for(var p in cdts) {
				if(cdts.hasOwnProperty(p) && !lookup.hasOwnProperty(p)) {
					var it = cdts[p],
						jsonObj = it.jsonObj,
						refs = it.refs;
					if(refs && coordPro.isCellInCoord(cellCoord, refs)) {
						lookup[p] = it;
					}
				}
			}
		}, this, true);
		var cdts = {};
		for(var p in lookup) {
			if(lookup.hasOwnProperty(p)) {
				var it = lookup[p];
				if(decode) {
					cdts[it.name] = SCOM.copy(it.jsonObj);
				} else {
					cdts[it.name] = SCOM.copy(it);
				}
			}
		}
		return cdts;
	},
	getConditionOfCell: function(sheetId, row, col) {
		var conditions = this.store.getConditionOfCell(sheetId, row, col);
		return conditions;
	},
	getCdtFloatingOfCell: function(sheetId, row, col) {
		var conditions = this.store.getCdtFloatingOfCell(sheetId, row, col);
		return conditions;
	},
	prepareForMoveCell: function(cell, nowSheetId, nowRow, nowCol, oldSheetId, oldRow, oldCol, lookup, prepareType, skipResetCondition) {
		cell = Ext.apply({}, cell);
		var store = this.getStore();
		lookup = lookup || {};
		var nowCell = store.getCell(nowSheetId, nowRow, nowCol);
		if(this.isCalculateCell(cell)) {
			var o = this.resetCalculateCellData(cell, nowSheetId, nowRow, nowCol, oldSheetId, oldRow, oldCol, undefined, "reverse" == prepareType);
			Ext.apply(cell, o);
		}
		cell.tpl = nowCell.tpl;
		if(!cell.tpl) {
			delete cell.tpl;
		}
		delete cell.itchk;
		if(0 !== nowRow) {
			for(var p in EnterpriseSheet.pure.sheet.data.Store.prototype.colProperties) {
				if(EnterpriseSheet.pure.sheet.data.Store.prototype.colProperties.hasOwnProperty(p)) {
					delete cell[p];
				}
			}
		}
		if(0 !== nowCol) {
			for(var p in EnterpriseSheet.pure.sheet.data.Store.prototype.rowProperties) {
				if(EnterpriseSheet.pure.sheet.data.Store.prototype.rowProperties.hasOwnProperty(p)) {
					delete cell[p];
				}
			}
		}
		for(var p in EnterpriseSheet.pure.sheet.data.Store.prototype.avoidPropertiesForApply) {
			if(EnterpriseSheet.pure.sheet.data.Store.prototype.avoidPropertiesForApply.hasOwnProperty(p)) {
				delete cell[p];
			}
		}
		var arr = withoutCdt = ["data", "cal", "arg", "value", "timestamp", "cdtVal", "tpl", "itms"].concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.styles);
		if("keep-style" == prepareType) {
			for(var k = 0, len = arr.length; k < len; k++) {
				delete cell[arr[k]];
			}
		} else if("keep-data" == prepareType) {
			cell = Ext.copyTo({}, cell, arr);
		} else if("style" == prepareType) {
			for(var k = 0, len = arr.length; k < len; k++) {
				delete cell[arr[k]];
			}
			Ext.copyTo(cell, nowCell, arr);
		} else if("style-cdt" == prepareType) {
			for(var k = 0, len = withoutCdt.length; k < len; k++) {
				delete cell[withoutCdt[k]];
			}
			Ext.copyTo(cell, nowCell, withoutCdt);
		} else if("data" == prepareType) {
			cell = Ext.copyTo({}, cell, arr);
		}
		var avoidProperties = ["ticon"];
		if(0 == nowRow || 0 == nowCol) {
			avoidProperties = avoidProperties.concat(["minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol"]);
		}
		if(0 != oldRow) {
			avoidProperties = avoidProperties.concat(["width", "woff"]);
		}
		if(0 != oldCol) {
			avoidProperties = avoidProperties.concat(["height", "hoff"]);
		}
		for(var k = 0, size = avoidProperties.length; k < size; k++) {
			delete cell[avoidProperties[k]];
		}
		return cell;
	},
	applyBrush: function(fromCoord, toCoord) {
		var store = this.getStore();
		var fromSpan = fromCoord[0],
			toSpan = toCoord[0];
		if(store.withBrokenMergedCell(toCoord)) {
			if(this.isSheetUI()) {
				Ext.Msg.alert(SLANG.hint, SLANG.can_not_change_part_merged_cell);
			}
			return;
		}
		var fsheet = fromSpan[0],
			fminrow = fromSpan[1],
			fmincol = fromSpan[2],
			fmaxrow = fromSpan[3],
			fmaxcol = fromSpan[4];
		var tsheet = toSpan[0],
			tminrow = toSpan[1],
			tmincol = toSpan[2],
			tmaxrow = toSpan[3],
			tmaxcol = toSpan[4];
		var frowLen = 0 == fromSpan[3] ? 0 : fromSpan[3] - fromSpan[1] + 1,
			fcolLen = 0 == fromSpan[4] ? 0 : fromSpan[4] - fromSpan[2] + 1,
			trowLen = 0 == toSpan[3] ? 0 : toSpan[3] - toSpan[1] + 1,
			tcolLen = 0 == toSpan[4] ? 0 : toSpan[4] - toSpan[2] + 1;
		var range = new EnterpriseSheet.pure.sheet.range.Range({
			sheet: this,
			coord: toCoord
		});
		if(false !== this.fireEvent("beforestylebrush", range, fromCoord, this)) {
			var lookup = {},
				cdtMap = {};
			var oldCdt = this.getCdtsFromCoord(fromCoord),
				originCdts = {};
			for(var p in oldCdt) {
				if(oldCdt.hasOwnProperty(p)) {
					var it = oldCdt[p];
					var id = Ext.id() + "-" + SCOM.genTimeStamp();
					lookup[p] = id;
					originCdts[id] = {
						sheet: fsheet,
						name: id
					};
					cdtMap[p] = {
						id: id,
						sheet: tsheet,
						cdt: Ext.decode(it.json)
					};
				}
			}
			var reCalCells = {};
			this.fireEvent("preparestylebrush", range, fromCoord, this, originCdts, reCalCells);
			var cellDataCache = {};
			store.walkRange([fromSpan, toSpan], function(rd) {
				var r = rd.data.row,
					c = rd.data.col;
				var cd = store.getCellProperty(rd.data.sheet, r, c, true);
				Ext.applyIf(cd, store.defaultProperty);
				cellDataCache[rd.data.sheet + "-" + r + "-" + c] = cd;
			}, this);
			var oldCellCdtLookup = {};
			store.walkRange([toSpan], function(rd, walkSpan, store, internalId) {
				var sid = rd.data.sheet,
					r = fminrow + (rd.data.row - tminrow) % frowLen,
					c = fmincol + (rd.data.col - tmincol) % fcolLen;
				var cdt = this.getConditionOfCell(sid, r, c);
				if(0 < cdt.length) {
					oldCellCdtLookup[internalId] = cdt;
				}
			}, this);
			for(var i = tminrow; i <= tmaxrow; i++) {
				for(var j = tmincol; j <= tmaxcol; j++) {
					if(0 == i && 0 == j) {
						var cd = cellDataCache[fsheet + "-" + fminrow + "-" + fmincol];
						cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, fminrow, fmincol, lookup, "style-cdt");
						store.setWhole(tsheet, cd, null, true);
					} else if(0 == i) {
						var col = (j - tmincol) % fcolLen + fmincol;
						if(0 != fmaxrow) {
							var cd = Ext.apply({}, cellDataCache[fsheet + "-" + fminrow + "-" + col]);
							cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, fminrow, col, lookup, "style-cdt");
							store.setColumn(tsheet, j, cd, null, true, true);
						} else {
							store.walkRange([
								[fsheet, 0, col, 0, col]
							], function(rd) {
								var r = rd.data.row,
									c = rd.data.col;
								var cd = cellDataCache[fsheet + "-" + r + "-" + c];
								cd = this.prepareForMoveCell(cd, tsheet, r, j, fsheet, r, c, lookup, "style-cdt");
								store.setCell(tsheet, r, j, cd, null, true);
							}, this);
						}
					} else if(0 == j) {
						var row = (i - tminrow) % frowLen + fminrow;
						if(0 != fmaxcol) {
							var cd = cellDataCache[fsheet + "-" + row + "-" + fmincol];
							cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, row, fmincol, lookup, "style-cdt");
							store.setRow(tsheet, i, cd, null, true, true);
						} else {
							store.walkRange([
								[fsheet, row, 0, row, 0]
							], function(rd) {
								var r = rd.data.row,
									c = rd.data.col;
								var cd = cellDataCache[fsheet + "-" + r + "-" + c];
								cd = this.prepareForMoveCell(cd, tsheet, i, c, fsheet, r, c, lookup, "style-cdt");
								store.setCell(tsheet, i, c, cd, null, true);
							}, this);
						}
					} else {
						var row = (i - tminrow) % frowLen + fminrow;
						var col = (j - tmincol) % fcolLen + fmincol;
						var cd = cellDataCache[fsheet + "-" + row + "-" + col];
						cd = this.prepareForMoveCell(cd, tsheet, i, j, fsheet, row, col, lookup, "style-cdt");
						store.setCell(tsheet, i, j, cd, null, true, true);
					}
				}
			}
			if(range.isCellCoord()) {
				if(Ext.isFunction(this.checkAutoHeightForCoord)) {
					this.checkAutoHeightForCoord(null, range.getCoord(), false, true);
				}
			}
			var coord = [toSpan];
			this.syncConditonForCoord(coord, originCdts, cdtMap, oldCellCdtLookup);
			var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
			coord = coord.concat(this.processRelatedCdt(coord));
			if(Ext.isFunction(this.refreshRange)) {
				this.refreshRange(coord);
			}
			this.fireEvent("stylebrush", range, fromCoord, this);
		}
	},
	apply2Span: function(fromSpan, toSpan, applyType, processData, bottomup, clearFlag, suspendRefresh, refreshCalCdt, skipHidden) {
		var me = this;
		applyType = applyType || "default";
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var fsheet = fromSpan[0],
			fminrow = fromSpan[1],
			fmincol = fromSpan[2],
			fmaxrow = fromSpan[3],
			fmaxcol = fromSpan[4];
		var frlen = 0 == fmaxrow ? 0 : fmaxrow - fminrow + 1,
			fclen = 0 == fmaxcol ? 0 : fmaxcol - fmincol + 1;
		var tsheet = toSpan[0],
			tminrow = toSpan[1],
			tmincol = toSpan[2],
			tmaxrow = toSpan[3],
			tmaxcol = toSpan[4];
		if(fsheet == tsheet && fminrow == tminrow && fmincol == tmincol && fmaxrow == tmaxrow && fmaxcol == tmaxcol) {
			return;
		}
		var minrow = tminrow,
			mincol = tmincol,
			maxrow = tmaxrow,
			maxcol = tmaxcol;
		if(fsheet === tsheet) {
			if(fminrow == tminrow && fmincol == tmincol) {
				if(fmaxcol == tmaxcol) {
					minrow = fmaxrow + 1;
				} else if(fmaxrow == tmaxrow) {
					mincol = fmaxcol + 1;
				}
			} else if(fmaxrow == tmaxrow && fmaxcol == tmaxcol) {
				if(fmincol == tmincol) {
					maxrow = fminrow - 1;
				} else if(fminrow == tminrow) {
					maxcol = fmincol - 1;
				}
			}
		}
		var rowHidden = {},
			colHidden = {};
		var fromRowIndexs = [],
			fromColIndexs = [];
		if(skipHidden) {
			for(var i = fminrow; i <= fmaxrow; i++) {
				if(store.isVisibleRow(fsheet, i)) {
					fromRowIndexs.push(i);
				}
			}
			for(var i = fmincol; i <= fmaxcol; i++) {
				if(store.isVisibleColumn(fsheet, i)) {
					fromColIndexs.push(i);
				}
			}
			for(var i = tminrow; i <= tmaxrow; i++) {
				if(!store.isVisibleRow(tsheet, i)) {
					rowHidden[i] = true;
				}
			}
			for(var i = tmincol; i <= tmaxcol; i++) {
				if(!store.isVisibleColumn(tsheet, i)) {
					colHidden[i] = true;
				}
			}
		}
		var lookup = {};
		var fn = function(br2lt, callback, scope) {
			if(0 == maxrow || 0 == maxcol) {
				store.walkRange([
					[tsheet, minrow, mincol, maxrow, maxcol]
				], function(rd) {
					if(!rowHidden[rd.data.row] && !colHidden[rd.data.col]) {
						store.setCell(rd.data.sheet, rd.data.row, rd.data.col, {
							tpl: rd.data.json.tpl
						}, null, true, "clear");
					}
				});
			}
			var skipRow = skipCol = 0;
			for(var i = tminrow; i < minrow; i++) {
				if(rowHidden[i]) {
					skipRow++;
				}
			}
			for(var i = tmincol; i < mincol; i++) {
				if(colHidden[i]) {
					skipCol++;
				}
			}
			for(var i = minrow; i <= maxrow; i++) {
				if(rowHidden[i]) {
					skipRow++;
					continue;
				}
				for(var j = mincol; j <= maxcol; j++) {
					if(colHidden[j]) {
						skipCol++;
						continue;
					}
					if(0 == i) {
						var coff, c = j;
						if(0 != fclen) {
							if("r2l" == br2lt) {
								coff = tmaxcol - j;
								if(skipHidden) {
									if(fromColIndexs.length) {
										coff -= skipCol;
										c = fromColIndexs[fromColIndexs.length - coff % fromColIndexs.length - 1];
									}
								} else {
									c = fmaxcol - coff % fclen;
								}
							} else {
								coff = j - tmincol;
								if(skipHidden) {
									if(fromColIndexs.length) {
										coff -= skipCol;
										c = fromColIndexs[coff % fromColIndexs.length];
									}
								} else {
									c = coff % fclen + fmincol;
								}
							}
						}
						store.walkRange([
							[tsheet, 0, c, 0, c]
						], function(rd) {
							var r = rd.data.row;
							callback.call(scope, r, c, r, j, skipRow, skipCol);
						}, scope);
					} else if(0 == j) {
						var roff, r = i;
						if(0 != frlen) {
							if("b2t" == br2lt) {
								roff = tmaxrow - i;
								if(skipHidden) {
									if(fromRowIndexs.length) {
										roff -= skipRow;
										r = fromRowIndexs[fromRowIndexs.length - roff % fromRowIndexs.length - 1];
									}
								} else {
									r = fmaxrow - roff % frlen;
								}
							} else {
								roff = i - tminrow;
								if(skipHidden) {
									if(fromRowIndexs.length) {
										roff -= skipRow;
										r = fromRowIndexs[roff % fromRowIndexs.length];
									}
								} else {
									r = roff % frlen + fminrow;
								}
							}
						}
						store.walkRange([
							[tsheet, r, 0, r, 0]
						], function(rd) {
							var c = rd.data.col;
							callback.call(scope, r, c, i, c, skipRow, skipCol);
						}, scope);
					} else {
						var roff, r = i;
						if(0 != frlen) {
							if("b2t" == br2lt) {
								roff = tmaxrow - i;
								if(skipHidden) {
									if(fromRowIndexs.length) {
										roff -= skipRow;
										r = fromRowIndexs[fromRowIndexs.length - roff % fromRowIndexs.length - 1];
									}
								} else {
									r = fmaxrow - roff % frlen;
								}
							} else {
								roff = i - tminrow;
								if(skipHidden) {
									if(fromRowIndexs.length) {
										roff -= skipRow;
										r = fromRowIndexs[roff % fromRowIndexs.length];
									}
								} else {
									r = roff % frlen + fminrow;
								}
							}
						}
						var coff, c = j;
						if(0 != fclen) {
							if("r2l" == br2lt) {
								coff = tmaxcol - j;
								if(skipHidden) {
									if(fromColIndexs.length) {
										coff -= skipCol;
										c = fromColIndexs[fromColIndexs.length - coff % fromColIndexs.length - 1];
									}
								} else {
									c = fmaxcol - coff % fclen;
								}
							} else {
								coff = j - tmincol;
								if(skipHidden) {
									if(fromColIndexs.length) {
										coff -= skipCol;
										c = fromColIndexs[coff % fromColIndexs.length];
									}
								} else {
									c = coff % fclen + fmincol;
								}
							}
						}
						callback.call(scope, r, c, i, j, skipRow, skipCol);
					}
				}
			}
			if(clearFlag) {
				store.walkRange([fromSpan], function(rd) {
					store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, null, true, "clear");
				});
			}
		};
		var refs = [];
		fn(bottomup, function(r, c, row, col, skipR, skipC) {
			var cd = store.getCellProperty(fsheet, r, c, true),
				curCd = store.getCellProperty(tsheet, row, col);
			if(!store.isDisabledForMe(curCd.dsd)) {
				cd = this.prepareForMoveCell(cd, tsheet, row, col, fsheet, r, c, lookup, applyType, true);
				if(cd.cal && cd.refs) {
					refs = refs.concat(cd.refs);
				}
				var flag = "data" == applyType ? null : "clear";
				if(!(fsheet === tsheet && r === row && c === col)) {
					if(("data" == applyType || "default" == applyType) && "function" == SCOM.typeOf(processData)) {
						var curR = row,
							curC = col;
						if(skipHidden) {
							curR -= skipR;
							curC -= skipC;
						}
						cd = processData(cd, curR, curC, skipR, skipC);
					}
					if(0 == row || 0 == col) {
						delete cd.data;
					}
					store.setCell(tsheet, row, col, cd, null, true, flag);
				}
			}
		}, this);
		this.syncAutoExtendCdt(toSpan, fromSpan);
		var coord = [toSpan];
		if(clearFlag) {
			coord.push(fromSpan);
		}
		if(!suspendRefresh) {
			if(Ext.isObject(refreshCalCdt)) {
				var reCalCells = this.getCalCdtCellsFromCoord([
					[tsheet, minrow, mincol, maxrow, maxcol]
				]);
				Ext.applyIf(refreshCalCdt, reCalCells);
			}
			if(0 < refs.length) {
				if(this.loadMask) {
					this.loadMask.show(SLANG.calculating, this.calMaskDelayTime);
				}
				store.checkLoadCoord(refs, function() {
					var arr = refs.concat(coord);
					if(Ext.isFunction(this.refreshRange)) {
						this.refreshRange(arr, refreshCalCdt);
					} else {
						this.refreshCalCdt(refreshCalCdt, true);
					}
					if(this.loadMask) {
						this.loadMask.hide();
					}
				}, this);
			} else {
				if(Ext.isFunction(this.refreshRange)) {
					this.refreshRange(coord, refreshCalCdt);
				} else {
					this.refreshCalCdt(refreshCalCdt, true);
				}
			}
		}
		return coord;
	},
	splitCdt: function(coord, originCdts) {
		var me = this;
		var curSheetId = me.getSheetId();
		var store = me.getStore();
		var findIncludedSpan = EnterpriseSheet.pure.sheet.range.Range.prototype.findIncludedSpan;
		var isCoordAIncludeCoordB = EnterpriseSheet.pure.sheet.range.Range.prototype.isCoordAIncludeCoordB;
		var cdts = {};
		for(var p in originCdts) {
			if(originCdts.hasOwnProperty(p)) {
				cdts[p] = Ext.decode(originCdts[p].json);
			}
		}
		var lookup = {},
			deleted = {},
			remains = {};
		for(var p in cdts) {
			if(cdts.hasOwnProperty(p)) {
				var it = cdts[p],
					name = it.name,
					rng = it.rng,
					arr = [];
				for(var i = 0, len = rng.length; i < len; i++) {
					var span = rng[i].span;
					arr.push(span);
				}
				if(isCoordAIncludeCoordB(coord, arr)) {
					deleted[p] = it;
				} else {
					remains[p] = it;
				}
			}
		}
		if(0 < SCOM.countObjMember(remains)) {
			store.walkRange(coord, function(rd) {
				var sheetId = rd.data.sheet,
					row = rd.data.row,
					col = rd.data.col;
				for(var p in remains) {
					if(remains.hasOwnProperty(p)) {
						if(!lookup[p]) {
							lookup[p] = {};
						}
						var it = remains[p];
						var found = findIncludedSpan(sheetId, row, col, it.rng);
						if(found) {
							var cid = sheetId + "-" + row + "-" + col;
							lookup[p][cid] = true;
							it.rng.splice(found.index, 1);
							var splitedSpans = me.splitSpanByRowCol(found.span, row, col);
							if(splitedSpans && 0 < splitedSpans.length) {
								it.rng = it.rng.concat(splitedSpans);
							}
						}
					}
				}
			});
			for(var p in remains) {
				if(remains.hasOwnProperty(p)) {
					var cdt = remains[p];
					cdt.rng = me.connectRowSpans(cdt.rng);
					store.setFloatingItem(curSheetId, cdt.id, "cdt", 0 < cdt.rng.length ? Ext.encode(cdt) : null);
				}
			}
		}
		for(var p in deleted) {
			if(deleted.hasOwnProperty(p)) {
				store.setFloatingItem(curSheetId, deleted[p].id, "cdt");
			}
		}
	},
	syncAutoExtendCdt: function(toSpan, fromSpan, oldCdts) {
		var coord = [toSpan];
		var me = this;
		var curSheetId = me.getSheetId();
		var store = me.getStore();
		var relatedCdts = {},
			cdtNewRng = {};
		var fromSheetId = fromSpan[0],
			fromRowSpan = fromSpan[3] - fromSpan[1] + 1,
			fromColSpan = fromSpan[4] - fromSpan[2] + 1;
		store.walkRange(coord, function(rd) {
			var sheetId = rd.data.sheet,
				row = rd.data.row,
				col = rd.data.col;
			var rowOff = row - toSpan[1],
				colOff = col - toSpan[2];
			var oldRow = fromSpan[1] + rowOff % fromRowSpan,
				oldCol = fromSpan[2] + colOff % fromColSpan;
			var cdt = me.getCdtFloatingOfCell(fromSheetId, oldRow, oldCol);
			if(0 < cdt.length) {
				for(var i = 0, len = cdt.length; i < len; i++) {
					var it = cdt[i];
					var id = it.name;
					if(!relatedCdts[id]) {
						var found = it.jsonObj;
						if(!found && oldCdts) {
							var old = oldCdts[id];
							found = Ext.decode(old.json);
							found.rng = [];
						}
						relatedCdts[id] = found;
					}
					if(!cdtNewRng[id]) {
						cdtNewRng[id] = [];
					}
					var included = false;
					var rng = relatedCdts[id].rng;
					for(var j = 0, count = rng.length; j < count; j++) {
						var span = rng[j].span;
						if(span[1] <= row && (row <= span[3] || 0 == span[3]) && span[2] <= col && (col <= span[4] || 0 == span[4])) {
							included = true;
							break;
						}
					}
					if(!included) {
						cdtNewRng[id].push([sheetId, row, col]);
					}
				}
			}
		});
		for(var p in cdtNewRng) {
			if(cdtNewRng.hasOwnProperty(p)) {
				var it = cdtNewRng[p];
				var minrow = false,
					maxrow = false,
					mincol = false,
					maxcol = false;
				for(var i = 0, len = it.length; i < len; i++) {
					var span = it[i];
					if(false === minrow) {
						minrow = span[1];
					} else if(minrow > span[1]) {
						minrow = span[1];
					}
					if(false === maxrow) {
						maxrow = span[1];
					} else if(0 !== maxrow && maxrow < span[1]) {
						maxrow = span[1];
					}
					if(false === mincol) {
						mincol = span[2];
					} else if(mincol > span[2]) {
						mincol = span[2];
					}
					if(false === maxcol) {
						maxcol = span[2];
					} else if(0 !== maxcol && maxcol < span[2]) {
						maxcol = span[2];
					}
				}
				var rngs = relatedCdts[p].rng;
				relatedCdts[p].rng = this.mergeRanges(rngs, [curSheetId, minrow, mincol, maxrow, maxcol]);
			}
		}
		for(var p in relatedCdts) {
			if(relatedCdts.hasOwnProperty(p)) {
				var it = relatedCdts[p];
				store.setFloatingItem(curSheetId, it.id, "cdt", Ext.encode(it));
			}
		}
	},
	getCalCdtCellsFromCoord: function(coord, avoidCoord) {
		var rangePro = EnterpriseSheet.pure.sheet.range.Range.prototype;
		var reCalCells = {};
		var store = this.getStore();
		store.walkRange(coord, function(rd, walkSpan, store, internalId) {
			var sheetId = rd.data.sheet,
				row = rd.data.row,
				col = rd.data.col;
			var json = rd.data.json;
			if(json.cal || this.isConditionCell(json, sheetId, row, col)) {
				if(!avoidCoord || !rangePro.isIncluded(sheetId, row, col, avoidCoord)) {
					var id = internalId;
					reCalCells[id] = [sheetId, row, col];
				}
			}
		}, this, true);
		return reCalCells;
	},
	pasteRange: function(fromCoord, toCoord, pasteType, clearFlag, checkCallback, scope, skipHiddenCell) {
		var retFlag = true;
		var sheet = this,
			store = sheet.getStore();
		var sep = store.separateChar;
		var curSheetId = sheet.getSheetId();
		if(skipHiddenCell) {
			fromCoord = store.skipHiddenForCoord(fromCoord);
		}
		var range = new EnterpriseSheet.pure.sheet.range.Range({
			sheet: sheet,
			coord: fromCoord
		});
		var copyRange = range.clone();
		if(range.includeMergedCell() || !range.isCellRange()) {
			if("reverse" === pasteType) {
				pasteType = undefined;
			}
		}
		if(range.isInSingleSheet()) {
			var minPos = range.getMinPos(skipHiddenCell),
				oldMinRow = minPos.row,
				oldMinCol = minPos.col;
			var curCoordSpan = toCoord[0];
			var row = curCoordSpan[1],
				col = curCoordSpan[2];
			var rowOffset = row - minPos.row,
				colOffset = col - minPos.col;
			var oldRange = range.clone();
			var oldCoord = oldRange.getCoord(),
				oldCoordSpan = oldCoord[0];
			var oldRowSpan = 0 == oldCoordSpan[3] ? 0 : oldCoordSpan[3] - oldCoordSpan[1] + 1,
				oldColSpan = 0 == oldCoordSpan[4] ? 0 : oldCoordSpan[4] - oldCoordSpan[2] + 1;
			var curRowSpan = 0 == curCoordSpan[3] ? 0 : curCoordSpan[3] - curCoordSpan[1] + 1,
				curColSpan = 0 == curCoordSpan[4] ? 0 : curCoordSpan[4] - curCoordSpan[2] + 1;
			if((0 == oldRowSpan || 0 == curRowSpan) && oldRowSpan != curRowSpan || (0 == oldColSpan || 0 == curColSpan) && oldColSpan != curColSpan) {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.paste_copy_not_same_shape);
				}
				return false;
			}
			var rowProp = 1,
				colProp = 1;
			var hiddenRowCountLookup = {},
				hiddenColCountLookup = {};
			if(1 == oldCoord.length) {
				prop = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.isFactorSpan(oldCoordSpan, curCoordSpan);
				if(prop) {
					var tmpSpan = [].concat(oldCoordSpan);
					tmpSpan[3] = tmpSpan[1] + oldRowSpan * prop.rowProp - 1;
					tmpSpan[4] = tmpSpan[2] + oldColSpan * prop.colProp - 1;
					range.setCoord([tmpSpan]);
					rowProp = prop.rowProp;
					colProp = prop.colProp;
				}
				range.moveCoord(curSheetId, rowOffset, colOffset);
			} else if(skipHiddenCell) {
				var tabs = {};
				for(var i = 0, len = oldCoord.length; i < len; i++) {
					var span = oldCoord[i],
						tabId = span[0];
					tabs[tabId] = tabs[tabId] || {};
					var tab = tabs[tabId];
					if(!Ext.isNumber(tab.minrow) || tab.minrow > span[1]) {
						tab.minrow = span[1];
					}
					if(!Ext.isNumber(tab.maxrow) || tab.maxrow < span[3]) {
						tab.maxrow = span[3];
					}
					if(!Ext.isNumber(tab.mincol) || tab.mincol > span[2]) {
						tab.mincol = span[2];
					}
					if(!Ext.isNumber(tab.maxcol) || tab.maxcol < span[4]) {
						tab.maxcol = span[4];
					}
				}
				for(var p in tabs) {
					if(tabs.hasOwnProperty(p)) {
						var tab = tabs[p],
							minr = tab.minrow,
							maxr = tab.maxrow,
							minc = tab.mincol,
							maxc = tab.maxcol;
						var count = 0;
						for(var r = minr; r <= maxr; r++) {
							if(!store.isVisibleRow(p, r)) {
								count++;
							} else {
								var id = p + sep + r;
								hiddenRowCountLookup[id] = count;
							}
						}
						count = 0;
						for(var c = minc; c <= maxc; c++) {
							if(!store.isVisibleColumn(p, c)) {
								count++;
							} else {
								var id = p + sep + c;
								hiddenColCountLookup[id] = count;
							}
						}
					}
				}
				var tmpCoord = [];
				for(var i = 0, len = oldCoord.length; i < len; i++) {
					var span = [].concat(oldCoord[i]),
						tabId = span[0];
					span[0] = curSheetId;
					var id = tabId + sep + span[1];
					span[1] += rowOffset - hiddenRowCountLookup[id];
					id = tabId + sep + span[3];
					span[3] += rowOffset - hiddenRowCountLookup[id];
					id = tabId + sep + span[2];
					span[2] += colOffset - hiddenColCountLookup[id];
					id = tabId + sep + span[4];
					span[4] += colOffset - hiddenColCountLookup[id];
					tmpCoord.push(span);
				}
				range.setCoord(tmpCoord);
			}
			var newCoord = range.getCoord();
			curCoordSpan = newCoord[0];
			var coord = [oldCoordSpan, curCoordSpan];
			if(store.withBrokenMergedCell(coord)) {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.can_not_change_part_merged_cell);
				}
				return false;
			}
			var nextFn = function() {
				coord = [curCoordSpan];
				if("reverse" == pasteType) {
					range.reverseCoord();
					var tmpCoord = range.getCoord();
					curCoordSpan = tmpCoord[0];
					coord = coord.concat(tmpCoord);
				}
				minPos = range.getMinPos();
				var newRange = range.clone();
				if(clearFlag) {
					newRange.mergeCoord(oldCoord, true);
				}
				if(false !== sheet.fireEvent("beforepaste", newRange, sheet)) {
					var lookup = {},
						cdtMap = {};
					var oldCdt = sheet.getCdtsFromCoord(oldCoord),
						originCdts = {},
						newCdts = {};
					for(var p in oldCdt) {
						if(oldCdt.hasOwnProperty(p)) {
							var it = oldCdt[p];
							var id = Ext.id() + "-" + SCOM.genTimeStamp();
							lookup[p] = id;
							newCdts[id] = {
								sheet: oldCoordSpan[0],
								name: id
							};
							originCdts[id] = {
								sheet: oldCoordSpan[0],
								name: id
							};
							if(clearFlag) {
								originCdts[p] = it;
							}
							cdtMap[p] = {
								id: id,
								sheet: curCoordSpan[0],
								cdt: Ext.decode(it.json)
							};
						}
					}
					var oldCellCdtLookup = {};
					store.walkRange(oldCoord, function(rd) {
						var sid = rd.data.sheet,
							r = rd.data.row,
							c = rd.data.col;
						var cdt = sheet.getConditionOfCell(sid, r, c);
						if(0 < cdt.length) {
							var id = [sid, r + rowOffset, c + colOffset].join(store.separateChar);
							oldCellCdtLookup[id] = cdt;
						}
					}, this);
					var reCalCells = sheet.getRecalculateCellsByCoord(newRange.coord);
					var changedHeights = {};
					sheet.fireEvent("preparepaste", newRange, sheet, originCdts, reCalCells, changedHeights);
					var originCache = {};
					store.walkRange(oldCoord, function(rd, walkSpan, store, internalId) {
						var cd = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col, true);
						originCache[internalId] = cd;
					});
					range.clean(true, undefined, true, true);
					var refs = [];
					for(var r = 0; r < rowProp; r++) {
						var roff = rowOffset + r * oldRowSpan;
						for(var c = 0; c < colProp; c++) {
							var coff = colOffset + c * oldColSpan;
							store.walkRange(oldCoord, function(rd, walkSpan, store, internalId) {
								var oldRow = rd.data.row,
									oldCol = rd.data.col;
								var oldRId = rd.data.sheet + sep + oldRow,
									oldCId = rd.data.sheet + sep + oldCol;
								var cd = originCache[internalId];
								var hiddenRowOffset = hiddenRowCountLookup[oldRId] || 0,
									hiddenColOffset = hiddenColCountLookup[oldCId] || 0;
								var nowRow = Number(rd.data.row) + roff - hiddenRowOffset,
									nowCol = Number(rd.data.col) + coff - hiddenColOffset;
								if("reverse" == pasteType) {
									var tmp = nowRow - minPos.row;
									nowRow = minPos.row + nowCol - minPos.col;
									nowCol = minPos.col + tmp;
								}
								var cell = store.getCellProperty(curSheetId, nowRow, nowCol);
								if(!store.isDisabledForMe(cell.dsd)) {
									cd = sheet.prepareForMoveCell(cd, curSheetId, nowRow, nowCol, rd.data.sheet, oldRow, oldCol, lookup, pasteType);
									if(cd.cal && cd.refs) {
										refs = refs.concat(cd.refs);
									}
									delete cd.dsd;
									store.setCell(curSheetId, nowRow, nowCol, cd, null, true, "data" != pasteType ? "clear" : null);
								}
							}, this);
						}
					}
					if(clearFlag) {
						coord = coord.concat(oldRange.getCoord());
						oldRange.clean(true, range, true);
					}
					if(Ext.isFunction(sheet.checkAutoHeightForCoord)) {
						if(range.isCellCoord()) {
							Ext.apply(changedHeights, sheet.checkAutoHeightForCoord(clearFlag ? null : oldCoord, coord, false, true));
						}
					}
					sheet.syncConditonForCoord([curCoordSpan], newCdts, cdtMap, oldCellCdtLookup);
					Ext.applyIf(reCalCells, sheet.getCalCdtCellsFromCoord([curCoordSpan]));
					if(0 < refs.length) {
						if(sheet.loadMask) {
							sheet.loadMask.show(SLANG.calculating, sheet.calMaskDelayTime);
						}
						store.checkLoadCoord(refs, function() {
							if(Ext.isFunction(sheet.refreshRange)) {
								sheet.refreshRange(undefined, reCalCells);
							} else {
								sheet.refreshCalCdt(reCalCells, true);
							}
							if(sheet.loadMask) {
								sheet.loadMask.hide();
							}
						}, this);
					} else {
						if(Ext.isFunction(sheet.refreshRange)) {
							sheet.refreshRange(undefined, reCalCells);
						} else {
							sheet.refreshCalCdt(reCalCells, true);
						}
					}
					sheet.fireEvent("paste", newRange, sheet, copyRange, originCdts, reCalCells);
					retFlag = newRange;
				} else {
					retFlag = false;
				}
			};
			if(checkCallback) {
				checkCallback.call(scope, newCoord, function(cancel) {
					if(cancel) {
						return false;
					} else {
						nextFn.call(this);
						return retFlag;
					}
				}, this);
				retFlag = false;
			} else {
				nextFn.call(this);
			}
		}
		return retFlag;
	},
	updateCells: function(cellObjs, callback, scope) {
		var len = cellObjs.length;
		var sheet = this,
			store = sheet.getStore();
		var fn = function() {
			var calculate = sheet.getCalculate();
			for(var i = 0; i < len; i++) {
				var data = cellObjs[i],
					sheetId = data.sheet,
					row = data.row,
					col = data.col;
				if(!Ext.isDefined(sheetId)) {
					sheetId = sheet.getSheetId();
				}
				var json = data.json;
				if(typeof json === "string" || json instanceof String) {
					json = Ext.decode(json);
				}
				var deleted = [];
				if(Ext.isDefined(json.data)) {
					if(EnterpriseSheet.pure.sheet.calculate.Calculate.prototype.isCalculate(json.data)) {
						json.cal = true;
					} else {
						delete json.cal;
						deleted = ["cal", "arg", "refs", "value"];
					}
				}
				if(json.cal) {
					if(!json.arg) {
						calculate.transferCalculate(json, store, sheetId, row, col);
					}
				}
				store.setCell(sheetId, row, col, json, deleted, false, data.applyWay || "clear");
			}
			sheet.fireEvent("resethistory", sheet);
			if(Ext.isFunction(sheet.refresh)) {
				sheet.refresh();
			}
		};
		if(1000 < len) {
			if(sheet.loadMask) {
				sheet.loadMask.show();
			}
			Ext.Function.defer(function() {
				fn();
				if(sheet.loadMask) {
					sheet.loadMask.hide();
				}
				if(callback) {
					callback.call(scope);
				}
			}, 50, this);
		} else {
			fn();
			if(callback) {
				callback.call(scope);
			}
		}
	},
	loadSwitchSheet: function(sheetId, callback, scope) {
		var store = this.getStore();
		store.loadSheet(sheetId, function(success) {
			if(success) {
				this.switchSheet(sheetId, function() {
					if(callback) {
						callback.call(scope, sheetId);
					}
				}, this);
			} else {
				if(this.loadMask) {
					this.loadMask.hide();
				}
			}
		}, this);
	},
	switchSheet: function(sheetId, callback, scope) {
		var oldSheetId = this.getSheetId();
		if(oldSheetId != sheetId) {
			if(false !== this.fireEvent("beforeswitchsheet", oldSheetId, sheetId, this)) {
				var store = this.getStore();
				if(store.getSheetById(oldSheetId)) {
					if(this.enableRowColGroup) {
						this.updateRowGroups();
						this.updateColumnGroups();
					}
				}
				store.setActivedSheetId(sheetId);
				this.setSheetId(sheetId);
				this.fireEvent("switchsheet", oldSheetId, sheetId, this);
				if(callback) {
					callback.call(scope);
				}
			}
		}
	},
	setSheetId: function(sheetId) {
		this.sheetId = sheetId;
	},
	updateRowGroups: function(suspendUpdateStore) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		if(!suspendUpdateStore) {
			return store.updateRowGroups(sheetId, this.rowGroups);
		} else {
			return this.rowGroups;
		}
	},
	updateColumnGroups: function(suspendUpdateStore) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		if(!suspendUpdateStore) {
			return store.updateColumnGroups(sheetId, this.colGroups);
		} else {
			return this.colGroups;
		}
	},
	setRowHeight: function(h, pos) {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			old = {},
			cur = {};
		if(0 == minrow) {
			if(5 > h) {
				h = 5;
			}
			var cornerPro = store.getCell(sheetId, 0, 0);
			if(cornerPro.height === h) {
				return;
			}
			old[0] = {
				height: cornerPro.height
			};
			cur[0] = h;
			store.setWhole(sheetId, {
				height: h
			}, null, true);
		} else {
			if(0 >= h) {
				for(var i = minrow; i <= maxrow; i++) {
					old[i] = true;
					cur[i] = false;
				}
				store.hideRow(sheetId, minrow, maxrow, true);
			} else {
				if(minrow == maxrow) {
					var oh = store.getRowHeight(sheetId, minrow, true, true);
					if(oh != h) {
						var rowPro = store.getCell(sheetId, minrow, 0);
						old[minrow] = {
							height: rowPro.height,
							autoHeight: rowPro.autoHeight
						};
						cur[minrow] = h;
						store.setRowHeight(sheetId, minrow, h, true);
					}
				} else {
					for(var i = minrow; i <= maxrow; i++) {
						var oh = store.getRowHeight(sheetId, i, true, true);
						var rowPro = store.getCell(sheetId, i, 0);
						old[i] = {
							height: rowPro.height,
							autoHeight: rowPro.autoHeight
						};
						cur[i] = h;
						store.setRowHeight(sheetId, i, h, true, true);
					}
				}
			}
		}
		this.fireEvent("rowresized", maxrow, old, cur, this);
	},
	showRow: function(pos, sheetId) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow;
		if(minrow < 1) {
			minrow = 1;
		}
		if(maxrow < 1) {
			maxrow = 1;
		}
		var hidden = store.showRow(sheetId, minrow, maxrow);
		this.fireEvent("rowshow", sheetId, minrow, maxrow, hidden, this);
		return hidden;
	},
	showColumn: function(pos, sheetId) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var mincol = pos.mincol,
			maxcol = pos.maxcol;
		if(mincol < 1) {
			mincol = 1;
		}
		if(maxcol < 1) {
			maxcol = 1;
		}
		var hidden = store.showColumn(sheetId, mincol, maxcol);
		this.fireEvent("columnshow", sheetId, mincol, maxcol, hidden, this);
		return hidden;
	},
	hideRow: function(pos, sheetId) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow;
		if(minrow < 1) {
			minrow = 1;
		}
		if(maxrow < 1) {
			maxrow = 1;
		}
		var visibles = store.hideRow(sheetId, minrow, maxrow);
		this.fireEvent("rowhide", sheetId, minrow, maxrow, visibles, this);
		return visibles;
	},
	hideColumn: function(pos, sheetId) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var mincol = pos.mincol,
			maxcol = pos.maxcol;
		if(mincol < 1) {
			mincol = 1;
		}
		if(maxcol < 1) {
			maxcol = 1;
		}
		var visibles = store.hideColumn(sheetId, mincol, maxcol);
		this.fireEvent("columnhide", sheetId, mincol, maxcol, visibles, this);
		return visibles;
	},
	connectRowSpans: function(rng) {
		var splited = [],
			others = [];
		for(var i = 0, len = rng.length; i < len; i++) {
			var it = rng[i];
			if(it.splited) {
				splited.push(it);
			} else {
				others.push(it);
			}
		}
		var found = true;
		while(found) {
			found = false;
			for(var i = 0, len = splited.length; i < len; i++) {
				var it = splited[i];
				if(it.splited) {
					delete it.splited;
					found = it;
					splited.splice(i, 1);
					break;
				}
			}
			if(found) {
				splited = this.mergeRanges(splited, found.span);
			}
		}
		return others.concat(splited);
	},
	connectSpan: function(rng) {
		for(var i = 0, len = rng.length; i < len; i++) {
			var it = rng[i];
			it.splited = true;
		}
		var found = true;
		while(found) {
			found = false;
			for(var i = 0, len = rng.length; i < len; i++) {
				var it = rng[i];
				if(it.splited) {
					delete it.splited;
					found = it;
					rng.splice(i, 1);
					break;
				}
			}
			if(found) {
				rng = this.mergeRanges(rng, found.span);
			}
		}
		return rng;
	},
	splitColSpanByRow: function(span, row) {
		var sheetId = span[0],
			minrow = span[1],
			maxrow = span[3],
			mincol = span[2],
			maxcol = span[4];
		if(minrow == row && row == maxrow) {
			return [];
		}
		if(0 === minrow) {
			minrow = 1;
		}
		if(minrow == row) {
			return [{
				span: [sheetId, minrow + 1, mincol, maxrow, maxcol],
				type: SCONST.ABSOLUTE_COORD,
				splited: true
			}];
		}
		if(maxrow == row) {
			return [{
				span: [sheetId, minrow, mincol, maxrow - 1, maxcol],
				type: SCONST.ABSOLUTE_COORD,
				splited: true
			}];
		}
		return [{
			span: [sheetId, minrow, mincol, row - 1, maxcol],
			type: SCONST.ABSOLUTE_COORD,
			splited: true
		}, {
			span: [sheetId, row + 1, mincol, maxrow, maxcol],
			type: SCONST.ABSOLUTE_COORD,
			splited: true
		}];
	},
	splitRowSpanByCol: function(span, col) {
		var sheetId = span[0],
			minrow = span[1],
			maxrow = span[3],
			mincol = span[2],
			maxcol = span[4];
		if(mincol == col && col == maxcol) {
			return [];
		}
		if(0 === mincol) {
			mincol = 1;
		}
		if(mincol == col) {
			return [{
				span: [sheetId, minrow, mincol + 1, maxrow, maxcol],
				type: SCONST.ABSOLUTE_COORD,
				splited: true
			}];
		}
		if(maxcol == col) {
			return [{
				span: [sheetId, minrow, mincol, maxrow, maxcol - 1],
				type: SCONST.ABSOLUTE_COORD,
				splited: true
			}];
		}
		return [{
			span: [sheetId, minrow, mincol, maxrow, col - 1],
			type: SCONST.ABSOLUTE_COORD,
			splited: true
		}, {
			span: [sheetId, minrow, col + 1, maxrow, maxcol],
			type: SCONST.ABSOLUTE_COORD,
			splited: true
		}];
	},
	splitSpanByRowCol: function(span, row, col) {
		var sheetId = span[0],
			minrow = span[1],
			maxrow = span[3],
			mincol = span[2],
			maxcol = span[4];
		if(minrow == row && row == maxrow && mincol == col && maxcol == col) {
			return;
		}
		if(0 === minrow) {
			minrow = 1;
		}
		var hitted = [sheetId, row, mincol, row, maxcol];
		var rowSpans = this.splitRowSpanByCol(hitted, col);
		var arr;
		if(minrow == row && row == maxrow) {
			arr = rowSpans;
		} else {
			if(minrow == row) {
				arr = rowSpans.concat([{
					span: [sheetId, minrow + 1, mincol, maxrow, maxcol],
					type: SCONST.ABSOLUTE_COORD
				}]);
			} else if(maxrow == row) {
				arr = [{
					span: [sheetId, minrow, mincol, maxrow - 1, maxcol],
					type: SCONST.ABSOLUTE_COORD
				}].concat(rowSpans);
			} else {
				arr = [{
					span: [sheetId, minrow, mincol, row - 1, maxcol],
					type: SCONST.ABSOLUTE_COORD
				}].concat(rowSpans).concat([{
					span: [sheetId, row + 1, mincol, maxrow, maxcol],
					type: SCONST.ABSOLUTE_COORD
				}]);
			}
		}
		return arr;
	},
	splitSpanByColRow: function(span, row, col) {
		var sheetId = span[0],
			minrow = span[1],
			maxrow = span[3],
			mincol = span[2],
			maxcol = span[4];
		if(minrow == row && row == maxrow && mincol == col && maxcol == col) {
			return;
		}
		if(0 === mincol) {
			mincol = 1;
		}
		var hitted = [sheetId, minrow, col, maxrow, col];
		var colSpans = this.splitColSpanByRow(hitted, row);
		var arr;
		if(mincol == col && col == maxcol) {
			arr = colSpans;
		} else {
			if(mincol == col) {
				arr = colSpans.concat([{
					span: [sheetId, minrow, mincol + 1, maxrow, maxcol],
					type: SCONST.ABSOLUTE_COORD
				}]);
			} else if(maxcol == col) {
				arr = [{
					span: [sheetId, minrow, mincol, maxrow, maxcol - 1],
					type: SCONST.ABSOLUTE_COORD
				}].concat(colSpans);
			} else {
				arr = [{
					span: [sheetId, minrow, mincol, maxrow, col - 1],
					type: SCONST.ABSOLUTE_COORD
				}].concat(colSpans).concat([{
					span: [sheetId, minrow, col + 1, maxrow, maxcol],
					type: SCONST.ABSOLUTE_COORD
				}]);
			}
		}
		return arr;
	},
	updateNamedFunc: function(name, val, scope, comment, suspendEvent, suspendCheck) {
		var me = this,
			calculate = me.getCalculate();
		var store = me.getStore();
		var found = store.getFileConfigById(name, "named_func");
		if(found) {
			var json = found.jsonArr,
				arr = [],
				flag, changed;
			for(var i = 0, len = json.length; i < len; i++) {
				var it = json[i];
				var copy = Ext.apply({}, it);
				if(it.scope === scope) {
					flag = true;
					if(val && copy.cal !== val) {
						changed = true;
						copy.cal = val;
						var o = calculate.transferCalculate({
							data: "=beval(" + val + ")"
						}, store, undefined, undefined, undefined, "named_func");
						copy.arg = o.arg;
						copy.refs = o.refs;
					}
					if(comment && copy.comment !== comment) {
						changed = true;
						copy.comment = comment;
					}
				}
				arr.push(copy);
			}
			if(!flag) {
				changed = true;
				var obj = {
					cal: val
				};
				var o = calculate.transferCalculate({
					data: "=beval(" + val + ")"
				}, store, undefined, undefined, undefined, "named_func");
				obj.arg = o.arg;
				obj.refs = o.refs;
				if(Ext.isDefined(scope)) {
					obj.scope = scope;
				}
				if(comment) {
					obj.comment = comment;
				}
				arr.push(obj);
			}
			if(changed) {
				store.setNamedFuncConfig(name, {
					jsonArr: arr
				}, suspendEvent, suspendCheck);
			}
		} else {
			var json = {
				cal: val
			};
			var o = calculate.transferCalculate({
				data: "=beval(" + val + ")"
			}, store, undefined, undefined, undefined, "named_func");
			json.arg = o.arg;
			json.refs = o.refs;
			if(Ext.isDefined(scope)) {
				json.scope = scope;
			}
			if(comment) {
				json.comment = comment;
			}
			store.setNamedFuncConfig(name, {
				jsonArr: [json]
			}, suspendEvent, suspendCheck);
		}
	},
	deleteNamedFunc: function(name, scope, suspendEvent, suspendCheck) {
		var me = this;
		var store = me.getStore();
		var found = store.getFileConfigById(name, "named_func");
		if(found) {
			var json;
			try {
				json = found.jsonArr;
				var arr = [];
				for(var i = 0, len = json.length; i < len; i++) {
					var it = json[i];
					if(it.scope !== scope) {
						arr.push(it);
					}
				}
				var alen = arr.length;
				if(0 < alen) {
					store.setNamedFuncConfig(name, {
						jsonArr: arr
					}, suspendEvent, suspendCheck);
				} else {
					store.setNamedFuncConfig(name, undefined, suspendEvent, suspendCheck);
				}
			} catch(e) {
				store.setNamedFuncConfig(name, undefined, suspendEvent, suspendCheck);
			}
		}
	},
	mergeRanges: function(rngs, newSpan) {
		var merged = false,
			changed = true;
		var minrow = newSpan[1],
			maxrow = newSpan[3],
			mincol = newSpan[2],
			maxcol = newSpan[4];
		while(changed) {
			changed = false;
			for(var i = 0, len = rngs.length; i < len; i++) {
				var span = rngs[i].span;
				if(span[2] == mincol && span[4] == maxcol) {
					if(span[1] <= minrow) {
						if(0 === span[3] || span[3] >= minrow - 1) {
							merged = true;
							changed = true;
							minrow = span[1];
							if(0 === span[3] || 0 === maxrow) {
								maxrow = 0;
							} else if(span[3] > maxrow) {
								maxrow = span[3];
							}
							rngs.splice(i, 1);
							break;
						}
					} else {
						if(0 === maxrow || maxrow >= span[1] - 1) {
							merged = true;
							changed = true;
							if(0 === span[3] || 0 === maxrow) {
								maxrow = 0;
							} else if(span[3] > maxrow) {
								maxrow = span[3];
							}
							rngs.splice(i, 1);
							break;
						}
					}
				} else if(span[1] == minrow && span[3] == maxrow) {
					if(span[2] <= mincol) {
						if(0 === span[4] || span[4] >= mincol - 1) {
							merged = true;
							changed = true;
							mincol = span[2];
							if(0 === span[4] || 0 === maxcol) {
								maxcol = 0;
							} else if(span[4] > maxcol) {
								maxcol = span[4];
							}
							rngs.splice(i, 1);
							break;
						}
					} else {
						if(0 === maxcol || maxcol >= span[2] - 1) {
							merged = true;
							changed = true;
							if(0 === span[4] || 0 === maxcol) {
								maxcol = 0;
							} else if(span[4] > maxcol) {
								maxcol = span[4];
							}
							rngs.splice(i, 1);
							break;
						}
					}
				}
			}
		}
		if(false !== minrow) {
			var obj = {
				span: [newSpan[0], minrow, mincol, maxrow, maxcol],
				type: SCONST.ABSOLUTE_COORD
			};
			rngs.push(obj);
		}
		return rngs;
	},
	getDataArrayFromCal: function(val, callback, scope, cellScope) {
		cellScope = cellScope || {};
		var sheet = this;
		var store = sheet.getStore();
		var v = val,
			calPro = EnterpriseSheet.pure.sheet.calculate.Calculate.prototype;
		var curSheetId = store.getActivedSheetId();
		if(Ext.isString(v)) {
			if(calPro.isCalculate(v)) {
				v = v.slice(1);
			}
			try {
				var tmp = v;
				var cal = "=rangeObjsOf(" + v + ")";
				var o = calPro.transferCalculate({
					data: cal
				}, store, Ext.isDefined(cellScope.sheet) ? cellScope.sheet : curSheetId, cellScope.row, cellScope.col, "named_func");
				var refs = o.refs;
				var fn = function() {
					var obj = sheet.calculate.processCalculate(o, Ext.applyIf({
						store: store,
						isArrayFormula: true,
						from: "named_func"
					}, cellScope), "named_func");
					var val = obj.value;
					if(val._isExp) {
						val = [tmp];
					} else if(!Ext.isArray(val)) {
						val = [val];
					}
					if(callback) {
						callback.call(scope, val);
					}
				};
				if(refs && 0 < refs.length) {
					store.checkLoadCoord(refs, fn, this);
				} else {
					fn.call(this);
				}
			} catch(e) {
				if(callback) {
					callback.call(scope, [v]);
				}
			}
		} else {
			if(callback) {
				callback.call(scope, Ext.isArray(v) ? v : [v]);
			}
		}
	},
	checkLoopRefer: function(cells) {
		var store = this.getStore();
		for(var p in cells) {
			if(cells.hasOwnProperty(p)) {
				var pos = cells[p];
				if(store.isLoopRefered(pos[0], pos[1], pos[2])) {
					store.setCell(pos[0], pos[1], pos[2], {
						value: {
							code: "CAL_INFINATE_LOOP",
							span: [pos[0], pos[1], pos[2], pos[1], pos[2]]
						}
					}, undefined, true);
				}
			}
		}
	},
	addCrossFileReference: function(refName, crossFileSheet, skipResetAllCal) {
		var store = this.getStore();
		if(refName) {
			this.corssFileReference = this.corssFileReference || {};
			if(!this.corssFileReference[refName]) {
				this.corssFileReference[refName] = crossFileSheet;
				var crossStore = crossFileSheet.getStore();
				store.addCrossFileStoreReference(refName, crossStore);
				this.listenCrossFileStore(crossStore, crossFileSheet);
				if(!skipResetAllCal) {
					this.resetAllCalculates();
				}
				return true;
			}
		}
		return false;
	},
	listenCrossFileStore: function(crossStore, crossFileSheet) {
		var store = this.getStore(),
			me = this;
		var changedCells = {};
		var fn = function(curStore, sheetId, row, col) {
			if(curStore.suspendCrossFileListening) {
				return;
			}
			sheetId = [curStore.getId(), sheetId].join(curStore.crossSepChar);
			var pos = [sheetId, row, col],
				cellId = pos.join(store.separateChar);
			var changed = {};
			changed[cellId] = pos;
			var cells = me.findDirectRecalculateCellsForCells(changed);
			me.clearValueForCalCells(cells);
			me.checkLoopRefer(cells, sheetId, row, col);
			me.refreshCalCdt(cells, undefined, undefined, undefined, undefined, undefined, true);
		};
		crossFileSheet.on("checkvaluechange", function(sheetId, row, col, curSheet, oldVal, curVal) {
			var curStore = curSheet.getStore();
			fn(curStore, sheetId, row, col);
		}, this);
		crossStore.on("datachange", function(timestamp, sheetId, row, col, modified, deleted, origin, current, curStore) {
			fn(curStore, sheetId, row, col);
		}, this);
		crossStore.on("afteraddaction", function(act, opt, curStore) {
			if(curStore.suspendCrossFileListening) {
				return;
			}
			var sheetId;
			if(Ext.isDefined(act.sheetId)) {
				sheetId = [curStore.getId(), act.sheetId].join(curStore.crossSepChar);
			}
			var action = act.action;
			if("insertRow" == action) {
				this.holdInsertRow(sheetId, act.row, act.rowSpan);
			} else if("insertColumn" == action) {
				this.holdInsertColumn(sheetId, act.col, act.colSpan);
			} else if("removeRow" == action) {
				this.holdRemoveRow(sheetId, act.minrow, act.maxrow);
			} else if("removeColumn" == action) {
				this.holdRemovetColumn(sheetId, act.mincol, act.maxcol);
			} else if("removeCell" == action) {
				this.holdRemoveCell(sheetId, act.minrow, act.maxrow, act.mincol, act.maxcol, act.moveDir);
			} else if("insertCell" == action) {
				this.holdInsertCell(sheetId, act.row, act.col, act.rowSpan, act.colSpan, act.moveDir);
			} else if("sortSpan" == action || "moveRows" == action) {
				var diff = act.diff,
					mincol, maxcol, minrow = maxrow = false;
				if("sortSpan" == action) {
					var span = act.span;
					sheetId = span[0];
					if(act.expand) {
						mincol = maxcol = 0;
					} else {
						mincol = span[2];
						maxcol = span[4];
					}
				} else {
					sheetId = act.sheetId;
					mincol = act.mincol;
					maxcol = act.maxcol;
				}
				sheetId = [curStore.getId(), sheetId].join(curStore.crossSepChar);
				for(var p in diff) {
					if(diff.hasOwnProperty(p)) {
						p = Number(p);
						var q = Number(diff[q]);
						if(false === minrow || minrow > p) {
							minrow = p;
						}
						if(minrow > q) {
							minrow = q;
						}
						if(false === maxrow || maxrow < p) {
							maxrow = p;
						}
						if(maxrow < q) {
							maxrow = q;
						}
					}
				}
				var cells = this.getRecalculateCellsByCoord([
					[sheetId, minrow, mincol, maxrow, maxcol]
				]);
				this.refreshCalCdt(cells);
			} else if("createFloatingItem" == action || "updateFloatingItem" == action || "removeFloatingItem" == action) {
				if("meg" == act.ftype) {
					var span = act.name.split(store.separateChar);
					span[0] = sheetId;
					span[1] = Number(span[1]);
					span[2] = Number(span[2]);
					span[3] = Number(span[3]);
					span[4] = Number(span[4]);
					var cells = this.getRecalculateCellsByCoord([span]);
					this.refreshCalCdt(cells);
				}
			}
		}, this);
	},
	getCrossFileReference: function(refName) {
		if(this.corssFileReference) {
			return this.corssFileReference[refName];
		}
	},
	getCrossFileRef: function(crossFileName, express) {
		var calculate = this.getCalculate(),
			store = this.getStore();
		var o = calculate.transferCalculate({
			data: crossFileName ? "=[" + crossFileName + "]" + express : "=" + express
		}, store, undefined, undefined, undefined, "named_func");
		o = calculate.processCalculate(o, {
			store: store
		}, "named_func");
		return o.data;
	},
	addDropdownStore: function(name, config, callback, scope) {
		var store = this.getStore();
		if(store.isDisabledPulling()) {
			if(callback) {
				callback.call(scope, false);
			}
			return;
		}
		Ext.Ajax.request({
			timeout: SCONST.PULLING_TIMEOUT,
			url: SCONFIG.urls.createDataset,
			params: {
				documentId: store.fileId,
				name: name,
				data: Ext.encode(config)
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				var success = true;
				if(true !== json.success && "true" !== json.success) {
					success = false;
					if(this.isSheetUI()) {
						Ext.Msg.alert(SLANG.hint, SLANG.fail2add_dataset);
					}
				}
				if(callback) {
					callback.call(scope, success, json);
				}
			},
			failure: function(response) {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.fail2add_dataset);
				}
				if(callback) {
					callback.call(scope, false);
				}
			},
			scope: this
		});
	},
	deleteDropdownStore: function(drop, callback, scope) {
		if(store.isDisabledPulling()) {
			if(callback) {
				callback.call(scope, false);
			}
			return;
		}
		Ext.Ajax.request({
			timeout: SCONST.PULLING_TIMEOUT,
			url: SCONFIG.urls.deleteDataset,
			params: {
				id: drop.id
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				var success = true;
				if(true === json.success || "true" === json.success) {
					EnterpriseSheet.sheet.plugin.DropList.prototype.deleteDatasetFromLookup(drop);
				} else {
					success = false;
					if(this.isSheetUI()) {
						Ext.Msg.alert(SLANG.hint, SLANG.fail2delete_dataset);
					}
				}
				if(callback) {
					callback.call(scope, success, drop);
				}
			},
			failure: function(response) {
				if(this.isSheetUI()) {
					Ext.Msg.alert(SLANG.hint, SLANG.fail2delete_dataset);
				}
				if(callback) {
					callback.call(scope, false, drop);
				}
			},
			scope: this
		});
	},
	getCalReferenceTree: function() {
		var store = this.getStore(),
			calRefsMap = store.calRefsMap;
		console.log(calRefsMap);
	},
	syncSheetFloating: function(suspendEvent, skipUpdateConfig) {
		this.fireEvent("syncfloating", this);
	},
	addComboByStore: function(sheetId, row, col, storeJson) {
		var combo = {
			store: storeJson
		};
		this.setCell(sheetId, row, col, {
			drop: Ext.encode(combo)
		});
		this.fireEvent("addcombo", sheetId, row, col, combo, this);
	},
	addCombo: function(sheetId, row, col, dataSourceName) {
		var combo = {
			dataSource: dataSourceName
		};
		this.setCell(sheetId, row, col, {
			drop: Ext.encode(combo)
		});
		this.fireEvent("addcombo", sheetId, row, col, combo, this);
	},
	removeCombo: function(sheetId, row, col) {
		var cell = this.getStore().getCell(sheetId, row, col);
		var drop = cell.drop;
		if(drop) {
			drop = Ext.decode(drop);
			if(drop.store || drop.dataSource) {
				this.setCell(sheetId, row, col, undefined, ["drop", "valId"]);
				this.fireEvent("removecombo", sheetId, row, col, drop, this);
			}
		}
	},
	refreshCombo: function(sheetId, row, col) {
		var store = this.getStore();
		var cell = store.getCell(sheetId, row, col);
		var drop = cell.drop;
		if(drop) {
			drop = Ext.decode(drop);
			var dataSource = drop.dataSource;
			if(dataSource) {
				EnterpriseSheet.sheet.plugin.DropList.prototype.refreshDataSource(dataSource);
			}
		}
	}
});

if(!Ext.isIE) {
	var userAgent = navigator.userAgent;
	if(/(Edge\/)|(MSIE)/gi.test(userAgent) || /(Trident\/)/gi.test(navigator.appVersion)) {
		Ext.isIE = true;
		Ext.isChrome = false;
		Ext.isSafari = false;
		Ext.isWebKit = false;
		Ext.isGecko = false;
		Ext.isOpera = false
	}
}
if(Ext.form.field.VTypes) {
	Ext.apply(Ext.form.field.VTypes, {
		varname: function(v) {
			return /^(([a-z_]+[a-z_0-9]*)|([a-z_]+[a-z_0-9.]*[a-z_]+))$/.test(v)
		},
		varnameText: "Must be composed by letter, number, _ or ."
	})
}
Ext.override(Ext.menu.Menu, {
	onMouseLeave: function(e) {
		var me = this;
		var visibleSubmenu = false;
		me.items.each(function(item) {
			if(item.menu && item.menu.isVisible()) {
				visibleSubmenu = true
			}
		});
		if(visibleSubmenu) {
			return
		}
		me.deactivateActiveItem();
		if(me.disabled) {
			return
		}
		me.fireEvent("mouseleave", me, e)
	}
});
Ext.override(Ext.button.Button, {
	renderTpl: ['<span id="{id}-btnWrap" class="{baseCls}-wrap', '<tpl if="splitCls"> {splitCls}</tpl>', '{childElCls}" unselectable="on">', '<span id="{id}-btnEl" class="{baseCls}-button">', '<span id="{id}-btnInnerEl" class="{baseCls}-inner {innerCls}', '{childElCls}" unselectable="on">', "{text}", "</span>", '<span role="img" id="{id}-btnIconEl" class="{baseCls}-icon-el {iconCls}', '{childElCls} {glyphCls}" unselectable="on" style="', '<tpl if="iconUrl">background-image:url({iconUrl});</tpl>', '<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">', '<tpl if="glyph">&#{glyph};</tpl><tpl if="iconCls || iconUrl"><tpl if="needBlank">&#160;</tpl></tpl>', "</span>", "</span>", "</span>", '<tpl if="closable">', '<span id="{id}-closeEl" class="{baseCls}-close-btn" title="{closeText}" tabIndex="0"></span>', "</tpl>"],
	getTemplateArgs: function() {
		var me = this,
			glyph = me.glyph,
			glyphFontFamily = Ext._glyphFontFamily,
			glyphParts;
		if(typeof glyph === "string") {
			glyphParts = glyph.split("@");
			glyph = glyphParts[0];
			glyphFontFamily = glyphParts[1]
		}
		return {
			innerCls: me.getInnerCls(),
			splitCls: me.getSplitCls(),
			iconUrl: me.icon,
			iconCls: me.iconCls,
			glyph: glyph,
			glyphCls: glyph ? me.glyphCls : "",
			glyphFontFamily: glyphFontFamily,
			needBlank: !(me.iconCls && -1 !== me.iconCls.indexOf("fa fa-")),
			text: me.text || "&#160;"
		}
	}
});
Ext.define("Ext.ux.TopReminder", {
	singleton: true,
	createBox: function(t, s) {
		return '<div class="top-reminder">' + (t ? "<h3>" + t + "</h3>" : "") + "<p>" + s + "</p></div>"
	},
	showMsg: function(title, msg, stayTime) {
		if(!this.msgCt) {
			this.msgCt = Ext.DomHelper.insertFirst(document.body, {
				id: "top-reminder"
			}, true)
		}
		var m = Ext.DomHelper.append(this.msgCt, this.createBox(title, msg), true);
		m.hide();
		stayTime = stayTime || 4000;
		m.slideIn("t").ghost("t", {
			delay: stayTime,
			remove: true
		})
	},
	init: function() {
		if(!this.msgCt) {
			this.msgCt = Ext.DomHelper.insertFirst(document.body, {
				id: "top-reminder"
			}, true)
		}
	}
}, function() {
	TOPMINDER = Ext.ux.TopReminder;
	Ext.onReady(TOPMINDER.init, TOPMINDER)
});
Ext.define("Ext.ux.BoxReorderer", {
	mixins: {
		observable: "Ext.util.Observable"
	},
	itemSelector: ".x-box-item",
	animate: 100,
	constructor: function() {
		this.mixins.observable.constructor.apply(this, arguments)
	},
	init: function(container) {
		var me = this;
		me.container = container;
		me.animatePolicy = {};
		me.animatePolicy[container.getLayout().names.x] = true;
		me.container.on({
			scope: me,
			boxready: me.afterFirstLayout,
			beforedestroy: me.onContainerDestroy
		})
	},
	onContainerDestroy: function() {
		var dd = this.dd;
		if(dd) {
			dd.unreg();
			this.dd = null
		}
	},
	afterFirstLayout: function() {
		var me = this,
			layout = me.container.getLayout(),
			names = layout.names,
			dd;
		dd = me.dd = Ext.create("Ext.dd.DD", layout.innerCt, me.container.id + "-reorderer");
		Ext.apply(dd, {
			animate: me.animate,
			reorderer: me,
			container: me.container,
			getDragCmp: this.getDragCmp,
			clickValidator: Ext.Function.createInterceptor(dd.clickValidator, me.clickValidator, me, false),
			onMouseDown: me.onMouseDown,
			startDrag: me.startDrag,
			onDrag: me.onDrag,
			endDrag: me.endDrag,
			getNewIndex: me.getNewIndex,
			doSwap: me.doSwap,
			findReorderable: me.findReorderable
		});
		dd.dim = names.width;
		dd.startAttr = names.beforeX;
		dd.endAttr = names.afterX
	},
	getDragCmp: function(e) {
		return this.container.getChildByElement(e.getTarget(this.itemSelector, 10))
	},
	clickValidator: function(e) {
		var cmp = this.getDragCmp(e);
		return !!(cmp && cmp.reorderable !== false)
	},
	onMouseDown: function(e) {
		var me = this,
			container = me.container,
			containerBox, cmpEl, cmpBox;
		me.dragCmp = me.getDragCmp(e);
		if(me.dragCmp) {
			cmpEl = me.dragCmp.getEl();
			me.startIndex = me.curIndex = container.items.indexOf(me.dragCmp);
			cmpBox = cmpEl.getBox();
			me.lastPos = cmpBox[this.startAttr];
			containerBox = container.el.getBox();
			if(me.dim === "width") {
				me.minX = containerBox.left;
				me.maxX = containerBox.right - cmpBox.width;
				me.minY = me.maxY = cmpBox.top;
				me.deltaX = e.getX() - cmpBox.left
			} else {
				me.minY = containerBox.top;
				me.maxY = containerBox.bottom - cmpBox.height;
				me.minX = me.maxX = cmpBox.left;
				me.deltaY = e.getY() - cmpBox.top
			}
			me.constrainY = me.constrainX = true
		}
	},
	startDrag: function() {
		var me = this,
			dragCmp = me.dragCmp;
		if(dragCmp) {
			dragCmp.setPosition = Ext.emptyFn;
			dragCmp.animate = false;
			if(me.animate) {
				me.container.getLayout().animatePolicy = me.reorderer.animatePolicy
			}
			me.dragElId = dragCmp.getEl().id;
			me.reorderer.fireEvent("StartDrag", me, me.container, dragCmp, me.curIndex);
			dragCmp.suspendEvents();
			dragCmp.disabled = true;
			dragCmp.el.setStyle("zIndex", 100)
		} else {
			me.dragElId = null
		}
	},
	findReorderable: function(newIndex) {
		var me = this,
			items = me.container.items,
			newItem;
		if(items.getAt(newIndex).reorderable === false) {
			newItem = items.getAt(newIndex);
			if(newIndex > me.startIndex) {
				while(newItem && newItem.reorderable === false) {
					newIndex++;
					newItem = items.getAt(newIndex)
				}
			} else {
				while(newItem && newItem.reorderable === false) {
					newIndex--;
					newItem = items.getAt(newIndex)
				}
			}
		}
		newIndex = Math.min(Math.max(newIndex, 0), items.getCount() - 1);
		if(items.getAt(newIndex).reorderable === false) {
			return -1
		}
		return newIndex
	},
	doSwap: function(newIndex) {
		var me = this,
			items = me.container.items,
			container = me.container,
			wasRoot = me.container._isLayoutRoot,
			orig, dest, tmpIndex, temp;
		newIndex = me.findReorderable(newIndex);
		if(newIndex === -1) {
			return
		}
		me.reorderer.fireEvent("ChangeIndex", me, container, me.dragCmp, me.startIndex, newIndex);
		orig = items.getAt(me.curIndex);
		dest = items.getAt(newIndex);
		items.remove(orig);
		tmpIndex = Math.min(Math.max(newIndex, 0), items.getCount() - 1);
		items.insert(tmpIndex, orig);
		items.remove(dest);
		items.insert(me.curIndex, dest);
		container._isLayoutRoot = true;
		container.updateLayout();
		container._isLayoutRoot = wasRoot;
		me.curIndex = newIndex
	},
	onDrag: function(e) {
		var me = this,
			newIndex;
		newIndex = me.getNewIndex(e.getPoint());
		if((newIndex !== undefined)) {
			me.reorderer.fireEvent("Drag", me, me.container, me.dragCmp, me.startIndex, me.curIndex);
			me.doSwap(newIndex)
		}
	},
	endDrag: function(e) {
		if(e) {
			e.stopEvent()
		}
		var me = this,
			layout = me.container.getLayout(),
			temp;
		if(me.dragCmp) {
			delete me.dragElId;
			delete me.dragCmp.setPosition;
			me.dragCmp.animate = true;
			me.dragCmp.lastBox[layout.names.x] = me.dragCmp.getPosition(true)[layout.names.widthIndex];
			me.container._isLayoutRoot = true;
			me.container.updateLayout();
			me.container._isLayoutRoot = undefined;
			temp = Ext.fx.Manager.getFxQueue(me.dragCmp.el.id)[0];
			if(temp) {
				temp.on({
					afteranimate: me.reorderer.afterBoxReflow,
					scope: me
				})
			} else {
				Ext.Function.defer(me.reorderer.afterBoxReflow, 1, me)
			}
			if(me.animate) {
				delete layout.animatePolicy
			}
			me.reorderer.fireEvent("drop", me, me.container, me.dragCmp, me.startIndex, me.curIndex)
		}
	},
	afterBoxReflow: function() {
		var me = this;
		me.dragCmp.el.setStyle("zIndex", "");
		me.dragCmp.disabled = false;
		me.dragCmp.resumeEvents()
	},
	getNewIndex: function(pointerPos) {
		var me = this,
			dragEl = me.getDragEl(),
			dragBox = Ext.fly(dragEl).getBox(),
			targetEl, targetBox, targetMidpoint, i = 0,
			it = me.container.items.items,
			ln = it.length,
			lastPos = me.lastPos;
		me.lastPos = dragBox[me.startAttr];
		for(; i < ln; i++) {
			targetEl = it[i].getEl();
			if(targetEl.is(me.reorderer.itemSelector)) {
				targetBox = targetEl.getBox();
				targetMidpoint = targetBox[me.startAttr] + (targetBox[me.dim] >> 1);
				if(i < me.curIndex) {
					if((dragBox[me.startAttr] < lastPos) && (dragBox[me.startAttr] < (targetMidpoint - 5))) {
						return i
					}
				} else {
					if(i > me.curIndex) {
						if((dragBox[me.startAttr] > lastPos) && (dragBox[me.endAttr] > (targetMidpoint + 5))) {
							return i
						}
					}
				}
			}
		}
	}
});

Ext.define("EnterpriseSheet.common.CONST", {
	extend: "EnterpriseSheet.pure.common.CONST",
	constructor: function(config) {
		config = config || {};
		var ml = Ext.isChrome || Ext.isSafari ? 17895697 : Ext.isGecko ? 8000000 : 10000000;
		ml = 4094267;
		config.ml = ml;
		EnterpriseSheet.common.CONST.prototype.superclass.constructor.apply(this, [config]);
	}
}, function() {
	SCONST = Ext.create("EnterpriseSheet.common.CONST");
});

Ext.define("EnterpriseSheet.common.Common", {
	extend: "EnterpriseSheet.pure.common.Common",
	requires: ["Ext.data.proxy.Memory", "Ext.data.ArrayStore", "Ext.form.field", "Ext.tip.QuickTip"],
	constructor: function() {
		var getStr = function(str, defaultStr) {
			var text;
			if(SLANG) {
				text = SLANG[str];
			}
			if(!text) {
				text = defaultStr || str;
			}
			return text;
		};
		var textFormatStore = new Ext.data.ArrayStore({
			fields: ["id", "text", "preview"],
			data: [
				["regular", getStr("regular"), ""],
				["number", getStr("number"), ""],
				["comma", getStr("comma"), ""],
				["money", getStr("money"), ""],
				["date", getStr("date"), ""],
				["time", getStr("time"), ""],
				["percent", getStr("percentage"), ""],
				["fraction", getStr("fraction"), ""],
				["science", getStr("science"), ""],
				["text", getStr("text"), ""]
			]
		});
		var fontFamilyStore;
		if(SCONFIG.default_locale == "zh_CN") {
			fontFamilyStore = new Ext.data.ArrayStore({
				fields: ["id", "text"],
				data: SCONFIG.fontFamilyDataCN
			});
		} else {
			fontFamilyStore = new Ext.data.ArrayStore({
				fields: ["id", "text"],
				data: SCONFIG.fontFamilyDataEN
			});
		}
		var fontSizeStore = new Ext.data.ArrayStore({
			fields: ["id", "text"],
			data: [
				["6", "6pt"],
				["7", "7pt"],
				["8", "8pt"],
				["9", "9pt"],
				["10", "10pt"],
				["11", "11pt"],
				["12", "12pt"],
				["14", "14pt"],
				["16", "16pt"],
				["18", "18pt"],
				["20", "20pt"],
				["22", "22pt"],
				["24", "24pt"],
				["26", "26pt"],
				["28", "28pt"],
				["36", "36pt"],
				["48", "48pt"],
				["72", "72pt"]
			]
		});
		var boolStyleStore = new Ext.data.ArrayStore({
			fields: ["id", "text", "style"],
			data: [
				[1, getStr("red_fill_darkred_text"), {
					cbgc: "rgb(248,105,107)",
					ccolor: "rgb(150,0,0)"
				}],
				[2, getStr("yellow_fill_darkyellow_text"), {
					cbgc: "rgb(255,235,132)",
					ccolor: "rgb(150,150,0)"
				}],
				[3, getStr("green_fill_darkgreen_text"), {
					cbgc: "rgb(90,190,123)",
					ccolor: "rgb(0,100,50)"
				}],
				[4, getStr("pink_fill"), {
					cbgc: "rgb(248,105,107)"
				}],
				[5, getStr("red_text"), {
					ccolor: "red"
				}],
				[6, getStr("yellow_text"), {
					ccolor: "rgb(255,255,0)"
				}],
				[7, getStr("gray_text"), {
					ccolor: "rgb(216,216,216)"
				}],
				[8, getStr("complete"), {
					cbgc: "#735773",
					cbg: " "
				}],
				[9, getStr("complete_beyond"), {
					cbgc: "#E9AB51",
					cbg: " "
				}],
				[10, getStr("plan"), {
					cbgc: "#ffffff",
					cbg: "url(js/EnterpriseSheet/resources/images/fill/t_d_s.png)"
				}],
				[11, getStr("actual_start"), {
					cbgc: "#C9B8C9",
					cbg: "url(js/EnterpriseSheet/resources/images/fill/t_d_s.png)"
				}],
				[12, getStr("actual_beyond"), {
					cbgc: "#F6DDB9",
					cbg: "url(js/EnterpriseSheet/resources/images/fill/t_d_s.png)"
				}]
			]
		});
		var repeatStore = new Ext.data.ArrayStore({
			fields: [{
				name: "id",
				type: "int"
			}, "text"],
			data: [
				[SCONST.REPEAT_VALUE, getStr("repeat_value")],
				[SCONST.SOLE_VALUE, getStr("sole_value")]
			]
		});
		var paperSizeStore = new Ext.data.ArrayStore({
			fields: [{
				name: "id",
				type: "int"
			}, "text"],
			data: [
				[1, getStr("paper_letter")],
				[5, getStr("paper_legal")],
				[190, getStr("paper_oficio")],
				[14, getStr("paper_folio")],
				[9, getStr("paper_a4")],
				[34, getStr("paper_b5")],
				[13, getStr("paper_b5_jis")],
				[7, getStr("paper_executive")],
				[11, getStr("paper_a5")],
				[37, getStr("paper_monach")],
				[20, getStr("paper_no10")],
				[27, getStr("paper_dl")],
				[28, getStr("paper_c5")],
				[130, getStr("paper_postcard")],
				[3, getStr("paper_ledger")],
				[8, getStr("paper_a3")],
				[12, getStr("paper_b4")],
				[30, getStr("paper_c4")]
			]
		});
		var printQualityStore = new Ext.data.ArrayStore({
			fields: [{
				name: "id",
				type: "int"
			}, "text"],
			data: [
				[600, "600 dpi"],
				[1200, "1200 dpi"]
			]
		});
		var dateOptionStore = new Ext.data.ArrayStore({
			fields: [{
				name: "id",
				type: "int"
			}, "text"],
			data: [
				[SCONST.YESTERDAY, getStr("yesterday")],
				[SCONST.TODAY, getStr("today")],
				[SCONST.TOMORROW, getStr("tomorrow")],
				[SCONST.SEVEN_DAY, getStr("7day")],
				[SCONST.LAST_WEEK, getStr("last_week")],
				[SCONST.THIS_WEEK, getStr("this_week")],
				[SCONST.NEXT_WEEK, getStr("next_week")],
				[SCONST.LAST_MONTH, getStr("last_month")],
				[SCONST.THIS_MONTH, getStr("this_month")],
				[SCONST.NEXT_MONTH, getStr("next_month")]
			]
		});
		var filterConditionStore = new Ext.data.ArrayStore({
			fields: ["ctype", "display"],
			data: [
				["eq", getStr("equal")],
				["neq", getStr("not_equal")],
				["gt", getStr("greater_than")],
				["ge", getStr("greater_or_equal")],
				["lt", getStr("less_than")],
				["le", getStr("less_or_equal")],
				["bw", getStr("between")],
				["t10", getStr("top10")],
				["b10", getStr("bottom10")],
				["av", getStr("above_average")],
				["bv", getStr("below_average")]
			]
		});
		var iconSetTpl = new Ext.XTemplate(["<tpl for=\".\"><div class=\"ss-condition-iconset x-boundlist-item\">", "<tpl for=\"icons\">", "<div class=\"ss-condition-icon\" style=\"background-image:url(", SCONFIG.CONDITION_ICONS_PATH, "/{parent.set}/{.}.png);\"></div>", "</tpl>", "</div></tpl>"].join(""));
		var iconSetData = [{
			set: 0,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 1,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 2,
			level: 4,
			icons: [0, 1, 2, 3]
		}, {
			set: 3,
			level: 5,
			icons: [0, 1, 2, 3, 4]
		}, {
			set: 4,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 5,
			level: 4,
			icons: [0, 1, 2, 3]
		}, {
			set: 6,
			level: 5,
			icons: [0, 1, 2, 3, 4]
		}, {
			set: 7,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 8,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 9,
			level: 4,
			icons: [0, 1, 2, 3]
		}, {
			set: 10,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 11,
			level: 4,
			icons: [0, 1, 2, 3]
		}, {
			set: 12,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 13,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 14,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 15,
			level: 3,
			icons: [0, 1, 2]
		}, {
			set: 16,
			level: 5,
			icons: [0, 1, 2, 3, 4]
		}, {
			set: 17,
			level: 5,
			icons: [0, 1, 2, 3, 4]
		}, {
			set: 18,
			level: 4,
			icons: [0, 1, 2, 3]
		}, {
			set: 19,
			level: 5,
			icons: [0, 1, 2, 3, 4]
		}];
		var iconSetStore = new Ext.data.Store({
			fields: ["set", "level", "icons"],
			data: iconSetData
		});
		var iconData = [];
		for(var i = 0, len = iconSetData.length; i < len; i++) {
			var it = iconSetData[i],
				setIndex = it.set,
				icons = it.icons;
			for(var j = 0, count = icons.length; j < count; j++) {
				iconData.push({
					set: setIndex,
					idx: icons[j]
				});
			}
		}
		var iconTpl = new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"ss-condition-iconset x-boundlist-item ss-condition-icon\" style=\"background-image:url(", SCONFIG.CONDITION_ICONS_PATH, "/{set}/{idx}.png);\"></div>", "</tpl>"].join(""));
		var iconStore = new Ext.data.Store({
			fields: ["set", "idx"],
			data: iconData
		});
		var titleIconTpl = new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"x-boundlist-item ss-title-icon\" style=\"background-image:url(", SCONFIG.TITLE_ICONS_PATH, "/{idx}.png);\"></div>", "</tpl>"].join(""));
		var titleIconData = [{
			idx: "add"
		}, {
			idx: "address"
		}, {
			idx: "attach"
		}, {
			idx: "bug"
		}, {
			idx: "calendar"
		}, {
			idx: "calculator"
		}, {
			idx: "cancel"
		}, {
			idx: "checkbox"
		}, {
			idx: "cog"
		}, {
			idx: "contact"
		}, {
			idx: "date"
		}, {
			idx: "disk"
		}, {
			idx: "dropdown"
		}, {
			idx: "email"
		}, {
			idx: "folder"
		}, {
			idx: "group"
		}, {
			idx: "image"
		}, {
			idx: "information"
		}, {
			idx: "key"
		}, {
			idx: "link"
		}, {
			idx: "map"
		}, {
			idx: "money"
		}, {
			idx: "money_dollar"
		}, {
			idx: "money_yen"
		}, {
			idx: "number"
		}, {
			idx: "page"
		}, {
			idx: "percent"
		}, {
			idx: "profile"
		}, {
			idx: "phone"
		}, {
			idx: "printer"
		}, {
			idx: "radio"
		}, {
			idx: "remoteList"
		}, {
			idx: "star"
		}, {
			idx: "sum"
		}, {
			idx: "table"
		}, {
			idx: "text"
		}, {
			idx: "textLong"
		}, {
			idx: "thumb_down"
		}, {
			idx: "thumb_up"
		}, {
			idx: "tick"
		}, {
			idx: "time"
		}, {
			idx: "user"
		}, {
			idx: "wrench"
		}, {
			idx: "zoom"
		}, {
			idx: "warning"
		}, {
			idx: "tag_blue"
		}, {
			idx: "tag_green"
		}, {
			idx: "tag_orange"
		}, {
			idx: "tag_purple"
		}, {
			idx: "tag_red"
		}];
		var titleIconStore = new Ext.data.Store({
			fields: ["idx"],
			data: titleIconData
		});
		var getInnerText = function(el) {
			if(el.innerText) {
				return el.innerText;
			} else if(el.textContent) {
				return el.textContent;
			} else {
				var anyString = "";
				var childS = el.childNodes;
				for(var i = 0; i < childS.length; i++) {
					if(childS[i].nodeType == 1) {
						anyString += childS[i].tagName == "BR" ? "" : childS[i].innerText;
					} else if(childS[i].nodeType == 3) {
						anyString += childS[i].nodeValue;
					}
				}
				return anyString;
			}
		};
		var getPureText = function(html) {
			var el = Ext.get("ss-puretext-tool");
			if(!el) {
				el = Ext.DomHelper.append(Ext.getBody(), "<div id=\"ss-puretext-tool\" style=\"position:absolute;top:-1000px;left:-1000px;\">" + html + "</div>", true);
			} else {
				el.update(html);
			}
			var text = getInnerText(el.dom);
			return text;
		};
		var findParentNodeForBoth = function(a, b) {
			if(a.contains(b)) {
				return a;
			}
			if(b.contains(a)) {
				return b;
			}
			var body = Ext.getBody();
			var p = a.parent();
			while(p !== body) {
				if(p.contains(b)) {
					return p;
				}
				p = p.parent();
			}
			return body;
		};
		var findTextOrEmptyElemNodeFromEnd = function(node) {
			if(node.childNodes && Ext.isNumber(node.childNodes.length) && 0 < node.childNodes.length) {
				for(var i = node.childNodes.length - 1; 0 <= i; i--) {
					var child = node.childNodes[i];
					if(3 === child.nodeType) {
						return child;
					} else if(1 === child.nodeType) {
						var found = findTextOrEmptyElemNodeFromEnd(child);
						if(found) {
							return found;
						}
					}
				}
			} else {
				return node;
			}
		};
		var config = {
			fontFamilyStore: fontFamilyStore,
			fontSizeStore: fontSizeStore,
			textFormatStore: textFormatStore,
			boolStyleStore: boolStyleStore,
			repeatStore: repeatStore,
			paperSizeStore: paperSizeStore,
			printQualityStore: printQualityStore,
			dateOptionStore: dateOptionStore,
			iconTpl: iconTpl,
			titleIconTpl: titleIconTpl,
			iconSetTpl: iconSetTpl,
			iconStore: iconStore,
			titleIconStore: titleIconStore,
			iconSetStore: iconSetStore,
			filterConditionStore: filterConditionStore,
			getInnerText: getInnerText,
			getPureText: getPureText,
			findParentNodeForBoth: findParentNodeForBoth,
			getSelectedText: function() {
				if(window.getSelection) {
					return window.getSelection().toString();
				} else if(document.getSelection) {
					return document.getSelection();
				} else if(document.selection) {
					return document.selection.createRange().text;
				}
			},
			getSelectedTextPos: function() {
				if(document.selection) {
					var r = document.selection.createRange();
					var container = r.parentElement();
					var d = r.duplicate();
					d.moveToElementText(container);
					d.setEndPoint("EndToEnd", r);
					var startOffset = d.text.length - r.text.length;
					var endOffset = d.text.length;
					return {
						container: container,
						startOffset: startOffset,
						endOffset: endOffset
					};
				} else if(window.getSelection) {
					var s = window.getSelection();
					if(0 < s.rangeCount) {
						var r = s.getRangeAt(0);
						return {
							startContainer: r.startContainer,
							endContainer: r.endContainer,
							startOffset: r.startOffset,
							endOffset: r.endOffset
						};
					}
				}
			},
			getCursorPosition: function(t) {
				if(document.selection) {
					t.focus();
					var ds = document.selection;
					var range = ds.createRange();
					var stored_range = range.duplicate();
					stored_range.moveToElementText(t);
					stored_range.setEndPoint("EndToEnd", range);
					t.selectionStart = stored_range.text.length - range.text.length;
					t.selectionEnd = t.selectionStart + range.text.length;
					return t.selectionStart;
				} else {
					return t.selectionStart;
				}
			},
			selectAll: function(elem) {
				try {
					var el = elem;
					var str = el.innerHTML;
					if(str && 0 < str.length) {
						var container = el,
							startContainer = endContainer = el.firstChild,
							endOffset = startOffset = str.length;
						if(document.selection) {
							var range = document.selection.createRange();
							document.selection.empty();
							range.moveToElementText(container);
							range.select();
						} else if(window.getSelection) {
							var s = window.getSelection();
							if(0 < s.rangeCount) {
								s.removeAllRanges();
							}
							var range = document.createRange();
							range.selectNodeContents(el);
							s.addRange(range);
						}
					}
				} catch(e) {}
			},
			setCursorPosition: function(elem, pos) {
				try {
					var el = elem;
					var str = el.innerHTML;
					var strLen = str.length;
					if(str && 0 < strLen) {
						var container = el,
							startContainer = endContainer = el.firstChild,
							endOffset = startOffset = strLen;
						if(document.selection) {
							var range = document.selection.createRange();
							document.selection.empty();
							range.moveToElementText(container);
							range.moveStart("character", pos);
							range.moveEnd("character", pos);
							range.collapse(true);
							range.select();
						} else if(window.getSelection) {
							var s = window.getSelection();
							if(0 < s.rangeCount) {
								s.removeAllRanges();
							}
							var range = document.createRange();
							range.setStart(startContainer, pos);
							range.setEnd(startContainer, pos);
							s.addRange(range);
						}
					}
				} catch(e) {}
			},
			moveCursor2End: function(elem) {
				try {
					var el = elem;
					var str = el.innerHTML;
					if(str && 0 < str.length && str != "<br>") {
						var container = el,
							startContainer = endContainer = el.firstChild,
							endOffset = startOffset = str.length;
						if(document.selection) {
							var range = document.selection.createRange();
							document.selection.empty();
							range.moveToElementText(container);
							range.collapse(false);
							range.select();
						} else if(window.getSelection) {
							var s = window.getSelection();
							if(0 < s.rangeCount) {
								s.removeAllRanges();
							}
							var range = document.createRange();
							var node = findTextOrEmptyElemNodeFromEnd(el);
							if(node) {
								if(3 === node.nodeType) {
									range.selectNode(node);
									s.addRange(range);
									var str = node.nodeValue,
										i = 0;
									if(str) {
										i = node.nodeValue.length;
									}
									s.collapse(node, i);
								} else if(1 === node.nodeType) {
									range.selectNode(node);
									s.addRange(range);
									s.collapse(node, 0);
								}
							} else {
								range.selectNode(el);
								s.addRange(range);
								s.collapse(el, 1);
							}
						}
					}
				} catch(e) {}
			},
			setActiveStyleSheet: function(title) {
				var i, a, links = document.getElementsByTagName("link"),
					len = links.length;
				for(i = 0; i < len; i++) {
					a = links[i];
					if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
						a.disabled = true;
						if(a.getAttribute("title") == title) {
							a.disabled = false;
						}
					}
				}
			},
			needShowLogo: function() {
				return "3.0.5.20150201" !== SCONST.limitType;
			},
			showPoweredByLogo: function(el) {
				var logoEl = Ext.DomHelper.append(el, ["<div style=\"", "position:absolute;right:20px;bottom:20px;padding: 10px 16px;", "background:rgb(60,60,60);color:white;cursor:pointer;font-size:12px;", "-webkit-border-radius: 3px;", "-moz-border-radius: 3px;", "border-radius: 3px;", "opacity:.9;", "-moz-box-shadow:2px 2px 6px #BBB;", "-webkit-box-shadow:2px 2px 6px #BBB;", "box-shadow:2px 2px 6px #BBB;", "z-index:", SCONST.CORNER_Z_INDEX, ";\">Power\x1Ded by EnterpriseSheet</div>"].join(""), true);
				var tip = Ext.create("Ext.tip.ToolTip", {
					target: logoEl.id,
					anchor: "left",
					width: 370,
					dismissDelay: 10000,
					renderTo: Ext.getBody(),
					html: "This FREE one month trial of spreadsheet is powered by EnterpriseSheet. You need buy commercial license before the expired date and remove this logo. Click here to see more detail information."
				});
				logoEl.on("click", function() {
					window.open("http://www.enterprisesheet.com");
				}, this);
			}
		};
		EnterpriseSheet.common.Common.prototype.superclass.constructor.apply(this, arguments);
		Ext.apply(this, config);
	}
}, function() {
	SCOM = Ext.create("EnterpriseSheet.common.Common");
});

Ext.define("EnterpriseSheet.common.Helper", {
	extend: "EnterpriseSheet.pure.common.Helper"
}, function() {
	HELPER = Ext.create("EnterpriseSheet.common.Helper");
});

Ext.define("EnterpriseSheet.common.FormulaHelper", {
	extend: "EnterpriseSheet.pure.common.FormulaHelper"
}, function() {
	FORMULA_HELPER = Ext.create("EnterpriseSheet.common.FormulaHelper");
});

Ext.define("EnterpriseSheet.common.ColorMenu", {
	extend: "Ext.menu.Menu",
	requires: ["EnterpriseSheet.common.Common", "Ext.picker.Color"],
	themeColorStr: "Theme Colors",
	standardColorStr: "Standard Colors",
	plain: true,
	initComponent: function() {
		this.cls = this.cls || "";
		this.cls = "color-menu " + this.cls;
		this.themeColorPicker = Ext.create("Ext.picker.Color", {
			allowReselect: true,
			colors: SCOM.themeColors,
			listeners: {
				select: {
					fn: this.onSelectColor,
					scope: this
				}
			}
		});
		this.standardColorPicker = Ext.create("Ext.picker.Color", {
			allowReselect: true,
			listeners: {
				select: {
					fn: this.onSelectColor,
					scope: this
				}
			}
		});
		var mitems = ["<span class=\"menu-title\">" + this.themeColorStr + "</span>", this.themeColorPicker, "<span class=\"menu-title\">" + this.standardColorStr + "</span>", this.standardColorPicker];
		if(this.items instanceof Array) {
			mitems = mitems.concat(this.items);
		}
		this.items = mitems;
		this.callParent();
		this.on("afterrender", function() {
			var block = this.themeColorPicker.getEl().down(".x-color-picker-item");
			var w = block.getWidth() * 10 + 10;
			this.themeColorPicker.setWidth(w);
			this.themeColorPicker.getEl().setStyle("height", "auto");
			this.standardColorPicker.setWidth(w);
			this.standardColorPicker.getEl().setStyle("height", "auto");
		}, this);
	},
	onSelectColor: function(cp, color) {
		color = "#" + color;
		this.hide();
		if(this.selectHandler) {
			this.selectHandler.call(this.scope || this, cp, color);
		}
	}
});

Ext.define("EnterpriseSheet.common.ColorButton", {
	extend: "Ext.button.Split",
	requires: ["EnterpriseSheet.common.Common", "EnterpriseSheet.common.ColorMenu"],
	themeColorStr: "Theme Colors",
	standardColorStr: "Standard Colors",
	initialColor: "black",
	initComponent: function() {
		this.cls = this.cls || "";
		this.cls = "color-picker " + this.cls;
		this.menu = new EnterpriseSheet.common.ColorMenu({
			items: Ext.isArray(this.menu) ? this.menu : [],
			selectHandler: this.onSelectColor,
			scope: this
		});
		this.callParent();
		this.on({
			scope: this,
			afterrender: this._afterRender
		});
	},
	_afterRender: function() {
		if(this.useFontGlyph) {
			var em = this.el.down(".x-btn-inner");
			em.setStyle("color", this.initialColor);
			this.fontWrapEl = em;
		} else {
			var em = this.el.down(".x-btn-button");
			if(em) {
				this.colorBlock = Ext.core.DomHelper.append(em.dom, "<a class=\"color-block\"></a>", true);
				this.setColor(this.initialColor);
			}
		}
	},
	setColor: function(color) {
		if(this.colorBlock) {
			if(!color || "transparent" == color) {
				this.colorBlock.setStyle("background-color", "");
				this.colorBlock.setStyle("border", "1px solid");
			} else {
				this.colorBlock.setStyle("background-color", color);
				this.colorBlock.setStyle("border", "1px solid " + color);
			}
		} else {
			this.fontWrapEl.setStyle("color", color);
		}
	},
	onSelectColor: function(cp, color) {
		this.setColor(color);
		if(this.selectHandler) {
			this.selectHandler.call(this.scope || this, cp, color);
		}
	}
});

Ext.define("EnterpriseSheet.common.SimpleButton", {
	extend: "Ext.Component",
	alias: "widget.simplebtn",
	color: "rgb(1,132,187)",
	maxTextLength: 15,
	renderTpl: "<span class=\"ss-simple-button-text\">{text}</span><div class=\"ss-simple-button-sep\"><div class=\"ss-simple-button-arrow\"></div></div>",
	initRenderData: function() {
		var data = this.callParent(arguments);
		var text = this.text;
		if(text && text.length > this.maxTextLength) {
			text = Ext.util.Format.ellipsis(text, this.maxTextLength);
			text = "<span data-qtip=\"" + this.text + "\">" + text + "</span>";
		}
		data.text = text || "&nbsp;";
		return data;
	},
	initComponent: function() {
		this.cls = this.cls || "";
		this.cls += " ss-simple-button x-unselectable";
		this.initMenu();
		this.callParent(arguments);
		this.on("afterrender", this._afterRender, this);
		this.on("resize", function() {
			var el = this.getEl();
			var width = el.getWidth();
			el.setStyle("min-width", Math.ceil(width) + "px");
		}, this);
	},
	initMenu: function() {
		if(this.menu) {
			if(!(this.menu instanceof Ext.menu.Menu)) {
				this.menu = new Ext.menu.Menu({
					items: this.menu
				});
			}
		}
	},
	_afterRender: function() {
		var el = this.getEl();
		var paddingRight = el.getPadding("r") || "";
		if(this.iconCls) {
			el.addCls(this.iconCls);
		}
		if(this.color) {
			el.setStyle("outline-color", this.color);
		}
		this.spanEl = el.down(".ss-simple-button-text");
		this.sepEl = el.down(".ss-simple-button-sep");
		this.arrowEl = el.down(".ss-simple-button-arrow");
		this.toggle(this.pressed, true);
		this.mon(el, {
			scope: this,
			mousedown: function() {
				if(!this.disabled) {
					el.addCls("ss-simple-button-push");
				}
			}
		});
		Ext.getBody().on("mouseup", function() {
			var el = this.getEl();
			if(el && el.hasCls("ss-simple-button-push")) {
				el.removeCls("ss-simple-button-push");
			}
		}, this);
		if(this.menu && !this.hideArrow && !this.notSplited) {
			el.setStyle("padding-right", 18 + paddingRight + "px");
			this.sepEl.show();
		} else {
			if(paddingRight != null && paddingRight != "") {
				el.setStyle("padding-right", paddingRight + "px");
			}
			this.sepEl.hide();
		}
		this.mon(el, {
			scope: this,
			click: function(e) {
				if(this.disabled) {
					return;
				}
				var target = Ext.get(e.getTarget(".ss-simple-button-sep"));
				if(target == this.sepEl) {
					this.showMenu();
				} else {
					if(this.handler) {
						this.handler.call(this.scope, this, e);
					} else if(this.notSplited) {
						this.showMenu();
					}
					this.fireEvent("click", this, e);
				}
			}
		});
	},
	showMenu: function() {
		var el = this.getEl();
		this.menu.on("hide", function() {
			el.removeCls("ss-simple-button-menu-pop");
		}, this, {
			single: true
		});
		el.addCls("ss-simple-button-menu-pop");
		this.menu.bindBtn = this;
		this.menu.showBy(this.sepEl);
	},
	correctColor: function(color) {
		var res = SCOM.getRGB(color);
		if(res) {
			var th = 230;
			if(th < res[0] && th < res[1] && th < res[2]) {
				return ["rgb(230,230,230)", "rgb(" + [255 - res[0], 255 - res[1], 255 - res[2]].join(",") + ")"];
			}
		}
		return [color, "white"];
	},
	toggle: function(pressed, suspendEvent) {
		this.pressed = pressed;
		var el = this.getEl();
		var c = this.color ? this.correctColor(this.color) : undefined;
		if(this.pressed) {
			el.addCls("ss-simple-button-pressed");
			if(this.color) {
				el.setStyle("color", c[1]);
				el.setStyle("background-color", this.color);
				this.arrowEl.setStyle("border-top-color", c[1]);
				this.sepEl.setStyle("border-left-color", c[1]);
			}
		} else {
			el.removeCls("ss-simple-button-pressed");
			if(this.color) {
				el.setStyle("color", c[0]);
				el.setStyle("background-color", "");
				this.arrowEl.setStyle("border-top-color", c[0]);
				this.sepEl.setStyle("border-left-color", c[0]);
			}
		}
		if(!suspendEvent) {
			this.fireEvent("toggle", this, this.pressed);
		}
	},
	isPressed: function() {
		return this.pressed;
	},
	setMaxTextLength: function(maxLength) {
		this.maxTextLength = maxLength;
	},
	setText: function(text) {
		this.text = text;
		if(text && text.length > this.maxTextLength) {
			var fullText = text;
			text = Ext.util.Format.ellipsis(text, this.maxTextLength);
			text = "<span data-qtip=\"" + fullText + "\">" + text + "</span>";
		}
		this.el.setStyle("min-width", "0px");
		this.spanEl.update(text);
		var w = Math.ceil(this.el.getWidth());
		this.el.setStyle("min-width", w + "px");
	},
	getText: function() {
		return this.text;
	},
	setIconCls: function(cls) {
		var me = this,
			el = me.el,
			oldCls = me.iconCls;
		me.iconCls = cls;
		if(el) {
			el.removeCls(oldCls);
			el.addCls(cls || "");
		}
		return me;
	},
	setBtnColor: function(color) {
		this.color = color;
		var el = this.getEl();
		if(this.color) {
			el.setStyle("outline-color", this.color);
		}
		this.toggle(this.pressed, true);
	},
	setBtnWidth: function(width) {
		this.width = width;
		var el = this.getEl();
		el.setStyle("width", this.width + "px");
		this.toggle(this.pressed, true);
		el.setStyle("min-width", "0px");
		var w = Math.ceil(el.getWidth());
		el.setStyle("min-width", w + "px");
	}
});

Ext.define("EnterpriseSheet.common.Tip", {
	extend: "Ext.tip.ToolTip",
	showAtTarget: function(t, xy) {
		this.target = t;
		if(this.disabled || this.triggerElement == t) {
			return;
		}
		if(t) {
			this.triggerElement = t;
			this.clearTimer("hide");
			this.targetXY = xy || t.getXY();
			this.show();
		}
	}
}, function() {
	SQTIP = (function() {
		var tip;
		return {
			init: function(config) {
				if(!tip) {
					var o = Ext.apply({
						autoWidth: true,
						autoHeight: true,
						mouseOffset: [0, -40]
					}, config);
					o.autoHide = false;
					tip = new EnterpriseSheet.common.Tip(o);
				}
			},
			show: function(html, t, xy) {
				if(tip) {
					if(html) {
						if(tip.body) {
							var el = tip.getEl(),
								body = tip.body;
							el.setStyle("width", "auto");
							body.setStyle("width", "auto");
							body.update(html);
							el.setStyle("height", "auto");
							body.setStyle("height", "auto");
						} else {
							tip.html = html;
						}
					}
					tip.showAtTarget(t, xy);
				}
			},
			hide: function() {
				if(tip) {
					tip.hide();
				}
			}
		};
	})();
});

Ext.define("EnterpriseSheet.common.IconField", {
	extend: "Ext.button.Button",
	requires: ["EnterpriseSheet.common.Common"],
	initComponent: function() {
		this.cls = this.cls || "";
		this.cls = "icon-field " + this.cls;
		this.myIconTpl = SCOM.iconTpl;
		this.iconStore = SCOM.iconStore;
		this.iconView = Ext.create("Ext.view.View", {
			store: this.iconStore,
			tpl: this.myIconTpl,
			width: 150,
			itemSelector: "div.ss-condition-iconset",
			overItemCls: "ss-iconset-over"
		});
		this.menu = {
			plain: true,
			items: [this.iconView]
		};
		var data = this.iconValue || this.iconStore.getAt(0).data;
		this.setIcon(SCONFIG.CONDITION_ICONS_PATH + "/" + data.set + "/" + data.idx + ".png");
		this.iconValue = data;
		this.callParent();
		this.iconView.on("itemclick", this.onIconClick, this);
	},
	onIconClick: function(view, rec) {
		var data = rec.data;
		var oldVal = this.iconValue;
		this.iconValue = data;
		this.setIcon(SCONFIG.CONDITION_ICONS_PATH + "/" + data.set + "/" + data.idx + ".png");
		this.menu.hide();
		this.fireEvent("valuechange", oldVal, data, this);
	},
	getIconValue: function() {
		return this.iconValue;
	},
	setValue: function(data, suspendEvent) {
		var oldVal = this.iconValue;
		this.iconValue = data;
		this.setIcon(SCONFIG.CONDITION_ICONS_PATH + "/" + data.set + "/" + data.idx + ".png");
		if(!suspendEvent) {
			this.fireEvent("valuechange", oldVal, data, this);
		}
	}
});

Ext.define("EnterpriseSheet.common.IconSetField", {
	extend: "Ext.button.Button",
	requires: ["EnterpriseSheet.common.Common"],
	initComponent: function() {
		this.cls = this.cls || "";
		this.cls = "icon-field " + this.cls;
		this.iconSetTpl = SCOM.iconSetTpl;
		this.iconSetStore = SCOM.iconSetStore;
		this.iconSetView = Ext.create("Ext.view.View", {
			store: this.iconSetStore,
			tpl: this.iconSetTpl,
			itemSelector: "div.ss-condition-iconset",
			overItemCls: "ss-iconset-over"
		});
		this.menu = {
			plain: true,
			items: [this.iconSetView]
		};
		var data = this.value || this.iconSetStore.getAt(0).data;
		var html = this.iconSetTpl.apply([data]);
		this.iconValue = data;
		this.setText(html);
		this.callParent();
		this.iconSetView.on("itemclick", this.onIconSetClick, this);
	},
	onIconSetClick: function(view, rec) {
		var data = rec.data;
		var oldVal = this.iconValue;
		this.iconValue = data;
		var html = this.iconSetTpl.apply([data]);
		this.setText(html);
		this.menu.hide();
		this.fireEvent("valuechange", oldVal, data, this);
	},
	getIconValue: function() {
		return this.iconValue;
	},
	setValue: function(data, suspendEvent) {
		var oldVal = this.iconValue;
		this.iconValue = data;
		if(!data) {
			this.setText("<div>" + SLANG.customize + "</div>");
		} else {
			var html = this.iconSetTpl.apply([data]);
			this.setText(html);
		}
		if(!suspendEvent) {
			this.fireEvent("valuechange", oldVal, data, this);
		}
	}
});

Ext.define("EnterpriseSheet.common.LoadMask", {
	extend: "Ext.LoadMask",
	initComponent: function() {
		this.cls = this.cls || "";
		this.cls = "ss-loadmask " + this.cls;
		this.callParent(arguments);
		this.on("afterrender", function() {
			Ext.DomHelper.append(this.msgEl.dom, ["<div class=\"mask-per\" style=\"display:none;\">", "<div class=\"mask-perinner\"></div>", "</div>"].join(""), true);
			this.perEl = this.msgEl.child("div.mask-per");
			this.perInnerEl = this.perEl.child("div.mask-perinner");
		}, this);
	},
	updatePercent: function(percent) {
		percent = Math.floor(percent * 100);
		if(99 < percent) {
			percent = 99;
		}
		this.perInnerEl.setWidth(percent + "%");
		this.perEl.setStyle("display", "");
		this.msgTextEl.update(this.msg + " " + percent + "%");
	},
	hide: function() {
		delete this._delayShowFlag;
		if(this.perEl) {
			this.perEl.setStyle("display", "none");
		}
		this.callParent(arguments);
	},
	show: function(displayText, showDelayTime) {
		displayText = displayText || this.msg;
		if(Ext.isNumber(showDelayTime)) {
			this._delayShowFlag = true;
			Ext.Function.defer(function() {
				if(this._delayShowFlag) {
					EnterpriseSheet.common.LoadMask.prototype.superclass.show.apply(this);
					this.msgTextEl.update(displayText);
				}
			}, showDelayTime, this);
		} else {
			this.callParent(arguments);
			this.msgTextEl.update(displayText);
		}
	},
	updateText: function(displayText) {
		this.msgTextEl.update(displayText);
	}
});

Ext.define("EnterpriseSheet.common.action.Action", {
	extend: "Ext.Action",
	addComponent: function(comp) {
		this.callParent(arguments);
		if(this.onceConfig) {
			Ext.apply(comp, this.onceConfig);
			delete this.onceConfig;
		}
	},
	callEach: function(fnName, args) {
		var cs = this.items;
		for(var i = 0, len = cs.length; i < len; i++) {
			if("function" == SCOM.typeOf(cs[i][fnName])) {
				cs[i][fnName].apply(cs[i], args);
			}
		}
	},
	toggle: function(pressed, suspendEvent) {
		this.initialConfig.pressed = pressed;
		this.callEach("toggle", [pressed, suspendEvent]);
	}
});

Ext.define("EnterpriseSheet.common.measure.CharMeasure", {
	constructor: function() {
		this.callParent(arguments);
		this.el = Ext.core.DomHelper.append(Ext.getBody(), "<div class=\"sc-char-measure\"><span class=\"sp-span\"></span></div>");
		this.span = this.el.firstChild;
	},
	getTabCharWidth: function() {
		if(SCOM.nullOrUndefined(this._tabWidth)) {
			var el = Ext.core.DomHelper.append(Ext.getBody(), "<span style=\"padding-left:20px;font-size:14px;font-weight:normal;font-style:none;\">&nbsp;</span>", true);
			this._tabWidth = el.getWidth();
			Ext.removeNode(el.dom);
		}
		return this._tabWidth;
	},
	measure: function(html) {
		this.span.innerHTML = html;
		var rects = this.span.getClientRects();
		var arr = [];
		for(var i = 0, len = rects.length; i < len; i++) {
			var rect = rects[i];
			if(!SCOM.nullOrUndefined(rect.width)) {
				arr.push(rect.width);
			} else {
				arr.push(rect.right - rect.left);
			}
		}
		this.span.innerHTML = "";
		return arr;
	}
});

Ext.define("EnterpriseSheet.common.measure.PixelMeasure", {
	constructor: function() {
		this.callParent(arguments);
		this.el = Ext.core.DomHelper.append(Ext.getBody(), "<div class=\"sc-px-measure\"></div>", true);
	},
	measure: function(width) {
		this.el.setStyle("width", width);
		return this.el.getWidth();
	}
});

Ext.define("EnterpriseSheet.common.menu.ScaleItem", {
	extend: "Ext.menu.Item",
	alias: "widget.scaleitem",
	scale: "small",
	initComponent: function() {
		this.cls = Ext.baseCSSPrefix + "scale-menu-item" + " " + Ext.baseCSSPrefix + this.scale + "-menu-item";
		this.callParent(arguments);
	}
});

Ext.define("EnterpriseSheet.common.menu.ScaleMenu", {
	extend: "Ext.menu.Menu",
	alias: "widget.scalemenu",
	requires: ["EnterpriseSheet.common.menu.ScaleItem"],
	scale: "small",
	initComponent: function() {
		this.bodyCls = Ext.baseCSSPrefix + "scale-menu-body" + " " + Ext.baseCSSPrefix + this.scale + "-menu-body";
		this.callParent();
	}
});

Ext.define("EnterpriseSheet.common.SortedArray", {
	extend: "EnterpriseSheet.pure.common.SortedArray"
});

Ext.define("EnterpriseSheet.common.pop.PopWin", {
	extend: "Ext.window.Window",
	bodyStyle: "padding:10px;background-color:white;",
	cls: "ss-popup-win",
	resizable: false,
	stateful: false,
	modal: true,
	shim: true,
	buttonAlign: "right",
	okText: "OK",
	cancelText: "Cancel",
	closable: true,
	closeAction: "hide",
	skipResetOnShow: false,
	updateConfig: Ext.emptyFn,
	initComponent: function() {
		this.prepareButton();
		this.callParent();
		this.on({
			scope: this,
			show: function() {
				if(!this.skipResetOnShow) {
					this.reset();
				}
				this.getEl().setVisible(true);
			}
		});
		if("hide" === this.closeAction) {
			this.on("hide", this.quit, this);
		} else {
			this.on("close", this.quit, this);
		}
	},
	ghost: function(cls) {
		if(!Ext.getVersion("core").isLessThan("4.0.9")) {
			var me = this;
			me.ghostPanel = new Ext.panel.Panel({
				renderTo: document.body,
				floating: {
					shadow: false
				},
				frame: Ext.supports.CSS3BorderRadius && !me.isWindow ? me.frame : false,
				overlapHeader: me.overlapHeader,
				headerPosition: me.headerPosition,
				baseCls: me.baseCls,
				cls: me.baseCls + "-ghost " + (cls || "")
			});
		}
		return this.callParent(arguments);
	},
	getStr: function(str) {
		if(SLANG) {
			return SLANG[str] || str;
		}
		return str;
	},
	reset: function() {
		var fn = function(items) {
			items.each(function(it) {
				if(it.items) {
					fn(it.items);
				} else if("function" == SCOM.typeOf(it.reset)) {
					it.reset();
				}
			});
		};
		if(this.items) {
			fn(this.items);
		}
	},
	isValid: function() {
		var flag = true;
		var fn = function(items) {
			items.each(function(it) {
				if(it.isVisible() && !it.disabled) {
					if("function" == SCOM.typeOf(it.isValid)) {
						var valid = it.isValid();
						if(flag) {
							flag = valid;
						}
					} else if(it.items) {
						fn(it.items);
					}
				}
			});
		};
		if(this.items) {
			fn(this.items);
		}
		return flag;
	},
	prepareButton: function() {
		this.buttons = [{
			text: this.okText,
			handler: this.onOK,
			scope: this
		}, {
			text: this.cancelText,
			handler: this.onCancel,
			scope: this
		}];
	},
	onOK: function() {
		if(this.isValid()) {
			var flag = true;
			if(this.applyCallback) {
				var o = this.applyCallback;
				flag = o.fn.call(o.scope || this, this.prepareParam(), this);
			}
			if(false !== flag) {
				this.hide();
			}
		}
	},
	onCancel: function() {
		var flag = true;
		if(this.cancelCallback) {
			var o = this.cancelCallback;
			flag = o.fn.call(o.scope || this, this.prepareParam(), this);
		}
		if(false !== flag) {
			this.hide();
		}
	},
	quit: function() {
		if(this.closeCallback) {
			var o = this.closeCallback;
			o.fn.call(o.scope, this);
		}
	},
	prepareParam: Ext.emptyFn
});

Ext.define("EnterpriseSheet.common.toolbar.BorderToolbar", {
	extend: "Ext.toolbar.Toolbar",
	alias: "widget.bordertoolbar",
	onBeforeAdd: function(component) {
		if(component instanceof Ext.toolbar.Separator) {
			component.setUI(this.vertical ? "vertical" : "horizontal");
		}
		Ext.toolbar.Toolbar.superclass.onBeforeAdd.apply(this, arguments);
	}
});

Ext.define("EnterpriseSheet.common.ribbon.ButtonGroup", {
	extend: "Ext.container.ButtonGroup",
	alias: "widget.ribbonbuttongroup",
	layout: {
		type: "table",
		tableAttrs: {
			style: {
				height: "100%"
			}
		}
	}
});

Ext.define("EnterpriseSheet.common.ribbon.Toolbar", {
	extend: "Ext.toolbar.Toolbar",
	alias: "widget.ribbontoolbar",
	requires: ["EnterpriseSheet.common.ribbon.ButtonGroup"],
	enableOverflow: true,
	style: "border:none;",
	constructor: function() {
		if(!this.layout) {
			this.layout = {
				type: "hbox",
				align: "stretch"
			};
		}
		this.callParent(arguments);
	}
});

Ext.define("EnterpriseSheet.common.ribbon.TabToolbar", {
	extend: "Ext.panel.Panel",
	alias: "widget.ribbontabtoolbar",
	requires: ["EnterpriseSheet.common.ribbon.Toolbar", "Ext.layout.container.Card"],
	cls: "rb-tabtoolbar",
	layout: {
		type: "card",
		bindToOwnerCtComponent: false,
		bindToOwnerCtContainer: false,
		deferredRender: true
	},
	activeItem: 0,
	initComponent: function() {
		var len = !this.items ? 0 : this.items.length;
		if(0 < len) {
			this.hbuttons = this.hbuttons || [];
			var count = this.hbuttons.length;
			var id = Ext.id();
			for(var i = 0; i < len; i++) {
				this.hbuttons.push({
					minWidth: 55,
					text: this.items[i].title,
					closable: false,
					itemIndex: i,
					active: 0 === i,
					pressed: 0 === i,
					enableToggle: true,
					toggleGroup: id + "-tabs",
					handler: this.switchTab,
					scope: this
				});
			}
			this.tbar = new Ext.toolbar.Toolbar({
				items: this.hbuttons
			});
		}
		this._tmpItems = this.items;
		delete this.items;
		this.callParent();
		this.on("resize", function(p, width, height) {
			if(this._tmpItems) {
				if(this._tmpItems instanceof Ext.util.MixedCollection) {
					for(var i = 0, len = this._tmpItems.getCount(); i < len; i++) {
						var it = this._tmpItems.get(i);
						this.add(it);
					}
				} else if("array" == Ext.typeOf(this._tmpItems)) {
					for(var i = 0, len = this._tmpItems.length; i < len; i++) {
						var it = this._tmpItems[i];
						this.add(it);
					}
				} else {
					this.add(this._tmpItems);
				}
				delete this._tmpItems;
			}
		}, this, {
			single: true
		});
	},
	switchTab: function(btn) {
		if(!btn.pressed) {
			btn.toggle(true, true);
		} else {
			var itemIndex = btn.itemIndex;
			this.getLayout().setActiveItem(itemIndex);
		}
	}
});

Ext.define("EnterpriseSheet.common.PhotoViewer", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.pure.lang.Language"],
	shieldLabel: "Please enter password to view",
	showPhotos: function(photos, index) {
		this.photos = Ext.clone(photos);
		this.cursor = index;
		if(!this.el) {
			var body = Ext.getBody();
			var w = body.getWidth() - 300,
				h = body.getHeight() - 20;
			this.el = body.mask();
			this.el.addCls("photo-viewer");
			this.el.update(["<div class=\"photo-viewer-frame\"></div>", "<table cellpadding=\"0\" cellspacing=\"0\" class=\"photo-viewer-inner\"><tbody>", "<tr>", "<td class=\"photo-col\" rowspan=2>", "<img style=\"max-width:", w, "px;max-height:", h, "px;\" />", "</td>", "<td class=\"info-col\">", "<div class=\"photo-name\"></div>", "<div class=\"update-time\"></div>", "<div class=\"file-type\"></div>", "</td>", "</tr><tr>", "<td class=\"option-col\">", "<div class=\"cursor-info\">&nbsp;</div>", "<div class=\"photo-navi\">", "<div class=\"photo-prev enabled\"><span data-name=\"prev\" class=\"action\">", SLANG.previous, "</span></div>", "<div class=\"photo-next enabled\"><span data-name=\"next\" class=\"action\">", SLANG.next, "</span></div>", "</div>", "<div class=\"download enabled\"><span data-name=\"download\" class=\"action\">", SLANG.download, "</span></div>", "</td>", "</tr>", "</tbody></table>"].join(""));
			this.nameEl = this.el.down(".photo-name");
			this.updateTimeEl = this.el.down(".update-time");
			this.fileTypeEl = this.el.down(".file-type");
			this.photoEl = this.el.down(".photo-col");
			this.optionEl = this.el.down(".option-col");
			this.cursorEl = this.el.down(".cursor-info");
			this.imgEl = this.photoEl.down("img");
			this.prevEl = this.el.down(".photo-prev");
			this.nextEl = this.el.down(".photo-next");
			this.downloadEl = this.el.down(".download");
			this.downloadTextEl = this.downloadEl.down("span");
			this.el.on("click", this.onViewerElClick, this);
		}
		this.el.show();
		var photo = this.photos[this.cursor];
		this.updatePhoto(photo);
		this.updatePrevNext();
	},
	updatePhoto: function(photo) {
		this.imgEl.dom.src = SCONFIG.BLANK_PHOTO;
		this.nameEl.update(photo.name);
		this.updateTimeEl.update(photo.updateDate);
		this.downloadEl.addCls("enabled");
		this.downloadEl.removeCls("disabled");
		if("img" === photo.type) {
			this.imgEl.dom.src = photo.url;
			this.fileTypeEl.update(SLANG.image);
		} else {
			this.imgEl.dom.src = SCONFIG.ATTACH_ICON32;
			this.fileTypeEl.update(SLANG.file);
		}
		this.imgEl.attachUrl = photo.url;
	},
	updatePrevNext: function() {
		if(0 === this.cursor) {
			this.prevEl.removeCls("enabled");
			this.prevEl.addCls("disabled");
		} else {
			this.prevEl.addCls("enabled");
			this.prevEl.removeCls("disabled");
		}
		if(this.photos.length - 1 === this.cursor) {
			this.nextEl.removeCls("enabled");
			this.nextEl.addCls("disabled");
		} else {
			this.nextEl.addCls("enabled");
			this.nextEl.removeCls("disabled");
		}
		this.cursorEl.update(SLANG.display + " " + (this.cursor + 1) + "/" + this.photos.length + " " + SLANG.on_current_page);
	},
	onViewerElClick: function(e) {
		var target = e.getTarget(),
			tgEl = Ext.get(target);
		if(tgEl.hasCls("action")) {
			var name = target.getAttribute("data-name");
			var div = Ext.get(target).parent();
			if(!div.hasCls("disabled")) {
				if("download" == name) {
					if(!this.downloadState) {
						this.syncDownloadingState(true);
						document.location = this.imgEl.attachUrl;
					}
				} else if("prev" == name) {
					this.prevPhoto();
				} else if("next" == name) {
					this.nextPhoto();
				}
			}
		} else {
			if(target !== this.photoEl.dom && tgEl.up(".photo-col") !== this.photoEl) {
				this.imgEl.dom.src = SCONFIG.BLANK_PHOTO;
				this.el.hide();
			}
		}
	},
	prevPhoto: function() {
		this.syncDownloadingState(false);
		this.cursor--;
		this.updatePrevNext();
		var photo = this.photos[this.cursor];
		this.updatePhoto(photo);
	},
	nextPhoto: function() {
		this.syncDownloadingState(false);
		this.cursor++;
		this.updatePrevNext();
		var photo = this.photos[this.cursor];
		this.updatePhoto(photo);
	},
	syncDownloadingState: function(state) {
		if(state) {
			this.downloadState = true;
			this.downloadTextEl.update(SLANG.downloading + "...");
			Ext.Function.defer(function() {
				delete this.downloadState;
				this.downloadTextEl.update(SLANG.download);
			}, 3000, this);
		} else {
			delete this.downloadState;
			this.downloadTextEl.update(SLANG.download);
		}
	},
	onShieldFieldKeyDown: function(field, e) {
		var key = e.getKey();
		if(13 === key) {
			if(field.isValid()) {
				var val = field.getValue();
				this.fireEvent("checkphotoshield", val, this.photos[this.cursor], this);
			}
		}
	}
}, function() {
	PHOTOVIEWER = Ext.create("EnterpriseSheet.common.PhotoViewer", {
		shieldLabel: SLANG.enter_password
	});
});

Ext.define("EnterpriseSheet.sheet.data.Format", {
	extend: "EnterpriseSheet.pure.sheet.data.Format"
}, function() {
	SFORMAT = Ext.create("EnterpriseSheet.sheet.data.Format");
});

Ext.define("EnterpriseSheet.sheet.data.reader.CellReader", {
	extend: "EnterpriseSheet.pure.sheet.data.reader.CellReader"
});

Ext.define("EnterpriseSheet.sheet.calculate.Exception", {
	extend: "EnterpriseSheet.pure.sheet.calculate.Exception"
}, function() {
	SCALEXP = Ext.create("EnterpriseSheet.sheet.calculate.Exception");
});

Ext.define("EnterpriseSheet.sheet.calculate.CalCacheMap", {
	extend: "EnterpriseSheet.pure.sheet.calculate.CalCacheMap"
});

Ext.define("EnterpriseSheet.sheet.calculate.Coordinate", {
	extend: "EnterpriseSheet.pure.sheet.calculate.Coordinate"
});

Ext.define("EnterpriseSheet.sheet.calculate.Calculate", {
	extend: "EnterpriseSheet.pure.sheet.calculate.Calculate"
});

Ext.define("EnterpriseSheet.sheet.calculate.Condition", {
	extend: "EnterpriseSheet.pure.sheet.calculate.Condition",
	constructor: function(config) {
		EnterpriseSheet.sheet.calculate.Condition.prototype.superclass.constructor.apply(this);
		this.initListMenu();
	},
	init: function(sheet) {
		EnterpriseSheet.sheet.calculate.Condition.prototype.superclass.init.apply(this, arguments);
		sheet.on({
			scope: this,
			changing: this.hideListKit,
			changereadonly: this.onChangeReadOnly
		});
	},
	onFocusChange: function(row, col, sm) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var flag;
		var cdt = sheet.getConditionOfCell(sheetId, row, col, true);
		for(var i = 0, len = cdt.length; i < len; i++) {
			var it = cdt[i];
			if("vd" == it.name) {
				var opt = it.opt;
				if(SCONST.validateDataType.list === opt.dt) {
					var list = opt.list;
					flag = list;
				} else if(SCONST.validateDataType.date === opt.dt && !this.ignoreDate) {
					flag = "date";
				}
			}
		}
		if(flag) {
			var cls;
			this.listMenu.removeAll(true);
			if("date" === flag) {
				cls = "ss-date-picker";
				this.listMenu.add({
					xtype: "datepicker",
					handler: this.selectDate,
					scope: this
				});
			} else {
				cls = "icon-list-dot";
				for(var i = 0, len = flag.length; i < len; i++) {
					var it = flag[i];
					this.listMenu.add({
						text: it
					});
				}
			}
			this.listMenu.bindPos = [sheetId, row, col];
			this.showListKit(row, col, cls);
		} else {
			this.hideListKit();
		}
	},
	initListMenu: function() {
		this.listMenu = this.listMenu || new Ext.menu.Menu({
			plain: true,
			defaults: {
				scope: this,
				handler: this.selectItemFromList
			}
		});
	},
	selectDate: function(picker, date) {
		var pos = this.listMenu.bindPos;
		this.skipHideListKitFlag = true;
		this.sheet.setCellData(pos[0], pos[1], pos[2], {
			data: Ext.Date.format(date, "Y-m-d"),
			fm: "date"
		});
		this.listMenu.hide();
		delete this.skipHideListKitFlag;
	},
	selectItemFromList: function(item) {
		var menu = item.parentMenu;
		if(menu) {
			var pos = menu.bindPos;
			this.skipHideListKitFlag = true;
			this.sheet.setCellData(pos[0], pos[1], pos[2], {
				data: item.text
			});
			delete this.skipHideListKitFlag;
		}
	},
	showListKit: function(row, col, iconCls) {
		iconCls = iconCls || "icon-list-dot";
		var store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, col, undefined, true) + this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, row - 1, undefined, true) + this.kitOffset[1];
		if(!this.listKit) {
			this.listKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet: this.sheet,
				localKit: true,
				floatingConfig: {
					xtype: "button",
					iconCls: iconCls,
					x: x,
					y: y,
					ddConfig: false,
					resizeConfig: false,
					destroyMenu: false,
					menu: true,
					handler: function(btn) {
						this.listMenu.showBy(btn);
					},
					scope: this
				}
			});
		} else {
			this.listKit.setIconCls(iconCls);
			this.listKit.setXY([x, y]);
		}
		this.listMenu.cellPos = [sheetId, row, col];
		this.listKit.show();
	},
	hideListKit: function() {
		if(this.listKit && !this.skipHideListKitFlag) {
			this.listKit.hide();
		}
	},
	onChangeReadOnly: function(readOnly, sheet) {
		if(readOnly) {
			this.hideListKit();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.editor.CalculateEditor", {
	extend: "Ext.Component",
	requires: ["EnterpriseSheet.common.Common", "Ext.XTemplate"],
	keyDownThrottled: 10,
	cls: "ss-fixed-editor",
	renderSelectors: {
		innerEl: "div.ss-editor-inner",
		editorEl: "div.ss-html",
		cancelEl: "div.ss-editor-cancel",
		completeEl: "div.ss-editor-complete",
		dropEl: "div.ss-editor-coord-drop"
	},
	initComponent: function() {
		this.renderTpl = new Ext.XTemplate('<div class="ss-editor-inner">', '<div class="ss-cell ss-html" contentEditable="true" autocomplete="off"></div>', '<div class="ss-editor-complete"></div>', '<div class="ss-editor-cancel"></div>', '<div class="ss-editor-coord-drop"><div class="drop-arrow"></div></div>', "</div>", {
			compiled: true,
			disableFormats: false
		});
		this.initCoordMenu();
		this.callParent();
		this.on({
			scope: this,
			quit: this.onQuitEdit
		});
		this.on("keyup", this.onEditKeyUp, this, {
			buffer: 50
		});
		this.on({
			beforeeditorspecialkey: this.beforeEditorSpecialKeyFn,
			editornavigatedown: function() {
				var args = Array.prototype.slice.call(arguments);
				args.unshift("editornavigatedown");
				return this.sheet.fireEvent.apply(this.sheet, args)
			},
			editornavigateup: function() {
				var args = Array.prototype.slice.call(arguments);
				args.unshift("editornavigateup");
				return this.sheet.fireEvent.apply(this.sheet, args)
			},
			keyup: function() {
				var args = Array.prototype.slice.call(arguments);
				args.unshift("editorkeyup");
				return this.sheet.fireEvent.apply(this.sheet, args)
			}
		})
	},
	beforeEditorSpecialKeyFn: function(key) {
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		var args = Array.prototype.slice.call(arguments);
		args.unshift("beforeeditorspecialkey");
		var ret = this.sheet.fireEvent.apply(this.sheet, args);
		if(keyObj.ESC === key || keyObj.ENTER === key) {
			return false
		}
		return ret
	},
	checkCompleteEdit: function(item, e) {
		if(item.parentMenu !== this.coordMenu) {
			var me = this;
			if(me.isEditing()) {
				me.completeEdit();
				me.sheet.refreshFocus()
			}
		}
	},
	onQuitEdit: function() {
		var disabled = this.disabled;
		delete(this.available);
		var sheet = this.sheet;
		var ghost = this.getGhost();
		if(ghost) {
			ghost.hide()
		}
		if(sheet) {
			sheet.disableRefer();
			if(!this.notEnableSmOnQuit) {
				sheet.enableSelect()
			}
			var rm;
			for(var i = 0, len = sheet.regionLookup.length; i < len; i++) {
				var region = sheet[sheet.regionLookup[i]];
				if(region.isVisible()) {
					rm = region.getReferenceModel();
					if(rm) {
						rm.setKeepStack(false)
					}
				}
			}
			if(rm) {
				rm.hide()
			}
			var val = this.getValue();
			if(!disabled && EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(val) && sheet.getSheetId() != this.sheetId && Ext.isDefined(this.sheetId)) {
				sheet.switchSheet(this.sheetId)
			}
			if(!this.keepValueOnQuit) {
				this.setValue("")
			}
			sheet.fireEvent("quitedit", this, sheet, this.sheetId, this.row, this.col);
			delete(this.sheetId)
		}
	},
	onEditKeyUp: function(e, row, col, region, editor) {
		var sheet = this.sheet;
		if(sheet && this.inputing && this.isAvailable()) {
			this.processReferenceForEditing(this.getRawTextValue())
		}
	},
	afterStartEdit: function() {
		var sheet = this.sheet;
		if(sheet) {
			var rm = sheet.getReferenceModel();
			var val = this.getRawTextValue();
			if(sheet.calculate && sheet.calculate.couldbeCalculate(val)) {
				this.processReferenceForEditing(val);
				this.navigateFlag = true
			} else {
				rm.hide();
				delete(this.navigateFlag);
				this.moveFlag = true
			}
			this.fireEvent("afterstartedit", this, sheet)
		}
	},
	processReferenceForEditing: function(value) {
		var sheet = this.sheet;
		if(!sheet.calculate.couldbeCalculate(value)) {
			return
		}
		this.syncReferenceFlag = true;
		if(sheet.syncReferenceForCalculate(value, undefined, true)) {
			for(var i = 0, len = sheet.regionLookup.length; i < len; i++) {
				var region = sheet[sheet.regionLookup[i]];
				if(region.isVisible()) {
					var rm = region.getReferenceModel();
					if(rm) {
						rm.pushSelection();
						rm.setKeepStack(true);
						rm.clearEl()
					}
				}
			}
		}
		var selectedSpan = this.getSelectedCoordSpan();
		if(selectedSpan) {
			var coordSpanStr = SCOM.getInnerText(selectedSpan.dom);
			var index = this.indexOfCoordSpanEl(selectedSpan.dom);
			sheet.activeCoordSpan(coordSpanStr, index)
		}
		this.syncReferenceFlag = false
	},
	afterSpecialKey: function(key) {},
	initCoordMenu: function() {
		this.relatedCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.relatedCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteRowCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteRowCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteColCoordItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.absoluteColCoordWithSheetItem = new Ext.menu.Item({
			handler: this.changeCoordStr,
			scope: this
		});
		this.coordMenu = new Ext.menu.Menu({
			cls: "color-menu",
			plain: true,
			minWidth: 160,
			items: ['<span class="menu-title">' + SLANG.relative + "</span>", this.relatedCoordItem, this.relatedCoordWithSheetItem, "-", '<span class="menu-title">' + SLANG.absolute + "</span>", this.absoluteCoordItem, this.absoluteCoordWithSheetItem, "-", '<span class="menu-title">' + SLANG.row_absolute + "</span>", this.absoluteRowCoordItem, this.absoluteRowCoordWithSheetItem, "-", '<span class="menu-title">' + SLANG.column_absolute + "</span>", this.absoluteColCoordItem, this.absoluteColCoordWithSheetItem]
		});
		this.mon(this.coordMenu, {
			scope: this,
			hide: function() {
				this.dropEl.hide();
				this.focus(10)
			}
		})
	},
	init: function(sheet) {
		this.sheet = sheet;
		this.mon(sheet, {
			scope: this,
			referencechange: this.onReferenceChange,
			referencemouseup: this.onReferenceMouseUp,
			startmovereference: this.startMoveReference,
			movingreference: this.onMovingReference,
			endmovereference: this.endMoveReference,
			beforestartedit: this.onBeforeStartEditing,
			switchsheet: this.onSwitchSheet,
			prepareclickitem: function() {
				if(this.isAvailable()) {
					this.completeEdit()
				}
			}
		})
	},
	onBeforeStartEditing: function(editor, sheet, sheetId, row, col, region) {
		if(editor === this) {
			if(false === sheet.checkDataTypeConfigBeforeEdit(sheetId, row, col, region) || false === sheet.checkCustomizedEvent("beforeEdit", sheetId, row, col, {
					region: region
				})) {
				this.blurOff();
				this.cancelEdit();
				return false
			}
			if(editor != this && this.isAvailable()) {
				this.blurOff();
				this.cancelEdit()
			}
			if(true === this.disabled) {
				return false
			}
		}
	},
	isAvailable: function() {
		return this.available
	},
	startMoveReference: function(draggingCoordSpan, rm) {
		if(!this.isAvailable()) {
			return
		}
		this.dropEl.hide();
		var sheetId = this.region.getSheetId();
		var dragSpan = draggingCoordSpan.span;
		var colorIndex = draggingCoordSpan.colorIndex;
		var dragSpanStr = dragSpan.join("$");
		var val = this.getValue();
		var me = this;
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)) {
			var index = 0,
				stopFlag;
			EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg.lastIndex = 0;
			var str = val.replace(EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg, function(match) {
				var pos = arguments[arguments.length - 2];
				var str = arguments[arguments.length - 1];
				if(stopFlag) {
					return
				}
				var ret = EnterpriseSheet.sheet.calculate.Coordinate.prototype.assembleCoordByRegResult(arguments);
				if(ret) {
					var span = ret.span;
					span[0] = sheetId;
					if(span.join("$") == dragSpanStr && colorIndex == index) {
						var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', me.el.dom);
						for(var i = 0, len = spanEls.length; i < len; i++) {
							var spanEl = Ext.get(spanEls[i]);
							if(spanEl.hasCls("ss-cal-coord-selected")) {
								spanEl.removeCls("ss-cal-coord-selected")
							}
						}
						Ext.get(spanEls[index]).addCls("ss-cal-coord-selected");
						me.sheet.activeCoordSpan(match, index);
						stopFlag = true
					}
					index++
				}
			})
		}
	},
	onMovingReference: function(draggingCoordSpan, rm) {
		if(!this.isAvailable()) {
			return
		}
		var val = this.getValue();
		var store = this.sheet.getStore(),
			curSheetId = this.sheet.getSheetId();
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)) {
			var curSpan = [].concat(draggingCoordSpan.currentSpan);
			if(Ext.isNumber(curSpan[0])) {
				curSpan[0] = store.getSheetNameById(curSpan[0])
			}
			var ghost = this.getGhost();
			var selectedSpan = this.getSelectedCoordSpan();
			if(selectedSpan) {
				var oldCoordSpan = SCOM.getInnerText(selectedSpan.dom);
				var oldCoord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(oldCoordSpan);
				var ctype = oldCoord[0].type;
				var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
					span: curSpan,
					type: ctype
				}], undefined, -1 != oldCoordSpan.indexOf("!") || this.sheetId != curSheetId);
				var color = selectedSpan.child(".bgc").getStyle("background-color");
				str = '<span class="ss-cal-fletter">' + str[0] + "</span>" + str.slice(1, -1) + '<span class="ss-cal-lletter">' + str[str.length - 1] + "</span>";
				str = '<span class="bgc" style="background-color:' + color + ';">' + str + "</span>";
				selectedSpan.update(str);
				this.setValue(this.getGhostValue())
			}
		}
	},
	endMoveReference: function(draggingCoordSpan, rm) {
		if(!this.isAvailable()) {
			return
		}
		this.fireEvent("keyup", null, this.row, this.col, this.region, this, true);
		this.focus();
		this.resumeCursorPosition();
		this.navigateFlag = true
	},
	onReferenceMouseUp: function() {
		if(this.isAvailable()) {
			var span = this.getSelectedCoordSpan();
			if(span) {
				span.removeCls("ss-cal-coord-selected")
			}
			this.showCoordSpan(this.getValue());
			this.fireEvent("keyup", null, this.row, this.col, this.region, this, true);
			this.focus();
			this.resumeCursorPosition();
			this.navigateFlag = true
		}
	},
	resumeCursorPosition: function() {
		var editorEl = this.getEditorEl();
		if(editorEl && !SCOM.nullOrUndefined(this.lastCursorPos)) {
			if(0 !== this.lastCursorPos || this.getValue()) {
				SCOM.setCursorPosition(editorEl.dom, this.lastCursorPos)
			}
		}
	},
	onRender: function() {
		this.callParent(arguments);
		var el = this.getEl();
		this.addListener2Element()
	},
	addListener2Element: function() {
		var el = this.getEditorEl();
		var me = this;
		if(el) {
			el.swallowEvent(["mousedown"]);
			this.mon(el, {
				scope: this,
				focus: this.onEditorFocus,
				blur: function() {
					this.fireEvent("editorblur", this);
					if(this.inputing) {
						this.inputing = false
					}
				},
				keydown: this.onEditorElKeyDown,
				keypress: this.onEditorElKeyPress,
				keyup: this.onEditorElKeyUp,
				mousedown: this.onEditorElMouseDown,
				mousemove: this.onEditorElMouseMove
			});
			this.mon(this.el, {
				scope: this,
				click: this.onElClick
			});
			this.mon(this.dropEl, {
				scope: this,
				mousedown: this.onEditorElMouseDown
			});
			this.mon(this.completeEl, {
				scope: this,
				click: function() {
					this.completeEdit()
				}
			});
			this.mon(this.cancelEl, {
				scope: this,
				click: this.cancelEdit
			})
		}
	},
	onEditorFocus: function() {
		this.fireEvent("editorfocus", this);
		this.inputing = true;
		if(!this.available) {
			this.available = true;
			var sheet = this.sheet;
			if(sheet) {
				var sm = sheet.getSelectionModel();
				var focusCell = sm.getFocusCell();
				var val = this.getValue();
				var flag = this.startEdit(focusCell.row, focusCell.col, sheet.getCurrentRegion(), undefined, true, val);
				delete(this.navigateFlag);
				delete(this.moveFlag);
				if(false === flag) {
					return
				}
				if(SCOM.nullOrUndefined(this.lastCursorPos)) {
					this.lastCursorPos = val.length;
					SCOM.moveCursor2End(this.getEditorEl().dom)
				} else {
					this.resumeCursorPosition()
				}
			}
		}
	},
	onEditorElKeyDown: function(e) {
		this.dropEl.hide();
		var editEl = this.getEditorEl();
		if(this.isAvailable()) {
			var val = this.getValue();
			this.hasInputChange = true;
			var isCal = EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val);
			var key = e.getKey();
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				if(false !== this.fireEvent("beforeeditorspecialkey", key, this, this.sheet)) {
					this.cancelEdit();
					this.afterSpecialKey(key);
					this.fireEvent("specialkey", this, this.region, key)
				}
				return
			} else {
				if(keyObj.ENTER == key || keyObj.TAB == key) {
					var asArrayFormula = false;
					if(true === e.ctrlKey && true === e.shiftKey && keyObj.ENTER === key) {
						asArrayFormula = true
					} else {
						if(!isCal) {
							if(true === e.shiftKey || true === e.altKey) {
								return
							}
						}
					}
					e.stopEvent();
					var flag = false !== this.fireEvent("beforeeditorspecialkey", key, this, this.sheet, asArrayFormula);
					if(flag) {
						this.completeEdit(asArrayFormula);
						this.afterSpecialKey(key);
						this.fireEvent("specialkey", this, this.region, key, asArrayFormula)
					}
					return
				}
			}
			if(isCal) {
				if(Ext.isWebKit) {
					Ext.Function.defer(this.checkCoordChange, 5, this)
				} else {
					this.checkCoordChange()
				}
			}
			var navFlag = this.processNavigateKey(e, this.row, this.col);
			if(true === navFlag) {
				e.stopEvent();
				if(isCal) {
					this.resumeCursorPosition()
				}
			} else {
				if(false === navFlag) {
					e.stopEvent();
					return false
				} else {
					return this.fireEvent("keydown", e, this.row, this.col, this.region, this)
				}
			}
		} else {
			return this.fireEvent("keydown", e, this.row, this.col, this.region, this)
		}
	},
	onEditorElKeyPress: function(e) {
		if(this.isAvailable()) {
			var val = this.getValue();
			if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)) {
				this.cacheCursorPos()
			}
			this.fireEvent("keypress", e, this.row, this.col, this.region, this)
		}
	},
	navigateReference: function(shift, dir, backward) {
		if(!this._navigating) {
			this._navigating = true;
			var sheet = this.sheet;
			var rm = sheet.getReferenceModel();
			var pos;
			if(backward) {
				pos = rm.selectPrevious(dir, shift)
			} else {
				pos = rm.selectNext(dir, shift)
			}
			if(pos && this.region) {
				this.region.scrollCell2View(pos.row, pos.col)
			}
			Ext.Function.defer(function() {
				delete(this._navigating)
			}, this.keyDownThrottled, this)
		}
	},
	processNavigateKey: function(e, row, col) {
		this.isNavigateKey = false;
		var key = e.getKey();
		if(e.DOWN == key) {
			if(false === this.fireEvent("editornavigatedown", this, this.sheet)) {
				this.isNavigateKey = true;
				return true
			}
		} else {
			if(e.UP == key) {
				if(false === this.fireEvent("editornavigateup", this, this.sheet)) {
					this.isNavigateKey = true;
					return true
				}
			}
		}
		if(this.navigateFlag) {
			var shift = e.shiftKey;
			var dir, backward, navigatedRow, navigatedCol;
			if(e.DOWN == key) {
				dir = "row";
				navigatedRow = row + 1;
				navigatedCol = col
			} else {
				if(e.UP == key) {
					dir = "row";
					backward = true;
					navigatedRow = row - 1;
					navigatedCol = col
				} else {
					if(e.LEFT == key) {
						dir = "col";
						backward = true;
						navigatedRow = row;
						navigatedCol = col - 1
					} else {
						if(e.RIGHT == key) {
							dir = "col";
							navigatedRow = row;
							navigatedCol = col + 1
						}
					}
				}
			}
			if(dir) {
				this.isNavigateKey = true;
				var sheet = this.sheet,
					sheetId = sheet.getSheetId();
				var rm = sheet.getReferenceModel();
				var shift = e.shiftKey,
					key = e.getKey();
				var span = this.getSelectedCoordSpan();
				if(span) {
					var coordStr = SCOM.getInnerText(span.dom);
					var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coordStr);
					var coordSpan = coord[0].span;
					if(!Ext.isNumber(coordSpan[0]) || coordSpan[0] == sheetId) {
						this.navigateReference(shift, dir, backward)
					}
				} else {
					rm.setAnchorCell();
					rm.selectRange({
						row: navigatedRow,
						col: navigatedCol
					}, {
						row: navigatedRow,
						col: navigatedCol
					});
					var navigateSpan = rm.selection2Span();
					var spanInfo = this.getCoordSpanInfo(navigateSpan);
					if(spanInfo) {
						var spanEl = spanInfo.el,
							colorIndex = spanInfo.colorIndex;
						spanEl.addCls("ss-cal-coord-selected")
					}
				}
				return true
			}
		} else {
			if(this.moveFlag && (e.LEFT == key || e.RIGHT == key || e.UP == key || e.DOWN == key)) {
				e.stopEvent();
				var flag = false !== this.fireEvent("beforeeditorspecialkey", key, this, this.sheet);
				if(flag) {
					this.getEditorEl().blur();
					this.completeEdit();
					this.afterSpecialKey(key);
					this.fireEvent("specialkey", this, this.region, key);
					return false
				}
			}
		}
	},
	onEditorElKeyUp: function(e) {
		if(this.isNavigateKey || !this.isAvailable()) {
			return
		}
		var val = this.getValue(),
			ghost = this.getGhost();
		var isCal = false;
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val) && !this.disableCalEditorStyle) {
			this.el.addCls("ss-editor-calculate");
			if(ghost && !ghost.isVisible()) {
				ghost.show()
			}
			var selectedSpan = this.getSelectedCoordSpan();
			if(selectedSpan) {
				selectedSpan.removeCls("ss-cal-coord-selected")
			}
			this.cacheCursorPos();
			this.checkCoordChange();
			isCal = true
		} else {
			this.el.removeCls("ss-editor-calculate");
			if(ghost && ghost.isVisible()) {
				ghost.hide()
			}
		}
		this.fireEvent("keyup", e, this.row, this.col, this.region, this, isCal)
	},
	onElClick: function(e) {
		if(!this.isAvailable()) {
			return
		}
		var target = e.getTarget(".ss-editor-coord-drop", null, true);
		if(target) {
			var store = this.sheet.getStore();
			var span = target.showBySpan;
			var coordStr = SCOM.getInnerText(span.dom);
			var coordProto = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
			var coord = coordProto.string2Coord(coordStr);
			var coordSpan = coord[0].span;
			if(!coordSpan[0]) {
				var sheetId = this.sheet.getSheetId();
				coordSpan[0] = store.getSheetNameById(sheetId)
			}
			coord[0].type = SCONST.RELATIVE_COORD;
			var relativeCoordStr = coordProto.coord2String(coord, "");
			this.relatedCoordItem.setText(relativeCoordStr);
			var relativeCoordWithSheetStr = coordProto.coord2String(coord, "", true);
			this.relatedCoordWithSheetItem.setText(relativeCoordWithSheetStr);
			coord[0].type = SCONST.ABSOLUTE_COORD;
			var abCoordStr = coordProto.coord2String(coord);
			this.absoluteCoordItem.setText(abCoordStr);
			var abCoordWithSheetStr = coordProto.coord2String(coord, undefined, true);
			this.absoluteCoordWithSheetItem.setText(abCoordWithSheetStr);
			coord[0].type = SCONST.ABSOLUTE_ROW_COORD;
			var abCoordStr = coordProto.coord2String(coord);
			this.absoluteRowCoordItem.setText(abCoordStr);
			var abCoordWithSheetStr = coordProto.coord2String(coord, undefined, true);
			this.absoluteRowCoordWithSheetItem.setText(abCoordWithSheetStr);
			coord[0].type = SCONST.ABSOLUTE_COL_COORD;
			var abCoordStr = coordProto.coord2String(coord);
			this.absoluteColCoordItem.setText(abCoordStr);
			var abCoordWithSheetStr = coordProto.coord2String(coord, undefined, true);
			this.absoluteColCoordWithSheetItem.setText(abCoordWithSheetStr);
			this.coordMenu.relatedCoord = {
				span: span,
				coord: coord
			};
			this.coordMenu.showBy(target)
		}
	},
	onEditorElMouseMove: function(e) {
		if(!this.isAvailable()) {
			return
		}
		var el = this.el;
		if(el.hasCls("ss-editor-calculate")) {
			var ghostEl = this.getGhost();
			var xy = e.getXY();
			var x = xy[0],
				y = xy[1];
			var spans = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);
			var found;
			var rm = this.sheet.getReferenceModel();
			for(var i = 0, len = spans.length; i < len; i++) {
				var span = Ext.get(spans[i]);
				var l = span.getLeft(),
					r = span.getRight(),
					t = span.getTop(),
					b = span.getBottom();
				if(20 < span.getHeight()) {
					var firstLetter = span.down(".ss-cal-fletter"),
						lastLetter = span.down(".ss-cal-lletter");
					if(l <= x && x <= lastLetter.getRight() && lastLetter.getTop() <= y && y <= b) {
						found = span;
						break
					} else {
						if(firstLetter.getLeft() <= x && x <= r && t <= y && y <= firstLetter.getBottom()) {
							found = span;
							break
						}
					}
				} else {
					if(l <= x && x <= r && t <= y && y <= b) {
						found = span;
						break
					}
				}
			}
			if(found) {
				var color = found.child(".bgc").getStyle("background-color");
				var firstLetter = found.down(".ss-cal-fletter"),
					lastLetter = found.down(".ss-cal-lletter");
				this.dropEl.setStyle("background-color", color);
				var dropWidth = this.dropEl.getWidth();
				var spanWidth = found.getWidth();
				if(dropWidth > spanWidth - 10) {
					this.dropEl.setLeft(lastLetter.getRight() - ghostEl.getLeft())
				} else {
					this.dropEl.setLeft(lastLetter.getRight() - ghostEl.getLeft() - 13)
				}
				this.dropEl.setTop(lastLetter.getTop() - ghostEl.getTop());
				this.dropEl.showBySpan = span;
				this.dropEl.show()
			} else {
				this.dropEl.hide()
			}
		} else {
			this.dropEl.hide()
		}
	},
	onEditorElMouseDown: function(e) {
		if(!this.isAvailable()) {
			return
		}
		delete(this.navigateFlag);
		delete(this.moveFlag);
		var val = this.getValue();
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)) {
			var target = e.getTarget(".ss-editor-coord-drop", null, true);
			if(target) {
				return
			}
			var el = this.el;
			var sels = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord-selected"]', el.dom);
			var selCoord;
			for(var i = 0, len = sels.length; i < len; i++) {
				var sel = Ext.get(sels[i]);
				sel.removeCls("ss-cal-coord-selected");
				selCoord = SCOM.getInnerText(sel.dom)
			}
			var xy = e.getXY();
			var x = xy[0],
				y = xy[1];
			var spans = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);
			var found, foundIndex;
			for(var i = 0, len = spans.length; i < len; i++) {
				var span = Ext.get(spans[i]);
				var l = span.getLeft(),
					r = span.getRight(),
					t = span.getTop(),
					b = span.getBottom();
				if(20 < span.getHeight()) {
					var firstLetter = span.down(".ss-cal-fletter"),
						lastLetter = span.down(".ss-cal-lletter");
					if(l <= x && x <= lastLetter.getRight() && lastLetter.getTop() <= y && y <= b) {
						found = span;
						foundIndex = i;
						break
					} else {
						if(firstLetter.getLeft() <= x && x <= r && t <= y && y <= firstLetter.getBottom()) {
							found = span;
							foundIndex = i;
							break
						}
					}
				} else {
					if(l <= x && x <= r && t <= y && y <= b) {
						found = span;
						foundIndex = i;
						break
					}
				}
			}
			if(found) {
				found.addCls("ss-cal-coord-selected");
				var coordStr = SCOM.getInnerText(found.dom);
				this.fireEvent("activecoordspan", coordStr, foundIndex, this);
				this.sheet.activeCoordSpan(coordStr, foundIndex)
			} else {
				if(selCoord) {
					this.sheet.deactiveCoordSpan();
					this.fireEvent("deactivecoordspan", selCoord, this)
				}
			}
			Ext.Function.defer(this.cacheCursorPos, 100, this)
		}
	},
	getEditorEl: function() {
		return this.editorEl
	},
	getGhost: function() {
		return this.el.down(".ss-editor-ghost")
	},
	getValue: function() {
		var dom = this.editorEl.dom;
		var val = SCOM.getInnerText(dom);
		val = Ext.util.Format.htmlDecode(val);
		if("\n" == val) {
			val = ""
		}
		return val
	},
	getGhostValue: function() {
		var ghost = this.getGhost();
		if(ghost) {
			var dom = ghost.dom;
			return SCOM.getInnerText(dom)
		}
	},
	getHTMLValue: function() {
		if(this.editorEl) {
			return this.editorEl.dom.innerHTML
		}
	},
	getTextValue: function(val) {
		if(this.editorEl) {
			var dom = this.editorEl.dom;
			if(SCOM.nullOrUndefined(val)) {
				val = SCOM.getInnerText(dom)
			}
			if("\n" == val) {
				val = ""
			}
			val = Ext.util.Format.htmlEncode(val);
			val = val.replace(/\n/gi, "<br/>");
			return val
		}
	},
	getRawTextValue: function(val) {
		if(this.editorEl) {
			var dom = this.editorEl.dom;
			if(SCOM.nullOrUndefined(val)) {
				val = SCOM.getInnerText(dom)
			}
			if("\n" == val) {
				val = ""
			}
			return val
		}
	},
	setValue: function(v, syncGhost) {
		if(this.editorEl) {
			this.editorEl.dom.innerHTML = v;
			if(syncGhost) {
				this.checkCoordChange()
			}
		}
	},
	completeEdit: function(asArrayFormula) {
		var sheet = this.sheet;
		if(false !== this.fireEvent("beforecompleteedit", this.sheetId, this.row, this.col, this, asArrayFormula)) {
			var store = sheet.getStore(),
				sm = sheet.getSelectionModel();
			if(!this.holdComplete) {
				this.holdComplete = true;
				delete(this.editing);
				this.fireEvent("preparecompleteedit", this.sheetId, this.row, this.col, this, asArrayFormula);
				this.dropEl.hide();
				this.fireEvent("completeedit", this.sheetId, this.row, this.col, this, asArrayFormula);
				this.fireEvent("quit", this, this.sheetId, this.row, this.col);
				Ext.defer(function() {
					delete(this.holdComplete)
				}, 10, this)
			}
		} else {
			delete(this.editing)
		}
	},
	isEditing: function() {
		return this.editing
	},
	cancelEdit: function() {
		this.holdComplete = true;
		delete(this.editing);
		this.fireEvent("quit", this, this.sheetId, this.row, this.col);
		if(this._originVal) {
			if(Ext.isNumber(this.cell.afrow)) {
				this.setValue("{" + Ext.htmlEncode(this._originVal) + "}")
			} else {
				this.setValue(Ext.htmlEncode(this._originVal))
			}
		} else {
			this.setValue("")
		}
		Ext.defer(function() {
			delete(this.holdComplete)
		}, 10, this)
	},
	startEdit: function(row, col, region, e, noNeedFocus, preVal) {
		var store = region.getStore();
		var sheetId = region.getSheetId();
		delete(this.lastCursorPos);
		if(0 == row || 0 == col) {
			return false
		}
		var cell = store.getCell(sheetId, row, col);
		if(store.isMergedCell(undefined, sheetId, row, col)) {
			row += cell.minrow;
			col += cell.mincol
		}
		cell = this.showValueInCalEditor ? this.sheet.getCellValue(sheetId, row, col) : store.getCellData(sheetId, row, col);
		if(false === this.fireEvent("beforestartedit", this, this.sheet, sheetId, row, col, region)) {
			this.inputing = false;
			this.available = false;
			return false
		}
		this.inputing = true;
		this.editing = true;
		delete(this.hasInputChange);
		this.noNeedFocus = noNeedFocus;
		this.region = region;
		this.sheetId = sheetId;
		this.row = row;
		this.col = col;
		region.scrollCell2View(row, col);
		this.cell = cell;
		this._originVal = cell.data || "";
		if(Ext.isNumber(cell.afrow)) {
			var afrow = cell.afrow + row,
				afcol = cell.afcol + col;
			var afCell = store.getCell(sheetId, afrow, afcol);
			this._originVal = afCell.data || ""
		}
		var val = true === preVal ? this.getValue() : (!SCOM.nullOrUndefined(preVal) ? preVal : this._originVal);
		var flag = EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val);
		this.adjustEditorPos(flag);
		var editorEl = this.getEditorEl();
		if(flag && !this.disableCalEditorStyle) {
			this.el.addCls("ss-editor-calculate")
		} else {
			this.el.removeCls("ss-editor-calculate")
		}
		this.showCoordSpan(val);
		if(true !== preVal) {
			var hval = Ext.htmlEncode(val);
			if(Ext.isString(hval)) {
				hval = hval.replace(/\n/gi, "<br/>")
			}
			this.setValue(hval)
		}
		if(!noNeedFocus) {
			this.focus(Ext.isIE ? 50 : 10);
			SCOM.moveCursor2End(this.getEditorEl().dom)
		}
		this.afterStartEdit()
	},
	adjustEditorPos: function(flag) {},
	generateCoordSpan: function(val, colorOffset) {
		var colors = SCOM.colors;
		var calculate = this.sheet.getCalculate();
		var index = colorOffset || 0,
			count = 0;
		EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg.lastIndex = 0;
		var str = val.replace(EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg, function(match) {
			var pos = arguments[arguments.length - 2];
			var str = arguments[arguments.length - 1];
			var ret = EnterpriseSheet.sheet.calculate.Coordinate.prototype.assembleCoordByRegResult(arguments);
			if(!ret) {
				return match
			}
			var color = colors[index % colors.length];
			var spanStr;
			if(/[^0-9a-zA-Z]$/gi.test(match)) {
				var len = match.length;
				var pre = match.slice(0, -1),
					pos = match.slice(len - 1, len);
				pre = '<span class="ss-cal-fletter">' + pre[0] + "</span>" + pre.slice(1, -1) + '<span class="ss-cal-lletter">' + pre[pre.length - 1] + "</span>";
				spanStr = '<span class="ss-cal-coord"><span class="bgc" style="background-color:' + color + ';">' + pre + "</span></span>" + pos
			} else {
				match = '<span class="ss-cal-fletter">' + match[0] + "</span>" + match.slice(1, -1) + '<span class="ss-cal-lletter">' + match[match.length - 1] + "</span>";
				spanStr = '<span class="ss-cal-coord"><span class="bgc" style="background-color:' + color + ';">' + match + "</span></span>"
			}
			index++;
			count++;
			return spanStr
		});
		return {
			html: str,
			coordSpanCount: count
		}
	},
	showCoordSpan: function(val) {
		var calculate = this.sheet.getCalculate();
		if(calculate && calculate.couldbeCalculate(val)) {
			var selectedSpan = this.getSelectedCoordSpan(),
				index;
			if(selectedSpan) {
				index = this.indexOfCoordSpanEl(selectedSpan.dom)
			}
			val = this.generateCoordSpan(val).html;
			var ghost = this.getGhost();
			if(ghost) {
				ghost.update(val);
				if(!ghost.isVisible()) {
					ghost.show()
				}
			} else {
				val = '<span class="ss-editor-ghost">' + val + "</span>";
				Ext.core.DomHelper.insertFirst(this.innerEl.dom, val)
			}
			if(selectedSpan) {
				var spanEl = this.getCoordSpanByIndex(index);
				if(spanEl) {
					spanEl = Ext.get(spanEl);
					spanEl.addCls("ss-cal-coord-selected")
				}
			}
		} else {
			var ghost = this.getGhost();
			if(ghost && ghost.isVisible()) {
				ghost.hide()
			}
		}
	},
	focus: function(delay) {
		var el = this.getEditorEl();
		if(el && el.isVisible()) {
			el.focus(delay)
		}
		return this
	},
	blurOff: function() {
		var el = this.getEditorEl();
		if(el) {
			el.blur()
		}
	},
	updateCursorPos: function(target) {
		this.lastCursorPos = this.getTargetPos(target)
	},
	getTargetPos: function(target) {
		var ghost = this.getGhost();
		var index = 0;
		for(var i = 0, len = ghost.dom.childNodes.length; i < len; i++) {
			var child = ghost.dom.childNodes[i];
			if(3 == child.nodeType) {
				index += child.nodeValue.length
			} else {
				if(1 == child.nodeType && Ext.get(child).hasCls("ss-cal-coord")) {
					index += SCOM.getInnerText(child).length
				}
			}
			if(child == target) {
				return index
			}
		}
	},
	onReferenceChange: function(region, rm) {
		var el = this.getEditorEl();
		if(true === this.syncReferenceFlag || !this.isAvailable() || !el || !EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(this.getValue())) {
			return
		}
		var ghost = this.getGhost();
		var v = rm.getReferenceWithoutStack();
		var curSheetId = this.sheet.getSheetId();
		if(v && v.length) {
			var store = this.sheet.getStore();
			var span = [].concat(v[0]);
			if(Ext.isNumber(span[0])) {
				span[0] = store.getSheetNameById(span[0])
			} else {
				span[0] = store.getSheetNameById(curSheetId)
			}
			var selectedSpan = this.getSelectedCoordSpan();
			if(selectedSpan) {
				var oldCoordSpan = SCOM.getInnerText(selectedSpan.dom);
				var oldCoord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(oldCoordSpan);
				var ctype = oldCoord[0].type;
				var coordStr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
					span: span,
					type: ctype
				}], undefined, -1 != oldCoordSpan.indexOf("!") || this.sheetId != curSheetId);
				var color = selectedSpan.child(".bgc").getStyle("background-color");
				var str = coordStr;
				str = '<span class="ss-cal-fletter">' + str[0] + "</span>" + str.slice(1, -1) + '<span class="ss-cal-lletter">' + str[str.length - 1] + "</span>";
				str = '<span class="bgc" style="background-color:' + color + ';">' + str + "</span>";
				selectedSpan.update(str);
				this.setValue(this.getGhostValue());
				this.updateCursorPos(selectedSpan.dom)
			} else {
				var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
					span: span,
					type: SCONST.RELATIVE_COORD
				}], "", this.sheetId != curSheetId);
				var colors = SCOM.colors;
				var coordSpans = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', ghost.dom);
				var color = colors[coordSpans.length % colors.length];
				this.sheet.activeCoordSpan(span, coordSpans.length);
				var coordStr = str;
				str = '<span class="ss-cal-fletter">' + str[0] + "</span>" + str.slice(1, -1) + '<span class="ss-cal-lletter">' + str[str.length - 1] + "</span>";
				str = '<span class="ss-cal-coord ss-cal-coord-selected"><span class="bgc" style="background-color:' + color + ';">' + str + "</span></span>";
				this.merge2Ghost(str, coordStr);
				this.setValue(this.getGhostValue())
			}
			this.dropEl.hide()
		}
	},
	getSelectedCoordSpan: function() {
		var el = this.el;
		if(el) {
			var span = el.down(".ss-cal-coord-selected");
			return span
		}
	},
	getCoordSpanByIndex: function(index) {
		var el = this.el;
		if(el) {
			var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);
			if(0 <= index && index < spanEls.length) {
				return spanEls[index]
			}
		}
	},
	indexOfCoordSpanEl: function(spanEl) {
		var el = this.el;
		if(el) {
			var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', el.dom);
			for(var i = 0, len = spanEls.length; i < len; i++) {
				var sel = spanEls[i];
				if(spanEl == sel) {
					return i
				}
			}
		}
	},
	getCoordSpanInfo: function(span) {
		var el = this.el;
		if(el) {
			var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', this.el.dom);
			for(var i = 0, len = spanEls.length; i < len; i++) {
				var spanEl = Ext.get(spanEls[i]);
				var coordStr = SCOM.getInnerText(spanEl.dom);
				var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coordStr);
				var sp = coord[0].span;
				if(span[0] == sp[0] && span[1] == sp[1] && span[2] == sp[2] && span[3] == sp[3] && span[4] == sp[4]) {
					return {
						el: spanEl,
						colorIndex: i
					}
				}
			}
		}
	},
	checkCoordChange: function() {
		var val = this.getValue();
		this.showCoordSpan(val)
	},
	changeCoordStr: function(item) {
		var menu = item.parentMenu;
		var relatedCoord = menu.relatedCoord;
		var selectedSpan = relatedCoord.span;
		var color = selectedSpan.child(".bgc").getStyle("background-color");
		var str = item.text;
		str = '<span class="ss-cal-fletter">' + str[0] + "</span>" + str.slice(1, -1) + '<span class="ss-cal-lletter">' + str[str.length - 1] + "</span>";
		str = '<span class="bgc" style="background-color:' + color + ';">' + str + "</span>";
		selectedSpan.update(str);
		this.setValue(this.getGhostValue());
		this.resumeCursorPosition()
	},
	cacheCursorPos: function() {
		var pos = SCOM.getSelectedTextPos();
		if(pos) {
			this.lastCursorPos = pos.startOffset
		}
	},
	getCursorPos: function() {
		return this.lastCursorPos
	},
	setCursorPos: function(pos, refresh) {
		this.lastCursorPos = pos;
		if(refresh) {
			this.resumeCursorPosition()
		}
	},
	merge2Ghost: function(str, coordStr) {
		var ghost = this.getGhost();
		var html = ghost.dom.innerHTML;
		if("=" == html) {
			ghost.update("=" + str);
			this.lastCursorPos = this.getGhostValue().length
		} else {
			var inFun = false;
			var val = this.getValue();
			if(!SCOM.nullOrUndefined(this.lastCursorPos)) {
				inFun = EnterpriseSheet.sheet.calculate.Calculate.prototype.isInFun(val, this.lastCursorPos)
			}
			if(inFun) {
				var i = this.lastCursorPos;
				for(var len = val.length; i < len; i++) {
					if(")" == val[i] || "," == val[i]) {
						break
					}
				}
				var pre = val.slice(0, i),
					pos = val.slice(i, len);
				var textPre = pre,
					textPos = pos;
				var withoutComma;
				var offset = 0;
				if(pre) {
					var trimedPre = Ext.String.trim(pre);
					withoutComma = /[\[\}\(\,\+\-\*\/\%\<\>\=]$/i.test(Ext.htmlDecode(trimedPre));
					pre = this.generateCoordSpan(pre);
					offset = pre.coordSpanCount;
					pre = pre.html
				}
				if(pos) {
					pos = this.generateCoordSpan(pos, offset);
					pos = pos.html
				}
				if(withoutComma) {
					ghost.update(pre + str + pos);
					this.lastCursorPos = textPre.length + coordStr.length
				} else {
					ghost.update(pre + "," + str + pos);
					this.lastCursorPos = textPre.length + coordStr.length + 1
				}
			} else {
				var raw = Ext.htmlDecode(val);
				var trimedRaw = Ext.String.trim(raw);
				if(/[\(\,\+\-\*\/\%\>\<\=]$/i.test(trimedRaw)) {
					ghost.update(html + str)
				} else {
					ghost.update(html + "+" + str)
				}
				this.lastCursorPos = this.getGhostValue().length
			}
		}
	},
	checkCalculateValid: function(cal) {
		var sum = 0,
			meetDoubleQuote = false;
		for(var i = 0, len = cal.length; i < len; i++) {
			var ch = cal.charAt(i);
			if(ch == '"') {
				meetDoubleQuote = !meetDoubleQuote
			} else {
				if(!meetDoubleQuote && "(" == ch) {
					sum++
				} else {
					if(!meetDoubleQuote && ")" == ch) {
						sum--
					}
				}
			}
		}
		if(0 < sum) {
			for(var i = 0; i < sum; i++) {
				cal += ")"
			}
		}
		cal = cal.replace(/\"\"\"\"/g, '"\\""');
		return cal
	},
	onSwitchSheet: function(oldSheetId, sheetId) {
		if(this.isEditing() && this.sheet) {
			var val = this.getValue(),
				flag;
			if(EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)) {
				if(sheetId != this.sheetId) {
					var store = this.sheet.getStore();
					var relatedSheetName = store.getSheetNameById(this.sheetId);
					var spanEls = Ext.DomQuery.jsSelect('span[class*="ss-cal-coord"]', this.el.dom);
					var relatedSpans = [];
					for(var i = 0, len = spanEls.length; i < len; i++) {
						var spanEl = spanEls[i];
						var coordStr = SCOM.getInnerText(spanEl);
						if(-1 == coordStr.indexOf("!")) {
							relatedSpans.push({
								coordStr: coordStr,
								spanEl: spanEl,
								cursorPos: this.getTargetPos(spanEl)
							})
						}
					}
					if(!SCOM.nullOrUndefined(this.lastCursorPos)) {
						var lastCursorPos = this.lastCursorPos;
						var offset = relatedSheetName.length + 1;
						for(var i = 0, len = relatedSpans.length; i < len; i++) {
							var it = relatedSpans[i];
							var cursorPos = it.cursorPos;
							if(Ext.isNumber(cursorPos)) {
								cursorPos -= it.coordStr.length;
								if(cursorPos < lastCursorPos) {
									this.lastCursorPos += offset
								}
							}
						}
					}
					for(var i = 0, len = relatedSpans.length; i < len; i++) {
						var it = relatedSpans[i];
						var coordStr = it.coordStr,
							spanEl = it.spanEl;
						coordStr = relatedSheetName + "!" + coordStr;
						Ext.get(spanEl).update(coordStr)
					}
					this.setValue(this.getGhostValue());
					this.checkCoordChange();
					flag = true
				}
				val = this.getRawTextValue();
				this.processReferenceForEditing(val);
				this.resumeCursorPosition();
				this.dropEl.hide();
				return flag
			}
		}
	},
	enable: function() {
		this.disabled = false;
		this.el.unmask()
	},
	disable: function() {
		this.disabled = true;
		this.el.mask()
	}
});

Ext.define("EnterpriseSheet.sheet.editor.ContentEditor", {
	extend: "EnterpriseSheet.sheet.editor.CalculateEditor",
	initComponent: function() {
		this.callParent(arguments);
		this.on({
			scope: this,
			afterstartedit: function() {
				if(this.row && this.col) {
					var sheet = this.sheet;
					sheet.onCellEventCallback("onCellFocusFn", sheet.getSheetId(), this.row, this.col);
				}
			},
			specialkey: function(editor, region, key) {
				var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
				if(keyObj.ESC == key) {
					this.sheet.fireEvent("loseeditingfocus", this);
				}
			},
			beforestartedit: function() {
				var args = Array.prototype.slice.call(arguments);
				args.unshift("beforestartedit");
				return this.sheet.fireEvent.apply(this.sheet, args);
			},
			beforecompleteedit: function() {
				var args = Array.prototype.slice.call(arguments);
				args.unshift("beforecompleteedit");
				return this.sheet.fireEvent.apply(this.sheet, args);
			},
			preparecompleteedit: function() {
				var args = Array.prototype.slice.call(arguments);
				args.unshift("preparecompleteedit");
				return this.sheet.fireEvent.apply(this.sheet, args);
			},
			completeedit: function() {
				var args = Array.prototype.slice.call(arguments);
				args.unshift("completeedit");
				return this.sheet.fireEvent.apply(this.sheet, args);
			}
		});
	},
	beforeEditorSpecialKeyFn: function(key) {
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		var args = Array.prototype.slice.call(arguments);
		args.unshift("beforeeditorspecialkey");
		var ret = this.sheet.fireEvent.apply(this.sheet, args);
		return ret;
	},
	afterSpecialKey: function(key) {
		var region = this.region;
		var sm = region.getSelectionModel(),
			pos;
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.TAB == key || keyObj.RIGHT == key) {
			pos = sm.selectNext("col");
		} else if(keyObj.ENTER == key || keyObj.DOWN == key) {
			pos = sm.selectNext("row");
		} else if(keyObj.LEFT == key) {
			pos = sm.selectPrevious("col");
		} else if(keyObj.UP == key) {
			pos = sm.selectPrevious("row");
		}
		if(pos) {
			region.scrollCell2View(pos.row, pos.col);
			this.blurOff();
		}
	},
	onQuitEdit: function() {
		var sheetId = this.sheetId,
			sheet = this.sheet;
		this.callParent(arguments);
		sheet.onCellEventCallback("onCellBlurFn", this.sheetId, this.row, this.col);
	},
	init: function(sheet) {
		this.callParent(arguments);
		if(this.self.getName() == "EnterpriseSheet.sheet.editor.ContentEditor") {
			sheet.contentEditor = this;
		}
		this.mon(sheet, {
			scope: this,
			selectionchange: this.onSelectionChange
		});
	},
	completeEdit: function(asArrayFormula) {
		var sheet = this.sheet;
		if(false !== this.fireEvent("beforecompleteedit", this.sheetId, this.row, this.col, this, asArrayFormula)) {
			var store = sheet.getStore(),
				sm = sheet.getSelectionModel();
			if(!this.holdComplete) {
				this.holdComplete = true;
				delete this.editing;
				this.fireEvent("preparecompleteedit", this.sheetId, this.row, this.col, this, asArrayFormula);
				var rawValue = this.getRawTextValue(),
					isCal = EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(rawValue);
				if(isCal) {
					rawValue = this.checkCalculateValid(rawValue);
					rawValue = sheet.getCalculate().handleAliasName(rawValue);
				}
				var data = {
					data: rawValue
				};
				var cell = this.showValueInCalEditor ? sheet.getCellValue(this.sheetId, this.row, this.col) : store.getCellData(this.sheetId, this.row, this.col);
				var cellVal = cell.data;
				if(Ext.isNumber(cellVal)) {
					cellVal = cellVal.toString();
				}
				var valChanged = cellVal !== rawValue;
				if(!valChanged && this.showValueInCalEditor && this.hasInputChange) {
					valChanged = true;
				}
				if(valChanged || isCal && asArrayFormula || isCal && !asArrayFormula && Ext.isNumber(cell.afrow)) {
					if(!SCOM.nullOrUndefined(rawValue) && "" != rawValue) {
						if(SCOM.nullOrUndefined(cell.fm) || "" == cell.fm) {
							var o = SFORMAT.decideFormat(rawValue);
							Ext.apply(data, o);
						} else {
							var o = SFORMAT.syncFormat(rawValue, cell.fm);
							Ext.apply(data, o);
						}
					}
					if(isCal && asArrayFormula) {
						var afrow = cell.afrow + this.row,
							afcol = cell.afcol + this.col,
							aerow = cell.aerow,
							aecol = cell.aecol;
						if(Ext.isNumber(afrow)) {
							if(afrow !== this.row || afcol !== this.col) {
								cell = store.getCell(this.sheetId, afrow, afcol);
								aerow = cell.aerow;
								aecol = cell.aecol;
							}
							aerow += this.row;
							aecol += this.col;
							var oldSpan = [this.sheetId, afrow, afcol, aerow, aecol];
							var pos = sm.getMinMaxPos(),
								span = [store.getActivedSheetId(), pos.minrow, pos.mincol, pos.maxrow, pos.maxcol];
							if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isIncludedSpan(span, oldSpan)) {
								sheet.setArrayFormulaForSpan(span, data);
							} else {
								sheet.setArrayFormulaForSpan(oldSpan, data);
							}
						} else {
							sheet.setArrayFormulaForSelection(data);
						}
					} else {
						if(Ext.isNumber(cell.afrow)) {
							this.cancelEdit();
							sheet.fireEvent("try2changepartofarrayformula", this.sheetId, this.row, this.col, this, sheet);
							return false;
						}
						sheet.setCellData(this.sheetId, this.row, this.col, data, ["afrow", "afcol", "aerow", "aecol"]);
					}
				}
				this.dropEl.hide();
				this.fireEvent("completeedit", this.sheetId, this.row, this.col, this, asArrayFormula);
				this.fireEvent("quit", this, this.sheetId, this.row, this.col);
				Ext.defer(function() {
					delete this.holdComplete;
				}, 10, this);
			}
		} else {
			delete this.editing;
		}
	},
	onSelectionChange: function(startPos, endPos, region, sm) {
		if(this.editing) {
			var val = this.getValue();
			if(!EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)) {
				this.completeEdit();
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.editor.CellEditor", {
	extend: "EnterpriseSheet.sheet.editor.ContentEditor",
	marginOffset: 0,
	scrollerOffset: 0,
	cls: "ss-editor",
	initComponent: function() {
		this.callParent(arguments);
		this.on({
			scope: this,
			afterrender: this._afterRender
		});
	},
	init: function(sheet) {
		this.callParent(arguments);
		this.mon(sheet, {
			scope: this,
			celldblclick: this.onCellDblClick,
			cellclick: this.onCellClick,
			columnchange: this.onColumnChange,
			rowchange: this.onRowChange,
			afterrender: this.afterSheetRender
		});
		var sm = sheet.getSelectionModel();
		this.mon(sm, {
			scope: this,
			focuschange: this.onFocusChange
		});
	},
	onFocusChange: function(row, col, sm) {
		if(this.editing) {
			var val = this.getValue();
			if(!EnterpriseSheet.sheet.calculate.Calculate.prototype.couldbeCalculate(val)) {
				var region = sm.getRegion();
				var store = this.sheet.getStore();
				this.setValue("");
				var el = region.getCellEl(row, col);
				if(el) {
					if(store.isMergedCell(this.cell, region.getSheetId(), row, col)) {
						el = el.down(".ss-incell");
					}
					this.boundEl = el;
					this.renderEditor();
					var pEl = this.el.parent();
					if(pEl && el) {
						this.el.setLeft(el.getLeft() - pEl.getLeft());
						this.el.setTop(el.getTop() - pEl.getTop());
						this.el.setWidth(1);
						this.el.removeCls("ss-editor-calculate");
						this.el.setOpacity(0);
						var editorEl = this.getEditorEl();
						editorEl.blur();
						editorEl.focus(10);
					}
				}
			}
		} else {
			this.setValue("");
		}
	},
	afterSheetRender: function() {
		this.renderEditor();
	},
	renderEditor: function() {
		if(!this.rendered) {
			var pEl = this.sheet.getEl();
			var contentEditor = this.sheet.contentEditor;
			if(contentEditor) {
				var cEl = contentEditor.getEl();
				if(cEl) {
					pEl = SCOM.findParentNodeForBoth(pEl, cEl);
				}
			}
			this.render(pEl);
		}
	},
	isAvailable: function() {
		return this.el && this.available;
	},
	_afterRender: function() {
		if(this.el) {
			this.el.setStyle("z-index", SCONST.TOP_Z_INDEX);
		}
		this.hideAway();
		this.focus();
	},
	hideAway: function() {
		if(this.el) {
			this.el.setWidth(1);
			this.el.removeCls("ss-editor-calculate");
			this.el.setOpacity(0);
			this.el.setTop(0);
			this.el.setLeft(0);
		}
		this.available = false;
		this.setValue("");
	},
	onEditorFocus: function() {
		if(this.isAvailable()) {
			this.inputing = true;
			if(SCOM.nullOrUndefined(this.lastCursorPos)) {
				var val = this.getValue();
				this.lastCursorPos = val.length;
				SCOM.moveCursor2End(this.getEditorEl().dom);
			} else {
				this.resumeCursorPosition();
			}
		}
	},
	onEditorElKeyDown: function(e) {
		if(false === this.callParent(arguments)) {
			return;
		}
		if(!this.isAvailable()) {
			var key = e.getKey();
			if(!e.ctrlKey && !e.altKey && key && key != e.ENTER && key != e.ESC && key != e.TAB && e.SHIFT != key & e.F11 != key) {
				if(!this.disabled) {
					Ext.Function.defer(function() {
						var region = this.sheet.getCurrentRegion();
						var sm = region.getSelectionModel();
						var fc = sm.getFocusCell();
						if(e.F2 === key) {
							this.startEdit(fc.row, fc.col, region, e);
							delete this.moveFlag;
						} else {
							this.startEdit(fc.row, fc.col, region, e, true, true);
						}
					}, 50, this);
				}
			}
		}
	},
	prepareEditorStyle: function(scroller, disSyncStyleFlag) {
		var scrollDir = scroller.getDir();
		var store = this.sheet.getStore();
		var dp = store.defaultProperty;
		var el = this.getEditorEl(),
			cell = this.cell,
			rel = this.region.getEl();
		var sheetId = this.region.getSheetId();
		if(!disSyncStyleFlag) {
			el.setStyle("background-color", cell.bgc || "");
			if(cell.ff) {
				el.setStyle("font-family", cell.ff);
			}
			if(cell.color) {
				el.setStyle("color", cell.color);
			} else {
				el.setStyle("color", dp.color || "");
			}
			if(cell.fz) {
				el.setStyle("font-size", cell.fz + "pt");
			}
			if(cell.fw) {
				el.setStyle("font-weight", cell.fw);
			} else {
				el.setStyle("font-weight", "normal");
			}
		} else {
			el.setStyle("font-family", "");
			el.setStyle("font-size", "");
			el.setStyle("font-weight", "");
			el.setStyle("color", "");
			el.setStyle("background-color", "");
		}
		var padX = store.cellWidthOffset,
			padY = store.cellHeightOffset;
		var sz = this.boundEl.getSize(),
			w, h, mw, mh;
		mw = rel.getRight() - this.boundEl.getLeft() - this.marginOffset;
		mh = rel.getBottom() - this.boundEl.getTop() - this.marginOffset;
		var mergedCellFlag = store.isMergedCell(this.cell, this.sheetId, this.row, this.col);
		if(mergedCellFlag) {
			padX = padY = 1;
			el.setStyle("padding", "0");
		} else {
			el.setStyle("padding", "");
		}
		if("none" == scrollDir) {
			mw += this.scrollerOffset;
			mh += this.scrollerOffset;
		} else if("x" == scrollDir) {
			if(!scroller.isVisible()) {
				mw += this.scrollerOffset;
			}
			mh += this.scrollerOffset;
		} else if("y" == scrollDir) {
			if(!scroller.isVisible()) {
				mh += this.scrollerOffset;
			}
			mw += this.scrollerOffset;
		}
		mw = mw - this.el.getBorderWidth("lr");
		if("normal" != cell.ws) {
			w = this.region.guessCellWidth(sheetId, this.row, this.col, cell);
			if(w < mw) {
				el.setStyle("min-width", w - padX + "px");
			} else {
				el.setStyle("min-width", sz.width - padX + "px");
			}
			el.setStyle("max-width", mw - padX + "px");
			el.setStyle("width", "auto");
			if(!disSyncStyleFlag) {
				var minh = sz.height;
				minh -= padY;
				el.setStyle("min-height", minh + "px");
				el.setStyle("max-height", mh + "px");
				el.setStyle("height", "auto");
			} else {
				el.setStyle("height", "auto");
				el.setStyle("max-width", "10000px");
				el.setStyle("min-height", "0px");
			}
		} else {
			if(!disSyncStyleFlag) {
				h = this.region.guessCellHeight(sheetId, this.row, this.col, cell);
				h -= padY;
				if(h < mh) {
					el.setStyle("min-height", h + "px");
				} else {
					el.setStyle("min-height", sz.height + "px");
				}
				if(h < mh) {
					el.setStyle("max-height", mh + "px");
				} else {
					el.setStyle("max-height", h + "px");
				}
				el.setStyle("height", "auto");
			} else {
				el.setStyle("height", "auto");
				el.setStyle("min-height", "0px");
			}
			el.setStyle("min-width", "0px");
			el.setStyle("max-width", "10000px");
			el.setWidth(sz.width - padX);
		}
	},
	completeEdit: function() {
		this.callParent(arguments);
		this.hideAway();
	},
	cancelEdit: function() {
		this.callParent(arguments);
		this.hideAway();
	},
	onColumnChange: function(col, modified, deleted, odata, data, store, region) {
		if(region == this.region && this.is()) {
			this.syncPosition();
		}
	},
	onRowChange: function(row, modified, deleted, odata, data, store, region) {
		if(region == this.region && this.isAvailable()) {
			this.syncPosition();
		}
	},
	adjustEditorPos: function(flag) {
		var store = this.sheet.getStore();
		var row = this.row,
			col = this.col;
		var region = this.region;
		var el = region.getCellEl(row, col);
		if(el) {
			if(store.isMergedCell(this.cell, this.sheetId, this.row, this.col)) {
				el = el.down(".ss-incell");
			}
			this.boundEl = el;
			this.renderEditor();
			var pEl = this.el.parent();
			var left = el.getLeft() - pEl.getLeft(),
				top = el.getTop() - pEl.getTop();
			if(this.el.hasCls("ss-editor-floating-over")) {
				this.el.removeCls("ss-editor-floating-over");
			}
			this.el.setLeft(left);
			this.el.setTop(top);
			this.el.setStyle("width", "");
			this.prepareEditorStyle(region.getScroller(), flag);
			this.el.show();
		}
	},
	onCellDblClick: function(row, col, region, e) {
		if(!this.disabled) {
			this.startEdit(row, col, region, e);
			delete this.moveFlag;
			this.sheet.onCellEventCallback("onCellDoubleClickFn", region.getSheetId(), row, col);
		} else {
			this.hideAway();
		}
	},
	onCellClick: function(row, col, region, e) {
		if(!this.disabled) {
			this.sheet.onCellEventCallback("onCellClickFn", region.getSheetId(), row, col);
		}
	},
	startEdit: function() {
		if(this.disabled) {
			return false;
		}
		this.crossSheetFlag = false;
		this.available = true;
		this.el.setStyle("width", "auto");
		this.el.setOpacity(1);
		if(false === this.callParent(arguments)) {
			return false;
		}
		if(this.editing && this.region) {
			var el = this.getEl();
			this.mun(el, {
				scope: this,
				mousewheel: this.onMouseWheel
			});
			this.mon(el, {
				scope: this,
				mousewheel: this.onMouseWheel
			});
			this.mun(this.region, {
				scope: this,
				moving: this.onRegionMoving
			});
			this.mon(this.region, {
				scope: this,
				moving: this.onRegionMoving
			});
		}
	},
	onQuitEdit: function() {
		var el = this.getEl();
		if(this.region) {
			this.mun(this.region, {
				scope: this,
				moving: this.onRegionMoving
			});
			this.mun(el, {
				scope: this,
				mousewheel: this.onMouseWheel
			});
		}
		this.callParent(arguments);
		delete this.fixedMode;
		if(el.hasCls("ss-editor-floating-over")) {
			el.removeCls("ss-editor-floating-over");
		}
		el.setStyle("width", "auto");
		el.setStyle("height", "auto");
	},
	onMouseWheel: function(e) {
		this.region.getScroller().onMouseWheel(e);
	},
	onRegionMoving: function(dir, offset, region) {
		this.syncPosition();
	},
	syncPosition: function() {
		if(this.isAvailable() && this.isEditing()) {
			var region = this.region,
				store = region.getStore(),
				row = this.row,
				col = this.col;
			var el = this.getEl(),
				pEl = el.parent();
			if(!this.crossSheetFlag && region.isInRange(row, col)) {
				delete this.fixedMode;
				var cellEl = region.getCellEl(row, col);
				if(store.isMergedCell(this.cell, this.sheetId, row, col)) {
					cellEl = cellEl.down(".ss-incell");
				}
				var left = cellEl.getLeft() - pEl.getLeft(),
					top = cellEl.getTop() - pEl.getTop();
				el.setLeft(left);
				el.setTop(top);
				el.setStyle("width", "auto");
				el.setStyle("height", "auto");
				if(el.hasCls("ss-editor-floating-over")) {
					el.removeCls("ss-editor-floating-over");
				}
			} else {
				var contentEditor = this.sheet.contentEditor;
				if(contentEditor) {
					var fixed = contentEditor.getEl();
					if(fixed) {
						this.fixedMode = true;
						var left = fixed.getLeft() - pEl.getLeft() + 1,
							top = fixed.getTop() - pEl.getTop() + 1;
						el.setLeft(left);
						el.setTop(top);
						el.setWidth(fixed.getWidth() - 1);
						el.setHeight(fixed.getHeight() - 1);
						if(!el.hasCls("ss-editor-floating-over")) {
							el.addCls("ss-editor-floating-over");
						}
					}
				}
			}
		}
	},
	onSwitchSheet: function(oldSheetId, sheetId) {
		if(this.callParent(arguments)) {
			this.crossSheetFlag = true;
			this.syncPosition();
		} else {
			this.crossSheetFlag = false;
			this.syncPosition();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.filter.Filter", {
	requires: ["Ext.menu.Menu", "Ext.grid.Panel", "Ext.form.field.Text", "Ext.layout.container.Card"],
	pageCount: 2000,
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent();
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.sheet.on({
			scope: this,
			clickcelltrigger: this.onClickCellTrigger,
			cellclick: this.onClick
		});
		this.initMenu();
	},
	initMenu: function() {
		if(!this.menu) {
			this.clearFilterItem = new Ext.menu.Item({
				iconCls: "icon-cross",
				text: SLANG.clear_filter,
				disabled: true,
				handler: function() {
					this.clearFilter();
				},
				scope: this
			});
			this.distinctStore = new Ext.data.Store({
				fields: ["id", "text", "qtip", "checked"],
				proxy: {
					type: "memory"
				}
			});
			this.grid = this.getDistinctValueGrid();
			this.condCt = this.getConditionPanel();
			this.filterTypeCt = new Ext.panel.Panel({
				border: false,
				bodyStyle: "background:transparent;",
				layout: "card",
				activeItem: 0,
				items: [this.grid, this.condCt],
				buttons: [{
					text: SLANG.remove_filter,
					handler: function() {
						this.removeFilter();
					},
					scope: this
				}, {
					text: SLANG.ok,
					handler: function() {
						this.applyFilter();
					},
					scope: this
				}, {
					text: SLANG.cancel,
					handler: function() {
						this.cancelFilter();
					},
					scope: this
				}]
			});
			this.menu = new Ext.menu.Menu(Ext.apply({
				cls: "ss-filter-menu",
				autoWidth: false,
				plain: true,
				width: 300,
				items: [{
					iconCls: "icon-sort-asc",
					text: SLANG.sort_asc,
					handler: this.sortAsc,
					scope: this
				}, {
					iconCls: "icon-sort-desc",
					text: SLANG.sort_desc,
					handler: this.sortDesc,
					scope: this
				}, "-", this.clearFilterItem, "-", this.filterTypeCt]
			}, this.menuConfig));
			this.searchField.on("keyup", this.onSearchKeyUp, this, {
				buffer: 500
			});
			this.grid.on("itemclick", this.onItemClick, this);
			this.menu.on("beforehide", function() {
				if(this.holdMenu) {
					return false;
				}
			}, this);
			this.menu.on("hide", this.onMenuHide, this);
		}
	},
	getDistinctValueGrid: function() {
		this.searchField = new Ext.form.field.Text({
			iconCls: "no-icon",
			emptyText: SLANG.input2search,
			flex: 1,
			enableKeyEvents: true
		});
		this.lastPageBtn = Ext.create("Ext.button.Button", {
			text: SLANG.prev_page,
			handler: function() {
				var startIndex = this.startIndex - this.pageCount;
				if(0 > startIndex) {
					startIndex = 0;
				}
				if(0 === startIndex) {
					this.lastPageBtn.disable();
				} else {
					this.lastPageBtn.enable();
				}
				this.loadMask.show();
				Ext.Function.defer(function() {
					var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, startIndex, this.pageCount);
					if(isEnd) {
						this.nextPageBtn.disable();
					} else {
						this.nextPageBtn.enable();
					}
					this.loadMask.hide();
				}, 100, this);
			},
			scope: this
		});
		this.nextPageBtn = Ext.create("Ext.button.Button", {
			text: SLANG.next_page,
			handler: function() {
				var startIndex = this.startIndex + this.pageCount;
				this.loadMask.show();
				Ext.Function.defer(function() {
					var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, startIndex, this.pageCount);
					if(isEnd) {
						this.nextPageBtn.disable();
					} else {
						this.nextPageBtn.enable();
					}
					this.lastPageBtn.enable();
					this.loadMask.hide();
				}, 100, this);
			},
			scope: this
		});
		this.displayItem = Ext.create("Ext.Component", {
			flex: 1,
			style: "text-align:center;"
		});
		var grid = new Ext.grid.Panel({
			store: this.distinctStore,
			hideHeaders: true,
			disableSelection: true,
			selModel: {
				pruneRemoved: false
			},
			columns: [{
				header: "(" + SLANG.select_all + ")",
				dataIndex: "text",
				menuDisabled: true,
				flex: 1,
				tdCls: "ss-filter-distinct-item"
			}],
			viewConfig: {
				stripeRows: false,
				trackOver: false,
				getRowClass: function(rec) {
					return rec.data.checked ? "ss-filter-distinct-item-checked" : "";
				}
			},
			width: 230,
			height: 230,
			dockedItems: [{
				xtype: "container",
				dock: "top",
				layout: "hbox",
				items: [this.searchField]
			}, {
				xtype: "container",
				height: 30,
				dock: "top",
				style: "padding:3px;",
				layout: {
					type: "hbox",
					align: "stretch"
				},
				defaultType: "button",
				items: [{
					text: SLANG.check_all,
					handler: this.checkAll,
					scope: this
				}, {
					style: "margin-left:10px;",
					text: SLANG.uncheck_all,
					handler: this.uncheckAll,
					scope: this
				}]
			}],
			bbar: [this.lastPageBtn, this.displayItem, this.nextPageBtn]
		});
		this.loadMask = Ext.create("Ext.LoadMask", {
			target: grid,
			msg: SLANG.loading
		});
		return grid;
	},
	getConditionPanel: function() {
		this.condTypeCombo = new Ext.form.field.ComboBox({
			store: SCOM.filterConditionStore,
			queryMode: "local",
			displayField: "display",
			valueField: "ctype",
			emptyText: SLANG.select_filter_condition,
			anchor: "95%"
		});
		var ct = new Ext.container.Container({
			style: "padding-left:30px;",
			layout: "anchor",
			items: [this.condTypeCombo]
		});
		return ct;
	},
	onClickCellTrigger: function(sheetId, row, col, region, sheet, target) {
		this.onClick(row, col, region, {
			getTarget: function() {
				return Ext.get(target).dom;
			}
		});
	},
	onClick: function(row, col, region, e) {
		if(this.sheet.isReadOnly()) {
			return;
		}
		var target = e.getTarget();
		var tgEl = Ext.get(target);
		if(Ext.supports.ClassList && !target.classList) {
			return;
		}
		if(tgEl.hasCls("ss-filter")) {
			var sheet = this.sheet,
				store = sheet.getStore();
			var sheetId = sheet.getSheetId();
			var cell = sheet.getCellData(sheetId, row, col);
			var span = Ext.decode(cell.filter);
			if(cell.tpl) {
				var tpl = Ext.decode(cell.tpl);
				var tplSpan = tpl.span;
				tplSpan[1]++;
				this.isTplFilter = tplSpan;
			} else {
				this.isTplFilter = false;
			}
			cell.tpl ? Ext.decode(cell.tpl) : false;
			var filterCdt;
			if(cell.filterCdt) {
				filterCdt = Ext.decode(cell.filterCdt);
			}
			this.distinctStore.removeAll();
			this.menu.showBy(tgEl);
			if(!this.mask) {
				this.mask = Ext.getBody().mask();
				this.mask.addCls("top-mask");
			} else {
				this.mask.show();
			}
			this.holdMenu = true;
			this.showFilterReference(cell, sheetId, row, col);
			this.loadMask.show();
			Ext.Function.defer(this.setup, 10, this, [row, col, span, filterCdt]);
		}
	},
	checkAll: function() {
		for(var p in this.distinctCache) {
			this.distinctCache[p].checked = true;
		}
		this.distinctStore.each(function(rec) {
			rec.data.checked = true;
		}, this);
		this.grid.getView().refresh();
	},
	uncheckAll: function() {
		for(var p in this.distinctCache) {
			this.distinctCache[p].checked = false;
		}
		this.distinctStore.each(function(rec) {
			rec.data.checked = false;
		}, this);
		this.grid.getView().refresh();
	},
	isOverlapFilter: function(span1, span2) {
		if(span1[0] === span2[0]) {
			if(0 == span1[1] || 0 == span2[1]) {
				return true;
			}
			if(0 == span1[3] && 0 == span2[3]) {
				return true;
			}
			var tmp1 = [].concat(span1),
				tmp2 = [].concat(span2);
			if(0 == tmp1[3]) {
				if(tmp1[1] < tmp2[3]) {
					tmp1[3] = tmp2[3];
				} else {
					tmp1[3] = tmp1[1];
				}
			}
			if(0 == tmp2[3]) {
				if(tmp2[1] < tmp1[3]) {
					tmp2[3] = tmp1[3];
				} else {
					tmp2[3] = tmp2[1];
				}
			}
			if(tmp1[1] >= tmp2[1] && tmp1[1] <= tmp2[3] || tmp1[3] >= tmp2[1] && tmp1[3] <= tmp2[3] || tmp1[1] <= tmp2[1] && tmp1[3] >= tmp2[3]) {
				return true;
			}
		}
		return false;
	},
	getOtherRelatedFilters: function(sheetId, row, col, filterSpan) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var otherFilters = [];
		store.each(function(rd) {
			var s = rd.data.sheet,
				r = rd.data.row,
				c = rd.data.col;
			if(!(sheetId == s && row == r && col == c)) {
				var json = rd.data.json;
				if(json && (json.filter || json.tpl)) {
					var filter, flag = false;
					if(json.filter) {
						flag = true;
						filter = Ext.decode(json.filter);
						if("" === filter[0]) {
							filter[0] = s;
						}
						if("" === filter[3]) {
							filter[3] = 0;
							if("" === filter[1]) {
								filter[1] = 0;
							} else {
								filter[1] += r;
							}
						} else {
							filter[1] += r;
							filter[3] += r;
						}
					} else {
						filter = Ext.decode(json.tpl).span;
						if("" === filter[0]) {
							filter[0] = s;
						}
						if(filter[0] == s && filter[1] == r) {
							flag = true;
							filter[1]++;
							filter[3]--;
						}
					}
					if(flag) {
						filter[2] = filter[4] = c;
						if(this.isOverlapFilter(filter, filterSpan)) {
							var obj = {
								filterSpan: filter
							};
							if(json.filterCdt) {
								obj.filterCdt = Ext.decode(json.filterCdt);
							}
							otherFilters.push(obj);
						}
					}
				}
			}
		}, this);
		return otherFilters;
	},
	setup: function(row, col, filterSpan, filterCdt) {
		this.searchField.reset();
		this.filteringFlag = false;
		this.distinctCache = {};
		delete this.showHiddenCache;
		var sheet = this.sheet,
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		if("" === filterSpan[0]) {
			filterSpan[0] = sheetId;
		}
		var startRow, endRow;
		if("" === filterSpan[3] || 0 >= filterSpan[3]) {
			filterSpan[3] = 0;
			if("" === filterSpan[1]) {
				filterSpan[1] = 0;
			} else {
				filterSpan[1] += row;
			}
			endRow = null;
		} else {
			filterSpan[1] += row;
			filterSpan[3] += row;
			endRow = filterSpan[3];
		}
		filterSpan[2] = filterSpan[4] = col;
		startRow = filterSpan[1];
		store.checkLoadCoord([filterSpan], function() {
			this.setupInfo = {
				row: row,
				col: col,
				filterSpan: filterSpan,
				filterCdt: filterCdt
			};
			var startTime = new Date;
			filterCdt = SCOM.copy(filterCdt);
			filterSpan = SCOM.copy(filterSpan);
			var startIndex = 0;
			var sheet = this.sheet,
				store = sheet.getStore(),
				sheetId = sheet.getSheetId();
			var distinct = {},
				minrow = false,
				maxrow = false,
				nonemptys = {};
			var otherFilters = this.getOtherRelatedFilters(sheetId, row, col, filterSpan);
			this.otherFilters = otherFilters, totalNum = 0;
			store.walkRange([filterSpan], function(rd) {
				if(row < rd.data.row && 0 !== rd.data.row && 0 !== rd.data.col) {
					var sid = rd.data.sheet,
						r = rd.data.row,
						c = rd.data.col;
					var visible = store.isVisibleRow(sid, r);
					if(visible || this.checkFilters(r, this.otherFilters)) {
						var data = rd.data.json.data,
							fm = rd.data.json.fm,
							cd = rd.data.json;
						if(rd.data.json.cal) {
							cd = sheet.getCellValue(sid, r, c, SCOM.genTimeStamp());
							data = cd.data;
						}
						data = "link" == fm ? data : SFORMAT.transferFormat(cd, fm).data;
						if(false != SCOM.typeOf(data) && "" !== data) {
							if(!distinct[data]) {
								totalNum++;
								distinct[data] = {
									checked: false,
									rows: {}
								};
							}
							var dt = distinct[data];
							if(!dt.checked) {
								dt.checked = visible;
							}
							dt.rows[rd.data.row] = true;
							if(false === minrow || minrow > rd.data.row) {
								minrow = rd.data.row;
							}
							if(false === maxrow || maxrow < rd.data.row) {
								maxrow = rd.data.row;
							}
							nonemptys[rd.data.row] = true;
						}
					}
				}
			}, this, true);
			var emptys = {};
			if(null === endRow) {
				endRow = maxrow;
			}
			var erows = {};
			for(var i = startRow; i <= endRow; i++) {
				if(!nonemptys[i]) {
					var visible = store.isVisibleRow(sheetId, i);
					if(visible || this.checkFilters(i, this.otherFilters)) {
						emptys[i] = {
							visible: visible
						};
						erows[i] = true;
					}
				}
			}
			if(!SCOM.isEmptyObj(emptys)) {
				var blank = "(" + SLANG.blanks + ")";
				distinct[blank] = {
					id: "blank-text",
					checked: false,
					rows: erows
				};
				var dt = distinct[blank];
				for(var p in emptys) {
					if(!dt.checked) {
						dt.checked = emptys[p].visible;
					} else {
						break;
					}
				}
			}
			if(maxrow < filterSpan[3]) {
				maxrow = filterSpan[3];
			}
			this.pos = {
				row: row,
				col: col,
				minrow: minrow,
				maxrow: maxrow,
				totalNum: totalNum,
				totalPage: Math.ceil(totalNum / this.pageCount)
			};
			this.filterSpan = filterSpan;
			this.distinctCache = distinct;
			var isEnd = this.setupWithPage(row, col, filterSpan, filterCdt, 0, this.pageCount);
			this.lastPageBtn.disable();
			if(isEnd) {
				this.nextPageBtn.disable();
			} else {
				this.nextPageBtn.enable();
			}
			this.loadMask.hide();
			this.mask.hide();
			this.holdMenu = false;
		}, this);
	},
	setupWithPage: function(row, col, filterSpan, filterCdt, startIndex, limit) {
		var count = 0,
			index = 0;
		var disStore = this.distinctStore;
		this.startIndex = startIndex;
		var dataArr = [],
			distinct = this.distinctCache;
		for(var p in distinct) {
			if(distinct.hasOwnProperty(p)) {
				var it = distinct[p];
				if(index < startIndex) {
					index++;
					continue;
				} else {
					index++;
				}
				if(count > limit) {
					break;
				}
				if(!this.filteringFlag || "blank-text" !== it.id && -1 < p.toLowerCase().indexOf(this.filteringFlag.toLowerCase())) {
					var data = {
						id: it.id,
						text: p,
						qtip: p,
						checked: it.checked
					};
					dataArr.push(data);
					count++;
				}
			}
		}
		disStore.pageSize = dataArr.length;
		disStore.loadData(dataArr);
		var index = Math.floor(startIndex / this.pageCount) + 1;
		this.displayItem.update(index + "/" + this.pos.totalPage);
		this.clearFilterItem.enable();
		return count <= limit;
	},
	onItemClick: function(grid, rec) {
		var p = rec.data.qtip;
		if(this.distinctCache[p].checked) {
			this.distinctCache[p].checked = false;
			rec.set("checked", false);
		} else {
			this.distinctCache[p].checked = true;
			rec.set("checked", true);
		}
	},
	createFilterForSelecton: function() {
		var sheet = this.sheet;
		var sm = sheet.getSelectionModel();
		var span = sm.selection2Span();
		span = EnterpriseSheet.sheet.range.Range.prototype.expandSpanWithContent(span, sheet);
		var tpl = sheet.getTableTpl();
		var checkTpl = function() {
			if(tpl) {
				var flag = tpl.checkSelection([span]);
				if("part" == flag) {
					Ext.Msg.show({
						title: SLANG.hint,
						msg: SLANG.can_not_create_filter,
						icon: Ext.Msg.INFO,
						buttons: Ext.Msg.OK
					});
					return true;
				} else if("all" == flag) {
					tpl.toggleTplFilterForSpan(span);
					return true;
				}
			}
		};
		if(0 === span[3] || 0 < span[3] - span[1]) {
			if(0 === span[2]) {
				Ext.Msg.show({
					title: SLANG.hint,
					msg: SLANG.can_not_create_filter,
					icon: Ext.Msg.INFO,
					buttons: Ext.Msg.OK
				});
			} else {
				if(checkTpl()) {
					return;
				}
				this.createFilterForSpan(span);
			}
		} else {
			if(checkTpl()) {
				return;
			}
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.can_not_create_filter,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		}
	},
	prepareFilterPreporty: function(row, span) {
		var filter = [].concat(span);
		filter[0] = "";
		if(0 === span[1]) {
			filter[1] = 1;
			filter[3] = "";
		} else {
			filter[1] = filter[1] - row + 1;
			filter[3] -= row;
		}
		filter[2] = filter[4] = 0;
		var obj = {
			trigger: "ss-filter",
			filter: Ext.encode(filter)
		};
		return obj;
	},
	createFilterForSpan: function(span, suspendEvent, filterCdts, suspendPull) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var sheetId = span[0],
			minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4];
		var row = 0 === minrow ? 1 : span[1];
		var tmp = [].concat(span);
		tmp[3] = tmp[1] = row;
		var hidden = {},
			showPairs = [row + 1, maxrow];
		if(suspendEvent || false !== sheet.fireEvent("beforecreatefilter", tmp, sheet, suspendPull)) {
			if(!suspendEvent) {
				sheet.fireEvent("beforepreparecreatefilter", sheet);
			}
			if(store.withFilterInSheet(sheetId)) {
				this.cleanFilterForSheet(sheetId, suspendEvent, suspendPull);
			}
			if(!suspendEvent) {
				sheet.fireEvent("preparecreatefilter", tmp, sheet, suspendPull);
			}
			filterCdts = filterCdts || {};
			for(var i = mincol; i <= maxcol; i++) {
				var modified = this.prepareFilterPreporty(row, span);
				var fcdt = filterCdts[i],
					trigger = false;
				if(fcdt) {
					store.walkRange([
						[sheetId, minrow, i, maxrow, i]
					], function(rec) {
						var r = rec.data.row;
						if(minrow < r) {
							var cd = sheet.getCellValue(rec.data.sheet, r, rec.data.col);
							if(!this.checkWithFilterCdt(fcdt, cd, sheet)) {
								if(!hidden[r] && store.isVisibleRow(sheetId, r)) {
									hidden[r] = true;
								}
								trigger = true;
							}
						}
						if(showPairs[1] < r) {
							showPairs[1] = r;
						}
					}, this);
					modified.filterCdt = Ext.encode(fcdt);
				}
				if(trigger) {
					modified.trigger = "ss-filter ss-filtered-trigger";
				}
				store.setCell(sheetId, row, i, modified, null, true, undefined, suspendPull);
			}
			var hidePairs = SCOM.transferObj2Pairs(hidden),
				flag;
			showPairs = [showPairs];
			var hiddens = [],
				showns = [];
			for(var i = 0, len = showPairs.length; i < len; i++) {
				var it = showPairs[i];
				showns = showns.concat(store.showRow(sheetId, it[0], it[1], true, suspendPull));
				flag = true;
			}
			for(var i = 0, len = hidePairs.length; i < len; i++) {
				var it = hidePairs[i];
				hiddens = hiddens.concat(store.hideRow(sheetId, it[0], it[1], true, suspendPull));
				flag = true;
			}
			if(flag) {
				sheet.refreshRange();
			} else {
				sheet.refreshRange([
					[sheetId, minrow, mincol, minrow, maxcol]
				]);
			}
			if(!suspendEvent) {
				sheet.fireEvent("createfilter", tmp, sheet, suspendPull, showns, hiddens);
				sheet.fireEvent("aftercreatefilter", tmp, sheet, suspendPull, showns, hiddens);
			}
		}
	},
	checkWithFilterCdt: function(filterCdt, cd, sheet) {
		if(Ext.isObject(filterCdt)) {
			var type = filterCdt.type,
				values = filterCdt.values;
			if("match" === type) {
				return -1 !== values.indexOf(cd.data);
			} else {
				return -1 === values.indexOf(cd.data);
			}
		}
	},
	checkFilters: function(row, filters) {
		if(!filters) {
			return true;
		}
		var sheet = this.sheet;
		for(var i = 0, len = filters.length; i < len; i++) {
			var filter = filters[i];
			var span = filter.filterSpan,
				cdt = filter.filterCdt;
			if(cdt) {
				var col = span[2];
				var ctype = cdt.type,
					values = cdt.values;
				var data = sheet.getCellData(span[0], row, col);
				data = data.data;
				if(Ext.isNumber(data)) {
					data = data.toString();
				} else if(SCOM.nullOrUndefined(data)) {
					data = "";
				}
				var index = Ext.Array.indexOf(values, data);
				if("match" == ctype && -1 == index) {
					return false;
				} else if("match" != ctype && -1 !== index) {
					return false;
				}
			}
		}
		return true;
	},
	getShownHiddens: function() {
		var sheet = this.sheet,
			store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var hflag = false,
			shown = {},
			hidden = {};
		for(var p in this.distinctCache) {
			var rows = this.distinctCache[p].rows,
				checked = this.distinctCache[p].checked;
			var fn, arr;
			if(checked) {
				for(var q in rows) {
					if(!store.isVisibleRow(sheetId, q) && this.checkFilters(q, this.otherFilters)) {
						shown[q] = true;
					}
				}
			} else {
				hflag = true;
				for(var q in rows) {
					if(store.isVisibleRow(sheetId, q)) {
						hidden[q] = true;
					}
				}
			}
		}
		var arr = [];
		for(var p in shown) {
			if(shown.hasOwnProperty(p)) {
				arr.push(p);
			}
		}
		shown = arr;
		arr = [];
		for(var p in hidden) {
			if(hidden.hasOwnProperty(p)) {
				arr.push(p);
			}
		}
		hidden = arr;
		return {
			hflag: hflag,
			shown: shown,
			hidden: hidden,
			showPairs: SCOM.transferArr2Pairs(shown),
			hidePairs: SCOM.transferArr2Pairs(hidden)
		};
	},
	applyFilter: function(suspendEvent, refreshCalCdt, remove) {
		var sheet = this.sheet,
			store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var obj = this.getShownHiddens(),
			shown = obj.shown,
			hidden = obj.hidden,
			showPairs = obj.showPairs,
			hidePairs = obj.hidePairs;
		if(suspendEvent || false !== sheet.fireEvent("beforefiltering", sheetId, shown, hidden, this.pos, sheet)) {
			for(var i = 0, len = showPairs.length; i < len; i++) {
				var it = showPairs[i];
				store.showRow(sheetId, it[0], it[1], true);
			}
			for(var i = 0, len = hidePairs.length; i < len; i++) {
				var it = hidePairs[i];
				store.hideRow(sheetId, it[0], it[1], true);
			}
			if(0 < obj.hflag) {
				this.filteredFlag = true;
			} else {
				delete this.filteredFlag;
			}
			var oldData = store.getCell(sheetId, this.pos.row, this.pos.col, true);
			var oldTrigger = oldData.trigger,
				oldFilterCdt = oldData.filterCdt,
				oldFilter = oldData.filter;
			this.updateTrigger(remove);
			this.sheet.refreshRange(undefined, refreshCalCdt);
			this.menu.hide();
			if(!suspendEvent) {
				sheet.fireEvent("filtering", sheetId, shown, hidden, this.pos, oldTrigger, oldFilter, oldFilterCdt, sheet);
			}
			return [sheetId, shown, hidden, this.pos, oldTrigger, oldFilterCdt];
		}
	},
	cancelFilter: function() {
		this.menu.hide();
	},
	clearFilter: function(suspendEvent, refreshCalCdt, remove) {
		for(var p in this.distinctCache) {
			this.distinctCache[p].checked = true;
		}
		if(this.showHiddenCache) {
			this.showHiddenCache.hidden = {};
			delete this.showHiddenCache.hflag;
		}
		this.applyFilter(suspendEvent, refreshCalCdt, remove);
	},
	removeFilter: function() {
		this.clearFilter(false, false, true);
	},
	sortAsc: function() {
		this.checkSort("asc");
	},
	sortDesc: function() {
		this.checkSort("desc");
	},
	updateTrigger: function(remove) {
		var store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		if(true === remove) {
			store.setCell(sheetId, this.pos.row, this.pos.col, {
				trigger: false
			}, ["filterCdt", "filter"], true);
		} else {
			var arr = [];
			if(this.filteredFlag) {
				arr.push("filtered");
			}
			if(this.sortFlag) {
				arr.push(this.sortFlag);
			}
			arr.unshift("ss");
			arr.push("trigger");
			var str = arr.join("-");
			var filterCdt = this.getFilterCondition();
			store.setCell(sheetId, this.pos.row, this.pos.col, {
				trigger: "ss-filter " + str,
				filterCdt: Ext.encode(filterCdt)
			}, null, true);
		}
	},
	getFilterCondition: function() {
		var sm = this.grid.getSelectionModel();
		var recs = this.distinctStore.getRange();
		var len = recs.length;
		var sels = [],
			usels = [];
		for(var p in this.distinctCache) {
			var it = this.distinctCache[p],
				checked = this.distinctCache[p].checked;
			var text = p;
			if("blank-text" == it.id) {
				text = "";
			}
			if(!checked) {
				usels.push(text);
			} else {
				sels.push(text);
			}
		}
		var slen = sels.length,
			ulen = usels.length;
		if(slen < ulen) {
			return {
				type: "match",
				values: sels
			};
		} else {
			return {
				type: "no-match",
				values: usels
			};
		}
	},
	checkSort: function(dir, suspendEvent) {
		var sheet = this.sheet,
			store = this.sheet.getStore();
		var filterSpan = this.filterSpan;
		if(filterSpan[1] === filterSpan[3] && filterSpan[2] === filterSpan[4] && 0 !== filterSpan[1] && 0 !== filterSpan[2] || 0 === filterSpan[1] && 0 === filterSpan[2]) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.can_not_sort_range,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		} else {
			if(this.isTplFilter) {
				this.sort(dir, false, suspendEvent);
			} else {
				var withMerged = false,
					expand;
				SPOP.showSortColumnOption({
					applyCallback: {
						fn: function(opt) {
							if(0 == opt) {
								expand = true;
							} else {
								expand = false;
							}
							var tmpSpan = [].concat(filterSpan);
							if(expand) {
								tmpSpan[2] = tmpSpan[4] = 0;
							}
							store.walkRange([tmpSpan], function(rd) {
								var json = rd.data.json;
								if(store.isMergedCell(json, rd.data.sheet, rd.data.row, rd.data.col) || json.tpl) {
									withMerged = true;
									return false;
								}
							}, this, true);
							if(withMerged) {
								Ext.Msg.show({
									title: SLANG.hint,
									msg: SLANG.can_not_sort_merged_or_table_tpl,
									icon: Ext.Msg.INFO,
									buttons: Ext.Msg.OK
								});
							} else {
								this.sort(dir, expand, suspendEvent);
							}
						},
						scope: this
					}
				});
			}
		}
	},
	sort: function(dir, expand, suspendEvent) {
		var sortOn = "col";
		var sheet = this.sheet,
			store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var filterSpan = this.filterSpan;
		var keys = [filterSpan[2]];
		var sortSpan = filterSpan;
		if(this.isTplFilter) {
			sortSpan = this.isTplFilter;
		}
		var oldTrigger = store.getCell(sheetId, this.pos.row, this.pos.col, true).trigger;
		if(suspendEvent || false !== sheet.fireEvent("beforesortfilter", [].concat(sortSpan), keys, dir, sortOn, expand, false, store)) {
			var relatedRows = sheet.getRelatedRowsForAutoHeight([sortSpan], undefined, undefined, true);
			var coord;
			if(expand) {
				coord = [
					[sortSpan[0], sortSpan[1], 0, sortSpan[3], 0]
				];
			} else {
				coord = [sortSpan];
			}
			var reCalCells = sheet.getRecalculateCellsByCoord(coord);
			sheet.fireEvent("preparesortfilter", [].concat(sortSpan), keys, dir, sortOn, expand, false, store);
			this.sortFlag = dir;
			this.updateTrigger();
			var diff = store.sortSpan([].concat(sortSpan), SCOM.copy(keys), dir, sortOn, expand, false, true);
			store.walkRange(coord, function(rd, walkSpan, store, internalId) {
				var sid = rd.data.sheet,
					row = rd.data.row,
					col = rd.data.col,
					json = rd.data.json;
				if(sheet.isCalculateCell(json)) {
					var oldRow, oldCol;
					if("row" == sortOn) {
						oldCol = diff[rd.data.col];
					} else {
						oldRow = diff[rd.data.row];
					}
					var o = sheet.resetCalculateCellData(json, sid, row, col, undefined, oldRow, oldCol);
					store.setCell(sid, row, col, o, null, true);
					if(!reCalCells[internalId]) {
						reCalCells[internalId] = [sid, row, col];
					}
				}
			}, this, true);
			var span = [].concat(filterSpan);
			var distinct = {},
				minrow = false,
				maxrow = false,
				nonemptys = {};
			var row = this.pos.row,
				col = this.pos.col;
			store.walkRange([span], function(rd) {
				var json = rd.data.json;
				if(row < rd.data.row && 0 !== rd.data.row && 0 !== rd.data.col) {
					var cd = sheet.getCellValue(rd.data.sheet, rd.data.row, rd.data.col);
					var data = cd.data;
					if(false != SCOM.typeOf(data) && "" !== data) {
						distinct[data] = distinct[data] || {
							checked: this.distinctCache[data].checked,
							rows: {}
						};
						distinct[data].rows[rd.data.row] = true;
						nonemptys[rd.data.row] = true;
					}
				}
			}, this, true);
			var emptys = {};
			for(var i = this.pos.minrow; i <= this.pos.maxrow; i++) {
				if(!nonemptys[i]) {
					emptys[i] = true;
				}
			}
			if(!SCOM.isEmptyObj(emptys)) {
				var blank = "(" + SLANG.blank + ")";
				distinct[blank] = {
					id: "blank-text",
					checked: this.distinctCache[blank].checked,
					rows: emptys
				};
			}
			this.distinctCache = distinct;
			Ext.applyIf(relatedRows, sheet.getRelatedRowsForAutoHeight([sortSpan]));
			var changedHeights = sheet.checkAutoHeightForRows(relatedRows);
			var filterInfo = this.applyFilter(true, reCalCells);
			filterInfo[4] = oldTrigger;
			if(!suspendEvent) {
				sheet.fireEvent("sortfilter", [].concat(sortSpan), SCOM.copy(keys), dir, null, expand, false, diff, filterInfo, reCalCells, changedHeights, store);
			}
		}
	},
	onSearchKeyUp: function(field, e) {
		this.startIndex = 0;
		var count = 0,
			limit = this.pageCount;
		var val = field.getValue();
		var store = this.distinctStore,
			sm = this.grid.getSelectionModel();
		if(val) {
			var str = val.toString(),
				distinct = this.distinctCache;
			for(var text in distinct) {
				if(distinct.hasOwnProperty(text) && text) {
					var it = distinct[text];
					if("blank-text" === it.id) {
						it.checked = false;
					} else {
						var index = text.toLowerCase().indexOf(str.toLowerCase());
						if(-1 == index) {
							it.checked = false;
						} else {
							it.checked = true;
							count++;
						}
					}
				}
			}
			this.filteringFlag = str;
			this.pos.totalNum = count;
			this.pos.totalPage = Math.ceil(count / this.pageCount);
			var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, 0, this.pageCount);
			if(isEnd) {
				this.nextPageBtn.disable();
			} else {
				this.nextPageBtn.enable();
			}
		} else {
			this.filteringFlag = false;
			var distinct = this.distinctCache;
			for(var text in distinct) {
				if(distinct.hasOwnProperty(text)) {
					var it = distinct[text];
					it.checked = true;
				}
			}
			total = SCOM.countObjMember(distinct);
			this.pos.totalNum = total;
			this.pos.totalPage = Math.ceil(total / this.pageCount);
			var isEnd = this.setupWithPage(this.setupInfo.row, this.setupInfo.col, this.setupInfo.filterSpan, this.setupInfo.filterCdt, 0, this.pageCount);
			if(isEnd) {
				this.nextPageBtn.disable();
			} else {
				this.nextPageBtn.enable();
			}
		}
		sm.selectAll();
	},
	showFilterReference: function(cell, sheetId, row, col) {
		if(cell.filter) {
			var span = Ext.decode(cell.filter);
			var coord = [];
			if(!Ext.isNumber(span[0])) {
				span[0] = sheetId;
			}
			span[1] += row - 1;
			span[2] += col;
			span[3] += row;
			span[4] += col;
			if(!Ext.isNumber(span[3])) {
				span[1] = 0;
				span[3] = 0;
			}
			coord.push({
				span: span,
				cls: "ss-rm-condition"
			});
			var rm = this.sheet.getReferenceModel();
			rm.setReference(coord, false, false, "ss-cal-ref");
			rm.show();
			return true;
		}
		return false;
	},
	onMenuHide: function() {
		var rm = this.sheet.getReferenceModel();
		if(rm.hasCls("ss-cal-ref")) {
			rm.hide();
		}
	},
	onFilterTypeCheck: function(item, checked) {
		if(checked) {
			this.filterTypeCt.getLayout().setActiveItem(1);
		} else {
			this.filterTypeCt.getLayout().setActiveItem(0);
		}
	},
	cleanFilterForSheet: function(sheetId, suspendEvent, suspendPull) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var rows = {},
			oldCells = {},
			newCells = {},
			flag = false;
		store.each(function(rd, internalId) {
			if(rd.data.sheet === sheetId) {
				var row = rd.data.row,
					col = rd.data.col;
				var json = rd.data.json;
				var filter = json.filter;
				if(filter) {
					filter = Ext.decode(filter);
					var minrow = filter[1] + row,
						maxrow = filter[3] + row;
					if(0 === maxrow) {
						store.walkRange([
							[sheetId, minrow, col, maxrow, col]
						], function(rd) {
							if(0 !== rd.data.row) {
								rows[rd.data.row] = true;
							}
						});
					} else {
						for(var i = minrow; i <= maxrow; i++) {
							rows[i] = true;
						}
					}
					var id = internalId;
					oldCells[id] = SCOM.copy(rd.data);
					store.setCell(sheetId, row, col, null, ["trigger", "filter", "filterCdt"], true, undefined, suspendPull);
					newCells[id] = SCOM.copy(store.getRecord(sheetId, row, col).data);
					flag = true;
				}
			}
		});
		if(flag) {
			var hiddens = [];
			for(var p in rows) {
				if(rows.hasOwnProperty(p)) {
					var row = Number(p);
					if(!store.isVisibleRow(sheetId, row)) {
						hiddens.push(row);
					}
				}
			}
			var showPairs = SCOM.transferArr2Pairs(hiddens);
			for(var i = 0, len = showPairs.length; i < len; i++) {
				var it = showPairs[i];
				store.showRow(sheetId, it[0], it[1], true, suspendPull);
			}
			if(!suspendEvent) {
				sheet.fireEvent("cleanfilter", sheetId, oldCells, newCells, hiddens, sheet, suspendPull);
			}
			sheet.refreshRange();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.history.Motion", {
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent();
	},
	undo: function() {
		return this.defaultUndo.apply(this, arguments);
	},
	redo: function() {
		return this.defaultRedo.apply(this, arguments);
	},
	defaultUndo: function(suspendRefresh, suspendRefreshSelection) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			sm = sheet.getSelectionModel();
		var coord = this.coord,
			origins = this.origins,
			range = this.range,
			originSheetId = this.originSheetId,
			originSel = this.originSel,
			originFocus = this.originFocus,
			ignoreRowCol = this.ignoreRowCol,
			suspendPull = this.suspendPull;
		var oldSuspendAddActionFlag = store.suspendAddActionFlag;
		if(suspendPull) {
			store.suspendAddActionFlag = true;
		}
		store.walkRange(coord, function(rd, walkSpan, store, internalId) {
			var id = internalId;
			if(!origins[id]) {
				store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, null, true, "clear");
			}
		}, this, undefined, undefined, ignoreRowCol);
		for(var p in origins) {
			if(origins.hasOwnProperty(p)) {
				var it = origins[p];
				var sheetId = it.sheet,
					row = it.row,
					col = it.col,
					json = it.json;
				store.setCell(sheetId, row, col, json, null, true, "clear");
			}
		}
		if(!suspendRefresh) {
			if(sheet.getSheetId() != this.originSheetId) {
				sheet.go2Sheet(this.originSheetId, function() {
					sheet.refreshCalCdt(this.refreshCalCdt);
				}, this);
			} else {
				range.refresh(this.refreshCalCdt, undefined, this.concatCoord, this.expand2Around);
			}
		}
		if(!suspendRefreshSelection) {
			sm.selectRange(originSel.startPos, originSel.endPos);
			sheet.refreshFocus(originFocus.row, originFocus.col);
		}
		if(suspendPull) {
			store.suspendAddActionFlag = oldSuspendAddActionFlag;
		}
		return this.coord;
	},
	defaultRedo: function(suspendRefresh, suspendRefreshSelection) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			sm = sheet.getSelectionModel();
		var coord = this.coord,
			modifieds = this.modifieds,
			range = this.range,
			sheetId = this.sheetId,
			sel = this.sel,
			focus = this.focus,
			ignoreRowCol = this.ignoreRowCol,
			suspendPull = this.suspendPull;
		var oldSuspendAddActionFlag = store.suspendAddActionFlag;
		if(suspendPull) {
			store.suspendAddActionFlag = true;
		}
		store.walkRange(coord, function(rd, walkSpan, store, internalId) {
			var id = internalId;
			if(!modifieds[id]) {
				store.setCell(rd.data.sheet, rd.data.row, rd.data.col, null, null, true, "clear");
			}
		}, this, undefined, undefined, ignoreRowCol);
		for(var p in modifieds) {
			if(modifieds.hasOwnProperty(p)) {
				var it = modifieds[p];
				var sheetid = it.sheet,
					row = it.row,
					col = it.col,
					json = it.json;
				store.setCell(sheetId, row, col, json, null, true, "clear");
			}
		}
		if(!suspendRefresh) {
			if(sheet.getSheetId() != sheetId) {
				sheet.go2Sheet(this.originSheetId, function() {
					sheet.refreshCalCdt(this.refreshCalCdt);
				}, this);
			} else {
				range.refresh(this.refreshCalCdt, undefined, this.concatCoord, this.expand2Around);
			}
		}
		if(!suspendRefreshSelection) {
			sm.selectRange(sel.startPos, sel.endPos);
			sheet.refreshFocus(focus.row, focus.col);
		}
		if(suspendPull) {
			store.suspendAddActionFlag = oldSuspendAddActionFlag;
		}
		return this.coord;
	}
});

Ext.define("EnterpriseSheet.sheet.history.History", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.sheet.history.Motion"],
	maxStackLength: 20,
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent();
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.stack = [];
		this.cursor = -1;
		var store = sheet.getStore(),
			editor = sheet.getEditor();
		this.mon(store, {
			scope: this,
			afterload: this.afterStoreLoad,
			prepareremoverow: this.prepareRemoveRow,
			prepareremovecolumn: this.prepareRemoveColumn,
			prepareremovecell: this.prepareRemoveCell,
			prepareinsertrow: this.prepareInsertRow,
			prepareinsertcolumn: this.prepareInsertColumn,
			prepareinsertcell: this.prepareInsertCell,
			tplsummarychange: this.onTplSummaryChange
		});
		this.mon(sheet, {
			scope: this,
			resethistory: this.clearHistory,
			disablehistory: function() {
				this.disabled = true;
			},
			enablehistory: function() {
				delete this.disabled;
			},
			createdynamicrange: this.prepareMergeMotion,
			prepareprocessdynamicrange: this.onPrepareProcessDynamicRange,
			afterprocessdynamicrange: function() {
				this.mergeMotion(SLANG.create_dynamic_range);
			},
			prepareinsertdynamicrangerow: function() {
				this.prepareMergeMotion();
				this.onPrepareInsertDynamicRangeRow.apply(this, arguments);
			},
			insertdynamicrangerow: function() {
				this.mergeMotion(SLANG.insert_dynamic_range_row);
			},
			prepareinsertdynamicrangecol: function() {
				this.prepareMergeMotion();
				this.onPrepareInsertDynamicRangeCol.apply(this, arguments);
			},
			insertdynamicrangecol: function() {
				this.mergeMotion(SLANG.insert_dynamic_range_col);
			},
			preparedeletedynamicrangerow: function() {
				this.prepareMergeMotion();
				this.onPrepareDeleteDynamicRangeRow.apply(this, arguments);
			},
			deletedynamicrangerow: function() {
				this.mergeMotion(SLANG.delete_dynamic_range_row);
			},
			preparedeletedynamicrangecol: function() {
				this.prepareMergeMotion();
				this.onPrepareDeleteDynamicRangeCol.apply(this, arguments);
			},
			deletedynamicrangecol: function() {
				this.mergeMotion(SLANG.delete_dynamic_range_col);
			},
			preparecompleteedit: function(sheetId, row, col, editor, asArrayFormula) {
				if(asArrayFormula) {
					var span = sheet.getSelectionModel().selection2Span();
					this.onArrayFormulaChange(span);
				}
			},
			datachange: this.onDataChange,
			keydown: this.onKeyDown,
			prepareautoextendcdt: function(sheetId, row, col, changedCdt) {
				this.prepareautoextendcdt.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			preparesortspan: function() {
				this.beforeSortSpan.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			preparesortfilter: function() {
				this.beforeSortFilter.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			preparecreatefilter: function(span, sheet, suspendPull) {
				var range = new EnterpriseSheet.sheet.range.Range({
					sheet: this.sheet,
					coord: [span]
				});
				this.beforeRangeChange(range, "createfilter", SLANG.create_filter_for, undefined, undefined, undefined, undefined, undefined, undefined, suspendPull);
				sheet.fireEvent("changing", sheet);
			},
			filtering: function(sheetId, shown, hidden, triggerPos, oldTrigger, oldFilter, oldFilterCdt) {
				var eventName = "filtering";
				var display = SLANG.filtering;
				this.onFiltering(sheetId, shown, hidden, triggerPos, oldTrigger, oldFilter, oldFilterCdt, display);
				sheet.fireEvent("changing", sheet);
			},
			cleanfilter: this.onCleanFilter,
			prepareautofill: function(range, fromCoord, ss, originCdts, reCalCells, changedHeights) {
				this.beforeRangeChange(range, "autofill", SLANG.autofill, false, reCalCells, originCdts, changedHeights);
				sheet.fireEvent("changing", sheet);
			},
			preparestylebrush: function(range, fromCoord, sheet, originCdts, reCalCells) {
				this.beforeRangeChange(range, "stylebrush", SLANG.apply_style_brush, false, reCalCells, originCdts);
				sheet.fireEvent("changing", sheet);
			},
			preparerangechange: function(range, modified, deleted, changedHeights, cdtCoord) {
				this.beforeRangeChange(range, "rangechange", SLANG.change_property_for, undefined, undefined, undefined, changedHeights, cdtCoord, true);
				sheet.fireEvent("changing", sheet);
			},
			preparecleanrange: function(range, clearType, sheet, originCdts, reCalCells, changedHeights, concatCoord) {
				this.beforeRangeChange(range, "cleanrange", SLANG.clean_for, false, reCalCells, originCdts, changedHeights, concatCoord);
				sheet.fireEvent("changing", sheet);
			},
			preparepaste: function(range, sheet, originCdts, reCalCells, changedHeights) {
				this.beforeRangeChange(range, "paste", SLANG.paste_at, false, reCalCells, originCdts, changedHeights);
				sheet.fireEvent("changing", sheet);
			},
			preparerangemove: function(range, sheet, originCdt, reCalCells, changedHeights) {
				this.beforeRangeChange(range, "rangemove", SLANG.selection_move2, false, reCalCells, originCdt, changedHeights);
				sheet.fireEvent("changing", sheet);
			},
			prepareconditionchange: function(range, ss, originCdt, concatCoord) {
				this.beforeRangeChange(range, "conditionchange", SLANG.change_condition_for, false, undefined, originCdt, undefined, concatCoord);
				sheet.fireEvent("changing", sheet);
			},
			preparesettpl: function(span) {
				var range = new EnterpriseSheet.sheet.range.Range({
					coord: [span],
					sheet: this.sheet
				});
				this.beforeRangeChange(range, "settpl", SLANG.set_table_tpl, undefined, true);
				sheet.fireEvent("changing", sheet);
			},
			prepareborderchange: function(range) {
				this.beforeRangeChange(range, "borderchange", SLANG.change_border_for, true);
				sheet.fireEvent("changing", sheet);
			},
			aftercolumnresized: function() {
				this.onColumnResized.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			rowresized: function() {
				this.onRowResized.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			rowautoresized: function() {
				this.onRowAutoResized.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			columnhide: function() {
				this.onColumnHide.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			rowhide: function() {
				this.onRowHide.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			columnshow: function() {
				this.onColumnShow.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			rowshow: function() {
				this.onRowShow.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			togglerowgroup: function() {
				this.onToggleRowGroup.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			togglecolgroup: function() {
				this.onToggleColGroup.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			togglerowgrouplevel: function() {
				this.onToggleRowGroupLevel.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			togglecolgrouplevel: function() {
				this.onToggleColGroupLevel.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			changegroup: function() {
				this.onChangeGroup.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			updategroups: function() {
				this.onUpdateGroups.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			freezechange: function() {
				this.onFreezeChange.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			splitchange: function() {
				this.onSplitChange.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			mergecell: function() {
				this.onMergeCell.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			unmergecell: function() {
				this.onUnmergeCell.apply(this, arguments);
				sheet.fireEvent("changing", sheet);
			},
			undo: function(suspendRefresh, suspendEvent) {
				this.undo(null, suspendRefresh, suspendEvent);
			},
			redo: function(suspendRefresh, suspendEvent) {
				this.redo(null, suspendRefresh, suspendEvent);
			},
			createchart: function(chartType, chart, rangeStore) {
				this.onCreateChart(chartType, chart, rangeStore);
				sheet.fireEvent("changing", sheet);
			},
			deletechart: function(chartType, chart, rangeStore, posize) {
				this.onDeleteChart(chartType, chart, rangeStore, posize);
				sheet.fireEvent("changing", sheet);
			},
			createpicture: function(url, picFloor) {
				this.onCreatePicture(url, picFloor);
				sheet.fireEvent("changing", sheet);
			},
			deletepicture: function(url, picFloor, info) {
				this.onDeletePicture(url, picFloor, info);
				sheet.fireEvent("changing", sheet);
			},
			createwedgit: function(url, picFloor) {
				this.onCreateWedgit(url, picFloor);
				sheet.fireEvent("changing", sheet);
			},
			deletewedgit: function(url, picFloor, info) {
				this.onDeleteWedgit(url, picFloor, info);
				sheet.fireEvent("changing", sheet);
			},
			beforeinsertcopied: this.prepareMergeMotion,
			insertcopied: function() {
				this.mergeMotion(SLANG.insert_copied);
			},
			preparedeleterows: this.prepareMergeMotion,
			deleterows: function() {
				this.mergeMotion(SLANG.delete_repeat_item);
			},
			preparedeletecellrangemovetop: this.prepareMergeMotion,
			deletecellrangemovetop: function() {
				this.mergeMotion(SLANG.delete_repeat_item);
			},
			preparedeletecellrangemoveleft: this.prepareMergeMotion,
			deletecellrangemoveleft: function() {
				this.mergeMotion(SLANG.delete_cell);
			},
			preparesetheadertitle: this.prepareSetHeaderTitle,
			preparemoveforinsert: this.prepareMergeMotion,
			moveforinsert: function() {
				this.mergeMotion(SLANG.cut_move_selection);
			},
			createcustomerhistory: this.onCreateCustomerHistory,
			deletepagebreak: this.onDeletePageBreak,
			insertpagebreak: this.onInsertPageBreak,
			beforepreparecreatefilter: this.prepareMergeMotion,
			aftercreatefilter: function() {
				this.mergeMotion(SLANG.create_filter);
			}
		});
	},
	onKeyDown: function(e) {
		var key = e.getKey();
		if(e.ctrlKey) {
			if(89 == key) {
				e.preventDefault();
				this.redo();
			} else if(90 == key) {
				e.preventDefault();
				this.undo();
			}
		}
	},
	onUnmergeCell: function(span, unmerged, sheet, reCalCells) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: span,
			type: SCONST.RELATIVE_COORD
		}], "");
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.cancel_merge_cell + " " + str,
			conflictAction: "unmergeCell",
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var p in unmerged) {
					sheet.doMergeCell(unmerged[p], true, true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange(null, reCalCells);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var p in unmerged) {
					sheet.doUnmergeCell(unmerged[p], true, true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange(null, reCalCells);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onMergeCell: function(span, sheet, reCalCells) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: span,
			type: SCONST.RELATIVE_COORD
		}], "");
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.merge_cell + " " + str,
			conflictAction: "mergeCell",
			undo: function(suspendRefresh, suspendRefreshSelection) {
				sheet.doUnmergeCell(span, true, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, [span]);
						});
					} else {
						sheet.refreshRange([span], reCalCells);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				sheet.doMergeCell(span, true, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, [span]);
						});
					} else {
						sheet.refreshRange([span], reCalCells);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onSplitChange: function(splitPos, oldSplitPos, freezePos, oldFreezePos, rangeInfo, oldRangeInfo, sheet) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.split,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var obj = {
					splitPos: oldSplitPos,
					freezePos: oldFreezePos,
					rangeInfo: oldRangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var obj = {
					splitPos: splitPos,
					freezePos: freezePos,
					rangeInfo: rangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onFreezeChange: function(freezePos, oldFreezePos, splitPos, oldSplitPos, rangeInfo, oldRangeInfo, sheet) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var text;
		if(freezePos) {
			text = SLANG.freeze + " " + EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: ["", freezePos.row, freezePos.col, freezePos.row, freezePos.col],
				type: SCONST.RELATIVE_COORD
			}], "");
		} else {
			text = SLANG.cancel_freeze;
		}
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var obj = {
					freezePos: oldFreezePos,
					splitPos: oldSplitPos,
					rangeInfo: oldRangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var obj = {
					freezePos: freezePos,
					splitPos: splitPos,
					rangeInfo: rangeInfo
				};
				sheet.setSheetConfig(obj);
				sheet.updateSheetConfig(true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onRowShow: function(sheetId, minrow, maxrow, hidden) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: ["", minrow, 0, maxrow, 0],
			type: SCONST.RELATIVE_COORD
		}], "");
		var hidePairs = SCOM.transferArr2Pairs(hidden);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.show + " " + str,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = hidePairs.length; i < len; i++) {
					var it = hidePairs[i];
					store.hideRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = hidePairs.length; i < len; i++) {
					var it = hidePairs[i];
					store.showRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onColumnShow: function(sheetId, mincol, maxcol, hidden) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: ["", 0, mincol, 0, maxcol],
			type: SCONST.RELATIVE_COORD
		}], "");
		var hidePairs = SCOM.transferArr2Pairs(hidden);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.show + " " + str,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = hidePairs.length; i < len; i++) {
					var it = hidePairs[i];
					store.hideColumn(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = hidePairs.length; i < len; i++) {
					var it = hidePairs[i];
					store.showColumn(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	beforeSortSpan: function(span, keys, dir, sortOn, expand, allString) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var coord = expand ? [
			[span[0], span[1], 0, span[3], 0]
		] : [span];
		var preCal, posCal, reCalCells, preAutoHeights, posAutoHeights, me = this;
		sheet.on("sortspan", function(span, keys, dir, sortOn, expand, allString, diff) {
			var mincol = 0,
				maxcol = 0,
				minrow = 0,
				maxrow = 0;
			if(!expand) {
				minrow = span[1];
				maxrow = span[3];
				mincol = span[2];
				maxcol = span[4];
			}
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var sheetId = sheet.getSheetId();
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: span,
				type: SCONST.RELATIVE_COORD
			}], "");
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.sort + " " + str,
				conflictAction: "sortSpan",
				conflictAnswer: true,
				undo: function(suspendRefresh, suspendRefreshSelection) {
					store.moveRows(sheetId, diff, mincol, maxcol, true);
					me.recoverCell(preCal);
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
							});
						} else {
							sheet.refreshRange(null, reCalCells);
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.sortSpan(span, keys, dir, sortOn, expand, allString, true);
					me.recoverCell(posCal);
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
							});
						} else {
							sheet.refreshRange(null, reCalCells);
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
		sheet.on("spansorted", function(span, keys, dir, sortOn, expand, allString, reCals, oldCals, newCals, changedHeights, store, sheet) {
			preCal = oldCals;
			posCal = newCals;
			reCalCells = reCals;
			preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {
			single: true
		});
	},
	recoverAutoHeight: function(autoHeights, suspendRefresh) {
		var store = this.sheet.getStore();
		for(var p in autoHeights) {
			if(autoHeights.hasOwnProperty(p)) {
				var it = autoHeights[p];
				store.setRow(it.sheetId, it.row, {
					autoHeight: it.ah
				}, null, true, suspendRefresh, null, true);
			}
		}
	},
	beforeSortFilter: function(span, keys, dir, sortOn, expand, allString) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var coord = expand ? [
			[span[0], span[1], 0, span[3], 0]
		] : [span];
		var preCal = this.cacheCalCdt(coord),
			posCal, me = this;
		sheet.on("sortfilter", function(span, keys, dir, sortOn, expand, allString, diff, filterInfo, reCalCells, changedHeights, store) {
			var mincol = 0,
				maxcol = 0;
			if(!expand) {
				mincol = span[2];
				maxcol = span[4];
			}
			posCal = this.cacheCalCdt(coord);
			var preAutoHeights = changedHeights.oldHeights,
				posAutoHeights = changedHeights.newHeights;
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var sheetId = sheet.getSheetId();
			var shown = filterInfo[1],
				hidden = filterInfo[2],
				triggerPos = filterInfo[3],
				oldTrigger = filterInfo[4];
			var trigger = store.getCell(sheetId, triggerPos.row, triggerPos.col, true).trigger;
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: ["", triggerPos.row, triggerPos.col, triggerPos.row, triggerPos.col],
				type: SCONST.RELATIVE_COORD
			}], "");
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.sort_filter + " " + str,
				conflictAction: "sortFilter",
				conflictAnswer: true,
				undo: function(suspendRefresh, suspendRefreshSelection) {
					for(var i = 0, len = shown.length; i < len; i++) {
						var row = shown[i];
						store.hideRow(sheetId, row, row, true);
					}
					for(var i = 0, len = hidden.length; i < len; i++) {
						var row = hidden[i];
						store.showRow(sheetId, row, row, true);
					}
					store.setCell(sheetId, triggerPos.row, triggerPos.col, {
						trigger: oldTrigger
					}, null, true);
					store.moveRows(sheetId, diff, mincol, maxcol, true);
					me.recoverCell(preCal);
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
							sheet.syncPageBreak();
						});
					} else {
						sheet.refreshRange(null, reCalCells);
						sheet.syncPageBreak();
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.sortSpan(span, keys, dir, sortOn, expand, allString, true);
					for(var i = 0, len = shown.length; i < len; i++) {
						var row = shown[i];
						store.showRow(sheetId, row, row, true);
					}
					for(var i = 0, len = hidden.length; i < len; i++) {
						var row = hidden[i];
						store.hideRow(sheetId, row, row, true);
					}
					store.setCell(sheetId, triggerPos.row, triggerPos.col, {
						trigger: trigger
					}, null, true);
					me.recoverCell(posCal);
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
							sheet.syncPageBreak();
						});
					} else {
						sheet.refreshRange(null, reCalCells);
						sheet.syncPageBreak();
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
	},
	onRowHide: function(sheetId, minrow, maxrow, visibles) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: ["", minrow, 0, maxrow, 0],
			type: SCONST.RELATIVE_COORD
		}], "");
		var showPairs = SCOM.transferArr2Pairs(visibles);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.hide + " " + str,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = showPairs.length; i < len; i++) {
					var it = showPairs[i];
					store.showRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = showPairs.length; i < len; i++) {
					var it = showPairs[i];
					store.hideRow(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onFiltering: function(sheetId, shown, hidden, triggerPos, oldTrigger, oldFilter, oldFilterCdt, display) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var curData = store.getCell(sheetId, triggerPos.row, triggerPos.col);
		var trigger = curData.trigger,
			filter = curData.filter,
			filterCdt = curData.filterCdt;
		shown = shown || [];
		hidden = hidden || [];
		var showPairs = SCOM.transferArr2Pairs(shown),
			hidePairs = SCOM.transferArr2Pairs(hidden);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: display,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = showPairs.length; i < len; i++) {
					var it = showPairs[i];
					store.hideRow(sheetId, it[0], it[1], true);
				}
				for(var i = 0, len = hidePairs.length; i < len; i++) {
					var it = hidePairs[i];
					store.showRow(sheetId, it[0], it[1], true);
				}
				var modify = {
						trigger: oldTrigger
					},
					deleted = null;
				if(oldFilter) {
					modify.filter = oldFilter;
				} else {
					deleted = deleted || [];
					deleted.push("filter");
				}
				if(oldFilterCdt) {
					modify.filterCdt = oldFilterCdt;
				} else {
					deleted = deleted || [];
					deleted.push("filterCdt");
				}
				store.setCell(sheetId, triggerPos.row, triggerPos.col, modify, deleted, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = showPairs.length; i < len; i++) {
					var it = showPairs[i];
					store.showRow(sheetId, it[0], it[1], true);
				}
				for(var i = 0, len = hidePairs.length; i < len; i++) {
					var it = hidePairs[i];
					store.hideRow(sheetId, it[0], it[1], true);
				}
				var modify = {
						trigger: trigger
					},
					deleted = null;
				if(filter) {
					modify.filter = filter;
				} else {
					deleted = deleted || [];
					deleted.push("filter");
				}
				if(filterCdt) {
					modify.filterCdt = filterCdt;
				} else {
					deleted = deleted || [];
					deleted.push("filterCdt");
				}
				store.setCell(sheetId, triggerPos.row, triggerPos.col, modify, deleted, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onColumnHide: function(sheetId, mincol, maxcol, visibles) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: ["", 0, mincol, 0, maxcol],
			type: SCONST.RELATIVE_COORD
		}], "");
		var showPairs = SCOM.transferArr2Pairs(visibles);
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.hide + " " + str,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = showPairs.length; i < len; i++) {
					var it = showPairs[i];
					store.showColumn(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var i = 0, len = showPairs.length; i < len; i++) {
					var it = showPairs[i];
					store.hideColumn(sheetId, it[0], it[1], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onCleanFilter: function(sheetId, preCells, posCells, hiddens, suspendPull) {
		var me = this;
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.cancel_filtering,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var oldSuspendAddActionFlag = store.suspendAddActionFlag;
				if(suspendPull) {
					store.suspendAddActionFlag = true;
				}
				me.recoverCell(preCells);
				for(var i = 0, len = hiddens.length; i < len; i++) {
					store.hideRow(sheetId, hiddens[i], hiddens[i], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				if(suspendPull) {
					store.suspendAddActionFlag = oldSuspendAddActionFlag;
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var oldSuspendAddActionFlag = store.suspendAddActionFlag;
				if(suspendPull) {
					store.suspendAddActionFlag = true;
				}
				me.recoverCell(posCells);
				for(var i = 0, len = hiddens.length; i < len; i++) {
					store.showRow(sheetId, hiddens[i], hiddens[i], true);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				if(suspendPull) {
					store.suspendAddActionFlag = oldSuspendAddActionFlag;
				}
			}
		});
		this.add(motion);
	},
	onToggleRowGroup: function(name, expand, sheetId, rows, oldRowGroups, rowGroups, sheet) {
		var sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: expand ? SLANG.expand_row_group : SLANG.collapse_row_group,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				if(expand) {
					for(var i = 0, len = rows.length; i < len; i++) {
						store.hideRow(sheetId, rows[i], rows[i], true);
					}
				} else {
					for(var i = 0, len = rows.length; i < len; i++) {
						store.showRow(sheetId, rows[i], rows[i], true);
					}
				}
				store.updateRowGroups(sheetId, oldRowGroups);
				sheet.updateGroupState("row", name, expand);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				if(expand) {
					for(var i = 0, len = rows.length; i < len; i++) {
						store.showRow(sheetId, rows[i], rows[i], true);
					}
				} else {
					for(var i = 0, len = rows.length; i < len; i++) {
						store.hideRow(sheetId, rows[i], rows[i], true);
					}
				}
				store.updateRowGroups(sheetId, rowGroups);
				sheet.updateGroupState("row", name, !expand);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onToggleColGroup: function(name, expand, sheetId, columns, oldColGroups, colGroups, sheet) {
		var sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: expand ? SLANG.expand_column_group : SLANG.collapse_column_group,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				if(expand) {
					for(var i = 0, len = columns.length; i < len; i++) {
						store.hideColumn(sheetId, columns[i], columns[i], true);
					}
				} else {
					for(var i = 0, len = columns.length; i < len; i++) {
						store.showColumn(sheetId, columns[i], columns[i], true);
					}
				}
				store.updateColumnGroups(sheetId, oldColGroups);
				sheet.updateGroupState("col", name, expand);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				if(expand) {
					for(var i = 0, len = columns.length; i < len; i++) {
						store.showColumn(sheetId, columns[i], columns[i], true);
					}
				} else {
					for(var i = 0, len = columns.length; i < len; i++) {
						store.hideColumn(sheetId, columns[i], columns[i], true);
					}
				}
				store.updateColumnGroups(sheetId, colGroups);
				sheet.updateGroupState("col", name, !expand);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onToggleRowGroupLevel: function(expand, sheetId, showns, hiddens, oldRowGroups, rowGroups, oldRowLevels, rowLevels, sheet) {
		var sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: expand ? SLANG.expand_row_group : SLANG.collapse_row_group,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var row in hiddens) {
					store.showRow(sheetId, row, row, true);
				}
				for(var row in showns) {
					store.hideRow(sheetId, row, row, true);
				}
				store.updateRowGroups(sheetId, oldRowGroups);
				if(sheetId == sheet.getSheetId()) {
					sheet.setGroupLevel("row", oldRowLevels);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var row in showns) {
					store.showRow(sheetId, row, row, true);
				}
				for(var row in hiddens) {
					store.hideRow(sheetId, row, row, true);
				}
				store.updateRowGroups(sheetId, rowGroups);
				if(sheetId == sheet.getSheetId()) {
					sheet.setGroupLevel("row", rowLevels);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onToggleColGroupLevel: function(expand, sheetId, showns, hiddens, oldColGroups, colGroups, oldColLevels, colLevels, sheet) {
		var sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: expand ? SLANG.expand_column_group : SLANG.collapse_column_group,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var col in hiddens) {
					store.showColumn(sheetId, col, col, true);
				}
				for(var col in showns) {
					store.hideColumn(sheetId, col, col, true);
				}
				store.updateColumnGroups(sheetId, oldColGroups);
				if(sheetId == sheet.getSheetId()) {
					sheet.setGroupLevel("col", oldColLevels);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var col in showns) {
					store.showColumn(sheetId, col, col, true);
				}
				for(var col in hiddens) {
					store.hideColumn(sheetId, col, col, true);
				}
				store.updateColumnGroups(sheetId, colGroups);
				if(sheetId == sheet.getSheetId()) {
					sheet.setGroupLevel("col", colLevels);
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onChangeGroup: function(dir, sheetId, oldGroups, groups, sheet) {
		var sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.change_group,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var needLayout;
				if("row" == dir) {
					var oldMaxLevel = sheet.rowGroupMaxLevel;
					sheet.setRowGroups(oldGroups);
					needLayout = oldMaxLevel != sheet.rowGroupMaxLevel;
					store.updateRowGroups(sheetId, oldGroups);
				} else {
					var oldMaxLevel = sheet.colGroupMaxLevel;
					sheet.setColumnGroups(oldGroups);
					needLayout = oldMaxLevel != sheet.colGroupMaxLevel;
					store.updateColumnGroups(sheetId, oldGroups);
				}
				if(needLayout) {
					if(Ext.isFunction(sheet.doLayout)) {
						sheet.doLayout();
					} else if(Ext.isFunction(sheet.updateLayout)) {
						sheet.updateLayout();
					}
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var needLayout;
				if("row" == dir) {
					var oldMaxLevel = sheet.rowGroupMaxLevel;
					sheet.setRowGroups(groups);
					needLayout = oldMaxLevel != sheet.rowGroupMaxLevel;
					store.updateRowGroups(sheetId, groups);
				} else {
					var oldMaxLevel = sheet.colGroupMaxLevel;
					sheet.setColumnGroups(groups);
					needLayout = oldMaxLevel != sheet.colGroupMaxLevel;
					store.updateColumnGroups(sheetId, groups);
				}
				if(needLayout) {
					if(Ext.isFunction(sheet.doLayout)) {
						sheet.doLayout();
					} else if(Ext.isFunction(sheet.updateLayout)) {
						sheet.updateLayout();
					}
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onUpdateGroups: function(sheetId, oldRowGroups, oldColGroups, rowGroups, colGroups, sheet) {
		var sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.update_groups,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var needLayout;
				var oldRowMaxLevel = sheet.rowGroupMaxLevel;
				sheet.setRowGroups(oldRowGroups);
				needLayout = oldRowMaxLevel != sheet.rowGroupMaxLevel;
				store.updateRowGroups(sheetId, oldRowGroups);
				var oldColMaxLevel = sheet.colGroupMaxLevel;
				sheet.setColumnGroups(oldColGroups);
				needLayout = needLayout || oldMaxLevel != sheet.colGroupMaxLevel;
				store.updateColumnGroups(sheetId, oldColGroups);
				if(needLayout) {
					if(Ext.isFunction(sheet.doLayout)) {
						sheet.doLayout();
					} else if(Ext.isFunction(sheet.updateLayout)) {
						sheet.updateLayout();
					}
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var needLayout;
				var oldRowMaxLevel = sheet.rowGroupMaxLevel;
				sheet.setRowGroups(rowGroups);
				needLayout = oldRowMaxLevel != sheet.rowGroupMaxLevel;
				store.updateRowGroups(sheetId, rowGroups);
				var oldColMaxLevel = sheet.colGroupMaxLevel;
				sheet.setColumnGroups(colGroups);
				needLayout = needLayout || oldColMaxLevel != sheet.colGroupMaxLevel;
				store.updateColumnGroups(sheetId, colGroups);
				if(needLayout) {
					if(Ext.isFunction(sheet.doLayout)) {
						sheet.doLayout();
					} else if(Ext.isFunction(sheet.updateLayout)) {
						sheet.updateLayout();
					}
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onRowResized: function(row, old, cur) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell(),
			originSheetId = sheet.getSheetId();
		var minrow = row;
		for(var p in old) {
			if(p < minrow) {
				minrow = p;
			}
		}
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: ["", minrow, 0, row, 0],
			type: SCONST.RELATIVE_COORD
		}], "");
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.change_row_height_for + " " + str,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var p in old) {
					var i = Number(p);
					var v = old[p];
					if(true === v) {
						store.showRow(originSheetId, i, i, true);
					} else if(false === v) {
						store.hideRow(originSheetId, i, i, true);
					} else if(null === v) {
						if(0 == i) {
							store.setWhole(originSheetId, null, ["height"], true);
						} else {
							store.setRow(originSheetId, i, null, ["height"], true, true);
						}
					} else {
						var modified = {},
							deleted = [];
						if(!SCOM.canbeNumber(v.height)) {
							deleted.push("height");
						} else {
							modified.height = v.height;
						}
						if(!SCOM.canbeNumber(v.autoHeight)) {
							deleted.push("autoHeight");
						} else {
							modified.autoHeight = v.autoHeight;
						}
						if(!SCOM.canbeNumber(v.hoff)) {
							deleted.push("hoff");
						} else {
							modified.hoff = v.hoff;
						}
						store.setCell(originSheetId, i, 0, modified, deleted, true);
					}
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != originSheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var p in cur) {
					var i = Number(p);
					var v = cur[p];
					if(Ext.isNumber(v)) {
						store.setRowHeight(originSheetId, i, v, true, true);
					} else if(true === v) {
						store.showRow(originSheetId, i, i, true);
					} else if(false === v) {
						store.hideRow(originSheetId, i, i, true);
					} else if(null === v) {
						if(0 == i) {
							store.setWhole(originSheetId, null, ["height"], true);
						} else {
							store.setRow(originSheetId, i, null, ["height"], true, true);
						}
					}
				}
				if(!suspendRefresh) {
					if(sheet.getSheetId() != originSheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			}
		});
		this.add(motion);
	},
	onRowAutoResized: function(row, old, cur) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell(),
			originSheetId = sheet.getSheetId();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: ["", row, 0, row, 0],
			type: SCONST.RELATIVE_COORD
		}], "");
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.change_row_height_for + " " + str,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var modified = {},
					deleted = [];
				if(!SCOM.canbeNumber(old.height)) {
					deleted.push("height");
				} else {
					modified.height = old.height;
				}
				if(!SCOM.canbeNumber(old.autoHeight)) {
					deleted.push("autoHeight");
				} else {
					modified.autoHeight = old.autoHeight;
				}
				if(!SCOM.canbeNumber(old.hoff)) {
					deleted.push("hoff");
				} else {
					modified.hoff = old.hoff;
				}
				store.setCell(originSheetId, row, 0, modified, deleted, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != originSheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var modified = {},
					deleted = [];
				if(!SCOM.canbeNumber(cur.height)) {
					deleted.push("height");
				} else {
					modified.height = cur.height;
				}
				if(!SCOM.canbeNumber(cur.autoHeight)) {
					deleted.push("autoHeight");
				} else {
					modified.autoHeight = cur.autoHeight;
				}
				if(!SCOM.canbeNumber(cur.hoff)) {
					deleted.push("hoff");
				} else {
					modified.hoff = cur.hoff;
				}
				store.setCell(originSheetId, row, 0, modified, deleted, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != originSheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			}
		});
		this.add(motion);
	},
	onColumnResized: function(col, old, cur, changedHeights) {
		var me = this;
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell(),
			originSheetId = sheet.getSheetId();
		var preAutoHeights = changedHeights.oldHeights,
			posAutoHeights = changedHeights.newHeights;
		var mincol = col;
		for(var p in old) {
			if(p < mincol) {
				mincol = p;
			}
		}
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: ["", 0, mincol, 0, col],
			type: SCONST.RELATIVE_COORD
		}], "");
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.change_column_width_for + " " + str,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				for(var p in old) {
					var i = Number(p);
					var v = old[p];
					if(Ext.isNumber(v)) {
						store.setColumnWidth(originSheetId, i, v, true, true);
					} else if(true === v) {
						store.showColumn(originSheetId, i, i, true);
					} else if(false === v) {
						store.hideColumn(originSheetId, i, i, true);
					} else if(null === v) {
						if(0 == i) {
							store.setWhole(originSheetId, null, ["width"], true);
						} else {
							store.setColumn(originSheetId, i, null, ["width"], true, true);
						}
					}
				}
				me.recoverAutoHeight(preAutoHeights, suspendRefresh);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != originSheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				for(var p in cur) {
					var i = Number(p);
					var v = cur[p];
					if(Ext.isNumber(v)) {
						store.setColumnWidth(originSheetId, i, v, true, true);
					} else if(true === v) {
						store.showColumn(originSheetId, i, i, true);
					} else if(false === v) {
						store.hideColumn(originSheetId, i, i, true);
					} else if(null === v) {
						if(0 == i) {
							store.setWhole(originSheetId, null, ["width"], true);
						} else {
							store.setColumn(originSheetId, i, null, ["width"], true, true);
						}
					}
				}
				me.recoverAutoHeight(posAutoHeights, suspendRefresh);
				if(!suspendRefresh) {
					sheet.checkAutoHeightForCoord(null, [
						[originSheetId, 0, mincol, 0, col]
					], true);
					if(sheet.getSheetId() != originSheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.syncPageBreak();
						}, this);
					} else {
						sheet.refreshRange();
						sheet.syncPageBreak();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
			}
		});
		this.add(motion);
	},
	beforeAllChange: function(eventName, display) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell(),
			originSheetId = sheet.getSheetId();
		var origin = store.backupData();
		if(this[eventName + "Ref"]) {
			sheet.un(eventName, this[eventName + "Ref"], this);
			delete this[eventName + "Ref"];
		}
		var fn = function(range) {
			var modified = store.backupData();
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: display,
				undo: function(suspendRefresh, suspendRefreshSelection) {
					store.recoverData(origin);
					if(!suspendRefresh) {
						if(sheet.getSheetId() != originSheetId) {
							sheet.go2Sheet(originSheetId);
						} else {
							sheet.refreshRange();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(originSel.startPos, originSel.endPos);
						sheet.refreshFocus(originFocus.row, originFocus.col);
					}
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.recoverData(modified);
					if(!suspendRefresh) {
						if(sheet.getSheetId() != originSheetId) {
							sheet.go2Sheet(originSheetId);
						} else {
							sheet.refreshRange();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(originSel.startPos, originSel.endPos);
						sheet.refreshFocus(originFocus.row, originFocus.col);
					}
				}
			});
			this.add(motion);
		};
		sheet.on(eventName, fn, this, {
			single: true
		});
		this[eventName + "Ref"] = fn;
	},
	prepareSetHeaderTitle: function(span) {
		var me = this;
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var origins = {};
		var tspan = [span[0], 0, span[2], 0, span[4]];
		store.walkRange([span], function(rd, walkSpan, store, internalId) {
			var id = store.getIdBasedData({
				sheet: rd.data.sheet,
				row: 0,
				col: rd.data.col
			});
			origins[id] = store.getCell(rd.data.sheet, 0, rd.data.col).data;
		}, this);
		sheet.on("setheadertitle", function(span, titles) {
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.set_header_title,
				undo: function(suspendRefresh, suspendRefreshSelection) {
					store.walkRange([span], function(rec, walkSpan, store, internalId) {
						var id = store.getIdBasedData({
							sheet: rec.data.sheet,
							row: 0,
							col: rec.data.col
						});
						store.setCell(rec.data.sheet, 0, rec.data.col, {
							data: origins[id]
						}, undefined, true);
					}, this);
					sheet.refreshRange([tspan]);
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.walkRange([span], function(rec, walkSpan, store, internalId) {
						var id = internalId;
						store.setCell(rec.data.sheet, 0, rec.data.col, {
							data: titles[id]
						}, undefined, true);
					}, this);
					sheet.refreshRange([tspan]);
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
	},
	beforeRangeChange: function(range, eventName, text, withMargin, refreshCalCdt, originCdts, changedHeights, concatCoord, ignoreRowCol, suspendPull) {
		var me = this;
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell(),
			originSheetId = sheet.getSheetId();
		var origins = {},
			coord = range.getCoord();
		if(withMargin) {
			coord = range.extend2Margin(coord);
		}
		if(concatCoord) {
			coord = coord.concat(concatCoord);
		}
		store.walkRange(coord, function(rd, walkSpan, store, internalId) {
			var id = internalId;
			if(!origins[id]) {
				origins[id] = SCOM.copy(rd.data);
			}
		}, this, undefined, undefined, ignoreRowCol);
		var oldRange = range;
		var fn = function(range) {
			var changedCdts;
			if(originCdts) {
				for(var p in originCdts) {
					if(originCdts.hasOwnProperty(p)) {
						changedCdts = changedCdts || {};
						var it = originCdts[p];
						if(it) {
							changedCdts[p] = store.getFloatingById(p, it.sheet);
						}
					}
				}
			}
			if(!(range instanceof EnterpriseSheet.sheet.range.Range)) {
				range = oldRange;
			}
			var sel = sm.getSelection(),
				focus = sm.getFocusCell(),
				sheetId = sheet.getSheetId();
			var modifieds = {};
			store.walkRange(coord, function(rd, walkSpan, store, internalId) {
				var id = internalId;
				if(!modifieds[id]) {
					modifieds[id] = SCOM.copy(rd.data);
				}
			}, this, undefined, undefined, ignoreRowCol);
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: sm.selection2Span(),
				type: SCONST.RELATIVE_COORD
			}], "");
			var motionCfg = {
				refreshCalCdt: refreshCalCdt,
				concatCoord: concatCoord,
				text: text + " " + str,
				sheet: sheet,
				coord: coord,
				range: range,
				sel: sel,
				focus: focus,
				sheetId: sheetId,
				modifieds: modifieds,
				origins: origins,
				originSheetId: originSheetId,
				originSel: originSel,
				originFocus: originFocus,
				ignoreRowCol: ignoreRowCol,
				suspendPull: suspendPull,
				expand2Around: "borderchange" === eventName || "conditionchange" === eventName
			};
			if("rangechange" == eventName || "paste" == eventName || "autofill" == eventName || "rangemove" == eventName || "cleanrange" == eventName || "conditionchange" == eventName || "stylebrush" == eventName) {
				var modifiedProperty, deletedProperty;
				if("rangechange" == eventName) {
					modifiedProperty = arguments[1];
					deletedProperty = arguments[2];
				}
				Ext.apply(motionCfg, {
					undo: function(suspendRefresh, suspendRefreshSelection) {
						var oldSuspendAddActionFlag = store.suspendAddActionFlag;
						if(suspendPull) {
							store.suspendAddActionFlag = true;
						}
						if(originCdts) {
							for(var p in originCdts) {
								if(originCdts.hasOwnProperty(p)) {
									var it = originCdts[p];
									store.setFloatingItem(it.sheet, p, "cdt", it.json);
								}
							}
						}
						this.defaultUndo.apply(this, arguments);
						if(changedHeights) {
							var preAutoHeights = changedHeights.oldHeights;
							me.recoverAutoHeight(preAutoHeights, suspendRefresh);
						}
						if(suspendPull) {
							store.suspendAddActionFlag = oldSuspendAddActionFlag;
						}
					},
					redo: function(suspendRefresh, suspendRefreshSelection) {
						var oldSuspendAddActionFlag = store.suspendAddActionFlag;
						if(suspendPull) {
							store.suspendAddActionFlag = true;
						}
						if(originCdts) {
							for(var p in originCdts) {
								if(changedCdts.hasOwnProperty(p)) {
									var it = changedCdts[p];
									if(it) {
										store.setFloatingItem(it.sheet, p, "cdt", it.json);
									} else {
										var it = originCdts[p];
										store.setFloatingItem(it.sheet, p, "cdt");
									}
								} else {
									var it = originCdts[p];
									store.setFloatingItem(it.sheet, p, "cdt");
								}
							}
						}
						this.defaultRedo.apply(this, arguments);
						if(changedHeights) {
							var posAutoHeights = changedHeights.newHeights;
							me.recoverAutoHeight(posAutoHeights, suspendRefresh);
						}
						if(suspendPull) {
							store.suspendAddActionFlag = oldSuspendAddActionFlag;
						}
					}
				});
			} else if("createfilter" == eventName) {
				var len = arguments.length;
				var showns = arguments[len - 3],
					hiddens = arguments[len - 2];
				var showPairs = SCOM.transferArr2Pairs(showns),
					hidePairs = SCOM.transferArr2Pairs(hiddens);
				Ext.apply(motionCfg, {
					undo: function(suspendRefresh, suspendRefreshSelection) {
						var flag = false;
						for(var i = 0, len = showPairs.length; i < len; i++) {
							var it = showPairs[i];
							store.hideRow(sheetId, it[0], it[1], true, suspendPull);
							flag = true;
						}
						for(var i = 0, len = hidePairs.length; i < len; i++) {
							var it = hidePairs[i];
							store.showRow(sheetId, it[0], it[1], true, suspendPull);
							flag = true;
						}
						this.defaultUndo.apply(this, [true, suspendRefreshSelection]);
						if(!suspendRefresh) {
							if(flag) {
								sheet.refreshRange();
							} else {
								sheet.refreshRange(coord);
							}
						}
					},
					redo: function(suspendRefresh, suspendRefreshSelection) {
						var flag = false;
						for(var i = 0, len = showPairs.length; i < len; i++) {
							var it = showPairs[i];
							store.showRow(sheetId, it[0], it[1], true, suspendPull);
							flag = true;
						}
						for(var i = 0, len = hidePairs.length; i < len; i++) {
							var it = hidePairs[i];
							store.hideRow(sheetId, it[0], it[1], true, suspendPull);
							flag = true;
						}
						this.defaultRedo.apply(this, [true, suspendRefreshSelection]);
						if(!suspendRefresh) {
							if(flag) {
								sheet.refreshRange();
							} else {
								sheet.refreshRange(coord);
							}
						}
					}
				});
			}
			var motion = new EnterpriseSheet.sheet.history.Motion(motionCfg);
			this.add(motion);
		};
		sheet.on(eventName, fn, this, {
			single: true
		});
	},
	prepareautoextendcdt: function(sheetId, row, col, changedCdts, sheet, reCalCells) {
		var me = this;
		var store = sheet.getStore();
		var origin = store.getCell(sheetId, row, col, true);
		var originCdts;
		if(changedCdts) {
			originCdts = {};
			for(var p in changedCdts) {
				if(changedCdts.hasOwnProperty(p)) {
					var it = changedCdts[p];
					originCdts[p] = store.getFloatingById(p, sheetId);
				}
			}
		}
		var fn = function(sheetId, row, col, modified, deleted) {
			me.onAutoExtendCdt(null, sheetId, row, col, modified, deleted, origin, originCdts, changedCdts, reCalCells);
		};
		sheet.on("autoextendcdt", fn, this, {
			single: true
		});
	},
	onAutoExtendCdt: function(timestamp, sheetId, row, col, modified, deleted, origin, originCdts, changedCdts, reCalCells) {
		var me = this;
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord([focus.row, focus.col]),
			type: SCONST.RELATIVE_COORD
		}], "");
		var inputStr = SCOM.removeHTMLTag(modified.data);
		inputStr = Ext.String.ellipsis(inputStr, 10);
		var coord = [
			[sheetId, row, col, row, col]
		];
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.input + " \"" + inputStr + "\" " + SLANG.at + " " + str,
			refreshCalCdt: true,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				if(originCdts) {
					for(var p in originCdts) {
						if(originCdts.hasOwnProperty(p)) {
							var it = originCdts[p];
							store.setFloatingItem(sheetId, p, "cdt", it.json);
						}
					}
				}
				me.mun(sheet, "datachange", me.onDataChange, me);
				var m = {},
					d = [];
				for(var p in modified) {
					if(origin && false != SCOM.typeOf(origin[p])) {
						m[p] = origin[p];
					} else {
						d.push(p);
					}
				}
				if(origin && deleted) {
					for(var i = 0, len = deleted.length; i < len; i++) {
						var p = deleted[i];
						if(false != SCOM.typeOf(origin[p])) {
							m[p] = origin[p];
						}
					}
				}
				sheet.setCell(sheetId, row, col, m, d, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					} else {
						sheet.refreshRange(coord, reCalCells);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
				me.mon(sheet, "datachange", me.onDataChange, me);
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				if(changedCdts) {
					for(var p in changedCdts) {
						if(changedCdts.hasOwnProperty(p)) {
							var it = changedCdts[p];
							store.setFloatingItem(sheetId, p, "cdt", Ext.encode(it));
						}
					}
				}
				me.mun(sheet, "datachange", me.onDataChange, me);
				sheet.setCell(sheetId, row, col, modified, deleted, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					} else {
						sheet.refreshRange(coord, reCalCells);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				me.mon(sheet, "datachange", me.onDataChange, me);
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onArrayFormulaChange: function(span) {
		var coordPro = EnterpriseSheet.sheet.calculate.Coordinate.prototype;
		var me = this,
			sheet = me.sheet,
			store = sheet.getStore();
		me.mun(sheet, "datachange", me.onDataChange, me);
		var oldCells = {},
			curCells = {};
		var reCalCells = coordPro.transferCoord2CellLookup([span]);
		Ext.apply(reCalCells, sheet.findDirectRecalculateCellsForCells(reCalCells));
		store.walkRange([span], function(rec, walkSpan, store, internalId) {
			oldCells[internalId] = Ext.apply({}, rec.data.json);
		}, me);
		sheet.on("completeedit", function(sheetId, row, col, editor, asArrayFormula) {
			store.walkRange([span], function(rec, walkSpan, store, internalId) {
				curCells[internalId] = Ext.apply({}, rec.data.json);
			}, me);
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.input_array_formula,
				undo: function(suspendRefresh, suspendRefreshSelection) {
					me.mun(sheet, "datachange", me.onDataChange, me);
					store.walkRange([span], function(rec, walkSpan, store, internalId) {
						store.setCell(rec.data.sheet, rec.data.row, rec.data.col, oldCells[internalId], undefined, true, "clear");
					}, me);
					sheet.refreshCalCdt(reCalCells);
					me.mon(sheet, "datachange", me.onDataChange, me);
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					me.mun(sheet, "datachange", me.onDataChange, me);
					store.walkRange([span], function(rec, walkSpan, store, internalId) {
						store.setCell(rec.data.sheet, rec.data.row, rec.data.col, curCells[internalId], undefined, true, "clear");
					}, me);
					sheet.refreshCalCdt(reCalCells);
					me.mon(sheet, "datachange", me.onDataChange, me);
				}
			});
			this.add(motion);
			me.mon(sheet, "datachange", me.onDataChange, me);
			sheet.fireEvent("changing", sheet);
		}, this, {
			single: true
		});
	},
	onDataChange: function(timestamp, sheetId, row, col, modified, deleted, origin, rd, store, suspendRefresh, reCalCells) {
		origin = Ext.apply({}, origin);
		var me = this;
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord([focus.row, focus.col]),
			type: SCONST.RELATIVE_COORD
		}], "");
		var text;
		if(modified) {
			if(modified.data) {
				var inputStr = SCOM.removeHTMLTag(modified.data);
				inputStr = Ext.String.ellipsis(inputStr, 10);
				text = SLANG.input + " \"" + inputStr + "\" " + SLANG.at + " " + str;
			} else {
				text = SLANG.change_checked + " " + SLANG.at + " " + str;
			}
		}
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			refreshCalCdt: reCalCells,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.mun(sheet, "datachange", me.onDataChange, me);
				var m = {},
					d = ["value"];
				for(var p in modified) {
					if(origin && false != SCOM.typeOf(origin[p])) {
						m[p] = origin[p];
					} else {
						d.push(p);
					}
				}
				if(origin && deleted) {
					for(var i = 0, len = deleted.length; i < len; i++) {
						var p = deleted[i];
						if(false != SCOM.typeOf(origin[p])) {
							m[p] = origin[p];
						}
					}
				}
				sheet.setCell(sheetId, row, col, m, d, suspendRefresh);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
				me.mon(sheet, "datachange", me.onDataChange, me);
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.mun(sheet, "datachange", me.onDataChange, me);
				deleted = deleted || [];
				deleted.push("value");
				sheet.setCell(sheetId, row, col, modified, deleted, suspendRefresh);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				me.mon(sheet, "datachange", me.onDataChange, me);
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onTplSummaryChange: function(timestamp, sheetId, row, col, modified, deleted, origin, rd, store, flag, reCalCells) {
		var me = this;
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var originSel = sm.getSelection(),
			originFocus = sm.getFocusCell();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
			span: EnterpriseSheet.sheet.calculate.Coordinate.prototype.normalizeCoord([focus.row, focus.col]),
			type: SCONST.RELATIVE_COORD
		}], "");
		var coord = [
			[sheet, row, col, row, col]
		];
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.change_tpl_summary + " " + SLANG.at + " " + str,
			refreshCalCdt: reCalCells,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.mun(sheet, "datachange", me.onDataChange, me);
				var m = {},
					d = [];
				for(var p in modified) {
					if(origin && false != SCOM.typeOf(origin[p])) {
						m[p] = origin[p];
					} else {
						d.push(p);
					}
				}
				if(origin && deleted) {
					for(var i = 0, len = deleted.length; i < len; i++) {
						var p = deleted[i];
						if(false != SCOM.typeOf(origin[p])) {
							m[p] = origin[p];
						}
					}
				}
				sheet.setCell(sheetId, row, col, m, d, suspendRefresh);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					} else {
						sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(originSel.startPos, originSel.endPos);
					sheet.refreshFocus(originFocus.row, originFocus.col);
				}
				me.mon(sheet, "datachange", me.onDataChange, me);
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.mun(sheet, "datachange", me.onDataChange, me);
				sheet.setCell(sheetId, row, col, modified, deleted, suspendRefresh);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId, function() {
							sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
						});
					} else {
						sheet.refreshCalCdt(reCalCells, undefined, undefined, coord);
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
				me.mon(sheet, "datachange", me.onDataChange, me);
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	cacheCalCdt: function(coord) {
		var calCdtCache = {};
		var sheet = this.sheet,
			store = sheet.getStore();
		store.walkRange(coord, function(rd, walkSpan, store, internalId) {
			var row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			if(json.cal || sheet.isConditionCell(json, rd.data.sheet, row, col)) {
				calCdtCache[internalId] = SCOM.copy(rd.data);
			}
		}, this);
		return calCdtCache;
	},
	recoverCal: function(calCache) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			flag;
		for(var p in calCache) {
			if(calCache.hasOwnProperty(p)) {
				var it = calCache[p];
				var sheetId = it.sheet,
					row = it.row,
					col = it.col;
				if(Ext.isDefined(row)) {
					store.setCell(sheetId, row, col, SCOM.copy(it.json), null, true);
				} else if("named_func" === it.ctype) {
					store.setNamedFuncConfig(p, Ext.apply({}, it), undefined, true);
					flag = true;
				}
			}
		}
		if(flag) {
			store.checkReferenceString();
		}
	},
	recoverCell: function(cellCache) {
		var sheet = this.sheet,
			store = sheet.getStore();
		for(var p in cellCache) {
			if(cellCache.hasOwnProperty(p)) {
				var it = cellCache[p];
				var sheetId = it.sheet,
					row = it.row,
					col = it.col;
				store.setCell(sheetId, row, col, it.json, null, true, "clear");
			}
		}
	},
	recoverCdt: function(cdtCache) {
		var sheet = this.sheet,
			store = sheet.getStore();
		for(var p in cdtCache) {
			if(cdtCache.hasOwnProperty(p)) {
				var it = cdtCache[p];
				store.setFloatingItem(it.sheet, it.name, it.ftype, it.json);
			}
		}
	},
	recoverFreeze: function(freezePos, rangeInfo) {
		var sheet = this.sheet;
		var curFreezePos = sheet.freezePos;
		if(!curFreezePos && !freezePos) {
			return;
		}
		if(curFreezePos && freezePos && curFreezePos.row == freezePos.row && curFreezePos.col == freezePos.col) {
			return;
		}
		var obj = {
			freezePos: freezePos,
			rangeInfo: rangeInfo
		};
		sheet.setSheetConfig(obj);
	},
	recoverMerged: function(merged) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		for(var p in merged) {
			if(merged.hasOwnProperty(p)) {
				var item = merged[p];
				var mergedMinRow = item.minrow,
					mergedMinCol = item.mincol,
					mergedMaxRow = item.maxrow,
					mergedMaxCol = item.maxcol;
				for(var i = mergedMinRow; i <= mergedMaxRow; i++) {
					for(var j = mergedMinCol; j <= mergedMaxCol; j++) {
						if(mergedMinRow == mergedMaxRow && mergedMinCol == mergedMaxCol) {
							store.setCell(sheetId, i, j, null, ["minrow", "mincol", "maxrow", "maxcol", "abminrow", "abmincol", "abmaxrow", "abmaxcol"], true);
						} else {
							store.setCell(sheetId, i, j, {
								minrow: mergedMinRow - i,
								mincol: mergedMinCol - j,
								maxrow: mergedMaxRow - i,
								maxcol: mergedMaxCol - j
							}, null, true);
						}
					}
				}
			}
		}
	},
	prepareRemoveRow: function() {
		var sheet = this.sheet,
			store = sheet.getStore();
		var preRowGroups, posRowGroups, posMerged, me = this;
		if(sheet.rowGroups) {
			preRowGroups = SCOM.copy(sheet.rowGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange;
		if(sheet.freezePos) {
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on("holdremoverow", function(sheetId, minrow, maxrow, deleted, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, changedPbs) {
			var rangeStoreRef = sheet.rangeStoreRef;
			var sheet = this.sheet,
				sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: ["", minrow, 0, maxrow, 0],
				type: SCONST.RELATIVE_COORD
			}], "");
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.remove + " " + SLANG.row + " " + str,
				refreshCalCdt: true,
				conflictAction: "removeRow",
				undo: function(suspendRefresh, suspendRefreshSelection) {
					me.recoverCell(preCells);
					var rowSpan = maxrow - minrow + 1;
					store.insertRow(sheetId, minrow, rowSpan, true);
					sheet.layoutRowGroups(preRowGroups);
					for(var i = 0, dlen = deleted.length; i < dlen; i++) {
						var d = deleted[i].data;
						store.setCell(d.sheet, d.row, d.col, d.json, null, true);
					}
					me.recoverMerged(merged);
					me.recoverCal(preCal);
					me.recoverCdt(preCdt);
					me.recoverFreeze(preFreezePos, preRange);
					sheet.updatePageBreaks(changedPbs, true);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(preReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, preReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent("undoremoverow", sheetId, minrow, maxrow, deleted, merged, this);
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.removeRow(sheetId, minrow, maxrow, true);
					sheet.layoutRowGroups(posRowGroups);
					me.recoverMerged(posMerged);
					me.recoverCal(posCal);
					me.recoverCdt(posCdt);
					me.recoverCell(posCells);
					me.recoverFreeze(posFreezePos, posRange);
					sheet.updatePageBreaks(changedPbs);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(posReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, posReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent("redoremoverow", sheetId, minrow, maxrow, posMerged, this);
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
		store.on("rowremoved", function(sheet, minrow, maxrow, affected, deleted, changedMerged, store) {
			if(sheet.rowGroups) {
				posRowGroups = SCOM.copy(sheet.rowGroups);
			}
			if(sheet.freezePos) {
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
			posMerged = changedMerged;
		}, this, {
			single: true
		});
		sheet.fireEvent("changing", sheet);
	},
	prepareRemoveColumn: function() {
		var sheet = this.sheet,
			store = sheet.getStore();
		var preColGroups, posColGroups, posMerged, me = this;
		if(sheet.colGroups) {
			preColGroups = SCOM.copy(sheet.colGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange, preAutoHeights, posAutoHeights;
		if(sheet.freezePos) {
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on("holdremovecolumn", function(sheetId, mincol, maxcol, deleted, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, changedPbs) {
			var rangeStoreRef = sheet.rangeStoreRef;
			var sheet = this.sheet,
				sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: ["", 0, mincol, 0, maxcol],
				type: SCONST.RELATIVE_COORD
			}], "");
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.remove + " " + SLANG.column + " " + str,
				refreshCalCdt: true,
				conflictAction: "removeColumn",
				undo: function(suspendRefresh, suspendRefreshSelection) {
					me.recoverCell(preCells);
					var colSpan = maxcol - mincol + 1;
					store.insertColumn(sheetId, mincol, colSpan, true);
					sheet.layoutColumnGroups(preColGroups);
					for(var i = 0, dlen = deleted.length; i < dlen; i++) {
						var d = deleted[i].data;
						store.setCell(d.sheet, d.row, d.col, d.json, null, true);
					}
					me.recoverMerged(merged);
					me.recoverCal(preCal);
					me.recoverCdt(preCdt);
					me.recoverFreeze(preFreezePos, preRange);
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					sheet.updatePageBreaks(changedPbs, true);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(preReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, preReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.removeColumn(sheetId, mincol, maxcol, true);
					sheet.layoutColumnGroups(posColGroups);
					me.recoverMerged(posMerged);
					me.recoverCal(posCal);
					me.recoverCdt(posCdt);
					me.recoverCell(posCells);
					me.recoverFreeze(posFreezePos, posRange);
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					sheet.updatePageBreaks(changedPbs);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(posReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, posReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
		sheet.on("columnremoved", function(sheetId, mincol, maxcol, changedHeights) {
			if(sheet.colGroups) {
				posColGroups = SCOM.copy(sheet.colGroups);
			}
			if(sheet.freezePos) {
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
			preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {
			single: true
		});
		store.on("columnremoved", function(sheet, mincol, maxcol, affected, deleted, changedMerged, store) {
			posMerged = changedMerged;
		}, this, {
			single: true
		});
		sheet.fireEvent("changing", sheet);
	},
	prepareRemoveCell: function() {
		var sheet = this.sheet,
			store = sheet.getStore();
		var me = this;
		var preAutoHeights, posAutoHeights;
		sheet.rangeStoreRef = {};
		sheet.on("holdremovecell", function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells) {
			var rangeStoreRef = sheet.rangeStoreRef;
			var sheet = this.sheet,
				sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: ["", minrow, mincol, maxrow, maxcol],
				type: SCONST.RELATIVE_COORD
			}], "");
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.remove + " " + SLANG.cell + " " + str,
				refreshCalCdt: true,
				conflictAction: "removeCell",
				undo: function(suspendRefresh, suspendRefreshSelection) {
					me.recoverCell(preCells);
					var rowSpan = maxrow - minrow + 1,
						colSpan = maxcol - mincol + 1;
					var insertDir = "up" == moveDir ? "down" : "right";
					store.insertCell(sheetId, minrow, mincol, rowSpan, colSpan, insertDir, true);
					for(var i = 0, dlen = deleted.length; i < dlen; i++) {
						var d = deleted[i].data;
						store.setCell(d.sheet, d.row, d.col, d.json, null, true);
					}
					me.recoverCal(preCal);
					me.recoverCdt(preCdt);
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						} else {
							sheet.refreshRange(null, preReCalCells);
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.removeCell(sheetId, minrow, maxrow, mincol, maxcol, moveDir, true, true);
					me.recoverCal(posCal);
					me.recoverCdt(posCdt);
					me.recoverCell(posCells);
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						} else {
							sheet.refreshRange(null, posReCalCells);
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
		sheet.on("cellremoved", function(sheetId, minrow, mincol, maxrow, maxcol, moveDir, changedHeights) {
			preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {
			single: true
		});
		sheet.fireEvent("changing", sheet);
	},
	prepareInsertRow: function() {
		var sheet = this.sheet,
			store = sheet.getStore();
		var preRowGroups, posRowGroups, posMerged, me = this;
		if(sheet.rowGroups) {
			preRowGroups = SCOM.copy(sheet.rowGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange;
		if(sheet.freezePos) {
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on("holdinsertrow", function(sheetId, row, rowSpan, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, insertCellCache, changedPbs) {
			var rangeStoreRef = sheet.rangeStoreRef;
			var maxrow = row + rowSpan - 1;
			var sheet = this.sheet,
				sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.insert_row_at + " " + row,
				refreshCalCdt: true,
				conflictAction: "insertRow",
				undo: function(suspendRefresh, suspendRefreshSelection) {
					me.recoverCell(preCells);
					store.removeRow(sheetId, row, maxrow, true);
					sheet.layoutRowGroups(preRowGroups);
					me.recoverMerged(merged);
					me.recoverCal(preCal);
					me.recoverCdt(preCdt);
					me.recoverFreeze(preFreezePos, preRange);
					sheet.updatePageBreaks(changedPbs, true);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(preReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, preReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent("undoinsertrow", sheetId, row, rowSpan, this);
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.insertRow(sheetId, row, rowSpan, true, insertCellCache);
					sheet.layoutRowGroups(posRowGroups);
					me.recoverMerged(posMerged);
					me.recoverCal(posCal);
					me.recoverCdt(posCdt);
					me.recoverCell(posCells);
					me.recoverFreeze(posFreezePos, posRange);
					sheet.updatePageBreaks(changedPbs);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(posReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, posReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
					sheet.fireEvent("redoinsertrow", sheetId, row, rowSpan, this);
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
		store.on("rowinserted", function(sheetId, row, rowSpan) {
			if(sheet.rowGroups) {
				posRowGroups = SCOM.copy(sheet.rowGroups);
			}
			if(sheet.freezePos) {
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
			posMerged = store.checkMergedCellChange(sheetId, {
				min: row,
				max: row
			}, null, "row", true, "insert");
		}, this, {
			single: true
		});
		sheet.fireEvent("changing", sheet);
	},
	prepareInsertColumn: function() {
		var sheet = this.sheet,
			store = sheet.getStore();
		var preColGroups, posColGroups, posMerged, me = this;
		if(sheet.colGroups) {
			preColGroups = SCOM.copy(sheet.colGroups);
		}
		var preFreezePos, posFreezePos, preRange, posRange;
		if(sheet.freezePos) {
			preFreezePos = SCOM.copy(sheet.freezePos);
			preRange = sheet.getRangeInfo();
		}
		sheet.rangeStoreRef = {};
		sheet.on("holdinsertcolumn", function(sheetId, col, colSpan, merged, e, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, insertCellCache, changedPbs) {
			var rangeStoreRef = sheet.rangeStoreRef;
			var maxcol = col + colSpan - 1;
			var sheet = this.sheet,
				sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: ["", 0, col, 0, col],
				type: SCONST.RELATIVE_COORD
			}], "");
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.insert_column_at + " " + str,
				refreshCalCdt: true,
				conflictAction: "insertColumn",
				undo: function(suspendRefresh, suspendRefreshSelection) {
					me.recoverCell(preCells);
					store.removeColumn(sheetId, col, maxcol, true);
					sheet.layoutColumnGroups(preColGroups);
					me.recoverMerged(merged);
					me.recoverCal(preCal);
					me.recoverCdt(preCdt);
					me.recoverFreeze(preFreezePos, preRange);
					sheet.updatePageBreaks(changedPbs, true);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(preReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, preReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.insertColumn(sheetId, col, colSpan, true, insertCellCache);
					sheet.layoutColumnGroups(posColGroups);
					me.recoverMerged(posMerged);
					me.recoverCal(posCal);
					me.recoverCdt(posCdt);
					me.recoverCell(posCells);
					me.recoverFreeze(posFreezePos, posRange);
					sheet.updatePageBreaks(changedPbs);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(posReCalCells);
								sheet.syncPageBreak();
							}, this);
						} else {
							sheet.refreshRange(null, posReCalCells);
							sheet.syncPageBreak();
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
		store.on("columninserted", function(sheetId, col, colSpan) {
			if(sheet.colGroups) {
				posColGroups = SCOM.copy(sheet.colGroups);
			}
			if(sheet.freezePos) {
				posFreezePos = SCOM.copy(sheet.freezePos);
				posRange = sheet.getRangeInfo();
			}
			posMerged = store.checkMergedCellChange(sheetId, null, {
				min: col,
				max: col
			}, "col", true, "insert");
		}, this, {
			single: true
		});
		sheet.fireEvent("changing", sheet);
	},
	prepareInsertCell: function() {
		var sheet = this.sheet,
			store = sheet.getStore();
		var me = this;
		var preAutoHeights, posAutoHeights;
		sheet.rangeStoreRef = {};
		sheet.on("holdinsertcell", function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, evt, sheet, preCal, posCal, preCdt, posCdt, preCells, posCells, preReCalCells, posReCalCells, insertCellCache) {
			var rangeStoreRef = sheet.rangeStoreRef;
			var maxrow = row + rowSpan - 1,
				maxcol = col + colSpan - 1;
			var sheet = this.sheet,
				sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var sel = sm.getSelection(),
				focus = sm.getFocusCell();
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: ["", row, col, row, col],
				type: SCONST.RELATIVE_COORD
			}], "");
			var motion = new EnterpriseSheet.sheet.history.Motion({
				text: SLANG.insert_cell_at + " " + str,
				refreshCalCdt: true,
				conflictAction: "insertCell",
				undo: function(suspendRefresh, suspendRefreshSelection) {
					me.recoverCell(preCells);
					var deleteDir = "right" == moveDir ? "left" : "up";
					store.removeCell(sheetId, row, maxrow, col, maxcol, deleteDir, true);
					me.recoverCal(preCal);
					me.recoverCdt(preCdt);
					me.recoverAutoHeight(preAutoHeights, suspendRefresh);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.oldConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(preReCalCells);
							}, this);
						} else {
							sheet.refreshRange(null, preReCalCells);
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				},
				redo: function(suspendRefresh, suspendRefreshSelection) {
					store.insertCell(sheetId, row, col, rowSpan, colSpan, moveDir, true, insertCellCache);
					me.recoverCal(posCal);
					me.recoverCdt(posCdt);
					me.recoverCell(posCells);
					me.recoverAutoHeight(posAutoHeights, suspendRefresh);
					for(var p in rangeStoreRef) {
						if(rangeStoreRef.hasOwnProperty(p)) {
							var it = rangeStoreRef[p];
							it.rangeStore.resetRangeConfig(it.newConfig);
						}
					}
					if(!suspendRefresh) {
						if(sheet.getSheetId() != sheetId) {
							sheet.go2Sheet(sheetId, function() {
								sheet.refreshCalCdt(posReCalCells);
							}, this);
						} else {
							sheet.refreshRange(null, posReCalCells);
						}
					}
					if(!suspendRefreshSelection) {
						sm.selectRange(sel.startPos, sel.endPos);
						sheet.refreshFocus(focus.row, focus.col);
					}
				}
			});
			this.add(motion);
		}, this, {
			single: true
		});
		sheet.on("cellinserted", function(sheetId, minrow, mincol, rowSpan, colSpan, moveDir, changedHeights) {
			preAutoHeights = changedHeights.oldHeights;
			posAutoHeights = changedHeights.newHeights;
		}, this, {
			single: true
		});
		sheet.fireEvent("changing", sheet);
	},
	add: function(motion) {
		if(this.disabled) {
			return;
		}
		this.forward();
		this.stack.splice(this.cursor);
		this.stack.push(motion);
		if(this.maxStackLength < this.stack.length) {
			this.stack.splice(0, this.stack.length - this.maxStackLength);
		}
		this.setCursor(this.stack.length - 1);
		this.fireEvent("add", motion, this);
	},
	undo: function(index, suspendRefresh, suspendEvent) {
		var rm = this.sheet.getReferenceModel();
		rm.hide();
		if(index) {
			var refreshCalCdt = false,
				motion, needRecheckRows = {};
			for(var i = 0; i < index; i++) {
				motion = this.stack[this.cursor];
				if(true !== refreshCalCdt) {
					if(true === motion.refreshCalCdt) {
						refreshCalCdt = true;
					} else if(Ext.isObject(motion.refreshCalCdt)) {
						refreshCalCdt = refreshCalCdt || {};
						Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
					}
				}
				var res = motion.undo(true, true);
				this.backward();
			}
			motion = this.stack[this.cursor];
			if(true === motion.refreshCalCdt) {
				refreshCalCdt = true;
			} else if(Ext.isObject(motion.refreshCalCdt)) {
				refreshCalCdt = refreshCalCdt || {};
				Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
			}
			var res = motion.undo(true);
			this.backward();
			if(!suspendRefresh) {
				this.sheet.refreshRange(null, refreshCalCdt);
			}
			if(!suspendEvent) {
				this.sheet.fireEvent("changing", this.sheet);
			}
		} else if(0 <= this.cursor) {
			this.stack[this.cursor].undo(suspendRefresh);
			this.backward();
			if(!suspendEvent) {
				this.sheet.fireEvent("changing", this.sheet);
			}
		}
	},
	redo: function(index, suspendRefresh, suspendEvent) {
		var rm = this.sheet.getReferenceModel();
		rm.hide();
		if(index) {
			var refreshCalCdt = false,
				motion, needRecheckRows = {};
			for(var i = 0; i < index; i++) {
				this.forward();
				motion = this.stack[this.cursor];
				if(true !== refreshCalCdt) {
					if(true === motion.refreshCalCdt) {
						refreshCalCdt = true;
					} else if(Ext.isObject(motion.refreshCalCdt)) {
						refreshCalCdt = refreshCalCdt || {};
						Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
					}
				}
				var res = motion.redo(true, true);
			}
			this.forward();
			motion = this.stack[this.cursor];
			if(true === motion.refreshCalCdt) {
				refreshCalCdt = true;
			} else if(Ext.isObject(motion.refreshCalCdt)) {
				refreshCalCdt = refreshCalCdt || {};
				Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
			}
			var res = motion.redo(true);
			if(!suspendRefresh) {
				this.sheet.refreshRange(null, refreshCalCdt);
			}
			if(!suspendEvent) {
				this.sheet.fireEvent("changing", this.sheet);
			}
		} else if(this.stack.length - 1 > this.cursor) {
			this.forward();
			this.stack[this.cursor].redo(suspendRefresh);
			if(!suspendEvent) {
				this.sheet.fireEvent("changing", this.sheet);
			}
		}
	},
	getStack: function() {
		return this.stack;
	},
	getMotion: function(index) {
		return this.stack[index];
	},
	getCount: function() {
		return this.stack.length;
	},
	setCursor: function(cursor) {
		var old = this.cursor;
		this.cursor = cursor;
		this.fireEvent("movecursor", this.cursor, old, this.stack.length, this);
	},
	moveCursor: function(offset) {
		var old = this.cursor;
		this.cursor += offset;
		this.fireEvent("movecursor", this.cursor, old, this.stack.length, this);
	},
	forward: function() {
		this.moveCursor(1);
	},
	backward: function() {
		this.moveCursor(-1);
	},
	onCreateChart: function(chartType, chart, rangeStore) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var info, chartId = chart.getId(),
			chartName = chart.getName();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.create_chart,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var chartFloor = sheet.getFloorById(chartId);
				info = chartFloor.getPositionSize();
				chartFloor.destroy(false, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				info.floorId = chartName;
				sheet.createChart(chartType, rangeStore, info, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onDeleteChart: function(chartType, chart, rangeStore, info) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var chartId = chart.getId(),
			chartName = chart.getName();
		info = info || {};
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.delete_chart,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				info.floorId = chartName;
				sheet.createChart(chartType, rangeStore, info, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var chartFloor = sheet.getFloorById(chartId);
				info = chartFloor.getPositionSize();
				chartFloor.destroy(false, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onCreatePicture: function(url, floor) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var info, floorId = floor.getId(),
			floorName = floor.getName();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.create_picture,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var floor = sheet.getFloorById(floorId);
				info = floor.getPositionSize();
				floor.destroy(false, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				info.floorId = floorName;
				sheet.createPicture(url, info, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onDeletePicture: function(url, floor, info) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var floorId = floor.getId(),
			floorName = floor.getName();
		info = info || {};
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.delete_picture,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				info.floorId = floorName;
				sheet.createPicture(url, info, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var floor = sheet.getFloorById(floorId);
				info = floor.getPositionSize();
				floor.destroy(false, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onCreateWedgit: function(url, floor) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var info, floorId = floor.getId(),
			floorName = floor.getName();
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.create_wedgit,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				var floor = sheet.getFloorById(floorId);
				info = floor.getPositionSize();
				floor.destroy(false, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				info.floorId = floorName;
				sheet.createWedgit(url, info, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	onDeleteWedgit: function(url, floor, info) {
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var sel = sm.getSelection(),
			focus = sm.getFocusCell();
		var floorId = floor.getId(),
			floorName = floor.getName();
		info = info || {};
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: SLANG.delete_wedgit,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				info.floorId = floorName;
				sheet.createWedgit(url, info, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				var floor = sheet.getFloorById(floorId);
				info = floor.getPositionSize();
				floor.destroy(false, true);
				if(!suspendRefresh) {
					if(sheet.getSheetId() != sheetId) {
						sheet.go2Sheet(sheetId);
					} else {
						sheet.refreshRange();
					}
				}
				if(!suspendRefreshSelection) {
					sm.selectRange(sel.startPos, sel.endPos);
					sheet.refreshFocus(focus.row, focus.col);
				}
			}
		});
		this.add(motion);
	},
	afterStoreLoad: function() {
		this.clearHistory();
	},
	clearHistory: function() {
		this.stack = [];
		this.cursor = -1;
		this.fireEvent("clearhistory", this);
	},
	prepareMergeMotion: function() {
		this.markPosition = this.cursor + 1;
	},
	mergeMotion: function(motionText, clearValueSpan) {
		if(Ext.isNumber(this.markPosition)) {
			if(1 < this.stack.length - this.markPosition) {
				var arr = this.stack.splice(this.markPosition);
				var len = arr.length;
				this.cursor -= len;
				var sheet = this.sheet;
				var motion = new EnterpriseSheet.sheet.history.Motion({
					text: motionText,
					undo: function(suspendRefresh, suspendRefreshSelection) {
						if(clearValueSpan) {
							sheet.clearValueForCoord([clearValueSpan]);
						}
						var refreshCalCdt = false,
							motion, needRecheckRows = {};
						for(var i = len - 1; 0 < i; i--) {
							var motion = arr[i];
							if(true !== refreshCalCdt) {
								if(true === motion.refreshCalCdt) {
									refreshCalCdt = true;
								} else if(Ext.isObject(motion.refreshCalCdt)) {
									refreshCalCdt = refreshCalCdt || {};
									Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
								}
							}
							motion.undo(true, true);
						}
						motion = arr[0];
						if(true === motion.refreshCalCdt) {
							refreshCalCdt = true;
						} else if(Ext.isObject(motion.refreshCalCdt)) {
							refreshCalCdt = refreshCalCdt || {};
							Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
						}
						var res = motion.undo(true);
						if(!suspendRefresh) {
							sheet.refreshRange(null, refreshCalCdt);
						}
					},
					redo: function(suspendRefresh, suspendRefreshSelection) {
						if(clearValueSpan) {
							sheet.clearValueForCoord([clearValueSpan]);
						}
						var refreshCalCdt = false,
							motion, needRecheckRows = {};
						for(var i = 0; i < len - 1; i++) {
							var motion = arr[i];
							if(true !== refreshCalCdt) {
								if(true === motion.refreshCalCdt) {
									refreshCalCdt = true;
								} else if(Ext.isObject(motion.refreshCalCdt)) {
									refreshCalCdt = refreshCalCdt || {};
									Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
								}
							}
							motion.redo(true, true);
						}
						motion = arr[len - 1];
						if(true === motion.refreshCalCdt) {
							refreshCalCdt = true;
						} else if(Ext.isObject(motion.refreshCalCdt)) {
							refreshCalCdt = refreshCalCdt || {};
							Ext.applyIf(refreshCalCdt, motion.refreshCalCdt);
						}
						var res = motion.redo(true);
						if(!suspendRefresh) {
							sheet.refreshRange(null, refreshCalCdt);
						}
					}
				});
				this.add(motion);
			}
			delete this.markPosition;
		}
	},
	onCreateMotionForSetCell: function(cells) {
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.change_cells;
		var newCells = {};
		for(var p in cells) {
			if(cells.hasOwnProperty(p)) {
				var it = cells[p];
				newCells[p] = {
					pos: it.pos,
					cell: store.getCell(it.pos[0], it.pos[1], it.pos[2], true, p)
				};
			}
		}
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				var activedSheetId = store.getActivedSheetId(),
					refreshFlag = false,
					allCoord = [];
				for(var p in cells) {
					if(cells.hasOwnProperty(p)) {
						var it = cells[p],
							cell = it.cell,
							pos = it.pos;
						var sheetId = pos[0],
							row = pos[1],
							col = pos[2];
						var oldCoord = store.presetTplForCells([
							[sheetId, row, col, row, col]
						], true, true);
						store.setCell(sheetId, row, col, cell, undefined, false, "clear");
						var coord = store.presetTplForCells([
							[sheetId, row, col, row, col]
						], undefined, true);
						if(activedSheetId === sheetId) {
							if(0 === row || 0 === col) {
								refreshFlag = true;
							} else if(!refreshFlag) {
								allCoord = allCoord.concat(oldCoord.concat(coord).concat([sheetId, row, col, row, col]));
							}
						}
					}
				}
				if(refreshFlag) {
					sheet.refreshRange();
				} else {
					sheet.refreshRange(allCoord);
				}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				var activedSheetId = store.getActivedSheetId(),
					refreshFlag = false,
					allCoord = [];
				for(var p in newCells) {
					if(newCells.hasOwnProperty(p)) {
						var it = newCells[p],
							cell = it.cell,
							pos = it.pos;
						var sheetId = pos[0],
							row = pos[1],
							col = pos[2];
						var oldCoord = store.presetTplForCells([
							[sheetId, row, col, row, col]
						], true, true);
						store.setCell(sheetId, row, col, cell, undefined, false, "clear");
						var coord = store.presetTplForCells([
							[sheetId, row, col, row, col]
						], undefined, true);
						if(activedSheetId === sheetId) {
							if(0 === row || 0 === col) {
								refreshFlag = true;
							} else if(!refreshFlag) {
								allCoord = allCoord.concat(oldCoord.concat(coord).concat([sheetId, row, col, row, col]));
							}
						}
					}
				}
				if(refreshFlag) {
					sheet.refreshRange();
				} else {
					sheet.refreshRange(allCoord);
				}
				me.disabled = false;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	disable: function() {
		this.disabled = true;
	},
	enable: function() {
		delete this.disabled;
	},
	onCreateCustomerHistory: function(callback, scope) {
		if(callback) {
			callback.call(scope, this);
		}
	},
	onCreateFileConfig: function(config, store) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.create_defined_func;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				if("named_func" === config.ctype) {
					store.setFileConfig(config.ctype, config.name);
				}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				if("named_func" === config.ctype) {
					store.setFileConfig(config.ctype, config.name, config.json);
				}
				me.disabled = false;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onUpdateFileConfig: function(config, store, oldJson) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.update_defined_func;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				if("named_func" === config.ctype) {
					store.setFileConfig(config.ctype, config.name, oldJson);
				}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				if("named_func" === config.ctype) {
					store.setFileConfig(config.ctype, config.name, config.json);
				}
				me.disabled = false;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onRemoveFileConfig: function(config, store) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.remove_defined_func;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				if("named_func" === config.ctype) {
					store.setFileConfig(config.ctype, config.name, config.json);
				}
				me.disabled = false;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				if("named_func" === config.ctype) {
					store.setFileConfig(config.ctype, config.name);
				}
				me.disabled = false;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onDeletePageBreak: function(sheetId, row, col) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.delete_page_break;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				sheet.insertPageBreak(sheetId, row, col, suspendRefresh, true);
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				sheet.deletePageBreak(sheetId, row, col, suspendRefresh, true);
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onInsertPageBreak: function(sheetId, row, col) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.insert_page_break;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				sheet.deletePageBreak(sheetId, row, col, suspendRefresh, true);
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				sheet.insertPageBreak(sheetId, row, col, suspendRefresh, true);
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onPrepareProcessDynamicRange: function(dynamicRange, insertCache) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.create_dynamic_range;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				store.setFloatingItem(dynamicRange.sheet, dynamicRange.name, dynamicRange.ftype, undefined, true);
				for(var p in insertCache) {
					if(insertCache.hasOwnProperty(p)) {
						var it = insertCache[p];
						var oldJson = it.oldJson;
						if(oldJson) {
							store.setCell(it.sheetId, it.row, it.col, oldJson, undefined, true, "clear");
							sheet.refreshRange([
								[it.sheetId, it.row, it.col, it.row, it.col]
							]);
						}
					}
				}
				delete me.disabled;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				store.setFloatingItem(dynamicRange.sheet, dynamicRange.name, dynamicRange.ftype, dynamicRange.json, true);
				delete me.disabled;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onPrepareInsertDynamicRangeRow: function(pos, drcells, reCals) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.insert_dynamic_range_row;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			refreshCalCdt: reCals,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.oldJson, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onPrepareInsertDynamicRangeCol: function(pos, drcells, reCals) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.insert_dynamic_range_col;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			refreshCalCdt: reCals,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.oldJson, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onPrepareDeleteDynamicRangeRow: function(pos, drcells, reCals) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.delete_dynamic_range_row;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			refreshCalCdt: reCals,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.oldJson, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	},
	onPrepareDeleteDynamicRangeCol: function(pos, drcells, reCals) {
		if(this.disabled) {
			return;
		}
		var me = this,
			sheet = this.sheet,
			store = sheet.getStore();
		var text = SLANG.delete_dynamic_range_col;
		var motion = new EnterpriseSheet.sheet.history.Motion({
			text: text,
			refreshCalCdt: reCals,
			undo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.oldJson, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			},
			redo: function(suspendRefresh, suspendRefreshSelection) {
				me.disabled = true;
				for(var p in drcells) {
					if(drcells.hasOwnProperty(p)) {
						var it = drcells[p];
						store.setCell(it.sheetId, it.row, it.col, it.json, undefined, true, "clear");
					}
				}
				if(!suspendRefresh) {
					sheet.refreshCalCdt(reCals);
				}
				delete me.disabled;
			}
		});
		this.add(motion);
		sheet.fireEvent("changing", sheet);
	}
});

Ext.define("EnterpriseSheet.sheet.history.HistoryList", {
	extend: "Ext.menu.Menu",
	minWidth: 200,
	defaultDisplay: "&nbsp;",
	initComponent: function() {
		this.displayItem = new Ext.toolbar.TextItem({
			text: this.defaultDisplay
		});
		this.items = [{}];
		this.bbar = {
			xtype: "toolbar",
			cls: "ss-sheetlist-bar",
			border: false,
			items: [this.displayItem]
		};
		this.callParent();
		this.on({
			scope: this,
			beforeshow: this._beforeShow
		});
	},
	_beforeShow: function() {
		var history = this.history;
		this.removeAll();
		if("undo" == this.mode) {
			for(var i = 0; i <= history.cursor; i++) {
				var motion = history.getMotion(i);
				this.insert(0, {
					text: motion.text,
					motion: motion,
					handler: this.doMotion,
					scope: this
				});
			}
		} else {
			for(var i = history.cursor + 1, len = history.getCount(); i < len; i++) {
				var motion = history.getMotion(i);
				this.add({
					text: motion.text,
					motion: motion,
					handler: this.doMotion,
					scope: this
				});
			}
		}
	},
	doMotion: function(item) {
		var index = this.items.indexOf(item);
		if("undo" == this.mode) {
			this.history.undo(index);
		} else {
			this.history.redo(index);
		}
	},
	updateDisplay: function() {
		var text = SLANG.cancel;
		if(0 < this.activeCount) {
			text = SLANG.cancel + " " + this.activeCount + " " + SLANG.steps;
		}
		this.displayItem.update(text);
	},
	deactiveAllItems: function() {
		for(var i = 0, len = this.items.getCount(); i < len; i++) {
			var it = this.items.get(i);
			if(it.deactivate) {
				it.deactivate();
			}
		}
		this.activeCount = 0;
		this.updateDisplay();
	},
	onMouseLeave: function(e) {
		this.deactiveAllItems();
		this.callParent(arguments);
	},
	onMouseOver: function(e) {
		this.callParent(arguments);
		var me = this,
			item = me.getItemFromEvent(e);
		var index = this.items.indexOf(item);
		this.activeCount = index + 1;
		this.updateDisplay();
		for(var i = 0; i < index; i++) {
			var it = this.items.get(i);
			if(it.activate) {
				it.activate();
			}
		}
		for(var i = index + 1, len = this.items.getCount(); i < len; i++) {
			var it = this.items.get(i);
			if(it.deactivate) {
				it.deactivate();
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.history.HistoryButton", {
	extend: "Ext.button.Split",
	requires: ["EnterpriseSheet.sheet.history.HistoryList"],
	disabled: true,
	disabledCls: "",
	initComponent: function() {
		this.mode = this.mode || "undo";
		this.menu = new EnterpriseSheet.sheet.history.HistoryList({
			mode: this.mode,
			history: this.history
		});
		this.callParent();
		this.mon(this.history, {
			scope: this,
			movecursor: this.onMoveCursor,
			clearhistory: this.onClearHistory
		});
	},
	handler: function() {
		if("undo" == this.mode) {
			this.history.undo();
		} else {
			this.history.redo();
		}
	},
	onMoveCursor: function(cursor, old, len) {
		if("undo" == this.mode) {
			if(0 <= cursor) {
				this.enable();
			} else {
				this.disable();
			}
		} else {
			if(len - 1 > cursor) {
				this.enable();
			} else {
				this.disable();
			}
		}
	},
	onClearHistory: function() {
		this.disable();
	}
});

Ext.define("EnterpriseSheet.sheet.layout.Table", {
	alias: ["layout.sheettable"],
	extend: "Ext.layout.container.Table",
	getLayoutItems: function() {
		var owner = this.owner,
			items = owner && owner.items;
		return items && items.items || [];
	}
});

Ext.define("EnterpriseSheet.sheet.layout.LayoutTemplates", {
	requires: ["EnterpriseSheet.Config", "EnterpriseSheet.common.Common", "Ext.XTemplate"],
	singleton: true,
	opacity: 0.85,
	constructor: function() {
		Ext.util.Format._istrue = function(v) {
			return undefined !== v && null !== v && "" !== v;
		};
		var isVerticalAlign = function(va) {
			return "middle" == va || "bottom" == va;
		};
		Ext.util.Format._isVerticalAlign = isVerticalAlign;
		var cell = ["<div data-cid=\"{ri}${ci}\" data-ri=\"{ri}\" data-ci=\"{ci}\" class=\"ss-cfloat ", "<tpl if=\"true===values.wrap\">", "ss-cwrap \" style=\"width:{width};height:{height};", "padding-right:{wpr}px;padding-bottom:{wpb}px;{[fm._istrue(values.zd)?\"z-index:\"+values.zd+\";\":\"\"]}\" >", "<div class=\"", "</tpl>", "ss-cell {css} {[values.dsd?\"ss-cell-disabled\":\"\"]}\" ", "style=\"width:{width};height:{height};{[fm._istrue(values.fz)?\"font-size:\"+values.fz+\"pt;\":\"\"]};{[values.body?\"\":\"line-height:\"+values.height+\";\"]}{[values.incell?\"overflow:hidden;\":\"", SCONFIG.hideOverflowInCell ? "overflow:hidden;" : "", "\"]}", "<tpl if=\"true===values.body\">", "{[fm._istrue(values.pl)?\"padding-left:\"+values.pl+\"px;\":\"\"]}{[fm._istrue(values.pr)?\"padding-right:\"+values.pr+\"px;\":\"\"]}", "{[fm._istrue(values.pt)?\"padding-top:\"+values.pt+\"px;\":\"\"]}{[fm._istrue(values.pb)?\"padding-bottom:\"+values.pb+\"px;\":\"\"]}", "{[values.ws?\"white-space:\"+values.ws+\";\":\"\"]}{[values.ww?\"word-wrap:\"+values.ww+\";\":\"\"]}", "{[!values.incell&&values.bg?\"background-image:\"+values.bg+\";background-repeat:repeat;\":\"\"]}{[values.bgc?\"background-color:\"+values.bgc+\";\":\"\"]}", "{[values.ta?\"text-align:\"+values.ta+\";\":\"\"]}", "{[values.ti?\"text-indent:\"+values.ti+\"px;\":\"\"]}{[values.color?\"color:\"+values.color+\";\":\"\"]}", "{[values.ff?\"font-family:\"+values.ff+\" !important;\":\"\"]}", "{[fm._istrue(values.fw)?\"font-weight:\"+values.fw+\";\":\"\"]}{[values.fs?\"font-style:\"+values.fs+\";\":\"\"]}", "{[values.u||values.o||values.s?\"text-decoration:\"+(values.u||\"\")+\" \"+(values.o||\"\")+\" \"+(values.s||\"\")+\";\":\"\"]}", "{[fm._istrue(values.zd)?\"z-index:\"+values.zd+\";\":\"\"]}", "{[fm._istrue(values.blw)?\"border-left-width:\"+values.blw+\"px;\":\"\"]}{[values.bls?\"border-left-style:\"+values.bls+\";\":\"\"]}{[values.blc?\"border-left-color:\"+values.blc+\";\":\"\"]}", "{[fm._istrue(values.btw)?\"border-top-width:\"+values.btw+\"px;\":\"\"]}{[values.bts?\"border-top-style:\"+values.bts+\";\":\"\"]}{[values.btc?\"border-top-color:\"+values.btc+\";\":\"\"]}", "{[fm._istrue(values.brw)?\"border-right-width:\"+values.brw+\"px;\":\"\"]}{[values.brs?\"border-right-style:\"+values.brs+\";\":\"\"]}{[values.brc?\"border-right-color:\"+values.brc+\";\":\"\"]}", "{[fm._istrue(values.bbw)?\"border-bottom-width:\"+values.bbw+\"px;\":\"\"]}{[values.bbs?\"border-bottom-style:\"+values.bbs+\";\":\"\"]}{[values.bbc?\"border-bottom-color:\"+values.bbc+\";\":\"\"]}", "</tpl>", "\">", "<tpl if=\"true===values.incell\">", "<div class=\"ss-incell\" ", "style=\"{[values.bg?\"background-image:\"+values.bg+\";background-repeat:repeat;\":\"\"]}{[values.icon?\"background-image:\"+values.icon+\";background-repeat:no-repeat;\":\"\"]}", "{[values.ws?\"white-space:\"+values.ws+\";\":\"\"]}{[values.ws?\"word-wrap:\"+values.ww+\";\":\"\"]}width:{w}px;height:{h}px;margin-left:{l}px;margin-top:{t}px;\">", "</tpl>", "<tpl if=\"true==this.isVerticalAlign(values.va)\">", "<div class=\"ss-vcell\" style=\"vertical-align:{va};{[true===values.incell?(\"width:\"+values.iw+\"px;height:\"+values.ih+\"px\"):(\"width:\"+values.width+\";height:\"+values.height)]};\">", "</tpl>", "{preItem}", "{data}", "{bar}", "{mini}", "{icp}", "{posTrigger}", "{ltcorner}", "{lbcorner}", "{rtcorner}", "{rbcorner}", "{[fm._isVerticalAlign(values.va)?\"</div>\":\"\"]}", "{[values.incell?\"</div>\":\"\"]}", "{[values.wrap?\"</div>\":\"\"]}", "{fixborders}", "</div>"];
		var cellTpl = (new Ext.XTemplate(cell.join(""), {
			isVerticalAlign: isVerticalAlign
		})).compile();
		var row = ["<tpl for=\".\">"].concat(cell, ["</tpl>"]);
		var rowTpl = (new Ext.XTemplate(row.join(""), {
			isVerticalAlign: isVerticalAlign
		})).compile();
		var region = ["<tpl for=\".\">", "<div class=\"ss-row\" style=\"height:{height};padding-bottom:1px;\">", "<tpl for=\"cells\">"].concat(cell, ["</tpl>", "</div>", "</tpl>"]);
		var regionTpl = (new Ext.XTemplate(region.join(""), {
			isVerticalAlign: isVerticalAlign
		})).compile();
		var getCellInnerText = function(cell) {
			var cellEl = Ext.get(cell);
			var text;
			if(cellEl) {
				var vcell = cellEl.down(".ss-vcell");
				if(vcell) {
					text = vcell.dom.innerHTML;
					text = SCOM.removeHTMLTag(text);
				} else {
					var incell = cellEl.down(".ss-incell");
					if(incell) {
						text = incell.dom.innerHTML;
						text = SCOM.removeHTMLTag(text);
					} else {
						text = cellEl.dom.innerHTML;
						text = SCOM.removeHTMLTag(text);
					}
				}
			}
			text = text || "";
			return text;
		};
		var groupTpl = (new Ext.XTemplate(["<div data-name=\"{name}\" data-start=\"{start}\" data-end=\"{end}\" class=\"ss-{dir}-group {cls}\" ", "style=\"border-color:{color};{[values.top?\"top:\"+values.top+\"px;\":\"\"]}{[values.left?\"left:\"+values.left+\"px;\":\"\"]}\">", "<tpl if=\"true===values.max||true===values.min\">", "<div class=\"{[true===values.max?\"ss-group-tail\":\"ss-group-head\"]}\" style=\"background-color:{color};border-color:{color};\"></div>", "</tpl>", "</div>"].join(""))).compile();
		var miniColumnTpl = (new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"ss-mini-col ss-cell-inside\" style=\"background-color:{bgc};{vpos};left:{l};width:{w};height:{h};\"></div>", "</tpl>"].join(""))).compile();
		var guessHeightTable = ["<table cellpadding=0 border=0 cellspacing=0><tbody><tr><tpl for=\".\"><td>"].concat(cell, ["</td></tpl></tr></tbody></table>"]);
		var guessHeightTpl = (new Ext.XTemplate(guessHeightTable.join(""), {
			isVerticalAlign: isVerticalAlign
		})).compile();
		this.callParent(arguments);
		var tpls = {
			region: regionTpl,
			row: rowTpl,
			cell: cellTpl,
			group: groupTpl,
			miniColumnTpl: miniColumnTpl,
			getCellInnerText: getCellInnerText,
			guessHeightTpl: guessHeightTpl
		};
		Ext.apply(this, tpls);
	}
}, function() {
	SLAYOUT = EnterpriseSheet.sheet.layout.LayoutTemplates;
});

Ext.define("EnterpriseSheet.sheet.tpl.TableTemplate", {
	requires: ["Ext.menu.Menu"],
	separateChar: "$",
	MAX_CACHE_SIZE: 500,
	kitOffset: [5, -20],
	constructor: function() {
		this.initSummaryMenu();
		this.resetCache();
		this.callParent();
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		var store = sheet.getStore();
		store.on({
			scope: this,
			beforehiderow: this.resetCache,
			beforehidecolumn: this.resetCache,
			beforeshowrow: this.resetCache,
			beforeshowcolumn: this.resetCache,
			beforeremovecell: this.beforeRemoveCell,
			beforeinsertcell: this.beforeInsertCell,
			beforeholdremoverow: this.holdRemoveRow,
			beforeholdremovecolumn: this.holdRemoveColumn,
			beforeholdinsertrow: this.holdInsertRow,
			beforeholdinsertcolumn: this.holdInsertColumn
		});
		sheet.on({
			scope: this,
			cellmousedown: this.onCellMouseDown,
			incellmousedown: this.onIncellMouseDown,
			cellmouseup: this.onCellMouseUp,
			changing: this.hideSummaryKit
		});
	},
	isTableHeader: function(cell, sheetId, row, col) {
		var tpl = cell.tpl;
		if(tpl) {
			tpl = Ext.decode(tpl);
			var span = tpl.span;
			return sheetId === span[0] && (row === span[1] || 1 === row && 0 === span[1]);
		}
	},
	onCellMouseDown: function(row, col, region, e) {
		var store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var cell = store.getCell(sheetId, row, col),
			flag = false;
		if(cell.tpl) {
			var tpl = Ext.decode(cell.tpl),
				withoutFoot = !tpl.withFoot;
			var tplData = this.getTplById(tpl.id);
			if(tplData) {
				Ext.apply(tpl, tplData);
			}
			var fs = withoutFoot ? false : tpl.footStyle;
			if(col !== tpl.span[2] && row === tpl.span[3] && fs) {
				flag = true;
				this.showSummaryKit(row, col);
			}
		}
		if(!flag) {
			this.hideSummaryKit();
		}
	},
	onIncellMouseDown: function(rc, target, region, e) {
		var store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId(),
			sm = this.sheet.getSelectionModel();
		var tgEl = Ext.get(target);
		if(tgEl.hasCls("ss-tpl-rz")) {
			this.rzFlag = true;
			var cell = store.getCell(sheetId, rc[0], rc[1]);
			var tpl = Ext.decode(cell.tpl);
			var span = tpl.span;
			var top = span[1],
				left = span[2];
			sm.addCls("ss-autofill");
			var mode = {
				type: "bottom-right",
				minrow: top + 1,
				mincol: left,
				maxrow: rc[0],
				maxcol: rc[1]
			};
			this.tplSpan = [sheetId, top, left, rc[0], rc[1]];
			sm.setMode(mode);
			sm.selectRange({
				row: top,
				col: left
			}, {
				row: rc[0],
				col: rc[1]
			});
			return false;
		}
	},
	onCellMouseUp: function() {
		if(this.rzFlag) {
			var sm = this.sheet.getSelectionModel();
			sm.removeCls("ss-autofill");
			sm.setMode();
			var span = sm.selection2Span();
			delete this.rzFlag;
			this.updateTplForSpan(span);
		}
	},
	updateTplForSpan: function(span) {
		var tplSpan = this.tplSpan;
		var sheetId = tplSpan[0],
			minrow = tplSpan[1],
			mincol = tplSpan[2],
			maxrow = tplSpan[3],
			maxcol = tplSpan[4];
		var sheet = this.sheet,
			store = sheet.getStore();
		var cell = store.getCell(sheetId, minrow, mincol);
		var tpl = Ext.decode(cell.tpl);
		if(span[3] > tplSpan[3] || span[4] > tplSpan[4]) {
			if(false === sheet.fireEvent("beforesettpl", span, tpl, sheet)) {
				return;
			}
			sheet.fireEvent("preparesettpl", span, tpl, sheet);
			store.walkRange([span], function(rd) {
				var row = rd.data.row,
					col = rd.data.col;
				if(maxcol >= col) {
					cell = store.getCell(sheetId, maxrow, col);
					tpl = Ext.decode(cell.tpl);
				}
				if(tpl) {
					tpl.span = [].concat(span);
					store.setCell(sheetId, row, col, {
						tpl: Ext.encode(tpl)
					}, null, true);
				}
			}, this);
			sheet.fireEvent("settpl", span, tpl, sheet);
			this.syncPlainForTplHead(tpl);
			sheet.refreshRange([span], true);
		} else if(span[3] < tplSpan[3] || span[4] < tplSpan[4]) {
			if(false === sheet.fireEvent("beforesettpl", tplSpan, tpl, sheet)) {
				return;
			}
			sheet.fireEvent("preparesettpl", tplSpan, tpl, sheet);
			store.walkRange([tplSpan], function(rd) {
				var row = rd.data.row,
					col = rd.data.col;
				if(maxcol >= col) {
					cell = store.getCell(sheetId, maxrow, col);
					tpl = Ext.decode(cell.tpl);
				}
				if(row <= span[3] && col <= span[4]) {
					tpl.span = [].concat(span);
					store.setCell(sheetId, row, col, {
						tpl: Ext.encode(tpl)
					}, null, true);
				} else {
					store.setCell(sheetId, row, col, null, ["tpl"], true);
				}
			}, this);
			sheet.fireEvent("settpl", tplSpan, tpl, sheet);
			this.syncPlainForTplHead(tpl);
			sheet.refreshRange([tplSpan], true);
		}
		var rm = sheet.getReferenceModel();
		rm.hide();
	},
	setTplForSpan: function(span, tpl, config) {
		config = config || {
			withoutFoot: true
		};
		Ext.apply(tpl, config);
		var flag = this.checkSelection([span]);
		var sheet = this.sheet,
			store = sheet.getStore();
		var minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4],
			sheetId = span[0];
		if("none" == flag) {
			if(span[1] == span[3] && span[2] == span[4]) {
				Ext.Msg.alert(SLANG.hint, SLANG.cannot_set_table_tpl_for_single_cell);
			} else {
				if(false === sheet.fireEvent("beforesettpl", span, tpl, sheet)) {
					return;
				}
				sheet.fireEvent("preparesettpl", span, tpl, sheet);
				for(var row = minrow; row <= maxrow; row++) {
					for(var col = mincol; col <= maxcol; col++) {
						tpl.span = [].concat(span);
						var modified = {};
						modified.tpl = Ext.encode(tpl);
						if(0 === row) {
							store.setColumn(sheetId, col, modified, null, true, true);
						} else if(0 === col) {
							store.setRow(sheetId, row, modified, null, true, true);
						} else {
							store.setCell(sheetId, row, col, modified, null, true);
						}
					}
				}
				sheet.fireEvent("settpl", span, tpl, sheet);
				this.syncPlainForTplHead(tpl);
				sheet.refreshRange([span], true);
			}
		} else if("all" == flag) {
			var row = minrow,
				col = mincol;
			var cp = store.getCellProperty(sheetId, row, col);
			var oldTpl = Ext.decode(cp.tpl);
			span = oldTpl.span;
			minrow = "" !== span[1] ? span[1] : 0;
			mincol = "" !== span[2] ? span[2] : 0;
			maxrow = "" !== span[3] ? span[3] : 0;
			maxcol = "" !== span[4] ? span[4] : 0;
			span[1] = minrow, span[2] = mincol, span[3] = maxrow, span[4] = maxcol;
			if(false === sheet.fireEvent("beforesettpl", span, tpl, sheet)) {
				return;
			}
			sheet.fireEvent("preparesettpl", span, tpl, sheet);
			for(var row = minrow; row <= maxrow; row++) {
				for(var col = mincol; col <= maxcol; col++) {
					tpl.span = [].concat(span);
					var modified = {};
					modified.tpl = Ext.encode(tpl);
					if(0 === row) {
						store.setColumn(sheetId, col, modified, null, true, true);
					} else if(0 === col) {
						store.setRow(sheetId, row, modified, null, true, true);
					} else {
						store.setCell(sheetId, row, col, modified, null, true);
					}
				}
			}
			span[0] = sheetId;
			sheet.fireEvent("settpl", span, tpl, sheet);
			this.syncPlainForTplHead(tpl);
			this.sheet.refreshRange([span], true);
		} else {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.cannot_set_tpl_for_selection,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		}
	},
	syncPlainForTplHead: function(tpl) {
		var span = tpl.span,
			store = this.sheet.getStore();
		store.walkRange([span], function(rd) {
			var sheetId = rd.data.sheet,
				row = rd.data.row,
				col = rd.data.col;
			if(span[1] === row || 0 === span[1] && 1 === row) {
				var cell = this.sheet.getCellValue(sheetId, row, col);
				store.setCell(sheetId, row, col, {
					plain: cell.data
				}, undefined, true);
			} else {
				store.setCell(sheetId, row, col, undefined, ["plain"], true);
			}
		}, this, true);
	},
	clearTplForSpan: function(span) {
		var deleted = ["tpl", "trigger", "filter", "filterCdt", "plain"];
		var flag = this.checkSelection([span]);
		var sheet = this.sheet,
			store = sheet.getStore();
		var minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4],
			sheetId = span[0];
		if("none" == flag) {
			if(false === sheet.fireEvent("beforesettpl", span, null, sheet)) {
				return;
			}
			sheet.fireEvent("preparesettpl", span, null, sheet);
			for(var row = minrow; row <= maxrow; row++) {
				for(var col = mincol; col <= maxcol; col++) {
					if(0 === row) {
						store.setColumn(sheetId, col, null, deleted, true, true);
					} else if(0 === col) {
						store.setRow(sheetId, row, null, deleted, true, true);
					} else {
						store.setCell(sheetId, row, col, null, deleted, true);
					}
				}
			}
			sheet.fireEvent("settpl", span, null, sheet);
			sheet.refreshRange([span], true);
		} else if("all" == flag) {
			var row = minrow,
				col = mincol;
			var cp = store.getCellProperty(sheetId, row, col);
			var oldTpl = Ext.decode(cp.tpl);
			span = oldTpl.span;
			minrow = "" !== span[1] ? span[1] : 0;
			mincol = "" !== span[2] ? span[2] : 0;
			maxrow = "" !== span[3] ? span[3] : 0;
			maxcol = "" !== span[4] ? span[4] : 0;
			span[1] = minrow, span[2] = mincol, span[3] = maxrow, span[4] = maxcol;
			if(false === sheet.fireEvent("beforesettpl", span, null, sheet)) {
				return;
			}
			sheet.fireEvent("preparesettpl", span, null, sheet);
			for(var row = minrow; row <= maxrow; row++) {
				for(var col = mincol; col <= maxcol; col++) {
					if(0 === row) {
						store.setColumn(sheetId, col, null, deleted, true, true);
					} else if(0 === col) {
						store.setRow(sheetId, row, null, deleted, true, true);
					} else {
						store.setCell(sheetId, row, col, null, deleted, true);
					}
				}
			}
			span[0] = sheetId;
			sheet.fireEvent("settpl", span, null, sheet);
			this.sheet.refreshRange([span], true);
		} else {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.cannot_set_tpl_for_selection,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		}
	},
	processTpl: function(cell, scope) {
		var row = scope.row,
			col = scope.col,
			sheetId = scope.sheet;
		var style = this.getStyle(cell.tpl, sheetId, row, col);
		if(SCOM.nullOrUndefined(cell.data)) {
			cell.data = style.data;
		} else {
			delete style.cal;
			delete style.value;
			delete style.arg;
		}
		for(var p in cell) {
			if(cell.hasOwnProperty(p) && SCOM.isEmptyValue(cell[p])) {
				delete cell[p];
			}
		}
		cell = Ext.applyIf(cell, style);
		if(style.hideFilter) {
			delete cell.trigger;
		}
		return cell;
	},
	prepareTplStyle: function(tpl, sheetId, row, col) {
		var calPro = EnterpriseSheet.sheet.calculate.Calculate.prototype;
		var sheet = this.sheet,
			store = sheet.getStore();
		var span = [].concat(tpl.span);
		var minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4];
		var tplData = this.getTplById(tpl.id);
		if(tplData) {
			Ext.apply(tpl, tplData);
		}
		var bs = tpl.bodyStyle,
			hs = tpl.withoutHead ? false : tpl.headStyle,
			fs = !tpl.withFoot ? false : tpl.footStyle,
			fcs = tpl.firstColumn,
			lcs = tpl.lastColumn;
		var ri, style, ci;
		var loff = store.countVisibleColumn(sheetId, col + 1, maxcol),
			boff = store.countVisibleRow(sheetId, row + 1, maxrow);
		if(hs && (0 !== minrow && minrow === row || 0 === minrow && 1 == row)) {
			ci = 1 == hs.length ? 0 : store.countVisibleColumn(sheetId, mincol + 1, col) % hs.length;
			style = hs[ci];
			var filter = sheet.getFilter();
			if(filter && !tpl.hideFilter) {
				var tmp = [].concat(span);
				if(fs) {
					tmp[3]--;
				}
				var o = filter.prepareFilterPreporty(row, tmp);
				Ext.apply(style, o);
			}
			style.hideFilter = tpl.hideFilter;
			var startCol = 0 === span[2] ? 1 : span[2];
			style.data = SLANG.column + (col - startCol + 1);
			if(col == mincol || 0 === mincol && 1 == col) {
				Ext.applyIf(style, fcs);
			}
			if((col == maxcol || 0 === loff) && 0 !== maxcol) {
				Ext.applyIf(style, lcs);
			}
		} else {
			if(fs && 0 !== maxrow && maxrow === row) {
				ci = 1 == fs.length ? 0 : store.countVisibleColumn(sheetId, mincol + 1, col) % fs.length;
				style = fs[ci];
				style.css = "ss-tpl-foot";
				if(col !== mincol && 1 < maxrow - minrow) {
					var calName = tpl.cal || "SUM";
					var tmpSpan = ["", span[1] + 1, col, span[3] - 1, col];
					var data = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
						span: tmpSpan,
						type: SCONST.RELATIVE_COORD
					}], "", false);
					style.data = "=" + calName + "(" + data + ")";
					style.cal = true;
					tmpSpan = ["", span[1] - row + 1, 0, span[3] - row - 1, 0];
					calPro.transferCalculate(style, store, sheetId, row, col);
				}
			} else {
				ri = 1 == bs.length ? 0 : store.countVisibleRow(sheetId, 0 === minrow ? 2 : minrow + 1, row) % bs.length;
				ci = 1 == bs[ri].length ? 0 : store.countVisibleColumn(sheetId, 0 === mincol ? 2 : mincol + 1, col) % bs[ri].length;
				style = bs[ri][ci];
				if(minrow === row && !Ext.isDefined(style.btf)) {
					style.btf = 1;
				}
			}
			if(col == mincol || 0 === mincol && 1 == col) {
				Ext.applyIf(style, fcs);
				if(row == maxrow && fs) {
					style.data = SLANG.summary;
				}
			}
			if((col == maxcol || 0 === loff) && 0 !== maxcol) {
				Ext.applyIf(style, lcs);
			}
			if(0 !== maxrow && 0 !== maxcol && (row == maxrow || 0 === boff) && (col == maxcol || 0 === loff)) {
				style.rbcorner = "<div class=\"ss-tpl-rz\"></div>";
			}
		}
		return style;
	},
	resetCache: function() {
		this.lookup = {};
	},
	maintainCacheSize: function() {
		var size = SCOM.countObjMember(this.lookup);
		var beyond = size - this.MAX_CACHE_SIZE;
		if(0 < beyond) {
			var i = 0;
			for(var p in this.lookup) {
				delete this.lookup[p];
				i++;
				if(i == beyond) {
					break;
				}
			}
		}
	},
	getStyle: function(tplStr, sheetId, row, col) {
		var id = [sheetId, row, col].join(this.separateChar);
		var it = this.lookup[id];
		if(it && it.tplStr == tplStr) {
			return it.style;
		} else {
			var tpl = Ext.decode(tplStr);
			var style = this.prepareTplStyle(tpl, sheetId, row, col);
			this.maintainCacheSize();
			this.lookup[id] = {
				tplStr: tplStr,
				style: style
			};
			return style;
		}
	},
	holdRemoveRow: function(sheetId, minrow, maxrow) {
		var store = this.sheet.getStore();
		var dspan = maxrow - minrow + 1;
		store.each(function(rd) {
			var orow = row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != row && json.tpl) {
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var top = span[1],
					bottom = span[3],
					flag = false;
				if(minrow < top && maxrow > top && maxrow < bottom) {
					top = maxrow;
					flag = true;
				} else if(minrow >= top && maxrow <= bottom) {
					bottom -= dspan;
					flag = true;
				} else if(minrow < bottom && maxrow > bottom && minrow > top) {
					bottom = minrow;
					flag = true;
				} else if(maxrow < top) {
					top -= dspan;
					bottom -= dspan;
					flag = true;
				}
				if(flag) {
					span[1] = top;
					span[3] = bottom;
					store.setCell(sheetId, orow, col, {
						tpl: Ext.encode(tpl)
					}, null, true);
				}
			}
		}, this);
		this.resetCache();
	},
	beforeRemoveRow: function(sheetId, minrow, maxrow) {
		var flag = this.checkSelection();
		if("part" == flag) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.cannot_delete_normal_tpl_cell,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		}
	},
	holdRemoveColumn: function(sheetId, mincol, maxcol) {
		var store = this.sheet.getStore();
		var dspan = maxcol - mincol + 1;
		store.each(function(rd) {
			var row = rd.data.row,
				ocol = col = rd.data.col,
				json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != col && json.tpl) {
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var left = span[2],
					right = span[4],
					flag = false;
				if(mincol < left && maxcol > right && maxcol < right) {
					left = maxcol;
					flag = true;
				} else if(mincol >= left && maxcol <= right) {
					right -= dspan;
					flag = true;
				} else if(mincol < right && maxcol > right && mincol > left) {
					right = mincol;
					flag = true;
				} else if(maxcol < left) {
					left -= dspan;
					right -= dspan;
					flag = true;
				}
				if(flag) {
					span[2] = left;
					span[4] = right;
					store.setCell(sheetId, row, ocol, {
						tpl: Ext.encode(tpl)
					}, null, true);
				}
			}
		}, this);
		this.resetCache();
	},
	beforeRemoveColumn: function(sheetId, mincol, maxcol) {
		var flag = this.checkSelection();
		if("part" == flag) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.cannot_delete_normal_tpl_cell,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		}
	},
	checkSelection: function(coord) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			sm = sheet.getSelectionModel();
		coord = coord || sm.selection2Coord(), span = coord[0];
		if(0 == span[1] && 0 == span[2]) {
			return "whole";
		} else {
			var sheetId = span[0],
				minrow = span[1],
				maxrow = span[3],
				mincol = span[2],
				maxcol = span[4];
			if(0 == maxrow) {
				var flag = true,
					hasTpl = false;
				store.walkRange(coord, function(rd) {
					var property = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col);
					if(property.tpl) {
						hasTpl = true;
						var tpl = Ext.decode(property.tpl);
						var span = tpl.span;
						if(!(mincol > span[2] && maxcol < span[4] || maxcol < span[2] || mincol > span[4])) {
							flag = false;
							return false;
						}
					}
				}, this);
				if(flag) {
					return hasTpl ? "all" : "none";
				} else {
					return "part";
				}
			} else if(0 == maxcol) {
				var flag = true,
					hasTpl = false;
				store.walkRange(coord, function(rd) {
					var property = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col);
					if(property.tpl) {
						hasTpl = true;
						var tpl = Ext.decode(property.tpl);
						var span = tpl.span;
						if(!(minrow > span[1] && maxrow < span[3] || maxrow < span[1] || minrow > span[3])) {
							flag = false;
							return false;
						}
					}
				}, this);
				if(flag) {
					return hasTpl ? "all" : "none";
				} else {
					return "part";
				}
			} else {
				var tplCount = 0,
					sum = 0;
				store.walkRange(coord, function(rd) {
					var property = store.getCellProperty(rd.data.sheet, rd.data.row, rd.data.col);
					if(property.tpl) {
						tplCount++;
					}
					sum++;
				}, this);
				if(0 === tplCount) {
					return "none";
				} else if(tplCount == sum) {
					return "all";
				} else {
					return "part";
				}
			}
		}
	},
	beforeRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store) {
		var flag = this.checkSelection();
		if("part" == flag) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.cannot_delete_normal_tpl_cell,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		} else if("all" == flag) {
			var sheet = this.sheet;
			if("left" == moveDir) {
				Ext.Msg.show({
					title: SLANG.confirm,
					msg: SLANG.delete_column_in_tabletpl,
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid) {
						if("yes" == bid) {
							sheet.deleteColumn();
						}
					},
					scope: this
				});
				return false;
			} else {
				Ext.Msg.show({
					title: SLANG.confirm,
					msg: SLANG.delete_row_in_tabletpl,
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid) {
						if("yes" == bid) {
							sheet.deleteRow();
						}
					},
					scope: this
				});
				return false;
			}
		}
	},
	beforeInsertRow: function(sheetId, insertRow, rowSpan) {
		var store = this.sheet.getStore();
		var maxrow = insertRow + rowSpan - 1;
		store.each(function(rd) {
			var orow = row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != row && json.tpl) {
				if(row > maxrow) {
					row -= rowSpan;
				}
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var top = span[1],
					bottom = span[3];
				if(top < insertRow && insertRow <= bottom) {
					bottom += rowSpan;
					span[1] = top;
					span[3] = bottom;
					store.setCell(sheetId, orow, col, {
						tpl: Ext.encode(tpl)
					}, null, true);
				} else if(insertRow <= top) {
					top += rowSpan;
					bottom += rowSpan;
					span[1] = top;
					span[3] = bottom;
					store.setCell(sheetId, orow, col, {
						tpl: Ext.encode(tpl)
					}, null, true);
				}
			}
		}, this);
		this.resetCache();
	},
	holdInsertRow: function(sheetId, insertRow, rowSpan) {
		this.beforeInsertRow(sheetId, insertRow, rowSpan);
		var store = this.sheet.getStore();
		var maxrow = insertRow + rowSpan;
		var cols = [];
		store.each(function(rd) {
			var row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != row && maxrow == row && json.tpl) {
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var top = span[1],
					bottom = span[3];
				if(top < maxrow) {
					cols.push([col, tpl, top, bottom]);
				}
			}
		}, this);
		for(var i = 0, len = cols.length; i < len; i++) {
			var c = cols[i];
			var col = c[0],
				tpl = c[1],
				top = c[2],
				bottom = c[3];
			for(var row = insertRow; row < maxrow; row++) {
				tpl.span[1] = top;
				tpl.span[3] = bottom;
				store.setCell(sheetId, row, col, {
					tpl: Ext.encode(tpl)
				}, null, true);
			}
		}
	},
	beforeInsertColumn: function(sheetId, insertCol, colSpan) {
		var store = this.sheet.getStore();
		var maxcol = insertCol + colSpan - 1;
		store.each(function(rd) {
			var row = rd.data.row,
				ocol = col = rd.data.col,
				json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != col && json.tpl) {
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var left = span[2],
					right = span[4];
				if(left < insertCol && insertCol <= right) {
					right += colSpan;
					span[2] = left;
					span[4] = right;
					store.setCell(sheetId, row, ocol, {
						tpl: Ext.encode(tpl)
					}, null, true);
				} else if(insertCol <= left) {
					left += colSpan;
					right += colSpan;
					span[2] = left;
					span[4] = right;
					store.setCell(sheetId, row, ocol, {
						tpl: Ext.encode(tpl)
					}, null, true);
				}
			}
		}, this);
		this.resetCache();
	},
	holdInsertColumn: function(sheetId, insertCol, colSpan) {
		this.beforeInsertColumn(sheetId, insertCol, colSpan);
		var store = this.sheet.getStore();
		var maxcol = insertCol + colSpan;
		var rows = [];
		store.each(function(rd) {
			var row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			if(sheetId == rd.data.sheet && 0 != col && maxcol == col && json.tpl) {
				var tpl = Ext.decode(json.tpl);
				var span = tpl.span;
				var left = span[2],
					right = span[4];
				if(left < maxcol) {
					rows.push([row, tpl, left, right]);
				}
			}
		}, this);
		for(var i = 0, len = rows.length; i < len; i++) {
			var r = rows[i];
			var row = r[0],
				tpl = r[1],
				left = r[2],
				right = r[3];
			for(var col = insertCol; col < maxcol; col++) {
				tpl.span[2] = left;
				tpl.span[4] = right;
				store.setCell(sheetId, row, col, {
					tpl: Ext.encode(tpl)
				}, null, true);
			}
		}
	},
	beforeInsertCell: function(sheet, row, col, rowSpan, colSpan, moveDir, merged, store) {
		var flag = this.checkSelection();
		if("part" == flag) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.cannot_insert_break_tpl_cell,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		} else if("all" == flag) {
			var sheet = this.sheet;
			if("right" == moveDir) {
				Ext.Msg.show({
					title: SLANG.confirm,
					msg: SLANG.insert_column_in_tabletpl,
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid) {
						if("yes" == bid) {
							sheet.insertColumn();
						}
					},
					scope: this
				});
				return false;
			} else {
				Ext.Msg.show({
					title: SLANG.confirm,
					msg: SLANG.insert_row_in_tabletpl,
					icon: Ext.Msg.QUESTION,
					buttons: Ext.Msg.YESNO,
					fn: function(bid) {
						if("yes" == bid) {
							sheet.insertRow();
						}
					},
					scope: this
				});
				return false;
			}
		}
	},
	initSummaryMenu: function() {
		this.summaryMenu = this.summaryMenu || new Ext.menu.Menu({
			items: [{
				text: SLANG.sum,
				cal: "sum",
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text: SLANG.average,
				cal: "average",
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text: SLANG.count,
				cal: "count",
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text: SLANG.max,
				cal: "max",
				handler: this.selectSummaryCal,
				scope: this
			}, {
				text: SLANG.min,
				cal: "min",
				handler: this.selectSummaryCal,
				scope: this
			}, "-", {
				text: SLANG.more_functions + ".."
			}]
		});
	},
	showSummaryKit: function(row, col) {
		var store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, col, undefined, true) + this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, row, undefined, true) + this.kitOffset[1];
		if(!this.summaryKit) {
			this.summaryKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet: this.sheet,
				localKit: true,
				floatingConfig: {
					xtype: "button",
					iconCls: "icon-sum",
					x: x,
					y: y,
					ddConfig: false,
					resizeConfig: false,
					destroyMenu: false,
					menu: this.summaryMenu
				}
			});
		} else {
			this.summaryKit.setXY([x, y]);
		}
		this.summaryMenu.cellPos = [sheetId, row, col];
		this.summaryKit.show();
	},
	hideSummaryKit: function() {
		if(this.summaryKit) {
			this.summaryKit.hide();
		}
	},
	selectSummaryCal: function(item) {
		var menu = item.parentMenu;
		var pos = menu.cellPos;
		if(pos) {
			var cal = item.cal;
			var sheet = this.sheet,
				store = sheet.getStore();
			var cell = store.getCell(pos[0], pos[1], pos[2]);
			var tpl = Ext.decode(cell.tpl);
			tpl.cal = cal;
			var modified = {
				tpl: Ext.encode(tpl)
			};
			var ret = store.setCell(pos[0], pos[1], pos[2], modified, null, true);
			var timestamp = SCOM.genTimeStamp();
			var changedCalCells = sheet.findDirectRecalculateCellsOfCell(pos[0], pos[1], pos[2]) || {};
			this.clearValueForCalCells(changedCalCells);
			sheet.refreshCalCdt(changedCalCells, undefined, undefined, [pos[0], pos[1], pos[2], pos[1], pos[2]]);
			store.fireEvent("tplsummarychange", timestamp, pos[0], pos[1], pos[2], modified, null, ret[0], ret[1], store, false, changedCalCells);
		}
	},
	getTplById: function(id) {
		var tpls = this.tableTplData;
		if(tpls) {
			for(var i = 0, len = tpls.length; i < len; i++) {
				if(id == tpls[i].id) {
					return SCOM.copy(tpls[i].tpl);
				}
			}
		}
	},
	toggleTplFilterForSpan: function(span) {
		var sheet = this.sheet,
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		var row = span[1],
			col = span[2];
		var cp = store.getCellProperty(sheetId, row, col);
		var oldTpl = Ext.decode(cp.tpl);
		if(oldTpl.hideFilter) {
			delete oldTpl.hideFilter;
		} else {
			oldTpl.hideFilter = true;
		}
		var newTpl = Ext.encode(oldTpl);
		span = oldTpl.span;
		minrow = "" !== span[1] ? span[1] : 0;
		mincol = "" !== span[2] ? span[2] : 0;
		maxrow = "" !== span[3] ? span[3] : 0;
		maxcol = "" !== span[4] ? span[4] : 0;
		span[1] = minrow, span[2] = mincol, span[3] = maxrow, span[4] = maxcol;
		if(false === sheet.fireEvent("beforesettpl", span, newTpl, sheet)) {
			return;
		}
		sheet.fireEvent("preparesettpl", span, null, sheet);
		for(var row = minrow; row <= maxrow; row++) {
			for(var col = mincol; col <= maxcol; col++) {
				if(0 === row) {
					store.setColumn(sheetId, col, {
						tpl: newTpl
					}, null, true, true);
				} else if(0 === col) {
					store.setRow(sheetId, row, {
						tpl: newTpl
					}, null, true, true);
				} else {
					store.setCell(sheetId, row, col, {
						tpl: newTpl
					}, null, true);
				}
			}
		}
		span[0] = sheetId;
		sheet.fireEvent("settpl", span, newTpl, sheet);
		sheet.refreshRange([span]);
	}
}, function() {
	EnterpriseSheet.sheet.tpl.TableTemplate.prototype.tableTplData = [{
		id: "tpl_0",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_0.png",
		tip: SLANG[''],
		type: "light",
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "black",
				bbc: "black",
				fw: "bold"
			}],
			footStyle: [{
				btf: 1,
				btc: "black",
				bbc: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(217,217,217)"
				}]
			]
		}
	}, {
		id: "tpl_1",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_1.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(79,129,189)",
				bbc: "rgb(79,129,189)",
				fw: "bold",
				color: "rgb(54,96,146)"
			}],
			footStyle: [{
				btf: 1,
				btc: "rgb(79,129,189)",
				bbc: "rgb(79,129,189)",
				fw: "bold",
				color: "rgb(54,96,146)"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(230,230,241)"
				}]
			]
		}
	}, {
		id: "tpl_2",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_2.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(192,80,77)",
				bbc: "rgb(192,80,77)",
				fw: "bold",
				color: "rgb(150,54,52)"
			}],
			footStyle: [{
				btf: 1,
				btc: "rgb(192,80,77)",
				bbc: "rgb(192,80,77)",
				fw: "bold",
				color: "rgb(150,54,52)"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(242,220,219)"
				}]
			]
		}
	}, {
		id: "tpl_3",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_3.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(155,187,89)",
				bbc: "rgb(155,187,89)",
				fw: "bold",
				color: "rgb(118,147,60)"
			}],
			footStyle: [{
				btf: 1,
				btc: "rgb(155,187,89)",
				bbc: "rgb(155,187,89)",
				fw: "bold",
				color: "rgb(118,147,60)"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(235,241,222)"
				}]
			]
		}
	}, {
		id: "tpl_4",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_4.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(128,100,162)",
				bbc: "rgb(128,100,162)",
				fw: "bold",
				color: "rgb(96,73,122)"
			}],
			footStyle: [{
				btf: 1,
				btc: "rgb(128,100,162)",
				bbc: "rgb(128,100,162)",
				fw: "bold",
				color: "rgb(96,73,122)"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(228,226,236)"
				}]
			]
		}
	}, {
		id: "tpl_5",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_5.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(75,172,198)",
				bbc: "rgb(75,172,198)",
				fw: "bold",
				color: "rgb(49,134,155)"
			}],
			footStyle: [{
				btf: 1,
				btc: "rgb(75,172,198)",
				bbc: "rgb(75,172,198)",
				fw: "bold",
				color: "rgb(49,134,155)"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(218,238,243)"
				}]
			]
		}
	}, {
		id: "tpl_6",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_6.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(247,150,70)",
				bbc: "rgb(247,150,70)",
				fw: "bold",
				color: "rgb(226,107,10)"
			}],
			footStyle: [{
				btf: 1,
				btc: "rgb(247,150,70)",
				bbc: "rgb(247,150,70)",
				fw: "bold",
				color: "rgb(226,107,10)"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(253,233,217)"
				}]
			]
		}
	}, {
		id: "tpl_7",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_7.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				brc: "black",
				btf: 1,
				btc: "black",
				bbc: "black",
				fw: "bold",
				color: "white"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "black",
				bbc: "black",
				fw: "bold"
			}],
			firstColumn: {
				blf: 1,
				blc: "black"
			},
			lastColumn: {
				brc: "black"
			},
			bodyStyle: [
				[{
					bbc: "black"
				}]
			]
		}
	}, {
		id: "tpl_8",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_8.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(79,129,189)",
				brc: "rgb(79,129,189)",
				btf: 1,
				btc: "rgb(79,129,189)",
				bbc: "rgb(79,129,189)",
				fw: "bold",
				color: "white"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(79,129,189)",
				bbc: "rgb(79,129,189)",
				fw: "bold"
			}],
			firstColumn: {
				blf: 1,
				blc: "rgb(79,129,189)"
			},
			lastColumn: {
				brc: "rgb(79,129,189)"
			},
			bodyStyle: [
				[{
					bbc: "rgb(79,129,189)"
				}]
			]
		}
	}, {
		id: "tpl_9",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_9.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(192,80,77)",
				brc: "rgb(192,80,77)",
				btf: 1,
				btc: "rgb(192,80,77)",
				bbc: "rgb(192,80,77)",
				fw: "bold",
				color: "white"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(192,80,77)",
				bbc: "rgb(192,80,77)",
				fw: "bold"
			}],
			firstColumn: {
				blf: 1,
				blc: "rgb(192,80,77)"
			},
			lastColumn: {
				brc: "rgb(192,80,77)"
			},
			bodyStyle: [
				[{
					bbc: "rgb(192,80,77)"
				}]
			]
		}
	}, {
		id: "tpl_10",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_10.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(155,187,89)",
				brc: "rgb(155,187,89)",
				btf: 1,
				btc: "rgb(155,187,89)",
				bbc: "rgb(155,187,89)",
				fw: "bold",
				color: "white"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(155,187,89)",
				bbc: "rgb(155,187,89)",
				fw: "bold"
			}],
			firstColumn: {
				blf: 1,
				blc: "rgb(155,187,89)"
			},
			lastColumn: {
				brc: "rgb(155,187,89)"
			},
			bodyStyle: [
				[{
					bbc: "rgb(155,187,89)"
				}]
			]
		}
	}, {
		id: "tpl_11",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_11.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(128,100,162)",
				brc: "rgb(128,100,162)",
				btf: 1,
				btc: "rgb(128,100,162)",
				bbc: "rgb(128,100,162)",
				fw: "bold",
				color: "white"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(128,100,162)",
				bbc: "rgb(128,100,162)",
				fw: "bold"
			}],
			firstColumn: {
				blf: 1,
				blc: "rgb(128,100,162)"
			},
			lastColumn: {
				brc: "rgb(128,100,162)"
			},
			bodyStyle: [
				[{
					bbc: "rgb(128,100,162)"
				}]
			]
		}
	}, {
		id: "tpl_12",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_12.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(75,172,198)",
				brc: "rgb(75,172,198)",
				btf: 1,
				btc: "rgb(75,172,198)",
				bbc: "rgb(75,172,198)",
				fw: "bold",
				color: "white"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(75,172,198)",
				bbc: "rgb(75,172,198)",
				fw: "bold"
			}],
			firstColumn: {
				blf: 1,
				blc: "rgb(75,172,198)"
			},
			lastColumn: {
				brc: "rgb(75,172,198)"
			},
			bodyStyle: [
				[{
					bbc: "rgb(75,172,198)"
				}]
			]
		}
	}, {
		id: "tpl_13",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_13.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(247,150,70)",
				brc: "rgb(247,150,70)",
				btf: 1,
				btc: "rgb(247,150,70)",
				bbc: "rgb(247,150,70)",
				fw: "bold",
				color: "white"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(247,150,70)",
				bbc: "rgb(247,150,70)",
				fw: "bold"
			}],
			firstColumn: {
				blf: 1,
				blc: "rgb(247,150,70)"
			},
			lastColumn: {
				brc: "rgb(247,150,70)"
			},
			bodyStyle: [
				[{
					bbc: "rgb(247,150,70)"
				}]
			]
		}
	}, {
		id: "tpl_14",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_14.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				blf: 1,
				btc: "black",
				blc: "black",
				brc: "black",
				bbc: "black",
				pb: 1,
				bbw: 2,
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				blf: 1,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "black",
				blc: "black",
				bbc: "black",
				brc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					blf: 1,
					btc: "black",
					blc: "black",
					bbc: "black",
					brc: "black"
				}],
				[{
					bgc: "rgb(217,217,217)",
					blf: 1,
					btc: "black",
					blc: "black",
					bbc: "black",
					brc: "black"
				}]
			]
		}
	}, {
		id: "tpl_15",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_15.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				blf: 1,
				btc: "rgb(79,129,189)",
				blc: "rgb(79,129,189)",
				brc: "rgb(79,129,189)",
				bbc: "rgb(79,129,189)",
				pb: 1,
				bbw: 2,
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				blf: 1,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(79,129,189)",
				blc: "rgb(79,129,189)",
				bbc: "rgb(79,129,189)",
				brc: "rgb(79,129,189)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					blf: 1,
					btc: "rgb(79,129,189)",
					blc: "rgb(79,129,189)",
					bbc: "rgb(79,129,189)",
					brc: "rgb(79,129,189)"
				}],
				[{
					bgc: "rgb(220,230,241)",
					blf: 1,
					btc: "rgb(79,129,189)",
					blc: "rgb(79,129,189)",
					bbc: "rgb(79,129,189)",
					brc: "rgb(79,129,189)"
				}]
			]
		}
	}, {
		id: "tpl_16",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_16.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				blf: 1,
				btc: "rgb(192,80,77)",
				blc: "rgb(192,80,77)",
				brc: "rgb(192,80,77)",
				bbc: "rgb(192,80,77)",
				pb: 1,
				bbw: 2,
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				blf: 1,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(192,80,77)",
				blc: "rgb(192,80,77)",
				bbc: "rgb(192,80,77)",
				brc: "rgb(192,80,77)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					blf: 1,
					btc: "rgb(192,80,77)",
					blc: "rgb(192,80,77)",
					bbc: "rgb(192,80,77)",
					brc: "rgb(192,80,77)"
				}],
				[{
					bgc: "rgb(242,220,219)",
					blf: 1,
					btc: "rgb(192,80,77)",
					blc: "rgb(192,80,77)",
					bbc: "rgb(192,80,77)",
					brc: "rgb(192,80,77)"
				}]
			]
		}
	}, {
		id: "tpl_17",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_17.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				blf: 1,
				btc: "rgb(155,187,89)",
				blc: "rgb(155,187,89)",
				brc: "rgb(155,187,89)",
				bbc: "rgb(155,187,89)",
				pb: 1,
				bbw: 2,
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				blf: 1,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(155,187,89)",
				blc: "rgb(155,187,89)",
				bbc: "rgb(155,187,89)",
				brc: "rgb(155,187,89)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					blf: 1,
					btc: "rgb(155,187,89)",
					blc: "rgb(155,187,89)",
					bbc: "rgb(155,187,89)",
					brc: "rgb(155,187,89)"
				}],
				[{
					bgc: "rgb(235,241,222)",
					blf: 1,
					btc: "rgb(155,187,89)",
					blc: "rgb(155,187,89)",
					bbc: "rgb(155,187,89)",
					brc: "rgb(155,187,89)"
				}]
			]
		}
	}, {
		id: "tpl_18",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_18.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				blf: 1,
				btc: "rgb(128,100,162)",
				blc: "rgb(128,100,162)",
				brc: "rgb(128,100,162)",
				bbc: "rgb(128,100,162)",
				pb: 1,
				bbw: 2,
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				blf: 1,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(128,100,162)",
				blc: "rgb(128,100,162)",
				bbc: "rgb(128,100,162)",
				brc: "rgb(128,100,162)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					blf: 1,
					btc: "rgb(128,100,162)",
					blc: "rgb(128,100,162)",
					bbc: "rgb(128,100,162)",
					brc: "rgb(128,100,162)"
				}],
				[{
					bgc: "rgb(228,223,236)",
					blf: 1,
					btc: "rgb(128,100,162)",
					blc: "rgb(128,100,162)",
					bbc: "rgb(128,100,162)",
					brc: "rgb(128,100,162)"
				}]
			]
		}
	}, {
		id: "tpl_19",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_19.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				blf: 1,
				btc: "rgb(75,172,198)",
				blc: "rgb(75,172,198)",
				brc: "rgb(75,172,198)",
				bbc: "rgb(75,172,198)",
				pb: 1,
				bbw: 2,
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				blf: 1,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(75,172,198)",
				blc: "rgb(75,172,198)",
				bbc: "rgb(75,172,198)",
				brc: "rgb(75,172,198)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					blf: 1,
					btc: "rgb(75,172,198)",
					blc: "rgb(75,172,198)",
					bbc: "rgb(75,172,198)",
					brc: "rgb(75,172,198)"
				}],
				[{
					bgc: "rgb(218,238,243)",
					blf: 1,
					btc: "rgb(75,172,198)",
					blc: "rgb(75,172,198)",
					bbc: "rgb(75,172,198)",
					brc: "rgb(75,172,198)"
				}]
			]
		}
	}, {
		id: "tpl_20",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_light_20.png",
		type: "light",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				blf: 1,
				btc: "rgb(247,150,70)",
				blc: "rgb(247,150,70)",
				brc: "rgb(247,150,70)",
				bbc: "rgb(247,150,70)",
				pb: 1,
				bbw: 2,
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				blf: 1,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(247,150,70)",
				blc: "rgb(247,150,70)",
				bbc: "rgb(247,150,70)",
				brc: "rgb(247,150,70)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					blf: 1,
					btc: "rgb(247,150,70)",
					blc: "rgb(247,150,70)",
					bbc: "rgb(247,150,70)",
					brc: "rgb(247,150,70)"
				}],
				[{
					bgc: "rgb(253,233,217)",
					blf: 1,
					btc: "rgb(247,150,70)",
					blc: "rgb(247,150,70)",
					bbc: "rgb(247,150,70)",
					brc: "rgb(247,150,70)"
				}]
			]
		}
	}, {
		id: "tpl_21",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_0.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "black",
				bbc: "black",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "black",
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bbc: "black"
				}],
				[{
					bgc: "rgb(217,217,217)",
					bbc: "black"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "black"
			},
			lastColumn: {
				brc: "black"
			}
		}
	}, {
		id: "tpl_22",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_1.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(149,179,215)",
				bbc: "rgb(149,179,215)",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "rgb(79,129,189)",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(149,179,215)",
				bbc: "rgb(149,179,215)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bbc: "rgb(149,179,215)"
				}],
				[{
					bgc: "rgb(220,230,241)",
					bbc: "rgb(149,179,215)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(149,179,215)"
			},
			lastColumn: {
				brc: "rgb(149,179,215)"
			}
		}
	}, {
		id: "tpl_23",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_2.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(218,150,148)",
				bbc: "rgb(218,150,148)",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "rgb(192,80,77)",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(218,150,148)",
				bbc: "rgb(218,150,148)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bbc: "rgb(218,150,148)"
				}],
				[{
					bgc: "rgb(242,220,219)",
					bbc: "rgb(218,150,148)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(218,150,148)"
			},
			lastColumn: {
				brc: "rgb(218,150,148)"
			}
		}
	}, {
		id: "tpl_24",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_3.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(196,215,155)",
				bbc: "rgb(196,215,155)",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "rgb(155,187,89)",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(196,215,155)",
				bbc: "rgb(196,215,155)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bbc: "rgb(196,215,155)"
				}],
				[{
					bgc: "rgb(235,241,222)",
					bbc: "rgb(196,215,155)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(196,215,155)"
			},
			lastColumn: {
				brc: "rgb(196,215,155)"
			}
		}
	}, {
		id: "tpl_25",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_4.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(177,160,199)",
				bbc: "rgb(177,160,199)",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "rgb(128,100,162)",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(177,160,199)",
				bbc: "rgb(177,160,199)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bbc: "rgb(177,160,199)"
				}],
				[{
					bgc: "rgb(228,223,236)",
					bbc: "rgb(177,160,199)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(177,160,199)"
			},
			lastColumn: {
				brc: "rgb(177,160,199)"
			}
		}
	}, {
		id: "tpl_26",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_5.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(146,205,220)",
				bbc: "rgb(146,205,220)",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "rgb(75,172,198)",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(146,205,220)",
				bbc: "rgb(146,205,220)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bbc: "rgb(146,205,220)"
				}],
				[{
					bgc: "rgb(218,238,243)",
					bbc: "rgb(146,205,220)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(146,205,220)"
			},
			lastColumn: {
				brc: "rgb(146,205,220)"
			}
		}
	}, {
		id: "tpl_27",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_6.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "rgb(250,191,143)",
				bbc: "rgb(250,191,143)",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "rgb(247,150,70)",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "rgb(250,191,143)",
				bbc: "rgb(250,191,143)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bbc: "rgb(250,191,143)"
				}],
				[{
					bgc: "rgb(253,233,217)",
					bbc: "rgb(250,191,143)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(250,191,143)"
			},
			lastColumn: {
				brc: "rgb(250,191,143)"
			}
		}
	}, {
		id: "tpl_28",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_7.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				btf: 1,
				blf: 1,
				btc: "white",
				blc: "white",
				brc: "white",
				bbc: "white",
				pb: 1,
				bbw: 2,
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "black",
				blf: 1,
				btf: 2,
				btc: "white",
				blc: "white",
				bbc: "white",
				brc: "white",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(217,217,217)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}],
				[{
					bgc: "rgb(166,166,166)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}]
			]
		}
	}, {
		id: "tpl_29",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_8.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(79,129,189)",
				btf: 1,
				blf: 1,
				btc: "white",
				blc: "white",
				brc: "white",
				bbc: "white",
				pb: 1,
				bbw: 2,
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(79,129,189)",
				blf: 1,
				btf: 2,
				btc: "white",
				blc: "white",
				bbc: "white",
				brc: "white",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(220,230,241)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}],
				[{
					bgc: "rgb(184,204,228)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}]
			]
		}
	}, {
		id: "tpl_30",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_9.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(192,80,77)",
				btf: 1,
				blf: 1,
				btc: "white",
				blc: "white",
				brc: "white",
				bbc: "white",
				pb: 1,
				bbw: 2,
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(192,80,77)",
				blf: 1,
				btf: 2,
				btc: "white",
				blc: "white",
				bbc: "white",
				brc: "white",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(242,220,219)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}],
				[{
					bgc: "rgb(230,184,183)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}]
			]
		}
	}, {
		id: "tpl_31",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_10.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(155,187,89)",
				btf: 1,
				blf: 1,
				btc: "white",
				blc: "white",
				brc: "white",
				bbc: "white",
				pb: 1,
				bbw: 2,
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(155,187,89)",
				blf: 1,
				btf: 2,
				btc: "white",
				blc: "white",
				bbc: "white",
				brc: "white",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(235,241,222)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}],
				[{
					bgc: "rgb(216,228,188)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}]
			]
		}
	}, {
		id: "tpl_32",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_11.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(128,100,162)",
				btf: 1,
				blf: 1,
				btc: "white",
				blc: "white",
				brc: "white",
				bbc: "white",
				pb: 1,
				bbw: 2,
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(128,100,162)",
				blf: 1,
				btf: 2,
				btc: "white",
				blc: "white",
				bbc: "white",
				brc: "white",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(228,223,236)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}],
				[{
					bgc: "rgb(204,192,218)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}]
			]
		}
	}, {
		id: "tpl_33",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_12.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(75,172,198)",
				btf: 1,
				blf: 1,
				btc: "white",
				blc: "white",
				brc: "white",
				bbc: "white",
				pb: 1,
				bbw: 2,
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(75,172,198)",
				blf: 1,
				btf: 2,
				btc: "white",
				blc: "white",
				bbc: "white",
				brc: "white",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(218,238,243)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}],
				[{
					bgc: "rgb(183,222,232)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}]
			]
		}
	}, {
		id: "tpl_34",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_13.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(247,150,70)",
				btf: 1,
				blf: 1,
				btc: "white",
				blc: "white",
				brc: "white",
				bbc: "white",
				pb: 1,
				bbw: 2,
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(247,150,70)",
				blf: 1,
				btf: 2,
				btc: "white",
				blc: "white",
				bbc: "white",
				brc: "white",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(253,233,217)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}],
				[{
					bgc: "rgb(252,213,180)",
					blf: 1,
					btc: "white",
					blc: "white",
					bbc: "white",
					brc: "white"
				}]
			]
		}
	}, {
		id: "tpl_35",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_14.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				btf: 1,
				btc: "black",
				bbc: "black",
				pb: 1,
				bbw: 2,
				color: "white",
				bgc: "black",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 0,
				btc: "black",
				brc: "black",
				bbw: 2,
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(217,217,217)",
					bbc: "black",
					brc: "black"
				}],
				[{
					brc: "black",
					bbc: "black"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "black"
			},
			lastColumn: {
				brc: "black"
			}
		}
	}, {
		id: "tpl_36",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_15.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(79,129,189)",
				btf: 2,
				btc: "black",
				bbw: 2,
				pt: 1,
				bbc: "black",
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 0,
				btc: "black",
				bbw: 2,
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(217,217,217)"
				}]
			]
		}
	}, {
		id: "tpl_37",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_16.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(192,80,77)",
				btf: 2,
				btc: "black",
				bbw: 2,
				pt: 1,
				bbc: "black",
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 0,
				btc: "black",
				bbw: 2,
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(217,217,217)"
				}]
			]
		}
	}, {
		id: "tpl_38",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_17.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(155,187,89)",
				btf: 2,
				btc: "black",
				bbw: 2,
				pt: 1,
				bbc: "black",
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 0,
				btc: "black",
				bbw: 2,
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(217,217,217)"
				}]
			]
		}
	}, {
		id: "tpl_39",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_18.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(128,100,162)",
				btf: 2,
				btc: "black",
				bbw: 2,
				pt: 1,
				bbc: "black",
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 0,
				btc: "black",
				bbw: 2,
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(217,217,217)"
				}]
			]
		}
	}, {
		id: "tpl_40",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_19.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(75,172,198)",
				btf: 2,
				btc: "black",
				bbw: 2,
				pt: 1,
				bbc: "black",
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 0,
				btc: "black",
				bbw: 2,
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(217,217,217)"
				}]
			]
		}
	}, {
		id: "tpl_41",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_20.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(247,150,70)",
				btf: 2,
				btc: "black",
				bbw: 2,
				pt: 1,
				bbc: "black",
				color: "white",
				fw: "bold"
			}],
			footStyle: [{
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 0,
				btc: "black",
				bbw: 2,
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{}],
				[{
					bgc: "rgb(217,217,217)"
				}]
			]
		}
	}, {
		id: "tpl_42",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_21.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(217,217,217)",
				btf: 1,
				btc: "black",
				brc: "black",
				bbc: "black",
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(217,217,217)",
				blf: 1,
				btf: 2,
				btc: "black",
				blc: "black",
				bbc: "black",
				brc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(217,217,217)",
					bbc: "black",
					brc: "black"
				}],
				[{
					bgc: "rgb(166,166,166)",
					brc: "black",
					bbc: "black"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "black"
			},
			lastColumn: {
				brc: "black"
			}
		}
	}, {
		id: "tpl_43",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_22.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(220,230,241)",
				btf: 1,
				btc: "rgb(149,179,215)",
				brc: "rgb(149,179,215)",
				bbc: "rgb(149,179,215)",
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(220,230,241)",
				blf: 1,
				btf: 2,
				btc: "rgb(149,179,215)",
				blc: "rgb(149,179,215)",
				bbc: "rgb(149,179,215)",
				brc: "rgb(149,179,215)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(220,230,241)",
					bbc: "rgb(149,179,215)",
					brc: "rgb(149,179,215)"
				}],
				[{
					bgc: "rgb(184,204,228)",
					brc: "rgb(149,179,215)",
					bbc: "rgb(149,179,215)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(149,179,215)"
			},
			lastColumn: {
				brc: "rgb(149,179,215)"
			}
		}
	}, {
		id: "tpl_44",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_23.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(242,220,219)",
				btf: 1,
				btc: "rgb(218,150,148)",
				brc: "rgb(218,150,148)",
				bbc: "rgb(218,150,148)",
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(242,220,219)",
				blf: 1,
				btf: 2,
				btc: "rgb(218,150,148)",
				blc: "rgb(218,150,148)",
				bbc: "rgb(218,150,148)",
				brc: "rgb(218,150,148)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(242,220,219)",
					bbc: "rgb(218,150,148)",
					brc: "rgb(218,150,148)"
				}],
				[{
					bgc: "rgb(230,184,183)",
					brc: "rgb(218,150,148)",
					bbc: "rgb(218,150,148)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(218,150,148)"
			},
			lastColumn: {
				brc: "rgb(218,150,148)"
			}
		}
	}, {
		id: "tpl_45",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_24.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(235,241,222)",
				btf: 1,
				btc: "rgb(196,215,155)",
				brc: "rgb(196,215,155)",
				bbc: "rgb(196,215,155)",
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(235,241,222)",
				blf: 1,
				btf: 2,
				btc: "rgb(196,215,155)",
				blc: "rgb(196,215,155)",
				bbc: "rgb(196,215,155)",
				brc: "rgb(196,215,155)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(235,241,222)",
					bbc: "rgb(196,215,155)",
					brc: "rgb(196,215,155)"
				}],
				[{
					bgc: "rgb(216,228,188)",
					brc: "rgb(196,215,155)",
					bbc: "rgb(196,215,155)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(196,215,155)"
			},
			lastColumn: {
				brc: "rgb(196,215,155)"
			}
		}
	}, {
		id: "tpl_46",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_25.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(228,223,236)",
				btf: 1,
				btc: "rgb(177,160,199)",
				brc: "rgb(177,160,199)",
				bbc: "rgb(177,160,199)",
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(228,223,236)",
				blf: 1,
				btf: 2,
				btc: "rgb(177,160,199)",
				blc: "rgb(177,160,199)",
				bbc: "rgb(177,160,199)",
				brc: "rgb(177,160,199)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(228,223,236)",
					bbc: "rgb(177,160,199)",
					brc: "rgb(177,160,199)"
				}],
				[{
					bgc: "rgb(204,192,218)",
					brc: "rgb(177,160,199)",
					bbc: "rgb(177,160,199)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(177,160,199)"
			},
			lastColumn: {
				brc: "rgb(177,160,199)"
			}
		}
	}, {
		id: "tpl_47",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_26.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(218,238,243)",
				btf: 1,
				btc: "rgb(149,205,220)",
				brc: "rgb(149,205,220)",
				bbc: "rgb(149,205,220)",
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(218,238,243)",
				blf: 1,
				btf: 2,
				btc: "rgb(149,205,220)",
				blc: "rgb(149,205,220)",
				bbc: "rgb(149,205,220)",
				brc: "rgb(149,205,220)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(218,238,243)",
					bbc: "rgb(149,205,220)",
					brc: "rgb(149,205,220)"
				}],
				[{
					bgc: "rgb(183,222,232)",
					brc: "rgb(149,205,220)",
					bbc: "rgb(149,205,220)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(149,205,220)"
			},
			lastColumn: {
				brc: "rgb(149,205,220)"
			}
		}
	}, {
		id: "tpl_48",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_medium_27.png",
		type: "medium",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(253,233,217)",
				btf: 1,
				btc: "rgb(250,191,143)",
				brc: "rgb(250,191,143)",
				bbc: "rgb(250,191,143)",
				color: "black",
				fw: "bold"
			}],
			footStyle: [{
				bgc: "rgb(253,233,217)",
				blf: 1,
				btf: 2,
				btc: "rgb(250,191,143)",
				blc: "rgb(250,191,143)",
				bbc: "rgb(250,191,143)",
				brc: "rgb(250,191,143)",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(253,233,217)",
					bbc: "rgb(250,191,143)",
					brc: "rgb(250,191,143)"
				}],
				[{
					bgc: "rgb(252,213,180)",
					brc: "rgb(250,191,143)",
					bbc: "rgb(250,191,143)"
				}]
			],
			firstColumn: {
				blf: 1,
				blc: "rgb(250,191,143)"
			},
			lastColumn: {
				brc: "rgb(250,191,143)"
			}
		}
	}, {
		id: "tpl_49",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_0.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				fw: "bold",
				pt: 1,
				bbw: 2,
				bbc: "white",
				color: "white"
			}],
			footStyle: [{
				btf: 2,
				btc: "white",
				bgc: "black",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(115,115,115)",
					color: "white"
				}],
				[{
					bgc: "rgb(64,64,64)",
					color: "white"
				}]
			]
		}
	}, {
		id: "tpl_50",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_1.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				fw: "bold",
				pt: 1,
				bbw: 2,
				bbc: "white",
				color: "white"
			}],
			footStyle: [{
				btf: 2,
				btc: "white",
				bgc: "rgb(36,64,98)",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(79,129,189)",
					color: "white"
				}],
				[{
					bgc: "rgb(54,96,146)",
					color: "white"
				}]
			]
		}
	}, {
		id: "tpl_51",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_2.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				fw: "bold",
				pt: 1,
				bbw: 2,
				bbc: "white",
				color: "white"
			}],
			footStyle: [{
				btf: 2,
				btc: "white",
				bgc: "rgb(99,37,35)",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(192,80,77)",
					color: "white"
				}],
				[{
					bgc: "rgb(150,54,52)",
					color: "white"
				}]
			]
		}
	}, {
		id: "tpl_52",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_3.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				fw: "bold",
				pt: 1,
				bbw: 2,
				bbc: "white",
				color: "white"
			}],
			footStyle: [{
				btf: 2,
				btc: "white",
				bgc: "rgb(79,98,40)",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(155,187,89)",
					color: "white"
				}],
				[{
					bgc: "rgb(118,147,60)",
					color: "white"
				}]
			]
		}
	}, {
		id: "tpl_53",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_4.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				fw: "bold",
				pt: 1,
				bbw: 2,
				bbc: "white",
				color: "white"
			}],
			footStyle: [{
				btf: 2,
				btc: "white",
				bgc: "rgb(64,49,81)",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(128,100,162)",
					color: "white"
				}],
				[{
					bgc: "rgb(96,73,122)",
					color: "white"
				}]
			]
		}
	}, {
		id: "tpl_54",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_5.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				fw: "bold",
				pt: 1,
				bbw: 2,
				bbc: "white",
				color: "white"
			}],
			footStyle: [{
				btf: 2,
				btc: "white",
				bgc: "rgb(33,89,103)",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(75,172,198)",
					color: "white"
				}],
				[{
					bgc: "rgb(49,134,155)",
					color: "white"
				}]
			]
		}
	}, {
		id: "tpl_55",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_6.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				fw: "bold",
				pt: 1,
				bbw: 2,
				bbc: "white",
				color: "white"
			}],
			footStyle: [{
				btf: 2,
				btc: "white",
				bgc: "rgb(151,71,6)",
				color: "white",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(247,150,70)",
					color: "white"
				}],
				[{
					bgc: "rgb(226,107,10)",
					color: "white"
				}]
			]
		}
	}, {
		id: "tpl_56",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_7.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "black",
				color: "white"
			}],
			footStyle: [{
				bgc: "rgb(217,217,217)",
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(217,217,217)"
				}],
				[{
					bgc: "rgb(166,166,166)"
				}]
			]
		}
	}, {
		id: "tpl_57",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_8.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(192,80,77)",
				color: "white"
			}],
			footStyle: [{
				bgc: "rgb(220,230,241)",
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(220,230,241)"
				}],
				[{
					bgc: "rgb(184,204,228)"
				}]
			]
		}
	}, {
		id: "tpl_58",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_9.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(128,100,162)",
				color: "white"
			}],
			footStyle: [{
				bgc: "rgb(235,241,222)",
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(235,241,222)"
				}],
				[{
					bgc: "rgb(216,228,188)"
				}]
			]
		}
	}, {
		id: "tpl_59",
		url: SCONFIG.ICONS_PATH + "/64px/tpl_dark_10.png",
		type: "dark",
		tip: SLANG[''],
		tpl: {
			headStyle: [{
				bgc: "rgb(247,150,70)",
				color: "white"
			}],
			footStyle: [{
				bgc: "rgb(218,238,243)",
				wrap: true,
				btw: 1,
				btt: "double",
				bts: "solid",
				pt: 1,
				btc: "black",
				color: "black",
				fw: "bold"
			}],
			bodyStyle: [
				[{
					bgc: "rgb(218,238,243)"
				}],
				[{
					bgc: "rgb(183,222,232)"
				}]
			]
		}
	}];
});

Ext.define("EnterpriseSheet.sheet.model.CustomModel", {
	extend: "Ext.data.Model",
	fields: ["id", "text", "iconCls"]
});

Ext.define("EnterpriseSheet.model.FileModel", {
	extend: "Ext.data.Model",
	fields: [{
		name: "id",
		type: "string"
	}, {
		name: "author",
		type: "string"
	}, {
		name: "exname",
		type: "string"
	}, {
		name: "name",
		type: "string"
	}, {
		name: "title",
		type: "string"
	}, {
		name: "permission",
		type: "string"
	}, {
		name: "updateDate",
		type: "string"
	}, {
		name: "userRole",
		type: "string"
	}]
});

Ext.define("EnterpriseSheet.sheet.model.CellModel", {
	extend: "Ext.data.Model",
	requires: ["EnterpriseSheet.common.Common"],
	fields: [{
		name: "sheet",
		type: "int"
	}, {
		name: "row",
		type: "int"
	}, {
		name: "col",
		type: "int"
	}, {
		name: "isCal",
		type: "int"
	}, {
		name: "json",
		type: "auto",
		convert: function(value, rec) {
			var o;
			if(value != null && Ext.isString(value)) {
				try {
					o = Ext.decode(value);
				} catch(e) {}
			} else {
				o = value;
			}
			if(Ext.isObject(o)) {
				delete o.timestamp;
				delete o.value;
				delete o.cdtVal;
				if(Ext.isNumber(o.afrow)) {
					var row = o.afrow + rec.data.row,
						col = o.afcol + rec.data.col;
					if(row !== rec.data.row || col !== rec.data.col) {
						o.data = "=" + SCOM.number2Letter(col) + row;
					}
				}
			} else {
				o = {};
			}
			return o;
		}
	}]
});

Ext.define("EnterpriseSheet.sheet.model.CellTplModel", {
	extend: "Ext.data.Model",
	fields: [{
		name: "text",
		type: "string"
	}, {
		name: "tip",
		type: "string"
	}, {
		name: "style",
		type: "string"
	}, {
		name: "property",
		type: "auto",
		convert: function(val, rec) {
			if(Ext.isString(val) && val) {
				val = Ext.decode(val);
			}
			return val;
		}
	}, {
		name: "fn",
		type: "auto"
	}]
});

Ext.define("EnterpriseSheet.sheet.model.ConditionModel", {
	extend: "Ext.data.Model",
	fields: [{
		name: "id",
		type: "string"
	}, {
		name: "sheet",
		type: "int"
	}, {
		name: "name",
		type: "string"
	}, {
		name: "opt",
		type: "auto",
		convert: function(val, rec) {
			if(Ext.isString(val) && val) {
				val = Ext.decode(val);
			}
			return val;
		}
	}, {
		name: "rng",
		type: "auto"
	}, {
		name: "coord",
		type: "auto"
	}]
});

Ext.define("EnterpriseSheet.sheet.model.InfoModel", {
	extend: "Ext.data.Model",
	fields: [{
		name: "name"
	}, {
		name: "display"
	}, {
		name: "value"
	}]
});

Ext.define("EnterpriseSheet.sheet.model.TableTplModel", {
	extend: "Ext.data.Model",
	fields: [{
		name: "url",
		type: "string"
	}, {
		name: "tip",
		type: "string"
	}, {
		name: "tpl",
		type: "auto",
		convert: function(val, rec) {
			if(Ext.isString(val) && val) {
				val = Ext.decode(val);
			}
			return val;
		}
	}]
});

Ext.define("EnterpriseSheet.sheet.model.TargetModel", {
	extend: "Ext.data.Model",
	fields: [{
		name: "sheet",
		type: "int"
	}, {
		name: "sheetName"
	}, {
		name: "row",
		type: "int"
	}, {
		name: "col",
		type: "int"
	}, {
		name: "cell"
	}, {
		name: "data"
	}]
});

Ext.define("EnterpriseSheet.sheet.data.CustomStore", {
	extend: "Ext.data.Store",
	model: "EnterpriseSheet.sheet.model.CustomModel",
	constructor: function() {
		this.callParent(arguments);
	},
	proxy: {
		type: "ajax",
		url: SCONFIG.js_standalone ? "" : SCONFIG.urls.listCustom,
		reader: {
			type: "json",
			rootProperty: "root"
		}
	}
});﻿
Ext.define("EnterpriseSheet.sheet.data.CalReferenceMap", {
	extend: "EnterpriseSheet.pure.sheet.data.CalReferenceMap"
});

Ext.define("EnterpriseSheet.sheet.data.Store", {
	extend: "EnterpriseSheet.pure.sheet.data.Store"
});

Ext.define("EnterpriseSheet.sheet.data.PullingStore", {
	extend: "EnterpriseSheet.pure.sheet.data.PullingStore"
});

Ext.define("EnterpriseSheet.sheet.data.RangeStore", {
	extend: "Ext.data.Store",
	seriesPosition: "row",
	useAbs: false,
	constructor: function(config) {
		Ext.apply(this, config);
		this.storeId = "rs-" + Ext.id();
		this.generateFieldsData();
		this.callParent();
		var store = this.sheet.getStore();
		this.mon(store, {
			scope: this,
			valuechange: this.syncValueChange,
			aftersortspan: this.afterSortSpan,
			moverows: this.onMoveRows
		});
		this.mon(this.sheet, {
			scope: this,
			holdremoverow: this.onRemoveRow,
			holdremovecolumn: this.onRemoveColumn,
			holdremovecell: this.onRemoveCell,
			holdinsertcolumn: this.onInsertColumn,
			holdinsertrow: this.onInsertRow,
			holdinsertcell: this.onInsertCell
		});
		this.mon(store, "valuechange", this.onValueChange, this, {
			buffer: 50
		});
		this.on("regeneratedata", this.regenerateData, this, {
			buffer: 100
		});
		this.checkLoad();
	},
	checkLoad: function() {
		var store = this.sheet.getStore();
		var coord = [];
		if(this.categories) {
			coord = coord.concat(this.categories);
		}
		if(this.labels) {
			coord = coord.concat(this.labels);
		}
		if(this.series) {
			coord = coord.concat(this.series);
		}
		store.checkLoadCoord(coord, function() {
			this.fireEvent("regeneratedata", this);
		}, this);
	},
	getSourceConfig: function() {
		var curSheetId = this.sheet.getSheetId();
		var series = SCOM.copy(this.series);
		for(var i = 0, len = series.length; i < len; i++) {
			var it = series[i];
			if(it[0] == curSheetId) {
				it[0] = "";
			}
		}
		var categories = SCOM.copy(this.categories);
		if(categories) {
			for(var i = 0, len = categories.length; i < len; i++) {
				var it = categories[i];
				if(it[0] == curSheetId) {
					it[0] = "";
				}
			}
		}
		var labels = SCOM.copy(this.labels);
		if(labels) {
			for(var i = 0, len = labels.length; i < len; i++) {
				var it = labels[i];
				if(it[0] == curSheetId) {
					it[0] = "";
				}
			}
		}
		return {
			series: series,
			categories: categories,
			labels: labels,
			usAbs: this.useAbs,
			cacheFields: SCOM.copy(this.cacheFields)
		};
	},
	generateFieldsData: function() {
		if(!this.series && this.coord) {
			this.parseRangeData();
		} else {
			if(!this.cacheFields) {
				this.cacheFields = [{
					name: "category"
				}];
				for(var i = 0, len = this.series.length; i < len; i++) {
					this.cacheFields.push({
						name: ("row" === this.seriesPosition ? SLANG.row : SLANG.column) + (i + 1)
					});
				}
			}
			var flag;
			for(var i = 0, len = this.cacheFields.length; i < len; i++) {
				if("category" === this.cacheFields[i].name) {
					flag = true;
					break;
				}
			}
			if(!flag) {
				this.cacheFields = [{
					name: "category"
				}].concat(this.cacheFields);
			}
			for(var i = 0, len = this.cacheFields.length; i < len; i++) {
				var title = this.cacheFields[i].title;
				if(title) {
					this.cacheFields[i].name = title;
				}
			}
			this.fields = SCOM.copy(this.cacheFields);
		}
		this.inlineData = this.getDataFromSeries();
	},
	getCategoryByIndex: function(index) {
		if(this.categories && index < this.categories.length) {
			var span = this.categories[index];
			var cd = this.sheet.getCellValue(span[0], span[1], span[2]);
			return SCOM.getPureText(cd.data);
		}
	},
	getLabelByIndex: function(index) {
		if(this.labels && index < this.labels.length) {
			var span = this.labels[index];
			var cd = this.sheet.getCellValue(span[0], span[1], span[2]);
			return SCOM.getPureText(cd.data);
		}
	},
	getSeriesPosition: function() {
		return this.seriesPosition;
	},
	generateSeries: function(sheetId, minRow, minCol, maxRow, maxCol) {
		var series = [];
		if("row" == this.seriesPosition) {
			for(var i = minRow; i <= maxRow; i++) {
				series.push([sheetId, i, minCol, i, maxCol]);
			}
			var fields = [{
				name: "category"
			}];
			for(var i = minRow; i <= maxRow; i++) {
				fields.push({
					name: this.getCategoryByIndex(i - minRow) || SLANG.row + i
				});
			}
			if(this.model && Ext.isFunction(this.model.setFields)) {
				this.model.setFields(fields);
			} else {
				this.fields = fields;
			}
			this.cacheFields = [].concat(fields);
		} else {
			for(var i = minCol; i <= maxCol; i++) {
				series.push([sheetId, minRow, i, maxRow, i]);
			}
			var fields = [{
				name: "category"
			}];
			for(var i = minCol; i <= maxCol; i++) {
				fields.push({
					name: this.getCategoryByIndex(i - minCol) || SLANG.column + i
				});
			}
			if(this.model && Ext.isFunction(this.model.setFields)) {
				this.model.setFields(fields);
			} else {
				this.fields = fields;
			}
			this.cacheFields = [].concat(fields);
		}
		this.series = series;
	},
	generateCategoriesAndLabels: function(span, rowFlag, colFlag) {
		var sheetId = span[0],
			minRow = span[1],
			minCol = span[2],
			maxRow = span[3],
			maxCol = span[4];
		var categories = [],
			labels = [];
		delete this.categories;
		delete this.labels;
		if("row" == this.seriesPosition) {
			if(colFlag) {
				for(var i = rowFlag ? minRow + 1 : minRow; i <= maxRow; i++) {
					categories.push([sheetId, i, minCol, i, minCol]);
				}
				this.categories = categories;
			}
			if(rowFlag) {
				for(var i = colFlag ? minCol + 1 : minCol; i <= maxCol; i++) {
					labels.push([sheetId, minRow, i, minRow, i]);
				}
				this.labels = labels;
			}
		} else {
			if(rowFlag) {
				for(var i = colFlag ? minCol + 1 : minCol; i <= maxCol; i++) {
					categories.push([sheetId, minRow, i, minRow, i]);
				}
				this.categories = categories;
			}
			if(colFlag) {
				for(var i = rowFlag ? minRow + 1 : minRow; i <= maxRow; i++) {
					labels.push([sheetId, i, minCol, i, minCol]);
				}
				this.labels = labels;
			}
		}
	},
	parseRangeData: function(config) {
		var span = this.coord[0];
		var sheetId = span[0],
			minRow = span[1],
			minCol = span[2],
			maxRow = span[3],
			maxCol = span[4];
		if(!this.seriesPosition) {
			if(minRow == maxRow) {
				this.seriesPosition = "row";
			} else if(minCol == maxCol) {
				this.seriesPosition = "col";
			}
		}
		var sheet = this.sheet,
			store = sheet.getStore();
		var rowFlag = false,
			colFlag = false;
		if(config) {
			if(Ext.isDefined(config.firstRowLabel)) {
				this.firstRowLabel = config.firstRowLabel;
			}
			if(Ext.isDefined(config.firstColLabel)) {
				this.firstColLabel = config.firstColLabel;
			}
		}
		if(Ext.isDefined(this.firstRowLabel) || Ext.isDefined(this.firstColLabel)) {
			rowFlag = this.firstRowLabel;
			if(rowFlag) {
				minRow++;
			}
			colFlag = this.firstColLabel;
			if(colFlag) {
				minCol++;
			}
		} else {
			var corner = store.getCell(sheetId, minRow, minCol);
			if(SCOM.nullOrUndefined(corner.data)) {
				rowFlag = true;
				colFlag = true;
				minRow++;
				minCol++;
			} else {
				var nonNumFlag = true;
				for(var i = minRow; i <= maxRow; i++) {
					var cd = sheet.getCellValue(sheetId, i, minCol);
					if(SCOM.canbeNumber(cd.data)) {
						nonNumFlag = false;
						break;
					}
				}
				if(nonNumFlag) {
					colFlag = true;
					minCol++;
				}
				nonNumFlag = true;
				for(var i = minCol; i <= maxCol; i++) {
					var cd = sheet.getCellValue(sheetId, minRow, i);
					if(SCOM.canbeNumber(cd.data)) {
						nonNumFlag = false;
						break;
					}
				}
				if(nonNumFlag) {
					rowFlag = true;
					minRow++;
				}
			}
			this.firstRowLabel = rowFlag || false;
			this.firstColLabel = colFlag || false;
		}
		this.generateCategoriesAndLabels(span, rowFlag, colFlag);
		this.generateSeries(sheetId, minRow, minCol, maxRow, maxCol);
	},
	getDataFromSeries: function() {
		var sheet = this.sheet;
		var fields = this.cacheFields;
		var data = [],
			series = this.series;
		var len = series.length;
		if("row" == this.seriesPosition) {
			var index, max = -1,
				span;
			for(var i = 0; i < len; i++) {
				span = series[i];
				var offset = span[4] - span[2];
				if(offset > max) {
					max = offset;
					index = i;
				}
			}
			if(SCOM.nullOrUndefined(index)) {
				return;
			}
			var span = series[index];
			var min = span[2];
			max = span[4];
			for(var j = min; j <= max; j++) {
				var index = j - min;
				var category = this.getLabelByIndex(index) || index + 1;
				category = category.toString();
				var obj = {
					category: category
				};
				for(var i = 0; i < len; i++) {
					span = series[i];
					var col = j - min + span[2];
					var num = 0;
					if(col <= span[4]) {
						var cd = sheet.getCellValue(span[0], span[1], col);
						num = Number(cd.data);
						num = Ext.isNumber(num) ? num : 0;
					}
					if(true == this.useAbs) {
						if(0 > num) {
							num = -num;
						}
					}
					obj[fields[i + 1].name] = num;
				}
				data.push(obj);
			}
		} else {
			var index, max = -1,
				span;
			for(var i = 0; i < len; i++) {
				span = series[i];
				var offset = span[3] - span[1];
				if(offset > max) {
					max = offset;
					index = i;
				}
			}
			if(SCOM.nullOrUndefined(index)) {
				return;
			}
			var span = series[index];
			var min = span[1];
			max = span[3];
			for(var j = min; j <= max; j++) {
				var index = j - min;
				var category = this.getLabelByIndex(index) || index + 1;
				category = category.toString();
				var obj = {
					category: category
				};
				for(var i = 0; i < len; i++) {
					span = series[i];
					var row = j - min + span[1];
					var num = 0;
					if(row <= span[3]) {
						var cd = sheet.getCellValue(span[0], row, span[2]);
						num = Number(cd.data);
						num = Ext.isNumber(num) ? num : 0;
					}
					if(this.useAbs) {
						if(0 > num) {
							num = -num;
						}
					}
					obj[fields[i + 1].name] = num;
				}
				data.push(obj);
			}
		}
		return data;
	},
	onValueChange: function(sheetId, row, col, modified, deleted, origin, current, store) {
		var coord = [];
		if(this.categories) {
			coord = coord.concat(this.categories);
		}
		if(this.labels) {
			coord = coord.concat(this.labels);
		}
		if(this.series) {
			coord = coord.concat(this.series);
		}
		var sheet = this.sheet;
		var store = sheet.getStore();
		store.walkRange(coord, function(rd) {
			var s = rd.data.sheet,
				r = rd.data.row,
				c = rd.data.col,
				json = rd.data.json;
			if(sheet.isCalculateCell(json)) {
				sheet.processCalCdtData(s, r, c);
			}
		}, sheet);
	},
	syncValueChange: function(sheet, row, col, modified, deleted, origin, current, store) {
		if(this.categories) {
			for(var i = 0, len = this.categories.length; i < len; i++) {
				var span = this.categories[i];
				if(sheet == span[0] && span[1] <= row && span[3] >= row && span[2] <= col && span[4] >= col) {
					this.cacheFields[i + 1].title = this.getCategoryByIndex(i);
					this.fireEvent("fieldtitlechange", this.cacheFields, this);
					this.fireEvent("regeneratedata", this);
					return;
				}
			}
		}
		if(this.labels) {
			for(var i = 0, len = this.labels.length; i < len; i++) {
				var span = this.labels[i];
				if(sheet == span[0] && span[1] <= row && span[3] >= row && span[2] <= col && span[4] >= col) {
					this.fireEvent("regeneratedata", this);
					return;
				}
			}
		}
		if(this.series) {
			for(var i = 0, len = this.series.length; i < len; i++) {
				var span = this.series[i];
				if(sheet == span[0] && span[1] <= row && span[3] >= row && span[2] <= col && span[4] >= col) {
					this.fireEvent("regeneratedata", this);
					return;
				}
			}
		}
	},
	afterSortSpan: function(span, keys, dir, sortOn, expand, allString, diff) {
		this.regenerateAll();
	},
	onMoveRows: function(sheetId, diff, mincol, maxcol, flag) {
		this.regenerateAll();
	},
	regenerateData: function() {
		if(this.series) {
			var data = this.getDataFromSeries();
			this.loadData(data);
		} else {
			this.removeAll();
		}
	},
	regenerateAll: function() {
		if(this.categories) {
			var cacheFields = [this.cacheFields[0]];
			for(var i = 0, len = this.categories.length; i < len; i++) {
				var j = i + 1;
				this.cacheFields[j].title = this.getCategoryByIndex(i);
				cacheFields.push(this.cacheFields[j]);
			}
			this.cacheFields = cacheFields;
			this.fireEvent("fieldtitlechange", this.cacheFields, this);
			this.fireEvent("regeneratedata", this);
			return;
		}
		this.fireEvent("regeneratedata", this);
		return;
	},
	getCoordSpan: function() {
		return [].concat(this.coord);
	},
	getCoordReference: function() {
		var arr = SCOM.copy(this.series);
		if(this.categories) {
			var categories = [];
			for(var i = 0, len = this.categories.length; i < len; i++) {
				categories.push({
					span: [].concat(this.categories[i]),
					cls: "ss-rm-nodot"
				});
			}
			arr = arr.concat(categories);
		}
		if(this.labels) {
			var labels = [];
			for(var i = 0, len = this.labels.length; i < len; i++) {
				labels.push({
					span: [].concat(this.labels[i]),
					cls: "ss-rm-nodot"
				});
			}
			arr = arr.concat(labels);
		}
		return arr;
	},
	monitorMoveReference: function(flag) {
		var sheet = this.sheet;
		if(flag) {
			this.mon(sheet, {
				scope: this,
				endmovereference: this.endMoveReference,
				beforemovingreference: this.beforeMovingReference
			});
		} else {
			this.mun(sheet, {
				scope: this,
				endmovereference: this.endMoveReference,
				beforemovingreference: this.beforeMovingReference
			});
		}
	},
	endMoveReference: function(draggingCoordSpan, rm) {
		var sheetId = this.sheet.getSheetId();
		var fields = this.cacheFields;
		var originSpan = [].concat(draggingCoordSpan.span);
		if(SCOM.nullOrUndefined(originSpan[0])) {
			originSpan[0] = sheetId;
		}
		var currentSpan = [].concat(draggingCoordSpan.currentSpan);
		currentSpan[0] = originSpan[0];
		var oid = originSpan.join("$");
		if(this.categories) {
			for(var i = 0, len = this.categories.length; i < len; i++) {
				var span = this.categories[i];
				var id = span.join("$");
				if(id == oid) {
					this.categories[i] = [].concat(currentSpan);
					fields[i + 1].title = this.getCategoryByIndex(i);
					this.fireEvent("fieldtitlechange", this.cacheFields, this);
					break;
				}
			}
		}
		if(this.labels) {
			for(var i = 0, len = this.labels.length; i < len; i++) {
				var span = this.labels[i];
				var id = span.join("$");
				if(id == oid) {
					this.labels[i] = [].concat(currentSpan);
					break;
				}
			}
		}
		for(var i = 0, len = this.series.length; i < len; i++) {
			var span = this.series[i];
			var id = span.join("$");
			if(id == oid) {
				this.series[i] = [].concat(currentSpan);
				if("row" == this.seriesPosition) {
					fields[i + 1].title = this.getCategoryByIndex(i) || SLANG.row + currentSpan[1];
				} else {
					fields[i + 1].title = this.getCategoryByIndex(i) || SLANG.column + currentSpan[2];
				}
				this.fireEvent("fieldtitlechange", this.cacheFields, this);
				break;
			}
		}
		this.fireEvent("regeneratedata", this);
		this.fireEvent("relatedcoordchange", this);
		this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
	},
	beforeMovingReference: function(startPos, endPos) {
		if("row" == this.seriesPosition) {
			endPos.row = startPos.row;
		} else {
			endPos.col = startPos.col;
		}
	},
	isSeriesRect: function(series) {
		var count = 0;
		series = series || this.series;
		var pos = this.getMinMaxPos(series);
		var minRow = pos[0],
			minCol = pos[1],
			maxRow = pos[2],
			maxCol = pos[3];
		for(var i = 0, len = series.length; i < len; i++) {
			var it = series[i];
			count += (it[3] - it[1] + 1) * (it[4] - it[2] + 1);
		}
		var take = (maxRow - minRow + 1) * (maxCol - minCol + 1);
		if(count == take) {
			return true;
		}
		return false;
	},
	getCoverCoord: function() {
		var arr = [].concat(this.series);
		if(this.categories) {
			arr = arr.concat(this.categories);
		}
		if(this.labels) {
			arr = arr.concat(this.labels);
		}
		var pos = this.getMinMaxPos(arr);
		return [
			[this.coord[0][0]].concat(pos)
		];
	},
	isRectangleCoord: function() {
		var cover = this.getCoverCoord();
		var minRow = cover[1],
			minCol = cover[2],
			maxRow = cover[3],
			maxCol = cover[4];
		var flags = {};
		for(var i = minRow; i <= maxRow; i++) {
			for(var j = minCol; j <= maxCol; j++) {
				flags[i + "-" + j] = false;
			}
		}
		var arr = [].concat(this.series);
		if(this.categories) {
			arr = arr.concat(this.categories);
		}
		if(this.labels) {
			arr = arr.concat(this.labels);
		}
		for(var i = 0, len = arr.length; i < len; i++) {
			var it = arr[i];
			for(var r = it[1]; r <= it[3]; r++) {
				for(var c = it[2]; c <= it[4]; c++) {
					flags[r + "-" + c] = true;
				}
			}
		}
		for(var p in flags) {
			if(flags.hasOwnProperty(p) && false === flags[p]) {
				return false;
			}
		}
		return true;
	},
	getMinMaxPos: function(arr) {
		var minRow = false,
			minCol = false,
			maxRow = false,
			maxCol = false;
		for(var i = 0, len = arr.length; i < len; i++) {
			var it = arr[i];
			if(false === minRow) {
				minRow = it[1];
			} else if(minRow > it[1]) {
				minRow = it[1];
			}
			if(false === minCol) {
				minCol = it[2];
			} else if(minCol > it[2]) {
				minCol = it[2];
			}
			if(false === maxRow) {
				maxRow = it[3];
			} else if(maxRow < it[3]) {
				maxRow = it[3];
			}
			if(false === maxCol) {
				maxCol = it[4];
			} else if(maxCol < it[4]) {
				maxCol = it[4];
			}
		}
		return [minRow, minCol, maxRow, maxCol];
	},
	changeSeriesPosition: function(seriesPosition, suspendEvent) {
		if(this.seriesPosition != seriesPosition) {
			this.seriesPosition = seriesPosition;
			this.coord = this.getCoverCoord();
			this.parseRangeData();
			if(!suspendEvent) {
				this.fireEvent("fieldtitlechange", this.cacheFields, this);
			}
			this.regenerateData();
			if(!suspendEvent) {
				this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
			}
		}
	},
	refreshAsLabelChange: function(firstRowLabel, firstColLabel) {
		this.coord = this.getCoverCoord();
		this.parseRangeData({
			firstRowLabel: firstRowLabel,
			firstColLabel: firstColLabel
		});
		this.fireEvent("fieldtitlechange", this.cacheFields, this);
		this.regenerateData();
		this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
	},
	onRemoveColumn: function(sheetId, mincol, maxcol, deleted, merged) {
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		var colSpan = maxcol - mincol + 1;
		if("row" == this.seriesPosition) {
			var series = this.series,
				remains = [];
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				var startCol = it[2],
					endCol = it[4];
				if(it[0] == sheetId) {
					if(!(startCol >= mincol && endCol <= maxcol)) {
						if(startCol <= mincol && endCol >= maxcol) {
							it[4] -= colSpan;
							changed = true;
						} else if(startCol <= mincol && mincol <= endCol) {
							it[4] = mincol - 1;
							changed = true;
						} else if(startCol <= maxcol && maxcol <= endCol) {
							it[2] = mincol;
							it[4] -= colSpan;
							changed = true;
						} else if(maxcol <= startCol) {
							it[2] -= colSpan;
							it[4] -= colSpan;
							changed = true;
						}
						remains.push(it);
					}
				} else {
					remains.push(it);
				}
			}
			if(0 < remains.length) {
				this.series = remains;
			} else {
				delete this.series;
			}
			if(this.categories) {
				var categories = [];
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var col = it[2];
						if(col < mincol) {
							categories.push(it);
						} else if(col > maxcol) {
							it[2] -= colSpan;
							it[4] -= colSpan;
							categories.push(it);
							changed = true;
						}
					} else {
						categories.push(it);
					}
				}
				if(0 < categories.length) {
					this.categories = categories;
				} else {
					delete this.categories;
				}
			}
			if(this.labels) {
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++) {
					var it = this.labels[i];
					if(it[0] == sheetId) {
						var col = it[2];
						if(col < mincol) {
							labels.push(it);
						} else if(col > maxcol) {
							it[2] -= colSpan;
							it[4] -= colSpan;
							labels.push(it);
							changed = true;
						}
					} else {
						labels.push(it);
					}
				}
				if(0 < labels.length) {
					this.labels = labels;
				} else {
					delete this.labels;
				}
			}
			this.regenerateAll();
		} else {
			var series = this.series,
				remains = [],
				categories = [];
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				if(it[0] == sheetId) {
					var col = it[2];
					if(col < mincol) {
						remains.push(it);
					} else if(col > maxcol) {
						it[2] -= colSpan;
						it[4] -= colSpan;
						remains.push(it);
						changed = true;
					}
				} else {
					remains.push(it);
				}
			}
			if(0 < remains.length) {
				this.series = remains;
			} else {
				delete this.series;
			}
			if(this.categories) {
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var col = it[2];
						if(col < mincol) {
							categories.push(it);
						} else if(col > maxcol) {
							it[2] -= colSpan;
							it[4] -= colSpan;
							categories.push(it);
							changed = true;
						}
					} else {
						categories.push(it);
					}
				}
				if(0 < categories.length) {
					this.categories = categories;
				} else {
					delete this.categories;
				}
			}
			if(this.labels) {
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++) {
					var it = this.labels[i];
					if(it[0] == sheetId) {
						var col = it[2];
						if(col < mincol) {
							labels.push(it);
						} else if(col > maxcol) {
							it[2] -= colSpan;
							it[4] -= colSpan;
							labels.push(it);
							changed = true;
						}
					} else {
						labels.push(it);
					}
				}
				if(0 < labels.length) {
					this.labels = labels;
				} else {
					delete this.labels;
				}
			}
			this.regenerateAll();
		}
		if(changed) {
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
		}
	},
	onRemoveRow: function(sheetId, minrow, maxrow, deleted, merged) {
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		var rowSpan = maxrow - minrow + 1;
		if("row" != this.seriesPosition) {
			var series = this.series,
				remains = [];
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				if(it[0] == sheetId) {
					var startRow = it[1],
						endRow = it[3];
					if(!(startRow >= minrow && endRow <= maxrow)) {
						if(startRow <= minrow && endRow >= maxrow) {
							it[3] -= rowSpan;
							changed = true;
						} else if(startRow <= minrow && minrow <= endRow) {
							it[3] = minrow - 1;
							changed = true;
						} else if(startRow <= maxrow && maxrow <= endRow) {
							it[1] = minrow;
							it[3] -= rowSpan;
							changed = true;
						} else if(maxrow <= startRow) {
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							changed = true;
						}
						remains.push(it);
					}
				} else {
					remains.push(it);
				}
			}
			if(0 < remains.length) {
				this.series = remains;
			} else {
				delete this.series;
			}
			if(this.categories) {
				var categories = [];
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var row = it[1];
						if(row < minrow) {
							categories.push(it);
						} else if(row > maxrow) {
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							categories.push(it);
							changed = true;
						}
					} else {
						categories.push(it);
					}
				}
				if(0 < categories.length) {
					this.categories = categories;
				} else {
					delete this.categories;
				}
			}
			if(this.labels) {
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++) {
					var it = this.labels[i];
					if(it[0] == sheetId) {
						var row = it[1];
						if(row < minrow) {
							labels.push(it);
						} else if(row > maxrow) {
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							labels.push(it);
							changed = true;
						}
					} else {
						labels.push(it);
					}
				}
				if(0 < labels.length) {
					this.labels = labels;
				} else {
					delete this.labels;
				}
			}
			this.regenerateAll();
		} else {
			var series = this.series,
				remains = [],
				categories = [];
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				if(it[0] == sheetId) {
					var row = it[1];
					if(row < minrow) {
						remains.push(it);
					} else if(row > maxrow) {
						it[1] -= rowSpan;
						it[3] -= rowSpan;
						remains.push(it);
						changed = true;
					}
				} else {
					remains.push(it);
				}
			}
			if(0 < remains.length) {
				this.series = remains;
			} else {
				delete this.series;
			}
			if(this.categories) {
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var row = it[1];
						if(row < minrow) {
							categories.push(it);
						} else if(row > maxrow) {
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							categories.push(it);
							changed = true;
						}
					} else {
						categories.push(it);
					}
				}
				if(0 < categories.length) {
					this.categories = categories;
				} else {
					delete this.categories;
				}
			}
			if(this.labels) {
				var labels = [];
				for(var i = 0, len = this.labels.length; i < len; i++) {
					var it = this.labels[i];
					if(it[0] == sheetId) {
						var row = it[1];
						if(row < minrow) {
							labels.push(it);
						} else if(row > maxrow) {
							it[1] -= rowSpan;
							it[3] -= rowSpan;
							labels.push(it);
							changed = true;
						}
					} else {
						labels.push(it);
					}
				}
				if(0 < labels.length) {
					this.labels = labels;
				} else {
					delete this.labels;
				}
			}
			this.regenerateAll();
		}
		if(changed) {
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
		}
	},
	resetRangeConfig: function(config) {
		this.series = config.series;
		this.categories = config.categories;
		this.labels = config.labels;
		this.regenerateAll();
		this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
	},
	onInsertColumn: function(sheetId, col, colSpan) {
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		if("row" == this.seriesPosition) {
			var series = this.series,
				inside = false;
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				if(it[0] == sheetId) {
					var startCol = it[2],
						endCol = it[4];
					if(col < startCol) {
						it[2] += colSpan;
						it[4] += colSpan;
						changed = true;
					} else if(col <= endCol) {
						it[4] += colSpan;
						inside = true;
						changed = true;
					}
				}
			}
			if(this.categories) {
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var startCol = it[2],
							endCol = it[4];
						if(col <= startCol) {
							it[2] += colSpan;
							it[4] += colSpan;
							changed = true;
						}
					}
				}
			}
			if(this.labels) {
				if(inside) {
					var labels = this.labels,
						index = false;
					for(var i = 0, len = labels.length; i < len; i++) {
						var it = labels[i];
						if(it[0] == sheetId) {
							var startCol = it[2],
								endCol = it[4];
							if(col <= startCol) {
								it[2] += colSpan;
								it[4] += colSpan;
								if(false === index) {
									index = i;
								}
								changed = true;
							}
						}
					}
					if(false === index) {
						var last = labels[labels.length - 1];
						if(last[0] == sheetId) {
							for(var i = 0; i < colSpan; i++) {
								var j = col + i;
								labels.push([last[0], last[1], j, last[3], j]);
								changed = true;
							}
						}
					} else {
						var last = labels[index];
						if(last[0] == sheetId) {
							for(var i = 0; i < colSpan; i++) {
								var j = col + colSpan - 1 - i;
								labels.splice(index, 0, [last[0], last[1], j, last[3], j]);
								changed = true;
							}
						}
					}
				} else {
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							var startCol = it[2],
								endCol = it[4];
							if(col < startCol) {
								it[2] += colSpan;
								it[4] += colSpan;
								changed = true;
							}
						}
					}
				}
			}
			this.regenerateAll();
		} else {
			var series = this.series;
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				if(it[0] == sheetId) {
					var startCol = it[2];
					if(col <= startCol) {
						it[2] += colSpan;
						it[4] += colSpan;
						changed = true;
					}
				}
			}
			if(this.categories) {
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var startCol = it[2];
						if(col <= startCol) {
							it[2] += colSpan;
							it[4] += colSpan;
							changed = true;
						}
					}
				}
			}
			if(this.labels) {
				for(var i = 0, len = this.labels.length; i < len; i++) {
					var it = this.labels[i];
					if(it[0] == sheetId) {
						var startCol = it[2];
						if(col <= startCol) {
							it[2] += colSpan;
							it[4] += colSpan;
							changed = true;
						}
					}
				}
			}
			this.regenerateAll();
		}
		if(changed) {
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
		}
	},
	onInsertRow: function(sheetId, row, rowSpan) {
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		if("row" !== this.seriesPosition) {
			var series = this.series,
				inside = false;
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				if(it[0] == sheetId) {
					var startRow = it[1],
						endRow = it[3];
					if(row < startRow) {
						it[1] += rowSpan;
						it[3] += rowSpan;
						changed = true;
					} else if(row <= endRow) {
						it[3] += rowSpan;
						inside = true;
						changed = true;
					}
				}
			}
			if(this.categories) {
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var startRow = it[1],
							endRow = it[3];
						if(row <= startRow) {
							it[1] += rowSpan;
							it[3] += rowSpan;
							changed = true;
						}
					}
				}
			}
			if(this.labels) {
				if(inside) {
					var labels = this.labels,
						index = false;
					for(var i = 0, len = labels.length; i < len; i++) {
						var it = labels[i];
						if(it[0] == sheetId) {
							var startRow = it[1],
								endRow = it[3];
							if(row <= startRow) {
								it[1] += rowSpan;
								it[3] += rowSpan;
								if(false === index) {
									index = i;
								}
								changed = true;
							}
						}
					}
					if(false === index) {
						var last = labels[labels.length - 1];
						if(last[0] == sheetId) {
							for(var i = 0; i < rowSpan; i++) {
								var j = row + i;
								labels.push([last[0], j, last[2], j, last[4]]);
								changed = true;
							}
						}
					} else {
						var last = labels[index];
						if(last[0] == sheetId) {
							for(var i = 0; i < rowSpan; i++) {
								var j = row + rowSpan - 1 - i;
								labels.splice(index, 0, [last[0], j, last[2], j, last[4]]);
								changed = true;
							}
						}
					}
				} else {
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							var startRow = it[1],
								endRow = it[3];
							if(row < startRow) {
								it[1] += rowSpan;
								it[3] += rowSpan;
								changed = true;
							}
						}
					}
				}
			}
			this.regenerateAll();
		} else {
			var series = this.series;
			for(var i = 0, len = series.length; i < len; i++) {
				var it = series[i];
				if(it[0] == sheetId) {
					var startRow = it[1];
					if(row <= startRow) {
						it[1] += rowSpan;
						it[3] += rowSpan;
						changed = true;
					}
				}
			}
			if(this.categories) {
				for(var i = 0, len = this.categories.length; i < len; i++) {
					var it = this.categories[i];
					if(it[0] == sheetId) {
						var startRow = it[1];
						if(row <= startRow) {
							it[1] += rowSpan;
							it[3] += rowSpan;
							changed = true;
						}
					}
				}
			}
			if(this.labels) {
				for(var i = 0, len = this.labels.length; i < len; i++) {
					var it = this.labels[i];
					if(it[0] == sheetId) {
						var startRow = it[1];
						if(row <= startRow) {
							it[1] += rowSpan;
							it[3] += rowSpan;
							changed = true;
						}
					}
				}
			}
			this.regenerateAll();
		}
		if(changed) {
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
		}
	},
	onRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged) {
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		if("left" === moveDir) {
			if("row" == this.seriesPosition) {
				var series = this.series,
					remains = [];
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					var startCol = it[2],
						endCol = it[4];
					if(it[0] == sheetId) {
						if(minrow <= it[1] && it[3] <= maxrow) {
							if(!(startCol >= mincol && endCol <= maxcol)) {
								if(startCol <= mincol && endCol >= maxcol) {
									it[4] -= colSpan;
									changed = true;
								} else if(startCol <= mincol && mincol <= endCol) {
									it[4] = mincol - 1;
									changed = true;
								} else if(startCol <= maxcol && maxcol <= endCol) {
									it[2] = mincol;
									it[4] -= colSpan;
									changed = true;
								} else if(maxcol <= startCol) {
									it[2] -= colSpan;
									it[4] -= colSpan;
									changed = true;
								}
								remains.push(it);
							}
						} else {
							remains.push(it);
						}
					} else {
						remains.push(it);
					}
				}
				if(0 < remains.length) {
					this.series = remains;
				} else {
					delete this.series;
				}
				if(this.categories) {
					var categories = [];
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							if(minrow <= it[1] && it[3] <= maxrow) {
								var col = it[2];
								if(col < mincol) {
									categories.push(it);
								} else if(col > maxcol) {
									it[2] -= colSpan;
									it[4] -= colSpan;
									categories.push(it);
									changed = true;
								}
							} else {
								categories.push(it);
							}
						} else {
							categories.push(it);
						}
					}
					if(0 < categories.length) {
						this.categories = categories;
					} else {
						delete this.categories;
					}
				}
				if(this.labels) {
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							if(minrow <= it[1] && it[3] <= maxrow) {
								var col = it[2];
								if(col < mincol) {
									labels.push(it);
								} else if(col > maxcol) {
									it[2] -= colSpan;
									it[4] -= colSpan;
									labels.push(it);
									changed = true;
								}
							} else {
								labels.push(it);
							}
						} else {
							labels.push(it);
						}
					}
					if(0 < labels.length) {
						this.labels = labels;
					} else {
						delete this.labels;
					}
				}
				this.regenerateAll();
			} else {
				var series = this.series,
					remains = [],
					categories = [];
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					if(it[0] == sheetId) {
						if(minrow <= it[1] && it[3] <= maxrow) {
							var col = it[2];
							if(col < mincol) {
								remains.push(it);
							} else if(col > maxcol) {
								it[2] -= colSpan;
								it[4] -= colSpan;
								remains.push(it);
								changed = true;
							}
						} else {
							remains.push(it);
						}
					} else {
						remains.push(it);
					}
				}
				if(0 < remains.length) {
					this.series = remains;
				} else {
					delete this.series;
				}
				if(this.categories) {
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							if(minrow <= it[1] && it[3] <= maxrow) {
								var col = it[2];
								if(col < mincol) {
									categories.push(it);
								} else if(col > maxcol) {
									it[2] -= colSpan;
									it[4] -= colSpan;
									categories.push(it);
									changed = true;
								}
							} else {
								categories.push(it);
							}
						} else {
							categories.push(it);
						}
					}
					if(0 < categories.length) {
						this.categories = categories;
					} else {
						delete this.categories;
					}
				}
				if(this.labels) {
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							if(minrow <= it[1] && it[3] <= maxrow) {
								var col = it[2];
								if(col < mincol) {
									labels.push(it);
								} else if(col > maxcol) {
									it[2] -= colSpan;
									it[4] -= colSpan;
									labels.push(it);
									changed = true;
								}
							} else {
								labels.push(it);
							}
						} else {
							labels.push(it);
						}
					}
					if(0 < labels.length) {
						this.labels = labels;
					} else {
						delete this.labels;
					}
				}
				this.regenerateAll();
			}
		} else {
			if("row" != this.seriesPosition) {
				var series = this.series,
					remains = [];
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					if(it[0] == sheetId) {
						var startRow = it[1],
							endRow = it[3];
						if(mincol <= it[2] && it[4] <= maxcol) {
							if(!(startRow >= minrow && endRow <= maxrow)) {
								if(startRow <= minrow && endRow >= maxrow) {
									it[3] -= rowSpan;
									changed = true;
								} else if(startRow <= minrow && minrow <= endRow) {
									it[3] = minrow - 1;
									changed = true;
								} else if(startRow <= maxrow && maxrow <= endRow) {
									it[1] = minrow;
									it[3] -= rowSpan;
									changed = true;
								} else if(maxrow <= startRow) {
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									changed = true;
								}
								remains.push(it);
							}
						} else {
							remains.push(it);
						}
					} else {
						remains.push(it);
					}
				}
				if(0 < remains.length) {
					this.series = remains;
				} else {
					delete this.series;
				}
				if(this.categories) {
					var categories = [];
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol) {
								if(row < minrow) {
									categories.push(it);
								} else if(row > maxrow) {
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									categories.push(it);
									changed = true;
								}
							} else {
								categories.push(it);
							}
						} else {
							categories.push(it);
						}
					}
					if(0 < categories.length) {
						this.categories = categories;
					} else {
						delete this.categories;
					}
				}
				if(this.labels) {
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol) {
								if(row < minrow) {
									labels.push(it);
								} else if(row > maxrow) {
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									labels.push(it);
									changed = true;
								}
							} else {
								labels.push(it);
							}
						} else {
							labels.push(it);
						}
					}
					if(0 < labels.length) {
						this.labels = labels;
					} else {
						delete this.labels;
					}
				}
				this.regenerateAll();
			} else {
				var series = this.series,
					remains = [],
					categories = [];
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					if(it[0] == sheetId) {
						var row = it[1];
						if(mincol <= it[2] && it[4] <= maxcol) {
							if(row < minrow) {
								remains.push(it);
							} else if(row > maxrow) {
								it[1] -= rowSpan;
								it[3] -= rowSpan;
								remains.push(it);
								changed = true;
							}
						} else {
							remains.push(it);
						}
					} else {
						remains.push(it);
					}
				}
				if(0 < remains.length) {
					this.series = remains;
				} else {
					delete this.series;
				}
				if(this.categories) {
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol) {
								if(row < minrow) {
									categories.push(it);
								} else if(row > maxrow) {
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									categories.push(it);
									changed = true;
								}
							} else {
								categories.push(it);
							}
						} else {
							categories.push(it);
						}
					}
					if(0 < categories.length) {
						this.categories = categories;
					} else {
						delete this.categories;
					}
				}
				if(this.labels) {
					var labels = [];
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							var row = it[1];
							if(mincol <= it[2] && it[4] <= maxcol) {
								if(row < minrow) {
									labels.push(it);
								} else if(row > maxrow) {
									it[1] -= rowSpan;
									it[3] -= rowSpan;
									labels.push(it);
									changed = true;
								}
							} else {
								labels.push(it);
							}
						} else {
							labels.push(it);
						}
					}
					if(0 < labels.length) {
						this.labels = labels;
					} else {
						delete this.labels;
					}
				}
				this.regenerateAll();
			}
		}
		if(changed) {
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
		}
	},
	onInsertCell: function(sheetId, row, col, rowSpan, colSpan, moveDir, merged) {
		var old = {
			series: SCOM.copy(this.series),
			categories: SCOM.copy(this.categories),
			labels: SCOM.copy(this.labels)
		};
		var changed = false;
		var minrow = row,
			maxrow = row + rowSpan - 1,
			mincol = col,
			maxcol = col + colSpan - 1;
		if("right" === moveDir) {
			if("row" == this.seriesPosition) {
				var series = this.series,
					inside = false;
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					if(it[0] == sheetId) {
						if(minrow <= it[1] && it[3] <= maxrow) {
							var startCol = it[2],
								endCol = it[4];
							if(col < startCol) {
								it[2] += colSpan;
								it[4] += colSpan;
								changed = true;
							} else if(col <= endCol) {
								it[4] += colSpan;
								inside = true;
								changed = true;
							}
						}
					}
				}
				if(this.categories) {
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							if(minrow <= it[1] && it[3] <= maxrow) {
								var startCol = it[2],
									endCol = it[4];
								if(col <= startCol) {
									it[2] += colSpan;
									it[4] += colSpan;
									changed = true;
								}
							}
						}
					}
				}
				if(this.labels) {
					if(inside) {
						var labels = this.labels,
							index = false;
						for(var i = 0, len = labels.length; i < len; i++) {
							var it = labels[i];
							if(it[0] == sheetId) {
								if(minrow <= it[1] && it[3] <= maxrow) {
									var startCol = it[2],
										endCol = it[4];
									if(col <= startCol) {
										it[2] += colSpan;
										it[4] += colSpan;
										if(false === index) {
											index = i;
										}
										changed = true;
									}
								}
							}
						}
						if(false === index) {
							var last = labels[labels.length - 1];
							if(last[0] == sheetId) {
								if(minrow <= last[1] && last[3] <= maxrow) {
									for(var i = 0; i < colSpan; i++) {
										var j = col + i;
										labels.push([last[0], last[1], j, last[3], j]);
										changed = true;
									}
								}
							}
						} else {
							var last = labels[index];
							if(last[0] == sheetId) {
								if(minrow <= last[1] && last[3] <= maxrow) {
									for(var i = 0; i < colSpan; i++) {
										var j = col + colSpan - 1 - i;
										labels.splice(index, 0, [last[0], last[1], j, last[3], j]);
										changed = true;
									}
								}
							}
						}
					} else {
						for(var i = 0, len = this.labels.length; i < len; i++) {
							var it = this.labels[i];
							if(it[0] == sheetId) {
								if(minrow <= it[1] && it[3] <= maxrow) {
									var startCol = it[2],
										endCol = it[4];
									if(col < startCol) {
										it[2] += colSpan;
										it[4] += colSpan;
										changed = true;
									}
								}
							}
						}
					}
				}
				this.regenerateAll();
			} else {
				var series = this.series;
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					if(it[0] == sheetId) {
						if(minrow <= it[1] && it[3] <= maxrow) {
							var startCol = it[2];
							if(col <= startCol) {
								it[2] += colSpan;
								it[4] += colSpan;
								changed = true;
							}
						}
					}
				}
				if(this.categories) {
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							if(minrow <= it[1] && it[3] <= maxrow) {
								var startCol = it[2];
								if(col <= startCol) {
									it[2] += colSpan;
									it[4] += colSpan;
									changed = true;
								}
							}
						}
					}
				}
				if(this.labels) {
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							if(minrow <= it[1] && it[3] <= maxrow) {
								var startCol = it[2];
								if(col <= startCol) {
									it[2] += colSpan;
									it[4] += colSpan;
									changed = true;
								}
							}
						}
					}
				}
				this.regenerateAll();
			}
		} else {
			if("row" !== this.seriesPosition) {
				var series = this.series,
					inside = false;
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					if(it[0] == sheetId) {
						if(mincol <= it[2] && it[4] <= maxcol) {
							var startRow = it[1],
								endRow = it[3];
							if(row < startRow) {
								it[1] += rowSpan;
								it[3] += rowSpan;
								changed = true;
							} else if(row <= endRow) {
								it[3] += rowSpan;
								inside = true;
								changed = true;
							}
						}
					}
				}
				if(this.categories) {
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							if(mincol <= it[2] && it[4] <= maxcol) {
								var startRow = it[1],
									endRow = it[3];
								if(row <= startRow) {
									it[1] += rowSpan;
									it[3] += rowSpan;
									changed = true;
								}
							}
						}
					}
				}
				if(this.labels) {
					if(inside) {
						var labels = this.labels,
							index = false;
						for(var i = 0, len = labels.length; i < len; i++) {
							var it = labels[i];
							if(it[0] == sheetId) {
								if(mincol <= it[2] && it[4] <= maxcol) {
									var startRow = it[1],
										endRow = it[3];
									if(row <= startRow) {
										it[1] += rowSpan;
										it[3] += rowSpan;
										if(false === index) {
											index = i;
										}
										changed = true;
									}
								}
							}
						}
						if(false === index) {
							var last = labels[labels.length - 1];
							if(last[0] == sheetId) {
								if(mincol <= last[2] && last[4] <= maxcol) {
									for(var i = 0; i < rowSpan; i++) {
										var j = row + i;
										labels.push([last[0], j, last[2], j, last[4]]);
										changed = true;
									}
								}
							}
						} else {
							var last = labels[index];
							if(last[0] == sheetId) {
								if(mincol <= last[2] && last[4] <= maxcol) {
									for(var i = 0; i < rowSpan; i++) {
										var j = row + rowSpan - 1 - i;
										labels.splice(index, 0, [last[0], j, last[2], j, last[4]]);
										changed = true;
									}
								}
							}
						}
					} else {
						for(var i = 0, len = this.labels.length; i < len; i++) {
							var it = this.labels[i];
							if(it[0] == sheetId) {
								if(mincol <= it[2] && it[4] <= maxcol) {
									var startRow = it[1],
										endRow = it[3];
									if(row < startRow) {
										it[1] += rowSpan;
										it[3] += rowSpan;
										changed = true;
									}
								}
							}
						}
					}
				}
				this.regenerateAll();
			} else {
				var series = this.series;
				for(var i = 0, len = series.length; i < len; i++) {
					var it = series[i];
					if(it[0] == sheetId) {
						if(mincol <= it[2] && it[4] <= maxcol) {
							var startRow = it[1];
							if(row <= startRow) {
								it[1] += rowSpan;
								it[3] += rowSpan;
								changed = true;
							}
						}
					}
				}
				if(this.categories) {
					for(var i = 0, len = this.categories.length; i < len; i++) {
						var it = this.categories[i];
						if(it[0] == sheetId) {
							if(mincol <= it[2] && it[4] <= maxcol) {
								var startRow = it[1];
								if(row <= startRow) {
									it[1] += rowSpan;
									it[3] += rowSpan;
									changed = true;
								}
							}
						}
					}
				}
				if(this.labels) {
					for(var i = 0, len = this.labels.length; i < len; i++) {
						var it = this.labels[i];
						if(it[0] == sheetId) {
							if(mincol <= it[2] && it[4] <= maxcol) {
								var startRow = it[1];
								if(row <= startRow) {
									it[1] += rowSpan;
									it[3] += rowSpan;
									changed = true;
								}
							}
						}
					}
				}
				this.regenerateAll();
			}
		}
		if(changed) {
			var sid = this.storeId;
			var cur = {
				series: SCOM.copy(this.series),
				categories: SCOM.copy(this.categories),
				labels: SCOM.copy(this.labels)
			};
			this.sheet.rangeStoreRef[sid] = {
				rangeStore: this,
				oldConfig: old,
				newConfig: cur
			};
			this.sheet.fireEvent("rangestorecoordchagne", this, this.sheet);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.data.SheetStore", {
	extend: "EnterpriseSheet.pure.sheet.data.SheetStore"
});

Ext.define("EnterpriseSheet.sheet.data.RollingStore", {
	extend: "EnterpriseSheet.pure.sheet.data.RollingStore"
});

Ext.define("EnterpriseSheet.sheet.menu.CustomFormatMenu", {
	extend: "Ext.menu.Menu",
	requires: ["EnterpriseSheet.sheet.data.CustomStore", "EnterpriseSheet.common.Helper"],
	offset: SCONFIG.js_standalone ? 8 : 9,
	initComponent: function() {
		this.store = Ext.create("EnterpriseSheet.sheet.data.CustomStore", {});
		this.defaults = {
			scope: this,
			handler: this.onClickFormatItem
		};
		this.items = [{
			text: SCONST.NUMBER_CUSTOM_FORMAT.num1
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num2
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num3
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num4
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num9
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num10
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num5
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num6
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num7
		}, {
			text: SCONST.NUMBER_CUSTOM_FORMAT.num8
		}, {
			text: SLANG.customFormat,
			hidden: SCONFIG.js_standalone,
			name: "createCustom",
			iconCls: "icon-add"
		}];
		this.callParent(arguments);
		this.store.on("beforeload", this.onBeforeStoreLoad, this);
		this.store.on("load", this.onStoreLoad, this);
		this.on("beforeshow", function() {
			if(!this.storeLoaded) {
				this.store.load();
				this.storeLoaded = true;
			}
		}, this);
	},
	onBeforeStoreLoad: function() {
		var dels = [];
		this.items.each(function(item) {
			if(item.fromStore) {
				dels.push(item);
			}
		}, this);
		for(var i = 0, len = dels.length; i < len; i++) {
			this.remove(dels[i]);
		}
	},
	onStoreLoad: function(store, recs, success) {
		if(success) {
			for(var i = 0, len = recs.length; i < len; i++) {
				var it = recs[i];
				this.add(Ext.applyIf({
					fromStore: true
				}, it.data));
			}
			if(this.parentItem) {
				this.showBy(this.parentItem, this.parentItem.menuAlign);
			}
		}
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	selectTextFormat: function(format) {
		var sheet = this.sheet;
		if(sheet) {
			if(HELPER.endWith(format, "%")) {
				sheet.setPercentFormatForSelection(format);
			} else {
				sheet.setNumberFormatForSelection(format);
			}
		}
	},
	onClickFormatItem: function(item) {
		if(item.name) {
			if(item.name == "createCustom") {
				this.customWin = Ext.create("EnterpriseSheet.sheet.pop.NumberCustomWin", {});
				this.customWin.bindSheet(this.sheet);
				this.customWin.popup();
			} else {
				this.sheet.setTextFormatForSelection(item.name);
			}
		} else {
			this.selectTextFormat(item.text);
		}
	},
	itemsHandler: function(item, evt) {
		this.selectTextFormat(item.text);
	}
});

Ext.define("EnterpriseSheet.sheet.menu.CellStyleMenu", {
	extend: "Ext.menu.Menu",
	requires: ["EnterpriseSheet.common.CONST", "EnterpriseSheet.sheet.model.CellTplModel", "Ext.data.Store"],
	plain: true,
	scrollOffset: 18,
	initComponent: function() {
		var preferStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var modelStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var titleStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var subjectStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var numberStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var tpl = new Ext.XTemplate("<tpl for=\".\">", "<div class=\"thumb-wrap\">", "<div class=\"thumb cell-style\" style=\"{style}\">{text}</div>", "</div>", "</tpl>", "<div class=\"x-clear\"></div>");
		for(var i = 0, len = CELLTPL_DATA.length; i < len; i++) {
			var it = CELLTPL_DATA[i];
			if("prefer" == it.type) {
				var r = preferStore.createModel(it);
				preferStore.add(r);
			} else if("model" == it.type) {
				var r = modelStore.createModel(it);
				modelStore.add(r);
			} else if("title" == it.type) {
				var r = titleStore.createModel(it);
				titleStore.add(r);
			} else if("subject" == it.type) {
				var r = subjectStore.createModel(it);
				subjectStore.add(r);
			} else if("number" == it.type) {
				var r = numberStore.createModel(it);
				numberStore.add(r);
			}
		}
		this.preferView = new Ext.view.View({
			cls: "images-view",
			store: preferStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.modelView = new Ext.view.View({
			cls: "images-view",
			store: modelStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.titleView = new Ext.view.View({
			cls: "images-view",
			store: titleStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.subjectView = new Ext.view.View({
			cls: "images-view",
			store: subjectStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.numberView = new Ext.view.View({
			cls: "images-view",
			store: numberStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.items = [{
			xtype: "container",
			style: "background:rgb(250,250,250);",
			width: 480,
			height: 430,
			autoScroll: true,
			items: [{
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.bad_good_ok
			}, this.preferView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.data_modal
			}, this.modelView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.title
			}, this.titleView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.subject_text
			}, this.subjectView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.number_format
			}, this.numberView],
			listeners: {
				afterrender: function(ct) {
					var el = ct.getEl();
					var me = this;
					me.mon(el, "mousewheel", function(e) {
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta * me.scrollOffset;
					});
				},
				scope: this
			}
		}, {
			iconCls: "icon-cell-tpl",
			text: SLANG.new_cell_tpl
		}];
		this.callParent();
		this.mon(this.preferView, "itemclick", this._onClickItem, this);
		this.mon(this.modelView, "itemclick", this._onClickItem, this);
		this.mon(this.titleView, "itemclick", this._onClickItem, this);
		this.mon(this.subjectView, "itemclick", this._onClickItem, this);
		this.mon(this.numberView, "itemclick", this._onClickItem, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	_onClickItem: function(dv, rec) {
		var property = rec.data.property,
			fn = rec.data.fn;
		if(property || fn) {
			this.setPropertyForSelection(property, fn);
		}
		this.hide();
	},
	setPropertyForSelection: function(property, fn) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var sm = sheet.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		if(false !== sheet.fireEvent("beforeborderchange", range, sheet)) {
			sheet.fireEvent("prepareborderchange", range, sheet);
			var dp = {
				bgc: "",
				fz: "",
				fw: "",
				fs: "",
				color: ""
			};
			property = Ext.apply(dp, property);
			sheet.setPropertyForSelection(property, null, true, true);
			if(fn) {
				fn(sheet);
			}
			range.refresh();
			sheet.fireEvent("borderchange", range, sheet);
		}
	}
}, function() {
	CELLTPL_DATA = [{
		text: SLANG.regular,
		tip: SLANG.regular,
		type: "prefer",
		style: "background:white;"
	}, {
		text: SLANG.bad,
		tip: SLANG[''],
		type: "prefer",
		style: "background:pink;color:rgb(156,0,6);",
		property: {
			bgc: "pink",
			color: "rgb(156,0,6)"
		}
	}, {
		text: SLANG.good,
		tip: SLANG[''],
		type: "prefer",
		style: "background:rgb(198,239,206);color:rgb(0,97,0);",
		property: {
			bgc: "rgb(198,239,206)",
			color: "rgb(0,97,0)"
		}
	}, {
		text: SLANG.ok,
		tip: SLANG[''],
		type: "prefer",
		style: "background:rgb(255,235,156);color:rgb(156,101,0);",
		property: {
			bgc: "rgb(255,235,156)",
			color: "rgb(156,101,0)"
		}
	}, {
		text: SLANG.calculate,
		tip: SLANG.calculate,
		type: "model",
		style: "background:rgb(242,242,242);border:1px solid gray;",
		property: {
			bgc: "rgb(242,242,242)"
		},
		fn: function(sheet) {
			sheet.setRangeBorder("all", "gray", 1, "solid", true, true);
		}
	}, {
		text: SLANG.check_cell,
		tip: SLANG.check_cell,
		type: "model",
		style: "background:rgb(165,165,165);border:3px double;padding-top:1px;padding-bottom:1px;color:white;",
		property: {
			bgc: "rgb(165,165,165)",
			color: "white"
		},
		fn: function(sheet) {
			sheet.setRangeBorder("all", "black", 3, "double", true, true);
		}
	}, {
		text: SLANG.explain_text,
		tip: SLANG.explain_text,
		type: "model",
		style: "background:white;color:rgb(127,127,127);font-style:italic;",
		property: {
			bgc: "",
			color: "rgb(127,127,127)",
			fs: "italic"
		}
	}, {
		text: SLANG.warning_text,
		tip: SLANG.warning_text,
		type: "model",
		style: "background:white;color:red;",
		property: {
			bgc: "",
			color: "red"
		}
	}, {
		text: SLANG.link_cell,
		tip: SLANG.link_cell,
		type: "model",
		style: "background:white;color:orange;border-bottom:3px double orange;",
		property: {
			bgc: "",
			color: "orange"
		},
		fn: function(sheet) {
			sheet.setRangeBorder("bottom", "orange", 3, "double", true, true);
		}
	}, {
		text: SLANG.output,
		tip: SLANG.output,
		type: "model",
		style: "background:rgb(242,242,242);border:1px solid;",
		property: {
			bgc: "rgb(242,242,242)"
		},
		fn: function(sheet) {
			sheet.setRangeBorder("all", "black", 1, "solid", true, true);
		}
	}, {
		text: SLANG.input,
		tip: SLANG.input,
		type: "model",
		style: "background:rgb(255,204,153);color:rgb(63,63,118);border:1px solid gray;",
		property: {
			bgc: "rgb(255,204,153)",
			color: "rgb(63,63,118)"
		},
		fn: function(sheet) {
			sheet.setRangeBorder("all", "gray", 1, "solid", true, true);
		}
	}, {
		text: SLANG.comment,
		tip: SLANG.comment,
		type: "model",
		style: "background:rgb(255,255,204);border:1px solid silver;",
		property: {
			bgc: "rgb(255,255,204)"
		},
		fn: function(sheet) {
			sheet.setRangeBorder("all", "silver", 1, "solid", true, true);
		}
	}, {
		text: SLANG.title,
		tip: SLANG.title,
		type: "title",
		style: "background:white;color:rgb(31,73,125);font-size:18px;",
		property: {
			color: "rgb(31,73,125)",
			fz: "18"
		}
	}, {
		text: SLANG.title + "1",
		tip: SLANG.title + "1",
		type: "title",
		style: "background:white;color:rgb(31,73,125);font-size:15px;border-bottom:3px solid rgb(79,129,189);",
		property: {
			color: "rgb(31,73,125)",
			fz: 15
		},
		fn: function(sheet) {
			sheet.setRangeBorder("bottom", "rgb(79,129,189)", 3, "solid", true, true);
		}
	}, {
		text: SLANG.title + "2",
		tip: SLANG.title + "2",
		type: "title",
		style: "background:white;color:rgb(31,73,125);font-size:13px;border-bottom:3px solid rgb(168,192,222);",
		property: {
			color: "rgb(31,73,125)",
			fz: 13
		},
		fn: function(sheet) {
			sheet.setRangeBorder("bottom", "rgb(168,192,222)", 3, "solid", true, true);
		}
	}, {
		text: SLANG.title + "3",
		tip: SLANG.title + "3",
		type: "title",
		style: "background:white;color:rgb(31,73,125);font-size:11px;border-bottom:2px solid rgb(149,179,215);",
		property: {
			color: "rgb(31,73,125)",
			fz: 11
		},
		fn: function(sheet) {
			sheet.setRangeBorder("bottom", "rgb(149,179,215)", 2, "solid", true, true);
		}
	}, {
		text: SLANG.title + "4",
		tip: SLANG.title + "4",
		type: "title",
		style: "background:white;color:rgb(31,73,125);font-size:11px;",
		property: {
			color: "rgb(31,73,125)",
			fz: 11
		}
	}, {
		text: SLANG.summary,
		tip: SLANG.summary,
		type: "title",
		style: "background:white;border-top:1px solid rgb(79,129,189);border-bottom:3px double rgb(79,129,189);",
		fn: function(sheet) {
			sheet.setRangeBorder("top", "rgb(79,129,189)", 1, "solid", true, true);
			sheet.setRangeBorder("bottom", "rgb(79,129,189)", 3, "double", true, true);
		}
	}, {
		text: "20% " + SLANG.strong,
		tip: "20% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(219,229,241);",
		property: {
			bgc: "rgb(219,229,241)"
		}
	}, {
		text: "20% " + SLANG.strong,
		tip: "20% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(242,221,220);",
		property: {
			bgc: "rgb(242,221,220)"
		}
	}, {
		text: "20% " + SLANG.strong,
		tip: "20% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(234,241,221);",
		property: {
			bgc: "rgb(234,241,221)"
		}
	}, {
		text: "20% " + SLANG.strong,
		tip: "20% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(229,224,236);",
		property: {
			bgc: "rgb(229,224,236)"
		}
	}, {
		text: "20% " + SLANG.strong,
		tip: "20% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(219,238,243);",
		property: {
			bgc: "rgb(219,238,243)"
		}
	}, {
		text: "20% " + SLANG.strong,
		tip: "20% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(253,233,217);",
		property: {
			bgc: "rgb(253,233,217)"
		}
	}, {
		text: "40% " + SLANG.strong,
		tip: "40% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(184,204,228);",
		property: {
			bgc: "rgb(184,204,228)"
		}
	}, {
		text: "40% " + SLANG.strong,
		tip: "40% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(230,185,184);",
		property: {
			bgc: "rgb(230,185,184)"
		}
	}, {
		text: "40% " + SLANG.strong,
		tip: "40% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(215,228,188);",
		property: {
			bgc: "rgb(215,228,188)"
		}
	}, {
		text: "40% " + SLANG.strong,
		tip: "40% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(204,192,218);",
		property: {
			bgc: "rgb(204,192,218)"
		}
	}, {
		text: "40% " + SLANG.strong,
		tip: "40% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(182,221,232);",
		property: {
			bgc: "rgb(182,221,232)"
		}
	}, {
		text: "40% " + SLANG.strong,
		tip: "40% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(252,213,180);",
		property: {
			bgc: "rgb(252,213,180)"
		}
	}, {
		text: "60% " + SLANG.strong,
		tip: "60% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(149,179,215);color:white;",
		property: {
			bgc: "rgb(149,179,215)",
			color: "white"
		}
	}, {
		text: "60% " + SLANG.strong,
		tip: "60% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(217,151,149);color:white;",
		property: {
			bgc: "rgb(217,151,149)",
			color: "white"
		}
	}, {
		text: "60% " + SLANG.strong,
		tip: "60% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(194,214,154);color:white;",
		property: {
			bgc: "rgb(194,214,154)",
			color: "white"
		}
	}, {
		text: "60% " + SLANG.strong,
		tip: "60% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(178,161,199);color:white;",
		property: {
			bgc: "rgb(178,161,199)",
			color: "white"
		}
	}, {
		text: "60% " + SLANG.strong,
		tip: "60% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(147,205,221);color:white;",
		property: {
			bgc: "rgb(147,205,221)",
			color: "white"
		}
	}, {
		text: "60% " + SLANG.strong,
		tip: "60% " + SLANG.strong,
		type: "subject",
		style: "background:rgb(250,192,144);color:white;",
		property: {
			bgc: "rgb(250,192,144)",
			color: "white"
		}
	}, {
		text: SLANG.strong,
		tip: SLANG.strong,
		type: "subject",
		style: "background:rgb(79,129,189);color:white;",
		property: {
			bgc: "rgb(79,129,189)",
			color: "white"
		}
	}, {
		text: SLANG.strong,
		tip: SLANG.strong,
		type: "subject",
		style: "background:rgb(192,80,77);color:white;",
		property: {
			bgc: "rgb(192,80,77)",
			color: "white"
		}
	}, {
		text: SLANG.strong,
		tip: SLANG.strong,
		type: "subject",
		style: "background:rgb(155,187,89);color:white;",
		property: {
			bgc: "rgb(155,187,89)",
			color: "white"
		}
	}, {
		text: SLANG.strong,
		tip: SLANG.strong,
		type: "subject",
		style: "background:rgb(128,100,162);color:white;",
		property: {
			bgc: "rgb(128,100,162)",
			color: "white"
		}
	}, {
		text: SLANG.strong,
		tip: SLANG.strong,
		type: "subject",
		style: "background:rgb(75,172,198);color:white;",
		property: {
			bgc: "rgb(75,172,198)",
			color: "white"
		}
	}, {
		text: SLANG.strong,
		tip: SLANG.strong,
		type: "subject",
		style: "background:rgb(247,150,70);color:white;",
		property: {
			bgc: "rgb(247,150,70)",
			color: "white"
		}
	}, {
		text: SLANG.percent + "[%]",
		tip: SLANG.percent,
		type: "number",
		style: "background:white;",
		property: {
			fm: SCONST.FORMAT_PERCENT
		}
	}, {
		text: SLANG.currency,
		tip: SLANG.currency,
		type: "number",
		style: "background:white;",
		property: {
			fm: SCONST.FORMAT_CURRENCY
		}
	}, {
		text: SLANG.comma,
		tip: SLANG.comma,
		type: "number",
		style: "background:white;",
		property: {
			fm: SCONST.FORMAT_COMMA
		}
	}];
});

Ext.define("EnterpriseSheet.sheet.menu.ConditionMenu", {
	extend: "EnterpriseSheet.common.menu.ScaleMenu",
	scale: "large",
	initComponent: function() {
		this.colors = {
			red: [255, 0, 0],
			green: [0, 255, 0],
			blue: [0, 0, 255],
			orange: [255, 128, 0],
			'native': [0, 128, 255],
			pink: [255, 0, 128],
			white: [255, 255, 255],
			yellow: [255, 255, 0]
		};
		this.gradColors = {
			red: [248, 105, 107],
			green: [90, 190, 123],
			blue: [90, 138, 198],
			white: [255, 255, 255],
			yellow: [255, 235, 132]
		};
		this.colorTpl = (new Ext.XTemplate("rgb({0},{1},{2})")).compile();
		this.items = [{
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-compare-highlight32",
			text: SLANG.condition_highlight_cell,
			menu: new EnterpriseSheet.common.menu.ScaleMenu({
				scale: "large",
				minWidth: 200,
				items: [{
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-greater32",
					text: SLANG.greater_than + "...",
					handler: this.onConditionGreater,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-less32",
					text: SLANG.less_than + "...",
					handler: this.onConditionLess,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-equal32",
					text: SLANG.equal + "...",
					handler: this.onConditionEqual,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-between32",
					text: SLANG.between + "...",
					handler: this.onConditionBetween,
					scope: this
				}, "-", {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-include32",
					text: SLANG.include + "...",
					handler: this.onConditionInclude,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-date32",
					text: SLANG.date_ocurring_at + "...",
					handler: this.onConditionDate,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-repeat32",
					text: SLANG.repeat_value + "...",
					handler: this.onConditionRepeat,
					scope: this
				}, "-", {
					text: SLANG.other_condition + "...",
					handler: this.onOtherCondition,
					scope: this
				}]
			})
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-calculate-highlight32",
			text: SLANG.calculate_highlight_cell,
			menu: new EnterpriseSheet.common.menu.ScaleMenu({
				scale: "large",
				minWidth: 200,
				items: [{
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-max32",
					text: SLANG.top_10_value + "...",
					handler: this.onConditionMax,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-top32",
					text: SLANG['top_10%'] + "...",
					handler: this.onConditionTop,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-min32",
					text: SLANG.bottom_10_value + "...",
					handler: this.onConditionMin,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-bottom32",
					text: SLANG['bottom_10%'] + "...",
					handler: this.onConditionBottom,
					scope: this
				}, "-", {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-above32",
					text: SLANG.above_average + "...",
					handler: this.onConditionAbove,
					scope: this
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-condition-below32",
					text: SLANG.below_average + "...",
					handler: this.onConditionBelow,
					scope: this
				}, "-", {
					text: SLANG.other_condition + "...",
					handler: this.onOtherCondition,
					scope: this
				}]
			})
		}, "-", {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-red-bar32",
			text: SLANG.colorbar,
			handler: this.onColorBar,
			scope: this,
			menu: new Ext.menu.Menu({
				plain: true,
				items: [{
					title: SLANG.pure_color_fill,
					xtype: "buttongroup",
					frame: false,
					height: 90,
					layout: {
						type: "table",
						columns: 3,
						tableAttrs: {
							style: {
								width: "100%"
							}
						}
					},
					defaults: {
						scale: "large",
						style: "padding:2px;",
						handler: this.onColorBar,
						scope: this
					},
					items: [{
						iconCls: "icon-blue-bar32",
						color: "blue"
					}, {
						iconCls: "icon-green-bar32",
						color: "green"
					}, {
						iconCls: "icon-red-bar32",
						color: "red"
					}, {
						iconCls: "icon-native-bar32",
						color: "native"
					}, {
						iconCls: "icon-orange-bar32",
						color: "orange"
					}, {
						iconCls: "icon-pink-bar32",
						color: "pink"
					}]
				}, "-", {
					text: SLANG.other_condition + "...",
					handler: this.onOtherCondition,
					scope: this
				}]
			})
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-colorchange32",
			text: SLANG.color_scales,
			handler: this.onColorChange,
			scope: this,
			menu: new Ext.menu.Menu({
				plain: true,
				items: [{
					xtype: "buttongroup",
					frame: false,
					height: 120,
					layout: {
						type: "table",
						columns: 4,
						tableAttrs: {
							style: {
								width: "100%"
							}
						}
					},
					defaults: {
						scale: "large",
						style: "padding:2px;",
						handler: this.onColorChange,
						scope: this
					},
					items: [{
						iconCls: "icon-grad-green2orange2red32",
						start: "green",
						stop: "yellow",
						end: "red"
					}, {
						iconCls: "icon-grad-red2orange2green32",
						start: "red",
						stop: "yellow",
						end: "green"
					}, {
						iconCls: "icon-grad-blue2orange2red32",
						start: "blue",
						stop: "yellow",
						end: "red"
					}, {
						iconCls: "icon-grad-red2orange2blue32",
						start: "red",
						stop: "yellow",
						end: "blue"
					}, {
						iconCls: "icon-grad-green2yellow32",
						start: "green",
						end: "yellow"
					}, {
						iconCls: "icon-grad-yellow2green32",
						start: "yellow",
						end: "green"
					}, {
						iconCls: "icon-grad-orange2red32",
						start: "yellow",
						end: "red"
					}, {
						iconCls: "icon-grad-red2orange32",
						start: "red",
						end: "yellow"
					}, {
						iconCls: "icon-grad-white2pink32",
						start: "white",
						end: "red"
					}, {
						iconCls: "icon-grad-pink2white32",
						start: "red",
						end: "white"
					}, {
						iconCls: "icon-grad-white2green32",
						start: "white",
						end: "green"
					}, {
						iconCls: "icon-grad-green2white32",
						start: "green",
						end: "white"
					}]
				}, "-", {
					text: SLANG.other_condition + "...",
					handler: this.onOtherCondition,
					scope: this
				}]
			})
		}, "-", {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-clear-condition32",
			text: SLANG.clear_condition,
			menu: [{
				text: SLANG.clear_selecttion_condition,
				handler: this.onClearSelectionCondition,
				scope: this
			}, {
				text: SLANG.clear_sheet_condition,
				handler: this.onClearSheetCondition,
				scope: this
			}]
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-manage-condition32",
			text: SLANG.condition_management + "...",
			handler: this.onManageCondition,
			scope: this
		}];
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onConditionGreater: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		var sheetId = this.sheet.getSheetId();
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.greater_than,
			label: SLANG.set_style_for_greater,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "greater",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt, sheetId);
				},
				scope: this
			}
		});
	},
	onConditionLess: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.less_than,
			label: SLANG.set_style_for_less,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "less",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionEqual: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.equal,
			label: SLANG.set_style_for_equal,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "equal",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionBetween: function() {
		SPOP.showConditionBetween({
			sheet: this.sheet,
			title: SLANG.between,
			label: SLANG.set_style_for_between,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "between",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionInclude: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.include,
			label: SLANG.set_style_for_include,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "include",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionRepeat: function() {
		SPOP.showConditionRepeat({
			sheet: this.sheet,
			title: SLANG.repeat_value,
			label: SLANG.set_style_for_cell,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "repeat",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionDate: function() {
		SPOP.showConditionDate({
			sheet: this.sheet,
			title: SLANG.date_ocurring_at,
			label: SLANG.set_style_date_ocurring_at,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "date",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionAbove: function() {
		SPOP.showConditionAverage({
			sheet: this.sheet,
			title: SLANG.above_average,
			label: SLANG.set_style_above_average,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "average",
						base: SCONST.ABOVE_AVERAGE,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionBelow: function() {
		SPOP.showConditionAverage({
			sheet: this.sheet,
			title: SLANG.below_average,
			label: SLANG.set_style_below_average,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "average",
						base: SCONST.BELOW_AVERAGE,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionMax: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG.top_10_value,
			label: SLANG.set_style_max_value,
			setAsTxt: SLANG.set_as,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "max",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionTop: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG['top_10%'],
			label: SLANG.set_style_top_value,
			setAsTxt: SLANG.percent_set_as,
			maxValue: 100,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "top",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionMin: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG.bottom_10_value,
			label: SLANG.set_style_min_value,
			setAsTxt: SLANG.set_as,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "min",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionBottom: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG['bottom_10%'],
			label: SLANG.set_style_bottom_value,
			setAsTxt: SLANG.percent_set_as,
			maxValue: 100,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "bottom",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onColorBar: function(btn) {
		var opt = {
			pos: "red",
			neg: "green"
		};
		if(btn) {
			var color = this.colors[btn.color];
			if(color) {
				opt = {
					pos: this.colorTpl.apply(color),
					neg: this.colorTpl.apply([255 - color[0], 255 - color[1], 255 - color[2]])
				};
			}
		}
		this.sheet.setConditionForSelection("colorbar", opt);
		this.hide();
	},
	onColorChange: function(btn) {
		var opt = {
			start: this.gradColors.green,
			end: this.gradColors.red
		};
		if(btn) {
			var start = this.gradColors[btn.start];
			var stop = this.gradColors[btn.stop];
			var end = this.gradColors[btn.end];
			if(start) {
				opt = opt || {};
				opt.start = start;
			}
			if(stop) {
				opt = opt || {};
				opt.stop = stop;
			}
			if(end) {
				opt = opt || {};
				opt.end = end;
			}
		}
		this.sheet.setConditionForSelection("colorgrad", opt);
		this.hide();
	},
	onClearSelectionCondition: function() {
		this.sheet.clearConditionForSelection();
	},
	onClearSheetCondition: function() {
		this.sheet.clearConditonForSheet();
	},
	onManageCondition: function() {
		SPOP.showConditionManage({
			sheet: this.sheet
		});
	}
});

Ext.define("EnterpriseSheet.sheet.menu.ContextMenu", {
	extend: "Ext.menu.Menu",
	minWidth: 200,
	itemsInMenu: ["freeze", "split", "-", "cut", "copy", "paste", "-", "insert", "insertCopied", "delete", "clean", "-", "hideRow", "showRow", "rowHeight", "hideColumn", "showColumn", "columnWidth", "-", "insertComment", "markRange", "insertVariable", "-", "addGroup", "cancelGroup", "hyperlink", "validate", "setHeaderTitle", "hideTitle", "showTitle"],
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.mon(sheet, {
			scope: this,
			cellcontextmenu: this.onCellContextMenu,
			copy2clip: this.onCopy2Clip,
			changing: this.onSheetChange
		});
	},
	initComponent: function() {
		this.items = [];
		this.freezeItem = new Ext.menu.Item(SABOX.get("doFreeze", {
			iconCls: "icon-freeze",
			text: SLANG.freeze_sheet,
			toggle: function(pressed, suspendEvent) {
				if(!pressed) {
					this.setText(SLANG.freeze_sheet);
				} else {
					this.setText(SLANG.cancel_freeze);
				}
			},
			sender: this
		}));
		this.splitItem = new Ext.menu.Item(SABOX.get("doSplit", {
			iconCls: "icon-split",
			text: SLANG.split_sheet,
			toggle: function(pressed, suspendEvent) {
				if(!pressed) {
					this.setText(SLANG.split_sheet);
				} else {
					this.setText(SLANG.cancel_split);
				}
			},
			sender: this
		}));
		this.cutItem = new Ext.menu.Item(SABOX.get("cut", {
			iconCls: "fa fa-cut fa-lg",
			text: SLANG.cut,
			sender: this
		}));
		this.copyItem = new Ext.menu.Item(SABOX.get("copy", {
			iconCls: "fa fa-copy fa-lg",
			text: SLANG.copy,
			sender: this
		}));
		this.pasteItem = new Ext.menu.Item(SABOX.get("paste", {
			iconCls: "fa fa-paste fa-lg",
			text: SLANG.paste,
			sender: this
		}));
		this.insertItem = new Ext.menu.Item(SABOX.get("insertRange", {
			iconCls: "icon-insert-col",
			text: SLANG.insert + "..",
			sender: this
		}));
		this.deleteItem = new Ext.menu.Item(SABOX.get("deleteRange", {
			iconCls: "icon-delete",
			text: SLANG['delete'] + "..",
			sender: this
		}));
		this.hideRowItem = new Ext.menu.Item(SABOX.get("hideRow", {
			text: SLANG.hide_row,
			sender: this
		}));
		this.hideColumnItem = new Ext.menu.Item(SABOX.get("hideColumn", {
			text: SLANG.hide_column,
			sender: this
		}));
		this.showRowItem = new Ext.menu.Item(SABOX.get("showRow", {
			iconCls: "icon-cancel",
			text: SLANG.cancel_hide_row,
			sender: this
		}));
		this.showColumnItem = new Ext.menu.Item(SABOX.get("showColumn", {
			iconCls: "icon-cancel",
			text: SLANG.cancel_hide_column,
			sender: this
		}));
		this.columnWidthItem = new Ext.menu.Item(SABOX.get("columnWidth", {
			iconCls: "icon-column-width",
			text: SLANG.column_width,
			sender: this
		}));
		this.rowHeightItem = new Ext.menu.Item(SABOX.get("rowHeight", {
			iconCls: "icon-row-height",
			text: SLANG.row_height,
			sender: this
		}));
		this.cleanItem = new Ext.menu.Item(SABOX.get("cleanContent", {
			iconCls: "fa fa-eraser",
			text: SLANG.clean_content,
			sender: this
		}));
		this.insertCopiedItem = new Ext.menu.Item(SABOX.get("insertCopied", {
			hidden: true,
			text: SLANG.insert_copied,
			sender: this
		}));
		this.insertCommentItem = new Ext.menu.Item(SABOX.get("insertComment", {
			iconCls: "fa fa-comment-o fa-lg",
			text: SLANG.insert_comment,
			sender: this
		}));
		this.markRangeItem = new Ext.menu.Item(SABOX.get("markRange", {
			text: SLANG.mark_range + "..",
			sender: this
		}));
		this.insertVariableItem = new Ext.menu.Item(SABOX.get("insertVariable", {
			iconCls: "icon-var-add",
			text: SLANG.add_variable,
			sender: this
		}));
		this.hyperlinkItem = new Ext.menu.Item(SABOX.get("insertHyperlink", {
			iconCls: "fa fa-link fa-lg",
			text: SLANG.hyperlink + "...(Ctrl+K)",
			sender: this
		}));
		this.addGroupItem = new Ext.menu.Item(SABOX.get("addGroup", {
			text: SLANG.add_group,
			sender: this
		}));
		this.cancelGroupItem = new Ext.menu.Item(SABOX.get("cancelGroup", {
			iconCls: "icon-cancel",
			text: SLANG.cancel_group,
			sender: this
		}));
		this.validateItem = new Ext.menu.Item(SABOX.get("validation", {
			text: SLANG.validation + "..",
			sender: this
		}));
		this.setHeaderTitleItem = new Ext.menu.Item(SABOX.get("setHeaderTitle", {
			text: SLANG.set_header_title,
			sender: this
		}));
		this.hideTitleItem = new Ext.menu.Item({
			text: SLANG.hide_title,
			handler: this.hideTitle,
			scope: this
		});
		this.showTitleItem = new Ext.menu.Item({
			text: SLANG.show_title,
			handler: this.showTitle,
			scope: this
		});
		var deafultList = this.itemsInMenu;
		for(var i = 0, len = deafultList.length; i < len; i++) {
			var item = deafultList[i];
			if(Ext.isObject(item)) {
				this.items.push(item);
			} else {
				if(item == "-") {
					this.items.push("-");
				} else {
					if(this[item + "Item"]) {
						this.items.push(this[item + "Item"]);
					}
				}
			}
		}
		this.callParent();
	},
	onCopy2Clip: function(range) {
		this.clipRange = range;
		var coord = range.getCoord();
		var span = coord[0];
		if(0 === span[3] && 0 === span[4]) {
			this.clipRangeType = "sheet";
		} else if(0 === span[3]) {
			this.clipRangeType = "col";
		} else if(0 === span[4]) {
			this.clipRangeType = "row";
		} else {
			this.clipRangeType = "cell";
		}
	},
	onSheetChange: function() {
		delete this.clipRange;
	},
	onCellContextMenu: function(row, col, region, e) {
		if(this.sheet.isReadOnly()) {
			return;
		}
		var xy = e.getXY();
		var sm = region.getSelectionModel(),
			store = region.getStore();
		if(!sm.isSelected(row, col)) {
			sm.selectRange({
				row: row,
				col: col
			});
			sm.setFocusCell(row, col);
		}
		this.setHeaderTitleItem.hide();
		this.hideTitleItem.hide();
		this.showTitleItem.hide();
		var span = sm.selection2Span();
		if(0 == row && 0 != col) {
			this.hideRowItem.hide();
			this.showRowItem.hide();
			this.rowHeightItem.hide();
			this.hideColumnItem.show();
			this.showColumnItem.show();
			this.columnWidthItem.show();
			var f1, f2;
			for(var i = span[2]; i <= span[4]; i++) {
				var cell = store.getCell(span[0], 0, i);
				if(cell.hideTitle) {
					f1 = true;
				} else {
					f2 = true;
				}
				if(f1 && f2) {
					break;
				}
			}
			if(f2) {
				this.hideTitleItem.show();
			} else {
				this.hideTitleItem.hide();
			}
			if(f1) {
				this.showTitleItem.show();
			} else {
				this.showTitleItem.hide();
			}
			if(0 < span[4] - span[2]) {
				this.addGroupItem.show();
			} else {
				this.addGroupItem.hide();
			}
			if(this.sheet.isSelectedGroup("col")) {
				this.cancelGroupItem.show();
			} else {
				this.cancelGroupItem.hide();
			}
			if(this.clipRange && "col" == this.clipRangeType) {
				this.insertCopiedItem.show();
			} else {
				this.insertCopiedItem.hide();
			}
		} else if(0 == col && 0 != row) {
			this.hideRowItem.show();
			this.showRowItem.show();
			this.rowHeightItem.show();
			this.hideColumnItem.hide();
			this.showColumnItem.hide();
			this.columnWidthItem.hide();
			if(0 < span[3] - span[1]) {
				this.addGroupItem.show();
			} else {
				this.addGroupItem.hide();
			}
			if(this.sheet.isSelectedGroup("row")) {
				this.cancelGroupItem.show();
			} else {
				this.cancelGroupItem.hide();
			}
			if(this.clipRange && "row" == this.clipRangeType) {
				this.insertCopiedItem.show();
			} else {
				this.insertCopiedItem.hide();
			}
		} else {
			this.hideRowItem.hide();
			this.showRowItem.hide();
			this.rowHeightItem.show();
			this.hideColumnItem.hide();
			this.showColumnItem.hide();
			this.columnWidthItem.show();
			this.addGroupItem.hide();
			this.cancelGroupItem.hide();
			this.setHeaderTitleItem.show();
			if(this.clipRange && "cell" == this.clipRangeType) {
				this.insertCopiedItem.show();
			} else {
				this.insertCopiedItem.hide();
			}
		}
		this.splitItem.toggle(this.sheet.isSplited(), true);
		this.freezeItem.toggle(this.sheet.isFreezed(), true);
		if(SCONFIG.SORT_DISABLE) {
			this.hideRowItem.hide();
			this.hideColumnItem.hide();
		}
		this.showAt(xy);
	},
	hideTitle: function() {
		var sm = this.sheet.getSelectionModel();
		var mm = sm.getMinMaxPos();
		this.sheet.setColumnTitleVisible(false, mm.mincol, mm.maxcol);
	},
	showTitle: function() {
		var sm = this.sheet.getSelectionModel();
		var mm = sm.getMinMaxPos();
		this.sheet.setColumnTitleVisible(true, mm.mincol, mm.maxcol);
	}
});

Ext.define("EnterpriseSheet.sheet.menu.TableStyleMenu", {
	extend: "Ext.menu.Menu",
	requires: ["EnterpriseSheet.common.CONST", "EnterpriseSheet.sheet.model.TableTplModel", "Ext.data.Store", "EnterpriseSheet.sheet.tpl.TableTemplate"],
	plain: true,
	scrollOffset: 18,
	initComponent: function() {
		var lightStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TableTplModel"
		});
		var mediumStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TableTplModel"
		});
		var darkStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TableTplModel"
		});
		var tpls = EnterpriseSheet.sheet.tpl.TableTemplate.prototype.tableTplData;
		for(var i = 0, len = tpls.length; i < len; i++) {
			var it = tpls[i];
			if("light" == it.type) {
				var r = lightStore.createModel(it);
				lightStore.add(r);
			} else if("medium" == it.type) {
				var r = mediumStore.createModel(it);
				mediumStore.add(r);
			} else {
				var r = darkStore.createModel(it);
				darkStore.add(r);
			}
		}
		var tpl = new Ext.XTemplate("<tpl for=\".\">", "<div class=\"thumb-wrap\">", "<div class=\"thumb\"><img src=\"{url}\"></div>", "</div>", "</tpl>", "<div class=\"x-clear\"></div>");
		this.lightView = new Ext.view.View({
			cls: "images-view",
			store: lightStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.mediumView = new Ext.view.View({
			cls: "images-view",
			store: mediumStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.darkView = new Ext.view.View({
			cls: "images-view",
			store: darkStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.items = [{
			xtype: "container",
			style: "background:white;",
			width: 515,
			height: 450,
			autoScroll: true,
			items: [{
				xtype: "component",
				cls: "tpl-title",
				html: SLANG.light_color
			}, this.lightView, {
				xtype: "component",
				cls: "tpl-title",
				html: SLANG.dark_color
			}, this.mediumView, {
				xtype: "component",
				cls: "tpl-title",
				html: SLANG.deep_dark_color
			}, this.darkView],
			listeners: {
				afterrender: function(ct) {
					var el = ct.getEl();
					var me = this;
					me.mon(el, "mousewheel", function(e) {
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta * me.scrollOffset;
					});
				},
				scope: this
			}
		}, {
			iconCls: "icon-customer-tpl",
			text: SLANG.new_customer_tpl
		}, "-", {
			text: SLANG.clear_table_tpl,
			handler: this.clearTableTpl,
			scope: this
		}];
		this.callParent();
		this.mon(this.lightView, "itemclick", this._onClickItem, this);
		this.mon(this.mediumView, "itemclick", this._onClickItem, this);
		this.mon(this.darkView, "itemclick", this._onClickItem, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	setTplForSelection: function(tpl) {
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl) {
			tableTpl.setTplForSpan(span, tpl);
		}
	},
	clearTableTpl: function() {
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl) {
			tableTpl.clearTplForSpan(span);
		}
	},
	_onClickItem: function(dv, rec) {
		var tpl = rec.data.tpl;
		if(tpl) {
			this.setTplForSelection({
				id: rec.data.id
			});
		}
		this.hide();
	}
});

Ext.define("EnterpriseSheet.sheet.menu.TextFormatMenu", {
	extend: "EnterpriseSheet.common.menu.ScaleMenu",
	scale: "large",
	initComponent: function() {
		this.defaults = {
			scope: this,
			handler: this.onClickFormatItem
		};
		this.items = [{
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-regular32",
			name: "regular",
			text: SLANG.regular
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-number32",
			name: SCONST.FORMAT_NUMBER,
			text: SLANG.number
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-money32",
			name: SCONST.FORMAT_CURRENCY,
			text: SLANG.currency
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-comma32",
			name: SCONST.FORMAT_COMMA,
			text: SLANG.comma
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-date32",
			name: "date",
			text: SLANG.date
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-time32",
			name: "time",
			text: SLANG.time
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-percent32",
			name: SCONST.FORMAT_PERCENT,
			text: SLANG.percentage
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-fraction32",
			name: SCONST.FORMAT_FRACTION,
			text: SLANG.fraction
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-science32",
			name: SCONST.FORMAT_SCIENCE,
			text: SLANG.science
		}, {
			xtype: "scaleitem",
			scale: "large",
			iconCls: "icon-text32",
			name: "text",
			text: SLANG.text
		}];
		this.callParent(arguments);
	},
	previewTextFormat: function(data) {
		if(data) {
			this.items.each(function(it) {
				var preview = SFORMAT.transferFormat({
					data: data
				}, it.name).data;
				it.setText(SLANG[it.name] + "<br><span style=\"padding-left:20px;\">" + preview + "</span>");
			}, this);
		} else {
			this.items.each(function(it) {
				it.setText(SLANG[it.name]);
			}, this);
		}
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	selectTextFormat: function(format) {
		var sheet = this.sheet;
		if(sheet) {
			if(format == SCONST.FORMAT_PERCENT) {
				sheet.setPercentFormatForSelection(SCONST.DEFAULT_PERCENT_FORMAT);
			} else {
				sheet.setTextFormatForSelection(format);
			}
		}
	},
	onClickFormatItem: function(item) {
		this.selectTextFormat(item.name);
	}
});

Ext.define("EnterpriseSheet.sheet.floating.Floating", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.common.Common", "Ext.ComponentManager", "Ext.container.Container", "Ext.util.ComponentDragger", "Ext.resizer.Resizer", "Ext.ComponentManager"],
	defaultType: "container",
	ddGroup: "sf-group",
	constructor: function(config) {
		config = Ext.apply({}, config);
		config.cls = config.cls || "";
		config.cls = "ss-floating " + config.cls;
		config.style = config.style || "";
		config.style = "z-index:" + SCONST.FLOAT_Z_INDEX + ";" + config.style;
		if(false == SCOM.typeOf(config.ddConfig)) {
			config.ddConfig = {
				scroll: false,
				moveOnly: true
			};
		}
		if(false == SCOM.typeOf(config.resizeConfig)) {
			config.resizeConfig = {
				handles: "all",
				pinned: true
			};
		}
		if(!config.xtype && "drawcomponent" == this.defaultType || "drawcomponent" == config.xtype) {
			delete config.xtype;
		} else {
			this.comp = new Ext.ComponentMgr.create(config, this.defaultType);
		}
		this.callParent();
		this.comp.on({
			scope: this,
			afterrender: this._afterRender
		});
	},
	_afterRender: function(comp) {
		if(comp.ddConfig) {
			this.initDD();
		}
		if(comp.resizeConfig) {
			this.initResize();
		}
		var el = comp.getEl();
		var evts = {
			mousedown: "elmousedown",
			mouseup: "elmouseup",
			mousemove: "elmousemove",
			click: "elclick",
			contextmenu: "elcontextmenu",
			dblclick: "eldblclick"
		};
		var me = this;
		for(var p in evts) {
			var evt = evts[p];
			this.mon(el, p, function(e) {
				me.fireEvent(this.evt, e, me);
			}, {
				evt: evt
			});
		}
		if(Ext.isIE) {
			this.focusEl = Ext.core.DomHelper.append(Ext.getBody(), "<a class=\"ss-focus\" href=\"#\"></a>", true);
		} else {
			this.focusEl = Ext.core.DomHelper.append(Ext.getBody(), "<input class=\"ss-focus\" />", true);
		}
		if(this.comp.withTool) {
			this.initTool();
		}
		evts = {
			focus: "focus",
			blur: "blur",
			keydown: "keydown",
			keypress: "keypress",
			keyup: "keyup"
		};
		for(var p in evts) {
			var evt = evts[p];
			this.mon(this.focusEl, p, function(e) {
				me.fireEvent(this.evt, e, me);
			}, {
				evt: evt
			});
		}
		this.mon(el, "mousedown", function() {
			this.focusEl.focus();
		}, this);
		this.mon(this.focusEl, {
			scope: this,
			focus: function(e) {
				if(el) {
					el.addCls("ss-floating-top");
				}
			},
			blur: function(e) {
				if(el) {
					el.removeCls("ss-floating-top");
				}
			}
		});
	},
	getComp: function() {
		return this.comp;
	},
	initTool: function() {
		var el = this.comp.getEl();
		this.toolEl = Ext.core.DomHelper.append(el, ["<div class=\"ss-floor-tool\">", "<div class=\"ss-floor-setting\"></div>", "</div>"].join(""), true);
		this.mon(this.toolEl, {
			scope: this,
			click: function(e) {
				var target = e.getTarget();
				var tgEl = Ext.get(target);
				if(tgEl.hasCls("ss-floor-setting")) {
					this.fireEvent("showfloorsetting", tgEl, this);
				}
			}
		});
	},
	initDD: function() {
		var comp = this.comp;
		var pnode = Ext.get(comp.el.dom.parentNode);
		var me = this,
			ddConfig = {
				el: comp.getDragEl(),
				constrainTo: pnode,
				constrain: true
			};
		this.dd = Ext.create("Ext.util.ComponentDragger", comp, ddConfig);
		if(Ext.getVersion("core").isLessThan("4.0.9")) {
			this.dd.onStart = function(e) {
				var me = this,
					comp = me.comp;
				this.startPosition = comp.getPosition();
				this.startPosition[0] -= pnode.getLeft();
				this.startPosition[1] -= pnode.getTop();
				if(comp.ghost && !comp.liveDrag) {
					me.proxy = comp.ghost();
					me.dragTarget = me.proxy.header.el;
				}
				if(me.constrain || me.constrainDelegate) {
					me.constrainTo = me.calculateConstrainRegion();
				}
			};
		}
		this.dd.on({
			scope: this,
			mousedown: function(dd, e) {
				var tgEl = Ext.get(e.getTarget());
				if(Ext.supports.ClassList && !tgEl.dom.classList) {
					return;
				}
				if(tgEl.hasCls("x-resizable-handle")) {
					return false;
				}
			},
			drag: function(dd, e) {
				me.fireEvent("moving", me, e);
			},
			dragend: function(dd, e) {
				me.fireEvent("moved", me, e);
			}
		});
	},
	initResize: function() {
		var comp = this.comp;
		var el = comp.getEl();
		this.resizer = new Ext.resizer.Resizer(el.id, comp.resizeConfig);
		this.resizer.on({
			scope: this,
			resize: function(resizer, width, height, e) {
				comp.setSize(width, height);
				this.fireEvent("resizing", this, width, height, e);
				this.fireEvent("resized", this, width, height, e);
			},
			resizedrag: function(resizer, width, height, e) {
				this.fireEvent("resizing", this, width, height, e);
			}
		});
	},
	getXYInRegion: function() {
		var comp = this.comp;
		var el = comp.getEl();
		if(el) {
			var pel = Ext.get(el.dom.parentNode);
			var x = el.getLeft() - pel.getLeft(),
				y = el.getTop() - pel.getTop();
			return [x, y];
		}
	},
	setXYInRegion: function(xy) {
		var comp = this.comp;
		var el = comp.getEl();
		if(el) {
			el.setLeft(xy[0]);
			el.setTop(xy[1]);
		}
	},
	show: function() {
		this.comp.show();
	},
	hide: function() {
		this.comp.hide();
	}
});

Ext.define("EnterpriseSheet.sheet.floating.Floor", {
	extend: "Ext.util.Observable",
	requires: ["Ext.menu.Menu", "EnterpriseSheet.sheet.floating.Floating"],
	constructor: function(config, suspendPulling) {
		config = config || {};
		var sheetId = config.sheetId;
		delete config.sheetId;
		Ext.apply(this, config);
		if(config.floorId) {
			this.id = config.floorId;
			delete config.floorId;
		} else if(config.floatingConfig && !SCOM.nullOrUndefined(config.floatingConfig.floorId)) {
			this.id = config.floatingConfig.floorId;
			delete config.floatingConfig.floorId;
		}
		if(config.floatingConfig) {
			if(config.localKit) {
				config.floatingConfig.style = config.floatingConfig.style || "";
				config.floatingConfig.style = "cursor:pointer;" + config.floatingConfig.style;
			}
			delete config.floatingConfig.id;
		}
		this.getId();
		this.initContextMenu();
		this.callParent();
		this.createFloating();
		if(this.sheet) {
			this.sheet.registerFloor(this, suspendPulling, sheetId);
		}
		this.on({
			scope: this,
			moving: function(floating, e) {
				if(this.sheet && (this.sheet.isFreezed() || this.sheet.isSplited())) {
					this.sysnFloatingPos(floating);
				}
			},
			moved: function() {
				this.sheet.fireEvent("floormove", this);
			},
			resizing: function(floating, width, height, e) {
				if(this.sheet && (this.sheet.isFreezed() || this.sheet.isSplited())) {
					this.sysnFloatingPos(floating);
					this.sysnFloatingSize(floating);
				}
			},
			resized: function() {
				this.sheet.fireEvent("floorresize", this);
			}
		});
		if(this.sheet) {
			this.mon(this.sheet, {
				scope: this,
				freezechange: this.onSheetLayoutChange,
				splitchange: this.onSheetLayoutChange,
				changereadonly: this.onChangeReadOnly
			});
		}
		this.addListenerForFloatings("elcontextmenu", this.onContextMenu, this);
		this.addListenerForFloatings("focus", this.onFocus, this);
		this.addListenerForFloatings("keydown", this.onKeyDown, this);
		this.addListenerForFloatings("blur", this.onBlur, this);
	},
	initContextMenu: function() {
		this.contextMenu = new Ext.menu.Menu({
			items: [{
				text: SLANG['delete'],
				handler: function() {
					this.destroy();
				},
				scope: this
			}]
		});
	},
	onKeyDown: function(e) {
		e.stopEvent();
		var key = e.getKey();
		if(46 == key || 8 == key) {
			this.destroy();
		}
	},
	onContextMenu: function(e) {
		if(this.sheet && this.sheet.isReadOnly()) {
			return;
		}
		if(this.contextMenu) {
			this.contextMenu.showAt(e.getXY());
		}
	},
	onFocus: function(e) {
		if(this.sheet && this.sheet.isReadOnly()) {
			return;
		}
		for(var p in this.lookup) {
			var comp = this.lookup[p].comp;
			var el = comp.getEl();
			if(el) {
				el.addCls("x-resizable-pinned");
				el.setStyle("z-index", SCONST.ACTIVE_FLOAT_Z_INDEX);
			}
		}
		this.pinned = true;
	},
	onBlur: function() {
		if(this.pinned) {
			var rm = this.sheet.getReferenceModel();
			rm.disableSelect();
			for(var p in this.lookup) {
				var comp = this.lookup[p].comp;
				var el = comp.getEl();
				if(el) {
					el.removeCls("x-resizable-pinned");
					el.setStyle("z-index", SCONST.FLOAT_Z_INDEX);
				}
			}
			delete this.pinned;
		}
	},
	onSheetLayoutChange: function() {
		if(this.sheet.isFreezed() || this.sheet.isSplited()) {
			var floating = this.lookup.cregion;
			for(var p in this.lookup) {
				var ft = this.lookup[p];
				var region = this.sheet[p];
				if(region && region.isVisible() && !ft.comp.rendered) {
					region.render2RegionBody(ft.comp);
				} else if(Ext.isFunction(ft.comp.doLayout)) {
					ft.comp.doLayout();
				} else if(Ext.isFunction(ft.comp.updateLayout)) {
					ft.comp.updateLayout();
				}
			}
			this.sysnFloatingPos(floating);
			this.sysnFloatingSize(floating, true);
		}
	},
	isLocalKit: function() {
		return this.localKit;
	},
	getId: function() {
		if(SCOM.nullOrUndefined(this.id)) {
			this.id = Ext.id() + "-" + SCOM.genTimeStamp();
		}
		if(SCOM.nullOrUndefined(this.name)) {
			this.name = this.id;
			if(this.sheet) {
				this.id += "-" + this.sheet.getSheetId();
			}
		}
		return this.id;
	},
	getName: function() {
		return this.name;
	},
	createFloating: function() {
		if(this.sheet) {
			this.lookup = {};
			this.sheet.walkFloorRegions(function(region, name) {
				var config = SCOM.copy(this.floatingConfig);
				var floating = new EnterpriseSheet.sheet.floating.Floating(config);
				if(region.isVisible()) {
					region.render2RegionBody(floating.comp);
				}
				this.relayEvents(floating, ["moving", "resizing", "moved", "resized"]);
				this.lookup[name] = floating;
			}, this);
			this.onChangeReadOnly(this.sheet.isReadOnly(), this.sheet);
		}
	},
	addListenerForFloatings: function() {
		for(var p in this.lookup) {
			var floating = this.lookup[p];
			floating.on.apply(floating, arguments);
		}
	},
	sysnFloatingPos: function(floating) {
		var xy = floating.getXYInRegion();
		for(var p in this.lookup) {
			var f = this.lookup[p];
			if(f != floating) {
				f.setXYInRegion(xy);
			}
		}
	},
	sysnFloatingSize: function(floating) {
		var size = floating.comp.getSize();
		for(var p in this.lookup) {
			var f = this.lookup[p];
			if(f != floating) {
				f.comp.setSize(size.width, size.height);
			}
		}
	},
	setXY: function(xy) {
		for(var p in this.lookup) {
			var f = this.lookup[p];
			f.setXYInRegion(xy);
		}
	},
	show: function() {
		for(var p in this.lookup) {
			var f = this.lookup[p];
			f.show();
		}
	},
	hide: function() {
		for(var p in this.lookup) {
			var f = this.lookup[p];
			f.hide();
		}
	},
	getPositionSize: function() {
		var store = this.sheet.getStore();
		for(var p in this.lookup) {
			var comp = this.lookup[p].comp;
			var el = comp.getEl();
			if(el) {
				var pEl = el.parent();
				var left = el.getLeft() - pEl.getLeft();
				var top = el.getTop() - pEl.getTop();
				return {
					x: store.unzoomSize(left),
					y: store.unzoomSize(top),
					width: store.unzoomSize(el.getWidth()),
					height: store.unzoomSize(el.getHeight())
				};
			}
		}
	},
	setPositionSize: function(info) {
		for(var p in this.lookup) {
			var f = this.lookup[p];
			f.setXYInRegion([info.x, info.y]);
			f.comp.setSize(info.width, info.height);
		}
	},
	addCls: function(cls) {
		for(var p in this.lookup) {
			var comp = this.lookup[p].comp;
			var el = comp.getEl();
			if(el) {
				el.addCls(cls);
			} else {
				comp.cls = cls;
			}
		}
	},
	setIconCls: function(cls) {
		for(var p in this.lookup) {
			var comp = this.lookup[p].comp;
			var el = comp.getEl();
			if(el) {
				comp.setIconCls(cls);
			} else {
				comp.iconCls = cls;
			}
		}
	},
	removeCls: function(cls) {
		for(var p in this.lookup) {
			var comp = this.lookup[p].comp;
			var el = comp.getEl();
			if(el) {
				el.removeCls(cls);
			} else if(comp.cls) {
				comp.cls = comp.cls.replace(cls, "");
			}
		}
	},
	eachFloating: function(callback, scope) {
		for(var p in this.lookup) {
			if(this.lookup.hasOwnProperty(p)) {
				var comp = this.lookup[p].comp;
				callback.call(scope, comp);
			}
		}
	},
	destroy: function(suspendUpdate, suspendEvent) {
		this.sheet.unregisterFloor(this, suspendUpdate);
		for(var p in this.lookup) {
			var f = this.lookup[p];
			var el = f.comp.getEl();
			if(el) {
				el.clearListeners();
			}
			f.comp.destroy();
			if(f.focusEl) {
				Ext.removeNode(f.focusEl.dom);
			}
		}
		this.clearListeners();
		if(!suspendEvent) {
			this.sheet.fireEvent("deletefloor", this, this.sheet);
		}
	},
	onChangeReadOnly: function(readOnly, sheet) {
		if(readOnly) {
			for(var p in this.lookup) {
				var f = this.lookup[p];
				if(f.dd) {
					f.dd.disable();
					f.resizer.disable();
				}
			}
		} else {
			for(var p in this.lookup) {
				var f = this.lookup[p];
				if(f.dd) {
					f.dd.enable();
					f.resizer.enable();
				}
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.range.Range", {
	extend: "EnterpriseSheet.pure.sheet.range.Range"
});﻿
Ext.define("EnterpriseSheet.sheet.range.RangeField", {
	extend: "Ext.form.field.Trigger",
	requires: ["EnterpriseSheet.sheet.calculate.Coordinate"],
	alias: "widget.rangefield",
	withSheetName: true,
	triggerCls: "ss-rng-trigger",
	initComponent: function() {
		if(this.normalModeLink) {
			this.enableKeyEvents = true;
		}
		this.callParent();
		if(this.sheet) {
			this.mon(this.sheet, {
				scope: this,
				referencechange: this.onReferenceChange,
				movingreference: this.movingReference,
				endmovereference: this.endMoveReference,
				beforeswitchsheet: this.beforeSwitchSheet,
				switchsheet: this.onSwitchSheet
			});
		}
		this.on({
			scope: this,
			focus: this._onFocus,
			keydown: this._onKeydown
		});
	},
	_onKeydown: function(field, e) {
		var key = e.getKey();
		if((e.ESC == key || e.ENTER == key) && this.normalModeLink) {
			var win = this.getMiniRangeBox();
			win.hide();
			this.normalModeLink.fireEvent("normalmode", win, this.normalModeLink);
			if(this.normalModeLink instanceof EnterpriseSheet.sheet.range.RangeField) {
				this.normalModeLink.setValue(this.getValue());
			}
		}
	},
	_onFocus: function() {
		var sheet = this.sheet;
		EnterpriseSheet.sheet.range.RangeField.prototype.focusId = this.getEl().id;
		var v = this.getValue();
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(v)) {
			if(sheet) {
				var coord = this.getCoord();
				var rm = sheet.getReferenceModel();
				if(coord && coord.length) {
					rm.setReference(coord, false, true);
				}
			}
		}
	},
	onReferenceChange: function(region, rm) {
		if(!this._sheetSwitching) {
			var el = this.getEl();
			if(el && el.isVisible(true) && EnterpriseSheet.sheet.range.RangeField.prototype.focusId == el.id) {
				var ref = rm.getReference(true);
				this.setValue(ref);
			}
		}
	},
	movingReference: function(draggingCoordSpan, rm) {
		var coord = [draggingCoordSpan.currentSpan];
		this.setValue(coord);
	},
	endMoveReference: function(draggingCoordSpan, rm) {
		var ref = rm.getReference();
		this.setValue(ref);
	},
	getCoord: function() {
		var store = this.sheet.getStore();
		var v = this.getValue();
		if(Ext.isString(v)) {
			var tmp = v;
			if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(v)) {
				try {
					v = v.slice(1);
					var oldStr = v;
					v = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(v);
					if(0 < v.length) {
						var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String(v, undefined, "" !== v[0][0]);
						if(oldStr === str) {
							for(var i = 0, len = v.length; i < len; i++) {
								var it = v[i],
									span = it.span;
								if("" !== span[0] && "string" == SCOM.typeOf(span[0])) {
									span[0] = store.getSheetIdByName(span[0]);
								}
							}
						} else {
							return;
						}
					} else {
						return;
					}
				} catch(e) {
					return;
				}
			}
		}
		return v;
	},
	setValue: function(refs) {
		if(Ext.isArray(refs)) {
			refs = this.sheet.coord2StringWithSheetName(refs, undefined, this.withSheetName);
			if(refs) {
				refs = "=" + refs;
			}
		}
		this.callParent([refs]);
	},
	onTriggerClick: function() {
		if(!this.normalModeLink) {
			var win = this.getMiniRangeBox(undefined, this);
			this.fireEvent("minimode", win, this);
			win.show();
			win.items.get(0).setValue(this.getValue());
		} else {
			var win = this.getMiniRangeBox();
			win.hide();
			this.normalModeLink.fireEvent("normalmode", win, this.normalModeLink);
			if(this.normalModeLink instanceof EnterpriseSheet.sheet.range.RangeField) {
				this.normalModeLink.setValue(win.items.get(0).getValue());
			}
		}
	},
	beforeSwitchSheet: function() {
		this._sheetSwitching = true;
	},
	onSwitchSheet: function() {
		this._sheetSwitching = false;
	}
}, function() {
	Ext.apply(EnterpriseSheet.sheet.range.RangeField.prototype, {
		getMiniRangeBox: function(sheet, normalModeLink) {
			sheet = sheet || this.sheet;
			var win = Ext.getCmp("ss-mini-reference-box");
			if(!win) {
				win = new Ext.window.Window({
					id: "ss-mini-reference-box",
					title: SLANG.drag_select_reference,
					autoHeight: true,
					width: 300,
					resizable: false,
					bodyStyle: "padding:5px;",
					closable: false,
					layout: "anchor",
					items: [{
						xtype: "rangefield",
						normalModeLink: normalModeLink || this,
						value: this.getValue(),
						withSheetName: this.withSheetName,
						sheet: sheet,
						anchor: "100%"
					}],
					getRangeField: function() {
						return win.items.get(0);
					},
					listeners: {
						show: {
							fn: function() {
								sheet.disableSelect();
								sheet.disableEdit();
								sheet.enableRefer(true, this.singleSelect, this.simpleSelect);
								win.items.get(0).focus(true, 100);
							},
							scope: this
						},
						hide: {
							fn: function() {
								sheet.enableSelect();
								sheet.enableEdit();
								sheet.disableRefer(true);
							},
							scope: this
						}
					}
				});
			} else if(normalModeLink) {
				win.getRangeField().normalModeLink = normalModeLink;
			}
			return win;
		}
	});
});

Ext.define("EnterpriseSheet.sheet.range.CalculateField", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.sheet.editor.CalculateEditor"],
	alias: "widget.calculatefield",
	cls: "ss-calculate-field-ct",
	layout: {
		type: "hbox",
		align: "stretch"
	},
	initComponent: function() {
		this.calEditor = Ext.create("EnterpriseSheet.sheet.editor.CalculateEditor", {
			cls: "ss-fixed-editor ss-calculate-field",
			keepValueOnQuit: true,
			notEnableSmOnQuit: true,
			flex: 1
		});
		this.items = [this.calEditor, {
			xtype: "component",
			cls: "ss-calculate-field-trigger",
			listeners: {
				afterrender: {
					fn: function(box) {
						box.getEl().on("click", this.onTriggerClick, this)
					},
					scope: this
				}
			}
		}];
		this.callParent();
		if(this.sheet) {
			this.calEditor.init(this.sheet)
		}
		if(this.value) {
			this.setValue(this.value)
		}
		this.calEditor.on({
			scope: this,
			keyup: function() {
				this.isValid()
			},
			editorfocus: function() {
				this.fireEvent("focus", this)
			},
			editorblur: function() {
				this.fireEvent("blur", this)
			}
		})
	},
	isValid: function() {
		var v = this.getValue();
		if(!this.allowBlank && !v) {
			this.getEl().addCls("ss-calculate-field-invalid");
			return false
		}
		this.getEl().removeCls("ss-calculate-field-invalid");
		return true
	},
	getValue: function() {
		return this.calEditor.getValue()
	},
	setValue: function(v) {
		this.calEditor.setValue(v, true)
	},
	getCoord: function() {
		var store = this.sheet.getStore();
		var v = this.getValue();
		if(Ext.isString(v)) {
			var tmp = v;
			if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(v)) {
				try {
					v = v.slice(1);
					var oldStr = v;
					v = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(v);
					if(0 < v.length) {
						var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String(v, undefined, "" !== v[0][0]);
						if(oldStr === str) {
							for(var i = 0, len = v.length; i < len; i++) {
								var it = v[i],
									span = it.span;
								if("" !== span[0] && "string" == SCOM.typeOf(span[0])) {
									span[0] = store.getSheetIdByName(span[0])
								}
							}
						} else {
							return
						}
					} else {
						return
					}
				} catch(e) {
					return
				}
			}
		}
		return v
	},
	reset: function() {
		this.setValue("", true)
	},
	focus: function() {
		return this.calEditor.focus.apply(this.calEditor, arguments)
	},
	blur: function() {
		return this.calEditor.blurOff.apply(this.calEditor, arguments)
	},
	quit: function() {
		this.calEditor.completeEdit()
	},
	onTriggerClick: function() {
		if(!this.normalModeLink) {
			var win = this.getMiniRangeBox(undefined, this);
			this.fireEvent("minimode", win, this);
			win.show();
			win.items.get(0).setValue(this.getValue())
		} else {
			var win = this.getMiniRangeBox();
			win.hide();
			this.normalModeLink.fireEvent("normalmode", win, this.normalModeLink);
			if(this.normalModeLink instanceof EnterpriseSheet.sheet.range.CalculateField) {
				this.normalModeLink.setValue(win.items.get(0).getValue())
			}
		}
	}
}, function() {
	Ext.apply(EnterpriseSheet.sheet.range.CalculateField.prototype, {
		getMiniRangeBox: function(sheet, normalModeLink) {
			sheet = sheet || this.sheet;
			var win = Ext.getCmp("ss-mini-calculate-box");
			if(!win) {
				win = new Ext.window.Window({
					id: "ss-mini-calculate-box",
					title: SLANG.input_calculate,
					autoHeight: true,
					width: 350,
					resizable: false,
					bodyStyle: "padding:5px;background:white;",
					closable: false,
					layout: "anchor",
					items: [{
						xtype: "calculatefield",
						normalModeLink: normalModeLink || this,
						value: this.getValue(),
						sheet: sheet,
						anchor: "100%"
					}],
					getRangeField: function() {
						return win.items.get(0)
					},
					listeners: {
						show: {
							fn: function() {
								sheet.disableSelect();
								sheet.disableEdit();
								win.items.get(0).focus(true, 100)
							},
							scope: this
						},
						hide: {
							fn: function() {
								sheet.enableSelect();
								sheet.enableEdit();
								sheet.disableRefer(true)
							},
							scope: this
						}
					}
				})
			} else {
				if(normalModeLink) {
					win.getRangeField().normalModeLink = normalModeLink
				}
			}
			return win
		}
	})
});

Ext.define("EnterpriseSheet.sheet.action.ClipBoard", {
	requires: ["Ext.button.Button", "Ext.container.ButtonGroup", "EnterpriseSheet.sheet.range.Range", "EnterpriseSheet.sheet.floating.Floor"],
	maxStackLength: 1,
	autoHideKitTime: 100000,
	constructor: function(config) {
		Ext.apply(this, config);
		this.kitOffset = this.kitOffset || [5, 5];
		this.stack = [];
		this.lastSSID = SCONST.SSID + "$" + SCOM.genTimeStamp();
		this.initClipMenu();
		this.initClipTpl();
		this.callParent();
	},
	initClipTpl: function() {
		this.clipTpl = new Ext.XTemplate(["<table name=\"{ssid}\"><tbody>", "<tpl for=\"rows\">", "<tr>", "<tpl for=\".\">", "<td>{data}</td>", "</tpl>", "</tr>", "</tpl>", "</tbody></table>"].join(""), {
			compiled: true
		});
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		sheet.on({
			scope: this,
			changing: this.onChanging
		});
		sheet.on("beforestartedit", this.hideClipKit, this);
		sheet.on("keydown", this.onKeyDown, this);
		sheet.on("changereadonly", this.onChangeReadOnly, this);
	},
	onChanging: function() {
		delete this.clipRange;
		this.hideClipKit();
	},
	generateHTMLForClip: function(coord) {
		var rows = [],
			span = coord[0];
		var minrow = span[1],
			mincol = span[2];
		var sheet = this.sheet,
			store = sheet.getStore();
		store.walkRange([span], function(rd) {
			var row = rd.data.row,
				col = rd.data.col,
				sheetId = rd.data.sheet,
				json = rd.data.json;
			var roff = row - minrow,
				coff = col - mincol,
				flag = false;
			if(Ext.isDefined(json.minrow)) {
				flag = 0 === json.minrow && 0 === json.mincol;
			}
			var cell = json;
			if(flag) {
				cell = store.getCellData(sheetId, row, col);
				if(!sheet.isCalculateCell(sheetId, row, col, cell)) {
					cell = SFORMAT.transferFormat(cell, cell.fm);
				}
			}
			var len = rows.length;
			if(roff > len - 1) {
				var offset = roff - len + 1;
				for(var i = 0; i < offset; i++) {
					rows.push([]);
				}
			}
			var tr = rows[roff];
			var clen = tr.length;
			if(coff > clen - 1) {
				var offset = coff - clen + 1;
				for(var i = 0; i < offset; i++) {
					tr.push({});
				}
			}
			var data = cell.data;
			if(SCOM.nullOrUndefined(data)) {
				data = "";
			}
			tr[coff].data = data;
		}, this);
		if(0 < rows.length) {
			this.lastSSID = SCONST.SSID + "$" + SCOM.genTimeStamp();
			var html = this.clipTpl.apply({
				ssid: this.lastSSID,
				rows: rows
			});
			return html;
		}
		return "";
	},
	parseFromClip: function(clip) {
		var clipStr = clip.innerHTML;
		if(clipStr && -1 != clipStr.indexOf(this.lastSSID)) {
			return false;
		}
		clip = Ext.get(clip);
		var sheet = this.sheet,
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var sheetId = sheet.getSheetId();
		var table = clip.down("table");
		var focusCell = sm.getFocusCell();
		var focusRow = focusCell.row,
			focusCol = focusCell.col;
		var rowLen, colLen = 0,
			lookup = [];
		if(table) {
			var trs = Ext.DomQuery.jsSelect("tr", table.dom);
			rowLen = trs.length;
			for(var i = 0; i < rowLen; i++) {
				var tr = trs[i];
				var tds = Ext.DomQuery.jsSelect("td", tr);
				var len = tds.length;
				if(colLen < len) {
					colLen = len;
				}
				var cols = [];
				for(var j = 0; j < len; j++) {
					var td = tds[j];
					var html = td.innerHTML;
					var data = "";
					if(html) {
						data = SCOM.getInnerText(td);
					}
					cols.push(data);
				}
				lookup.push(cols);
			}
		} else {
			var colIndex = 0,
				arr = [];
			var parseTxt = function(str) {
				var rows = str.split("\n");
				for(var j = 0, size = rows.length; j < size; j++) {
					var it = rows[j];
					var cols = it.split("\t");
					colIndex += cols.length;
					if(colIndex > colLen) {
						colLen = colIndex;
					}
					arr = arr.concat(cols);
					lookup.push(arr);
					arr = [];
					colIndex = 0;
				}
			};
			for(var i = 0, len = clip.dom.childNodes.length; i < len; i++) {
				var child = clip.dom.childNodes[i];
				var nodeType = child.nodeType;
				if(3 == nodeType) {
					var txt = child.nodeValue;
					if(txt) {
						txt = Ext.String.trim(txt);
						if(txt) {
							parseTxt(txt);
						}
					}
				} else if(1 == nodeType) {
					var tagName = child.tagName.toUpperCase();
					if("P" == tagName || "DIV" == tagName) {
						colIndex = 0;
						arr = [];
						var txt = SCOM.getInnerText(child);
						if(txt) {
							txt = Ext.String.trim(txt);
							if(txt) {
								parseTxt(txt);
							}
						}
					} else if("BR" == tagName) {
						colIndex = 0;
						arr = [];
					} else {
						var txt = SCOM.getInnerText(child);
						if(txt) {
							txt = Ext.String.trim(txt);
							if(txt) {
								parseTxt(txt);
							}
						}
					}
				}
			}
			rowLen = lookup.length;
		}
		var coord = [
			[sheetId, focusRow, focusCol, focusRow + rowLen - 1, focusCol + colLen - 1]
		];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		var flag = false;
		for(var i = 0; i < rowLen; i++) {
			var row = lookup[i];
			for(var j = 0, len = row.length; j < len; j++) {
				var rowIndex = focusRow + i,
					colIndex = focusCol + j;
				var pro = store.getCellProperty(sheetId, rowIndex, colIndex);
				if(store.isDisabledForMe(pro.dsd)) {
					flag = true;
					break;
				}
			}
		}
		var nextFn = function() {
			if(false !== sheet.fireEvent("beforepaste", range, sheet)) {
				var changedHeights = {};
				var reCalCells = sheet.getRecalculateCellsByCoord(coord);
				sheet.fireEvent("preparepaste", range, sheet, undefined, reCalCells, changedHeights);
				for(var i = 0; i < rowLen; i++) {
					var row = lookup[i];
					for(var j = 0, len = row.length; j < len; j++) {
						var data = row[j];
						if(SCOM.nullOrUndefined(data)) {
							data = "";
						}
						var rowIndex = focusRow + i,
							colIndex = focusCol + j;
						var pro = store.getCellProperty(sheetId, rowIndex, colIndex);
						if(!store.isDisabledForMe(pro.dsd)) {
							data = SCOM.skipBlankForCommaOrPercent(data);
							var o = {
								data: data
							};
							if(!SCOM.isEmptyValue(data)) {
								Ext.apply(o, SFORMAT.decideFormat(data));
							}
							sheet.setCell(sheetId, rowIndex, colIndex, o, null, true);
						}
					}
				}
				Ext.apply(changedHeights, sheet.checkAutoHeightForCoord(null, coord, false, true));
				Ext.applyIf(reCalCells, sheet.getCalCdtCellsFromCoord(coord));
				sheet.refreshRange(coord, reCalCells);
				range.select();
				sheet.refreshFocus();
				sheet.fireEvent("paste", range, sheet, lookup, undefined, reCalCells);
			}
		};
		if(flag) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.confirm_process_action_on_disabled_cell,
				buttons: Ext.Msg.YESNO,
				fn: function(bid) {
					if("yes" === bid) {
						return;
					} else {
						nextFn.call(this);
					}
				},
				scope: this
			});
		} else {
			nextFn.call(this);
		}
		return true;
	},
	getFocusEl: function() {
		var editor = this.sheet.getEditor();
		return editor.getEditorEl();
	},
	onKeyDown: function(e) {
		var key = e.getKey();
		if(e.ctrlKey) {
			var clipRange = false,
				flag;
			var sm = this.sheet.getSelectionModel();
			var coord = sm.selection2Coord();
			if(99 == key || 67 == key) {
				flag = "copy";
			} else if(88 == key) {
				flag = "cut";
			} else if(86 == key) {
				var clipArea = this.getFocusEl().dom;
				SCOM.selectAll(clipArea);
				Ext.Function.defer(function() {
					if(!this.parseFromClip(clipArea)) {
						this.paste(undefined, SCONFIG.DEFAULT_PASTE_TYPE);
					}
					clipArea.innerHTML = "";
				}, this.sheet.focusDelayTime, this);
			}
			if(flag) {
				var clipEl = this.getFocusEl();
				var clipArea = clipEl.dom;
				var html = this.generateHTMLForClip(coord);
				if(SCOM.nullOrUndefined(html)) {
					html = "";
				}
				clipArea.innerHTML = html;
				SCOM.selectAll(clipArea);
				Ext.Function.defer(function() {
					clipArea.innerHTML = "";
					if("cut" === flag) {
						this.cut();
					} else {
						this.copy();
					}
				}, this.sheet.focusDelayTime, this);
			}
		}
	},
	copy: function(coord, clearFlag) {
		var sheet = this.sheet;
		if(!coord) {
			var sm = sheet.getSelectionModel();
			var coord = sm.selection2Coord();
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		if(this.stack.length > this.maxStackLength) {
			this.stack.splice(0, this.stack.length - this.maxStackLength);
		}
		this.stack.push(range);
		this.clipRange = range;
		delete this.clearFlag;
		sheet.fireEvent("copy2clip", range, sheet, this);
		this.clearFlag = clearFlag;
		return range;
	},
	cut: function() {
		var res = this.copy(undefined, true);
		return res;
	},
	paste: function(index, pasteType, sclient, toCoord, notUpdateSelection) {
		if(!this.clipRange || !(this.stack && this.stack.length)) {
			return;
		}
		var sheet = this.sheet;
		var sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var clipRange = this.clipRange;
		var fromCoord = this.clipRange.getCoord();
		toCoord = toCoord || sm.selection2Coord();
		if(this.clipRange.includeMergedCell() || !this.clipRange.isCellRange()) {
			this.reversePasteBtn.hide();
		} else {
			this.reversePasteBtn.show();
		}
		var me = this;
		var fn = function(range) {
			me.lastClearFlag = me.clearFlag;
			if(me.clearFlag) {
				delete me.clearFlag;
				sheet.getReferenceModel().hide();
			}
			if(!notUpdateSelection) {
				range.select();
				sheet.refreshFocus();
			}
			if(!sclient) {
				me.showClipKit(range);
			}
			if(!me.lastClearFlag) {
				me.clipRange = clipRange;
			} else {
				delete me.clipRange;
			}
			delete me.suspendHideFlag;
		};
		this.suspendHideFlag = true;
		var retFlag = sheet.pasteRange(fromCoord, toCoord, pasteType, this.clearFlag, function(newCoord, callback, scope) {
			if(store.isCoordContainDisabledCell(newCoord)) {
				Ext.Msg.show({
					title: SLANG.hint,
					msg: SLANG.confirm_process_action_on_disabled_cell,
					buttons: Ext.Msg.YESNO,
					fn: function(bid) {
						var r = callback.call(scope, "yes" === bid);
						if(r) {
							fn(r);
						}
					},
					scope: this
				});
			} else {
				var r = callback.call(scope);
				if(r) {
					fn(r);
				}
			}
		}, this, true);
		if(false === retFlag) {
			delete me.suspendHideFlag;
		}
	},
	initClipMenu: function() {
		if(!this.clipMenu) {
			this.reversePasteBtn = new Ext.button.Button({
				iconCls: "icon-reverse-paste24",
				scale: "medium",
				tooltip: SLANG.paste_reverse,
				handler: this.pasteReverse
			});
			this.clipMenu = new Ext.menu.Menu({
				plain: true,
				items: ["<b class=\"menu-title\">" + SLANG.paste + "</b>", {
					xtype: "buttongroup",
					frame: false,
					border: false,
					columns: 4,
					defaults: {
						style: "padding:2px;",
						scope: this
					},
					items: [{
						iconCls: "icon-default-paste24",
						scale: "medium",
						tooltip: SLANG.paste,
						handler: this.pasteDefault
					}, {
						iconCls: "icon-calculate-paste24",
						scale: "medium",
						tooltip: SLANG.paste_calculate,
						handler: this.pasteData
					}, {
						iconCls: "icon-style-paste24",
						scale: "medium",
						tooltip: SLANG.paste_style,
						handler: this.pasteStyle
					}, this.reversePasteBtn]
				}]
			});
		}
	},
	showClipKit: function(range) {
		var maxPos = range.getMaxPos();
		var store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, maxPos.col, undefined, true) + this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, maxPos.row, undefined, true) + this.kitOffset[1];
		if(!this.clipKit) {
			this.clipKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet: this.sheet,
				localKit: true,
				floatingConfig: {
					xtype: "button",
					iconCls: "icon-paste",
					x: x,
					y: y,
					ddConfig: false,
					resizeConfig: false,
					destroyMenu: false,
					menu: true,
					handler: function(btn) {
						this.clipMenu.showBy(btn);
					},
					scope: this
				}
			});
		} else {
			this.sheet.registerFloor(this.clipKit, true);
			this.clipKit.setXY([x, y]);
			this.clipKit.show();
			delete this.clipMenu.floatParent;
		}
		Ext.Function.defer(function() {
			this.hideClipKit();
		}, this.autoHideKitTime, this);
	},
	hideClipKit: function() {
		if(this.clipKit && !this.suspendHideFlag) {
			this.clipKit.destroy();
			delete this.clipKit;
		}
	},
	pasteStyle: function() {
		this.sheet.fireEvent("undo", true);
		this.clearFlag = this.lastClearFlag;
		this.paste(null, "style");
		if(this.clipMenu) {
			this.clipMenu.hide();
		}
	},
	pasteDefault: function() {
		this.sheet.fireEvent("undo", true);
		this.clearFlag = this.lastClearFlag;
		this.paste();
		if(this.clipMenu) {
			this.clipMenu.hide();
		}
	},
	pasteData: function() {
		this.sheet.fireEvent("undo", true);
		this.clearFlag = this.lastClearFlag;
		this.paste(null, "data");
		if(this.clipMenu) {
			this.clipMenu.hide();
		}
	},
	pasteReverse: function() {
		this.sheet.fireEvent("undo", true);
		this.clearFlag = this.lastClearFlag;
		this.paste(null, "reverse");
		if(this.clipMenu) {
			this.clipMenu.hide();
		}
	},
	insertCopyRange: function() {
		var range = this.clipRange,
			newRange = range;
		var sheet = this.sheet;
		var sheetId = sheet.getSheetId();
		var store = sheet.getStore();
		var coord = range.getCoord();
		var span = coord[0];
		var sm = sheet.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var mincol = pos.mincol,
			minrow = pos.minrow;
		var colSpan = span[4] - span[2] + 1;
		var rowSpan = span[3] - span[1] + 1;
		var maxrow = minrow + rowSpan - 1;
		var maxcol = mincol + colSpan - 1;
		if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isOverlappedSpan(span, [sheetId, minrow, mincol, maxrow, maxcol])) {
			Ext.Msg.alert(SLANG.hint, SLANG.insert_copy_overlap);
			return;
		}
		var clearFlag = this.clearFlag;
		if(0 === maxrow) {
			if(false !== sheet.fireEvent("beforeinsertcopied", pos, span, this)) {
				store.insertColumn(sheetId, mincol, colSpan);
				if(mincol < span[2]) {
					span[2] += colSpan;
					span[4] += colSpan;
				}
				this.copy([span]);
				this.clearFlag = clearFlag;
				sm.selectRange({
					row: minrow,
					col: mincol
				}, {
					row: maxrow,
					col: maxcol
				});
				this.paste(undefined, undefined, true);
				if(clearFlag) {
					store.removeColumn(sheetId, span[2], span[4]);
				}
				sheet.fireEvent("insertcopied", pos, span, this);
			}
			if(this.clearFlag) {
				delete this.clipRange;
			}
		} else if(0 === maxcol) {
			if(false !== sheet.fireEvent("beforeinsertcopied", pos, span, this)) {
				store.insertRow(sheetId, minrow, rowSpan);
				if(minrow < span[1]) {
					span[1] += rowSpan;
					span[3] += rowSpan;
				}
				this.copy([span]);
				this.clearFlag = clearFlag;
				sm.selectRange({
					row: minrow,
					col: mincol
				}, {
					row: maxrow,
					col: maxcol
				});
				this.paste(undefined, undefined, true);
				if(clearFlag) {
					store.removeRow(sheetId, span[1], span[3]);
				}
				sheet.fireEvent("insertcopied", pos, span, this);
			}
			if(this.clearFlag) {
				delete this.clipRange;
			}
		} else {
			SPOP.showInsertCopiedCellOption({
				applyCallback: {
					fn: function(opt) {
						if(0 === opt) {
							maxrow = minrow + rowSpan - 1;
							maxcol = mincol + colSpan - 1;
							var flag = mincol === span[2] && maxcol === span[4];
							if(!flag) {
								if(mincol >= span[2] && mincol <= span[4] || maxcol >= span[2] && maxcol <= span[4] || mincol <= span[2] && maxcol >= span[2] || mincol <= span[4] && maxcol >= span[4]) {
									Ext.Msg.alert(SLANG.hint, SLANG.insert_copy_overlap);
									return;
								}
							}
							if(false !== sheet.fireEvent("beforeinsertcopied", pos, span, this)) {
								sheet.insertCellMoveBottom(sheetId, {
									minrow: minrow,
									maxrow: maxrow,
									mincol: mincol,
									maxcol: maxcol
								});
								if(flag && minrow < span[1]) {
									span[1] += rowSpan;
									span[3] += rowSpan;
								}
								this.copy([span]);
								this.clearFlag = clearFlag;
								sm.selectRange({
									row: minrow,
									col: mincol
								}, {
									row: maxrow,
									col: maxcol
								});
								this.paste(undefined, undefined, true);
								if(clearFlag) {
									sheet.deleteCellMoveTop(span[0], {
										minrow: span[1],
										mincol: span[2],
										maxrow: span[3],
										maxcol: span[4]
									});
								}
								sheet.fireEvent("insertcopied", pos, span, this);
								if(this.clearFlag) {
									delete this.clipRange;
								}
							}
						} else {
							maxrow = minrow + rowSpan - 1;
							maxcol = mincol + colSpan - 1;
							var flag = minrow === span[1] && maxrow === span[3];
							if(!flag) {
								if(minrow >= span[1] && minrow <= span[3] || maxrow >= span[1] && maxrow <= span[3] || minrow <= span[1] && maxrow >= span[1] || minrow <= span[3] && maxrow >= span[3]) {
									Ext.Msg.alert(SLANG.hint, SLANG.insert_copy_overlap);
									return;
								}
							}
							if(false !== sheet.fireEvent("beforeinsertcopied", pos, span, this)) {
								sheet.insertCellMoveRight(sheetId, {
									minrow: minrow,
									maxrow: maxrow,
									mincol: mincol,
									maxcol: maxcol
								});
								if(flag && mincol < span[2]) {
									span[2] += colSpan;
									span[4] += colSpan;
								}
								this.copy([span]);
								this.clearFlag = clearFlag;
								sm.selectRange({
									row: minrow,
									col: mincol
								}, {
									row: maxrow,
									col: maxcol
								});
								this.paste(undefined, undefined, true);
								if(clearFlag) {
									sheet.deleteCellMoveLeft(span[0], {
										minrow: span[1],
										mincol: span[2],
										maxrow: span[3],
										maxcol: span[4]
									});
								}
								sheet.fireEvent("insertcopied", pos, span, this);
							}
							if(this.clearFlag) {
								delete this.clipRange;
							}
						}
					},
					scope: this
				}
			});
		}
		this.lastClearFlag = this.clearFlag;
	},
	onChangeReadOnly: function(readOnly, sheet) {
		if(readOnly) {
			this.hideClipKit();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.NumberSpecialWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text"],
	width: 450,
	height: 300,
	layout: "border",
	bodyStyle: "padding:15px;background-color:white;",
	prepareButton: Ext.emptyFn,
	cancelText: SLANG.close,
	title: SLANG.formatCells,
	locale: SCONFIG.default_locale,
	closeAction: "hide",
	formatWith: null,
	checkValid: function() {
		return true;
	},
	initComponent: function() {
		var locales = Ext.create("Ext.data.Store", {
			fields: ["id", "name"],
			data: SCONST.locale_list
		});
		this.localeCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.locale,
			editable: false,
			store: locales,
			displayField: "name",
			valueField: "id",
			queryMode: "local",
			triggerAction: "all",
			width: 305,
			forceSelection: true,
			listeners: {
				select: {
					fn: this._onLocaleComboSelectFn,
					scope: this
				}
			}
		});
		this.hintField = Ext.create("Ext.form.field.Display", {
			fieldLabel: SLANG.type,
			anchor: "100%"
		});
		this.typeStore = Ext.create("Ext.data.Store", {
			fields: ["id", "name"],
			data: [{
				id: "0",
				name: "0"
			}]
		});
		this.listView = new Ext.grid.Panel({
			region: "center",
			store: this.typeStore,
			multiSelect: false,
			hideHeaders: true,
			columns: [{
				text: "Name",
				flex: 1,
				dataIndex: "name"
			}]
		});
		this.items = [{
			xtype: "container",
			region: "north",
			layout: "anchor",
			items: [this.localeCombo, this.hintField]
		}, this.listView];
		this.dockedItems = [{
			xtype: "container",
			dock: "right",
			width: 100,
			style: "padding:0px 10px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: "button",
				text: this.cancelText,
				style: "margin-top:10px;",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent();
		this.mon(this.listView, {
			scope: this,
			selectionchange: this.onSelectionChange,
			itemdblclick: this.onDoubleClick
		});
	},
	popup: function() {
		this.show();
		this.localeCombo.setValue(this.locale);
		this.initStore();
	},
	initStore: function() {
		this.typeStore.removeAll();
		var items = [],
			today = new Date;
		var localeList = SCONST[this.locale + "_number_special"];
		for(var i = 0, len = localeList.length; i < len; i++) {
			var fm = localeList[i];
			items.push({
				name: fm.name,
				id: fm.id
			});
		}
		this.typeStore.add(items);
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	_onLocaleComboSelectFn: function(combo, rd, index) {
		this.locale = combo.getValue();
		this.initStore();
	},
	onOK: function() {
		if(this.formatWith) {
			this.sheet.setSpecialFormatForSelection(this.formatWith);
			this.hide();
		}
	},
	onSelectionChange: function(sm, selection) {
		if(0 < selection.length) {
			var sel = selection[0];
			this.formatWith = sel.data.id;
		} else {
			this.formatWith = null;
		}
	},
	onDoubleClick: function(dv, record, item, index, e) {
		this.sheet.setSpecialFormatForSelection(record.data.id);
		this.hide();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.NumberCustomWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text", "EnterpriseSheet.sheet.data.CustomStore", "EnterpriseSheet.common.Helper"],
	width: 600,
	height: 400,
	layout: "border",
	labelWidth: 80,
	bodyStyle: "padding:15px;background-color:white;",
	prepareButton: Ext.emptyFn,
	cancelText: SLANG.close,
	deleteText: SLANG['delete'],
	listEmptyText: SLANG.none,
	title: SLANG.customFormat,
	checkValid: function() {
		return true;
	},
	initComponent: function() {
		this.nameField = new Ext.form.field.Text({
			labelAlign: "top",
			fieldLabel: SLANG.customEnter,
			allowBlank: false,
			enableKeyEvents: true,
			value: this.nameValue,
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			},
			anchor: "100%"
		});
		this.positiveField = new Ext.form.field.Display({
			fieldLabel: SLANG.positive,
			name: "positive",
			hidden: true
		});
		this.negativeField = new Ext.form.field.Display({
			fieldLabel: SLANG.negative,
			name: "negative",
			hidden: true
		});
		this.zeroField = new Ext.form.field.Display({
			fieldLabel: SLANG.zero,
			name: "zero",
			hidden: true
		});
		this.initStore();
		var selModel = Ext.create("Ext.selection.CheckboxModel", {});
		this.listView = new Ext.grid.Panel({
			region: "center",
			store: this.store,
			multiSelect: false,
			hideHeaders: true,
			viewConfig: {
				emptyText: "<div style=\"padding:10px;\">" + this.listEmptyText + "</div>",
				deferEmptyText: false
			},
			selModel: selModel,
			columns: [{
				text: "Name",
				flex: 1,
				dataIndex: "text"
			}]
		});
		this.items = [{
			xtype: "container",
			region: "north",
			layout: "anchor",
			items: [this.nameField, this.positiveField, this.negativeField, this.zeroField]
		}, this.listView];
		this.deleteBtn = new Ext.button.Button({
			disabled: true,
			iconCls: "icon-delete",
			style: "margin-top:10px;",
			text: this.deleteText,
			handler: this.onDelete,
			scope: this
		});
		this.applyBtn = new Ext.button.Button({
			disabled: true,
			style: "margin-top:10px;",
			text: SLANG.apply,
			handler: this.onApply,
			scope: this
		});
		this.dockedItems = [{
			xtype: "container",
			dock: "right",
			width: 100,
			style: "padding:0px 10px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				text: SLANG.create,
				handler: this.onOK,
				scope: this
			}, this.deleteBtn, this.applyBtn, {
				xtype: "button",
				text: this.cancelText,
				style: "margin-top:10px;",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent();
		this.mon(this.listView, {
			scope: this,
			selectionchange: this.onSelectionChange
		});
	},
	popup: function() {
		this.show();
		this.nameField.focus(true, 100);
	},
	initStore: function() {
		this.store = Ext.create("EnterpriseSheet.sheet.data.CustomStore", {});
		this.store.load();
	},
	onKeyPress: function(field, e) {
		this.setFields();
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	setFields: function() {
		var nameVal = this.nameField.getValue();
		if(nameVal.indexOf(";") > -1) {
			var items = nameVal.split(";");
			this.positiveField.setValue(HELPER.parseNumberFm(items[0]));
			if(items.length > 1) {
				this.negativeField.setValue(HELPER.parseNumberFm(items[1]));
			} else {
				this.negativeField.setValue("");
			}
			if(items.length > 2) {
				this.zeroField.setValue(HELPER.parseNumberFm(items[2]));
			} else {
				this.zeroField.setValue("");
			}
			this.positiveField.setVisible(true);
			this.negativeField.setVisible(true);
			this.zeroField.setVisible(true);
		} else {
			this.positiveField.setVisible(false);
			this.negativeField.setVisible(false);
			this.zeroField.setVisible(false);
		}
	},
	onOK: function() {
		if(this.nameField.isValid()) {
			var name = this.nameField.getValue();
			Ext.Ajax.request({
				url: SCONFIG.urls.addCustom,
				params: {
					content: name,
					category: "number"
				},
				success: function(result, request) {
					var jsonData = Ext.decode(result.responseText);
					if(jsonData.success) {
						this.store.reload();
					} else {
						Ext.MessageBox.alert(SLANG.error, jsonData.info);
					}
				},
				scope: this
			});
		}
	},
	onApply: function() {
		var sm = this.listView.getSelectionModel();
		var sel = sm.getLastSelected();
		var sheet = this.sheet;
		if(sheet) {
			var format = sel.data.text;
			if(HELPER.endWith(format, "%")) {
				sheet.setPercentFormatForSelection(format);
			} else {
				sheet.setNumberFormatForSelection(format);
			}
		}
	},
	onSelectionChange: function(sm, selection) {
		if(1 == selection.length) {
			var sel = selection[0];
			this.nameField.setValue(sel.data.text);
			this.deleteBtn.enable();
			this.applyBtn.enable();
		} else {
			this.deleteBtn.disable();
			this.applyBtn.disable();
		}
		this.setFields();
	},
	onDelete: function() {
		var sm = this.listView.getSelectionModel();
		var sel = sm.getLastSelected();
		this.store.remove(sel);
		Ext.Ajax.request({
			url: SCONFIG.urls.deleteCustom,
			params: {
				id: sel.data.id
			},
			success: function(result, request) {
				var jsonData = Ext.decode(result.responseText);
				if(jsonData.success) {
					this.store.reload();
				} else {
					Ext.MessageBox.alert(SLANG.error, jsonData.info);
				}
			},
			scope: this
		});
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.DateSelectWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text"],
	width: 450,
	height: 300,
	layout: "border",
	bodyStyle: "padding:15px;background-color:white;",
	prepareButton: Ext.emptyFn,
	cancelText: SLANG.close,
	title: SLANG.formatCells,
	locale: SCONFIG.default_locale,
	closeAction: "hide",
	formatWith: null,
	checkValid: function() {
		return true;
	},
	initComponent: function() {
		var locales = Ext.create("Ext.data.Store", {
			fields: ["id", "name"],
			data: SCONST.locale_list
		});
		this.localeCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.locale,
			editable: false,
			store: locales,
			displayField: "name",
			valueField: "id",
			queryMode: "local",
			triggerAction: "all",
			width: 305,
			forceSelection: true,
			listeners: {
				select: {
					fn: this._onLocaleComboSelectFn,
					scope: this
				}
			}
		});
		this.hintField = Ext.create("Ext.form.field.Display", {
			fieldLabel: SLANG.type,
			anchor: "100%"
		});
		this.typeStore = Ext.create("Ext.data.Store", {
			fields: ["fm", "name"],
			data: [{
				fm: "y",
				name: "2014-03-20"
			}]
		});
		this.listView = new Ext.grid.Panel({
			region: "center",
			store: this.typeStore,
			multiSelect: false,
			hideHeaders: true,
			columns: [{
				text: "Name",
				flex: 1,
				dataIndex: "name"
			}]
		});
		this.items = [{
			xtype: "container",
			region: "north",
			layout: "anchor",
			items: [this.localeCombo, this.hintField]
		}, this.listView];
		this.dockedItems = [{
			xtype: "container",
			dock: "right",
			width: 100,
			style: "padding:0px 10px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: "button",
				text: this.cancelText,
				style: "margin-top:10px;",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent();
		this.mon(this.listView, {
			scope: this,
			selectionchange: this.onSelectionChange,
			itemdblclick: this.onDoubleClick
		});
	},
	popup: function() {
		this.show();
		this.localeCombo.setValue(this.locale);
		this.initStore();
	},
	initStore: function() {
		this.typeStore.removeAll();
		var items = [],
			today = new Date;
		var localeList = SCONFIG[this.locale + "_moreDateTimeFm"];
		for(var i = 0, len = localeList.length; i < len; i++) {
			var fm = localeList[i];
			items.push({
				name: Ext.Date.format(today, fm),
				fm: fm
			});
		}
		this.typeStore.add(items);
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	_onLocaleComboSelectFn: function(combo, rd, index) {
		this.locale = combo.getValue();
		this.initStore();
	},
	onOK: function() {
		if(this.formatWith) {
			this.sheet.setDateTimeFormatForSelection(this.formatWith);
			this.hide();
		}
	},
	onSelectionChange: function(sm, selection) {
		if(0 < selection.length) {
			var sel = selection[0];
			this.formatWith = sel.data.fm;
		} else {
			this.formatWith = null;
		}
	},
	onDoubleClick: function(dv, record, item, index, e) {
		this.sheet.setDateTimeFormatForSelection(record.data.fm);
		this.hide();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.money.MoneySelectContainer", {
	extend: "Ext.container.Container",
	requires: ["Ext.form.field.Text"],
	withSheetName: true,
	currencyName: SCONFIG.default_currency,
	decimalNo: 2,
	formatWith: "none",
	initComponent: function() {
		var moneys = Ext.create("Ext.data.Store", {
			fields: ["abbr", "name"],
			data: SCONST.money_list
		});
		this.moneyCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.symbol,
			editable: false,
			store: moneys,
			displayField: "name",
			valueField: "abbr",
			queryMode: "local",
			triggerAction: "all",
			width: 355,
			forceSelection: true,
			listeners: {
				select: {
					fn: this._onMoneyComboSelectFn,
					scope: this
				}
			}
		});
		this.useCodeField = Ext.create("Ext.form.field.Checkbox", {
			fieldLabel: " ",
			labelSeparator: "",
			boxLabel: SLANG.currencyCodeUse,
			name: "useCurrencyCode",
			listeners: {
				change: {
					fn: this._onCurrencyCodeCheckFn,
					scope: this
				}
			}
		});
		this.decimal = Ext.create("Ext.form.field.Number", {
			fieldLabel: SLANG.decimalPlaces,
			value: 2,
			maxValue: 30,
			minValue: 0,
			anchor: "100%",
			listeners: {
				spin: {
					fn: this._onDecimalSelectFn,
					scope: this
				}
			}
		});
		this.hintField = Ext.create("Ext.form.field.Display", {
			fieldLabel: SLANG.nagativeNo,
			anchor: "100%"
		});
		this.typeStore = Ext.create("Ext.data.Store", {
			fields: ["id", "name"],
			data: [{
				id: "negative1",
				name: "-" + SCONST.money_code.dollar + "1,234.00"
			}, {
				id: "negative2",
				name: "<font color='red'>-" + SCONST.money_code.dollar + "1,234.00</font>"
			}]
		});
		this.listView = new Ext.grid.Panel({
			region: "center",
			store: this.typeStore,
			multiSelect: false,
			hideHeaders: true,
			columns: [{
				text: "Name",
				flex: 1,
				dataIndex: "name"
			}]
		});
		this.items = [{
			xtype: "container",
			region: "north",
			layout: "anchor",
			items: [this.moneyCombo, this.useCodeField, this.decimal, this.hintField]
		}, this.listView];
		this.callParent();
		var sm = this.listView.getSelectionModel();
		sm.on({
			scope: this,
			selectionchange: this.onSelectionChange
		});
	},
	onSelectionChange: function(sm, selection) {
		if(0 < selection.length) {
			var sel = selection[0];
			this.formatWith = sel.data.id;
		} else {
			this.formatWith = "none";
		}
	},
	_onMoneyComboSelectFn: function(combo, rd, index) {
		this.currencyName = combo.getValue();
		this.initStore();
	},
	_onCurrencyCodeCheckFn: function(item, checked) {
		this.initStore();
	},
	_onDecimalSelectFn: function(numberField, dir, eOpts) {
		var decimal = numberField.getValue();
		if(dir == "up") {
			this.decimalNo = decimal + 1;
		} else {
			this.decimalNo = decimal - 1;
		}
		this.initStore();
	},
	initCt: function(name) {
		this.moneyCombo.setValue(name);
		this.currencyName = name;
		this.decimalNo = 2;
		this.initStore();
	},
	initStore: function() {
		this.typeStore.removeAll();
		var arr = [];
		var name = this.currencyName;
		var code = SCONST.money_code[name];
		var label = SLANG.symbol + " (" + code + ")" + ":";
		if(this.useCodeField.getValue()) {
			label = SLANG.currency + " (" + name.toUpperCase() + ")" + ":";
			code = name.toUpperCase() + " ";
		}
		this.moneyCombo.labelEl.update(label);
		var decimalZero = "";
		if(this.decimalNo > 0) {
			decimalZero = ".";
			for(var i = 0; i < this.decimalNo; i++) {
				decimalZero += "0";
			}
		}
		var formatter = code + "1,234" + decimalZero;
		arr.push({
			id: "negative1",
			name: "-" + formatter
		});
		arr.push({
			id: "negative2",
			name: "<font color='red'>" + formatter + "</font>"
		});
		arr.push({
			id: "negative3",
			name: "<font color='red'>-" + formatter + "</font>"
		});
		this.typeStore.add(arr);
	},
	getFormat: function() {
		if(this.currencyName) {
			var name = SCONST.money_code[this.currencyName];
			if(this.useCodeField.getValue()) {
				name = this.currencyName.toUpperCase();
			}
			var format = "money|" + name + "|" + this.decimalNo + "|" + this.formatWith + "|" + this.moneyCombo.getValue() + "|" + this.useCodeField.getValue();
			return format;
		}
		return null;
	},
	setFormat: function(format) {
		var moneyCombineFormat = format.split("|");
		var negativeNo = moneyCombineFormat[3];
		this.currencyName = moneyCombineFormat[4];
		this.moneyCombo.setValue(this.currencyName);
		this.decimalNo = moneyCombineFormat[2];
		this.decimal.setValue(this.decimalNo);
		this.useCodeField.setValue(moneyCombineFormat[5]);
		this.initStore();
	}
});

Ext.define("EnterpriseSheet.sheet.pop.money.MoneySelectWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text", "EnterpriseSheet.sheet.pop.money.MoneySelectContainer"],
	width: 500,
	height: 300,
	bodyStyle: "padding:15px;background-color:white;",
	prepareButton: Ext.emptyFn,
	cancelText: SLANG.close,
	title: SLANG.formatCells,
	checkValid: function() {
		return true;
	},
	initComponent: function() {
		this.currencyConfigCt = Ext.create("EnterpriseSheet.sheet.pop.money.MoneySelectContainer", {
			sheet: this.sheet
		});
		this.items = [this.currencyConfigCt];
		this.dockedItems = [{
			xtype: "container",
			dock: "right",
			width: 100,
			style: "padding:0px 10px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: "button",
				text: this.cancelText,
				style: "margin-top:10px;",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent();
	},
	popup: function(name) {
		this.show();
		if(!name) {
			name = SCONFIG.default_currency;
		}
		this.currencyConfigCt.initCt(name);
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	onOK: function() {
		var format = this.currencyConfigCt.getFormat();
		if(format) {
			this.sheet.setTextFormatForSelection(format);
			this.hide();
		}
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.money.LocaleSelectContainer", {
	extend: "Ext.container.Container",
	requires: ["Ext.form.field.Text"],
	withSheetName: true,
	localeName: SCONFIG.default_locale,
	decimalNo: 2,
	formatWith: "none",
	initComponent: function() {
		var locales = Ext.create("Ext.data.Store", {
			fields: ["abbr", "name"],
			data: SCONST.locale_list_more
		});
		this.localeCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.locale,
			editable: false,
			store: locales,
			displayField: "name",
			valueField: "abbr",
			queryMode: "local",
			triggerAction: "all",
			value: "de-DE",
			width: 355,
			forceSelection: true
		});
		this.decimal = Ext.create("Ext.form.field.Number", {
			fieldLabel: SLANG.decimalPlaces,
			value: 2,
			maxValue: 20,
			minValue: 0,
			width: 355
		});
		var moneys = Ext.create("Ext.data.Store", {
			fields: ["abbr", "name"],
			data: SCONST.money_list
		});
		this.currencyCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.applyCurrency,
			editable: false,
			store: moneys,
			displayField: "name",
			valueField: "abbr",
			queryMode: "local",
			triggerAction: "all",
			width: 355,
			forceSelection: false
		});
		this.items = [{
			xtype: "container",
			region: "center",
			layout: "anchor",
			items: [this.localeCombo, this.decimal, this.currencyCombo]
		}];
		this.callParent()
	},
	initCt: function(name) {
		this.decimalNo = 2
	},
	getFormat: function() {
		if(this.localeCombo.isValid()) {
			var localeName = this.localeCombo.getValue();
			var decNo = this.decimal.getValue();
			var currency = this.currencyCombo.getValue();
			var result = {
				locale: localeName,
				decNo: decNo,
				currency: currency
			};
			return result
		}
		return null
	},
	setFormat: function(format) {}
});
Ext.define("EnterpriseSheet.sheet.pop.money.LocaleSelectWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text", "EnterpriseSheet.sheet.pop.money.LocaleSelectContainer"],
	width: 500,
	height: 200,
	bodyStyle: "padding:15px;background-color:white;",
	prepareButton: Ext.emptyFn,
	cancelText: SLANG.close,
	title: SLANG.formatCells,
	checkValid: function() {
		return true
	},
	initComponent: function() {
		this.localeConfigCt = Ext.create("EnterpriseSheet.sheet.pop.money.LocaleSelectContainer", {
			sheet: this.sheet
		});
		this.items = [this.localeConfigCt];
		this.dockedItems = [{
			xtype: "container",
			dock: "right",
			width: 100,
			style: "padding:0px 10px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: "button",
				text: this.cancelText,
				style: "margin-top:10px;",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent()
	},
	popup: function(name) {
		this.show();
		this.localeConfigCt.initCt()
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK()
		}
	},
	onOK: function() {
		var format = this.localeConfigCt.getFormat();
		if(format) {
			var options = {
				minimumFractionDigits: format.decNo,
				maximumFractionDigits: format.decNo
			};
			if(format.currency) {
				Ext.apply(options, {
					style: "currency",
					currency: format.currency
				})
			}
			this.sheet.setLocaleFormatForSelection(format.locale, options);
			this.hide()
		}
	},
	bindSheet: function(sheet) {
		this.sheet = sheet
	}
});

Ext.define("EnterpriseSheet.sheet.pop.PrintSettingWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: [],
	width: 500,
	height: 500,
	title: SLANG.print_setting,
	layout: "fit",
	bodyStyle: "background-color:white;padding:10px;",
	initComponent: function() {
		this.portraitRD = Ext.create("Ext.form.field.Radio", {
			checked: true,
			boxLabel: SLANG.portrait,
			name: "orientation"
		});
		this.landscapeRD = Ext.create("Ext.form.field.Radio", {
			boxLabel: SLANG.landscape,
			name: "orientation"
		});
		this.scaleAdjustField = Ext.create("Ext.form.field.Number", {
			fieldLabel: SLANG.adjust_to,
			labelWidth: 70,
			name: "scaleAdjust",
			minValue: 10,
			maxValue: 400,
			value: 100,
			width: 130
		});
		this.scaleAdjustRD = Ext.create("Ext.form.field.Radio", {
			name: "scaling",
			boxLabel: "&nbsp;",
			checked: true
		});
		this.scaleFitToRD = Ext.create("Ext.form.field.Radio", {
			name: "scaling",
			boxLabel: "&nbsp;"
		});
		this.scaleFit2Field = Ext.create("Ext.form.field.Number", {
			fieldLabel: SLANG.fit_to,
			labelWidth: 70,
			name: "scaleFitPage",
			minValue: 1,
			value: 1,
			width: 130
		});
		this.scaleFit2TallField = Ext.create("Ext.form.field.Number", {
			fieldLabel: "",
			name: "scaleFitTall",
			minValue: 1,
			value: 1,
			width: 55
		});
		this.scaleFieldSet = Ext.create("Ext.form.FieldSet", {
			title: SLANG.scaling,
			items: [{
				padding: "10 20 5 30",
				border: false,
				layout: {
					type: "hbox"
				},
				items: [this.scaleAdjustRD, this.scaleAdjustField, {
					xtype: "label",
					text: " % " + SLANG.normal_size,
					padding: "4 10"
				}]
			}, {
				padding: "5 20 15 30",
				border: false,
				layout: {
					type: "hbox"
				},
				items: [this.scaleFitToRD, this.scaleFit2Field, {
					xtype: "label",
					text: SLANG.pageWideBy,
					padding: "4 10"
				}, this.scaleFit2TallField, {
					xtype: "label",
					text: SLANG.tall,
					padding: "4 10"
				}]
			}]
		});
		this.paperSizeCombo = Ext.create("Ext.form.field.ComboBox", {
			anchor: "100%",
			fieldLabel: SLANG.paper_size,
			name: "paperSize",
			store: SCOM.paperSizeStore,
			valueField: "id",
			displayField: "text",
			value: 9
		});
		this.printQualityCombo = Ext.create("Ext.form.field.ComboBox", {
			anchor: "100%",
			fieldLabel: SLANG.print_quality,
			name: "printQuality",
			store: SCOM.printQualityStore,
			valueField: "id",
			displayField: "text",
			value: 600
		});
		this.pageSettingPanel = Ext.create("Ext.Panel", {
			title: SLANG.page,
			padding: "10",
			layout: "anchor",
			items: [{
				xtype: "fieldset",
				title: SLANG.orientation,
				layout: {
					type: "hbox"
				},
				padding: "10 40 15 40",
				items: [this.portraitRD, {
					xtype: "component",
					flex: 1
				}, this.landscapeRD]
			}, this.scaleFieldSet, this.paperSizeCombo, this.printQualityCombo, {
				xtype: "component",
				cls: "ss-print-hint",
				html: SLANG.print_hint
			}]
		});
		this.marginPanel = Ext.create("Ext.form.Panel", {
			title: SLANG.margins,
			layout: "anchor",
			padding: 20,
			items: [{
				xtype: "numberfield",
				anchor: "100%",
				fieldLabel: SLANG.top_margin,
				name: "top",
				minValue: 0,
				value: 1.91,
				step: 0.5,
				maxValue: 100
			}, {
				xtype: "numberfield",
				anchor: "100%",
				name: "bottom",
				fieldLabel: SLANG.bottom_margin,
				minValue: 0,
				value: 1.91,
				step: 0.5,
				maxValue: 100
			}, {
				xtype: "numberfield",
				anchor: "100%",
				fieldLabel: SLANG.left_margin,
				name: "left",
				minValue: 0,
				value: 1.78,
				step: 0.5,
				maxValue: 100
			}, {
				xtype: "numberfield",
				anchor: "100%",
				name: "right",
				fieldLabel: SLANG.right_margin,
				minValue: 0,
				value: 1.78,
				step: 0.5,
				maxValue: 100
			}, {
				xtype: "numberfield",
				anchor: "100%",
				name: "header",
				fieldLabel: SLANG.header_margin,
				minValue: 0,
				value: 0.76,
				step: 0.5,
				maxValue: 100
			}, {
				xtype: "numberfield",
				anchor: "100%",
				name: "footer",
				fieldLabel: SLANG.footer_margin,
				minValue: 0,
				value: 0.76,
				step: 0.5,
				maxValue: 100
			}]
		});
		this.headerPreview = Ext.create("Ext.Component", {
			anchor: "100%",
			cls: "ss-header-preview",
			name: "header-preview",
			height: 40
		});
		this.footerPreview = Ext.create("Ext.Component", {
			anchor: "100%",
			cls: "ss-footer-preview",
			name: "footer-preview",
			height: 40
		});
		this.hfStore = this.getHFStore();
		this.headerCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.header,
			anchor: "100%",
			store: this.hfStore,
			value: 0,
			valueField: "id",
			displayField: "text",
			listeners: {
				select: {
					fn: function(combo) {
						var val = combo.getValue();
						var rec = combo.store.getById(val);
						if(0 === val) {
							this.tabSettingCache.header = "";
							this.tabSettingLookup.header = {};
							this.headerPreview.update("");
						} else {
							this.tabSettingCache.header = rec.data.value;
							var obj = rec.data.obj;
							this.tabSettingLookup.header = Ext.apply({}, obj);
							this.updatePreview("header");
						}
					},
					scope: this
				}
			}
		});
		this.footerCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.footer,
			anchor: "100%",
			store: this.hfStore,
			valueField: "id",
			displayField: "text",
			value: 0,
			listeners: {
				select: {
					fn: function(combo) {
						var val = combo.getValue();
						var rec = combo.store.getById(val);
						if(0 === val) {
							this.tabSettingCache.footer = "";
							this.tabSettingLookup.footer = {};
							this.footerPreview.update("");
						} else {
							this.tabSettingCache.footer = rec.data.value;
							var obj = rec.data.obj;
							this.tabSettingLookup.footer = Ext.apply({}, obj);
							this.updatePreview("footer");
						}
					},
					scope: this
				}
			}
		});
		this.oddEvenCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.different_on_odd_even_page,
			handler: function(box) {
				var checked = box.getValue();
				if(checked || this.firstPageCB.getValue()) {
					this.headerCombo.disable();
					this.footerCombo.disable();
				} else {
					this.headerCombo.enable();
					this.footerCombo.enable();
				}
				this.setupHeaderFooterTabs();
			},
			scope: this
		});
		this.firstPageCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.different_on_first_page,
			handler: function(box) {
				var checked = box.getValue();
				if(checked || this.oddEvenCB.getValue()) {
					this.headerCombo.disable();
					this.footerCombo.disable();
				} else {
					this.headerCombo.enable();
					this.footerCombo.enable();
				}
				this.setupHeaderFooterTabs();
			},
			scope: this
		});
		this.scaleWithDocCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.print_scaleWithDoc,
			checked: true
		});
		this.alignWithMarginsCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.print_alignWithMargins,
			checked: true
		});
		this.headerTabs = Ext.create("Ext.Component", {
			cls: "ss-hf-tabs",
			height: 25,
			listeners: {
				afterrender: {
					fn: this.afterHFRender,
					scope: this
				}
			}
		});
		this.footerTabs = Ext.create("Ext.Component", {
			cls: "ss-hf-tabs",
			height: 15,
			listeners: {
				afterrender: {
					fn: this.afterHFRender,
					scope: this
				}
			}
		});
		this.footerHeaderPanel = Ext.create("Ext.Panel", {
			title: SLANG.header + "/" + SLANG.footer,
			layout: "anchor",
			padding: "0 20",
			items: [this.headerTabs, this.headerPreview, this.headerCombo, {
				xtype: "container",
				anchor: "100%",
				height: 50,
				layout: {
					type: "hbox",
					pack: "center"
				},
				padding: 12,
				items: [{
					xtype: "button",
					text: SLANG.define_header + "..",
					handler: function() {
						this.popupCustomerDefine({
							pos: "header",
							oddEven: this.oddEvenCB.getValue(),
							firstPage: this.firstPageCB.getValue()
						});
					},
					scope: this
				}, {
					xtype: "component",
					width: 20
				}, {
					xtype: "button",
					text: SLANG.define_footer + "..",
					handler: function() {
						this.popupCustomerDefine({
							pos: "footer",
							oddEven: this.oddEvenCB.getValue(),
							firstPage: this.firstPageCB.getValue()
						});
					},
					scope: this
				}]
			}, this.footerCombo, this.footerPreview, this.footerTabs, {
				xtype: "fieldset",
				title: SLANG.options,
				margin: "20 0 0 0",
				items: [this.oddEvenCB, this.firstPageCB, this.scaleWithDocCB, this.alignWithMarginsCB]
			}]
		});
		this.printAreaRangeField = Ext.create("EnterpriseSheet.sheet.range.RangeField", {
			fieldLabel: SLANG.print_area,
			sheet: this.sheet,
			allowBlank: true,
			withSheetName: false,
			anchor: "100%"
		});
		this.mon(this.printAreaRangeField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: this.showBackFromRangeField
		});
		this.rows2RepeatTopField = Ext.create("EnterpriseSheet.sheet.range.RangeField", {
			fieldLabel: SLANG.rows2RepeatTop,
			labelWidth: 160,
			sheet: this.sheet,
			allowBlank: true,
			withSheetName: false,
			anchor: "100%"
		});
		this.mon(this.rows2RepeatTopField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: this.showBackFromRangeField
		});
		this.cols2RepeatLeftField = Ext.create("EnterpriseSheet.sheet.range.RangeField", {
			fieldLabel: SLANG.cols2RepeatLeft,
			labelWidth: 160,
			sheet: this.sheet,
			allowBlank: true,
			withSheetName: false,
			anchor: "100%"
		});
		this.mon(this.cols2RepeatLeftField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: this.showBackFromRangeField
		});
		this.printTitlesFieldSet = Ext.create("Ext.form.FieldSet", {
			title: SLANG.printTitles,
			padding: "10 20 10 20",
			items: [this.rows2RepeatTopField, this.cols2RepeatLeftField]
		});
		this.gridlinesCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.gridlines,
			name: "gridlines"
		});
		this.blackWhiteCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.black_and_white,
			name: "blackAndWhite"
		});
		this.draftQualityCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.draftQuality,
			name: "draftQuality"
		});
		this.rowColHeadingsCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.rowColHeadings,
			name: "rowColHeadings"
		});
		this.printFieldSet = Ext.create("Ext.form.FieldSet", {
			title: SLANG.print,
			padding: "10 20 10 20",
			items: [this.gridlinesCB, this.blackWhiteCB, this.draftQualityCB, this.rowColHeadingsCB]
		});
		this.backgroundSet = Ext.create("Ext.form.FieldSet", {
			title: SLANG.background,
			padding: "10 20 10 20",
			items: [{
				xtype: "button",
				minWidth: 120,
				iconCls: "icon-add",
				text: SLANG.choosePicForBG,
				handler: this.addBackground,
				scope: this
			}]
		});
		this.sheetPanel = Ext.create("Ext.Panel", {
			title: SLANG.sheet,
			layout: "anchor",
			padding: "10 20",
			items: [this.printAreaRangeField, this.printTitlesFieldSet, this.printFieldSet, this.backgroundSet]
		});
		this.tabs = Ext.create("Ext.TabPanel", {
			plain: true,
			defaults: {
				xtype: "container"
			},
			items: [this.pageSettingPanel, this.marginPanel, this.footerHeaderPanel, this.sheetPanel]
		});
		this.items = [this.tabs];
		this.callParent();
	},
	showBackFromRangeField: function() {
		this.skipResetOnShow = true;
		this.show();
		delete this.skipResetOnShow;
	},
	afterHFRender: function(comp) {
		var el = comp.getEl();
		el.on("click", function(e) {
			for(var i = 0, len = el.dom.childNodes.length; i < len; i++) {
				Ext.get(el.dom.childNodes[i]).removeCls("selected");
			}
			var target = Ext.get(e.getTarget());
			if(target.hasCls("ss-hftab")) {
				target.addCls("selected");
				this.updatePreview(target.getAttribute("data-name"));
			}
		}, this);
	},
	getHFStore: function() {
		var data = [
			[0, SLANG.none, SLANG.none, {}],
			[1, SLANG.page_1, SLANG['page_&'], {
				c: SLANG['page_&']
			}],
			[2, SLANG.page_1_total_page, SLANG['page_&_total_page'], {
				c: SLANG['page_&_total_page']
			}]
		];
		var sheet = this.sheet,
			store = sheet.getStore();
		var fileName = store.fileName,
			curSheet = store.getSheetById(store.getActivedSheetId());
		var sheetName = curSheet.name;
		data.push([data.length, sheetName, "&A", {
			c: sheetName
		}]);
		data.push([data.length, SLANG.page_confidential_d_p, "&L&B Confidential&B&C&D&RPage &P", {
			l: " Confidential",
			c: SLANG['date_&'],
			r: SLANG['page_&']
		}]);
		data.push([data.length, fileName, "&F", {
			c: fileName
		}]);
		data.push([data.length, fileName + ", " + SLANG.page_1, "&C" + fileName + "&R" + SLANG['page_&'], {
			c: fileName,
			r: SLANG['page_&']
		}]);
		data.push([data.length, sheetName + ", " + SLANG.page_1, "&C" + sheetName + "&R" + SLANG['page_&'], {
			c: sheetName,
			r: SLANG['page_&']
		}]);
		data.push([data.length, SLANG.page_1 + ", " + sheetName, "&C" + SLANG['page_&'] + "&R" + sheetName, {
			c: SLANG['page_&'],
			r: sheetName
		}]);
		var store = new Ext.data.ArrayStore({
			fields: [{
				name: "id",
				type: "int"
			}, "text", "value", "obj"],
			data: data
		});
		return store;
	},
	transferVal2Parts: function(it) {
		var flag = false;
		var s = it.replace(/(&L)|(&C)|(&R)/gi, function(w) {
			var l = w[1].toLowerCase();
			if(flag) {
				r = "'," + l + ":'";
			} else {
				r = l + ":'";
			}
			flag = true;
			return r;
		});
		var o;
		if(flag) {
			s += "'";
			o = Ext.decode("{" + s + "}");
		} else {
			o = {
				c: s
			};
		}
		for(var q in o) {
			if(o.hasOwnProperty(q)) {
				var val = o[q];
				val = this.transferVal2Display(val);
				o[q] = val;
			}
		}
		return o;
	},
	popup: function() {
		var store = this.sheet.getStore(),
			sheetObj = store.getSheetById(store.getActivedSheetId());
		this.show();
		this.tabSettingCache = {};
		this.tabSettingLookup = {};
		var extraInfo = sheetObj.extraInfo;
		if(extraInfo) {
			extraInfo = Ext.decode(extraInfo);
			var printSetting = extraInfo.printSetting;
			if(printSetting) {
				var pageMargins = printSetting.pageMargins;
				if(pageMargins) {
					var form = this.tabs.items.get(1);
					form.items.get(0).setValue(Number(pageMargins.top));
					form.items.get(1).setValue(Number(pageMargins.bottom));
					form.items.get(2).setValue(Number(pageMargins.left));
					form.items.get(3).setValue(Number(pageMargins.right));
					form.items.get(4).setValue(Number(pageMargins.header));
					form.items.get(5).setValue(Number(pageMargins.footer));
				}
				var pageSetup = printSetting.pageSetup;
				if(pageSetup) {
					if("portrait" === pageSetup.orientation) {
						this.portraitRD.setValue(true);
					} else {
						this.landscapeRD.setValue(true);
					}
					if(pageSetup.paperSize) {
						this.paperSizeCombo.setValue(pageSetup.paperSize);
					}
					if(pageSetup.printQuality) {
						this.printQualityCombo.setValue(pageSetup.printQuality);
					}
					this.blackWhiteCB.setValue(pageSetup.blackAndWhite);
					this.gridlinesCB.setValue(pageSetup.gridlines);
					this.draftQualityCB.setValue(pageSetup.draftQuality);
					this.rowColHeadingsCB.setValue(pageSetup.rowColHeadings);
					if("adjust2" === pageSetup.scaling) {
						this.scaleAdjustRD.setValue(true);
						if(pageSetup.scaleAdjust2) {
							this.scaleAdjustField.setValue(pageSetup.scaleAdjust2);
						}
					} else {
						this.scaleFitToRD.setValue(true);
						if(pageSetup.scaleFit2) {
							this.scaleFit2Field.setValue(pageSetup.scaleFit2);
						}
						if(pageSetup.scaleFit2Tall) {
							this.scaleFit2TallField.setValue(pageSetup.scaleFit2Tall);
						}
					}
				}
				var headerFooter = printSetting.headerFooter;
				if(headerFooter) {
					if(!headerFooter.differentOddEven && headerFooter.differentFirst || !headerFooter.differentOddEven && !headerFooter.differentFirst) {
						if(headerFooter.oddHeader) {
							headerFooter.header = headerFooter.oddHeader;
							delete headerFooter.oddHeader;
						}
						if(headerFooter.oddFooter) {
							headerFooter.footer = headerFooter.oddFooter;
							delete headerFooter.oddFooter;
						}
					}
					this.tabSettingCache = Ext.apply({}, headerFooter);
					delete this.tabSettingCache.differentOddEven;
					delete this.tabSettingCache.differentFirst;
					for(var p in this.tabSettingCache) {
						if(this.tabSettingCache.hasOwnProperty(p)) {
							var it = this.tabSettingCache[p];
							if(Ext.isString(it)) {
								this.tabSettingLookup[p] = this.transferVal2Parts(it);
							}
						}
					}
					if(headerFooter.differentOddEven != null) {
						this.oddEvenCB.setValue(headerFooter.differentOddEven);
					}
					if(headerFooter.differentFirst != null) {
						this.firstPageCB.setValue(headerFooter.differentFirst);
					}
					if(headerFooter.scaleWithDoc != null) {
						this.scaleWithDocCB.setValue(headerFooter.scaleWithDoc);
					}
					if(headerFooter.alignWithMargins != null) {
						this.alignWithMarginsCB.setValue(headerFooter.alignWithMargins);
					}
					this.setupHeaderFooterTabs();
				}
				var pageSheet = printSetting.sheet;
				if(pageSheet) {
					this.printAreaRangeField.setValue(pageSheet.printArea);
					this.rows2RepeatTopField.setValue(pageSheet.rows2RepeatTop);
					this.cols2RepeatLeftField.setValue(pageSheet.cols2RepeatLeft);
					this.blackWhiteCB.setValue(pageSheet.blackAndWhite);
					this.gridlinesCB.setValue(pageSheet.gridlines);
					this.draftQualityCB.setValue(pageSheet.draftQuality);
					this.rowColHeadingsCB.setValue(pageSheet.rowColHeadings);
				}
			}
		}
	},
	setupHeaderFooterTabs: function() {
		var cache = this.tabSettingCache,
			arr = [],
			arr1 = [],
			name, name1;
		var differentOddEven = this.oddEvenCB.getValue(),
			differentFirst = this.firstPageCB.getValue();
		if(differentOddEven || differentFirst) {
			var map = {
				firstHeader: SLANG.first_page,
				oddHeader: SLANG.odd_page,
				evenHeader: SLANG.even_page,
				header: SLANG.other_page,
				firstFooter: SLANG.first_page,
				oddFooter: SLANG.odd_page,
				evenFooter: SLANG.even_page,
				footer: SLANG.other_page
			};
			var hs = [],
				fs = [];
			if(differentOddEven && differentFirst) {
				hs = ["firstHeader", "oddHeader", "evenHeader"];
				fs = ["firstFooter", "oddFooter", "evenFooter"];
			} else if(differentOddEven) {
				hs = ["oddHeader", "evenHeader"];
				fs = ["oddFooter", "evenFooter"];
			} else {
				hs = ["firstHeader", "header"];
				fs = ["firstFooter", "footer"];
			}
			var css = "selected";
			for(var i = 0, len = hs.length; i < len; i++) {
				var p = hs[i];
				if(cache[p]) {
					arr.push("<div data-name=\"" + p + "\" class=\"ss-hftab " + css + "\">" + map[p] + "</div>");
					css = "";
					if(!name) {
						name = p;
					}
				}
			}
			css = "selected";
			for(var i = 0, len = fs.length; i < len; i++) {
				var p = fs[i];
				if(cache[p]) {
					arr1.push("<div data-name=\"" + p + "\" class=\"ss-hftab " + css + "\">" + map[p] + "</div>");
					css = "";
					if(!name1) {
						name1 = p;
					}
				}
			}
			this.updatePreview(name);
			this.updatePreview(name1);
		} else {
			this.updatePreview("header");
			this.updatePreview("footer");
		}
		this.headerTabs.update(arr.join(""));
		this.footerTabs.update(arr1.join(""));
	},
	updatePreview: function(name) {
		if(!name) {
			this.headerPreview.update("");
			this.footerPreview.update("");
			this.headerCombo.setValue(0);
			this.footerCombo.setValue(0);
			return;
		}
		var box, combo;
		if(-1 !== name.toLowerCase().indexOf("header")) {
			box = this.headerPreview;
			combo = this.headerCombo;
		} else {
			box = this.footerPreview;
			combo = this.footerCombo;
		}
		var it = this.tabSettingLookup[name];
		if(it) {
			box.update(["<table class=\"ss-hf-table\"><tbody><tr>", "<td class=\"ss-hf-left\">", this.transferVal2Display(it.l), "</td>", "<td class=\"ss-hf-center\">", this.transferVal2Display(it.c), "</td>", "<td class=\"ss-hf-right\">", this.transferVal2Display(it.r), "</td>", "</tr></tbody></table>"].join(""));
			var val = this.tabSettingCache[name],
				flag;
			this.hfStore.each(function(rec) {
				if(rec.data.value === val) {
					combo.setValue(rec.data.id);
					flag = true;
					return false;
				}
			}, this);
			if(!flag) {
				var p = this.transferVal2Parts(val);
				var arr = [];
				if(p.l) {
					arr.push(p.l);
				}
				if(p.c) {
					arr.push(p.c);
				}
				if(p.r) {
					arr.push(p.r);
				}
				var text = arr.join(", ");
				combo.setRawValue(text);
			}
		} else {
			box.update("");
			combo.setValue(0);
		}
	},
	popupCustomerDefine: function(config) {
		config = config || {};
		var pos = config.pos,
			oddEven = config.oddEven,
			firstPage = config.firstPage;
		if(!this.customerDefineWin) {
			this.defineTabs = Ext.create("Ext.TabPanel", {
				plain: true,
				region: "north",
				listeners: {
					tabchange: {
						fn: this.onDefineTabChange,
						scope: this
					}
				}
			});
			this.leftPart = Ext.create("Ext.form.field.TextArea", {
				xtype: "textarea",
				labelAlign: "top",
				fieldLabel: SLANG.left,
				flex: 1,
				listeners: {
					focus: {
						fn: this.onPartFocus,
						scope: this
					},
					blur: {
						fn: this.onPartBlur,
						scope: this
					}
				}
			});
			this.centerPart = Ext.create("Ext.form.field.TextArea", {
				xtype: "textarea",
				labelAlign: "top",
				fieldLabel: SLANG.center,
				flex: 1,
				listeners: {
					focus: {
						fn: this.onPartFocus,
						scope: this
					},
					blur: {
						fn: this.onPartBlur,
						scope: this
					}
				}
			});
			this.rightPart = Ext.create("Ext.form.field.TextArea", {
				xtype: "textarea",
				labelAlign: "top",
				fieldLabel: SLANG.right,
				flex: 1,
				listeners: {
					focus: {
						fn: this.onPartFocus,
						scope: this
					},
					blur: {
						fn: this.onPartBlur,
						scope: this
					}
				}
			});
			this.customerDefineWin = Ext.create("Ext.window.Window", {
				modal: true,
				width: 600,
				height: 400,
				closeAction: "hide",
				bodyStyle: "background:white;padding:20px;",
				layout: "border",
				items: [this.defineTabs, {
					xtype: "container",
					padding: 10,
					region: "north",
					layout: {
						type: "hbox",
						pack: "center"
					},
					items: [{
						xtype: "button",
						text: "# " + SLANG.insert_page_no,
						handler: this.insertPageNo,
						scope: this
					}, {
						xtype: "button",
						style: "margin-left:10px;",
						text: "? " + SLANG.insert_total_page,
						handler: this.insertTotalPage,
						scope: this
					}, {
						xtype: "button",
						style: "margin-left:10px;",
						text: SLANG.insert_date,
						handler: this.insertDate,
						scope: this
					}, {
						xtype: "button",
						style: "margin-left:10px;",
						text: SLANG.insert_file,
						handler: this.insertFile,
						scope: this
					}, {
						xtype: "button",
						style: "margin-left:10px;",
						text: SLANG.insert_sheet,
						handler: this.insertSheet,
						scope: this
					}]
				}, {
					xtype: "container",
					region: "center",
					layout: {
						type: "hbox",
						padding: "10 0",
						align: "stretch"
					},
					padding: "0 0 20 0",
					items: [this.leftPart, {
						xtype: "component",
						width: 20
					}, this.centerPart, {
						xtype: "component",
						width: 20
					}, this.rightPart]
				}],
				buttons: [{
					text: SLANG.ok,
					handler: this.onDoneCustomDefine,
					scope: this
				}, {
					text: SLANG.cancel,
					handler: function() {
						this.customerDefineWin.hide();
					},
					scope: this
				}]
			});
		}
		if("header" === pos) {
			this.defineTabs.removeAll();
			if(firstPage && oddEven) {
				this.defineTabs.add([{
					title: SLANG.first_page_header,
					name: "firstHeader",
					border: false
				}, {
					title: SLANG.odd_page_header,
					name: "oddHeader",
					border: false
				}, {
					title: SLANG.even_page_header,
					name: "evenHeader",
					border: false
				}]);
			} else if(firstPage) {
				this.defineTabs.add([{
					title: SLANG.first_page_header,
					name: "firstHeader",
					border: false
				}, {
					title: SLANG.header,
					name: "header"
				}]);
			} else if(oddEven) {
				this.defineTabs.add([{
					title: SLANG.odd_page_header,
					name: "oddHeader",
					border: false
				}, {
					title: SLANG.even_page_header,
					name: "evenHeader",
					border: false
				}]);
			} else {
				this.defineTabs.add({
					title: SLANG.header,
					name: "header"
				});
			}
			this.customerDefineWin.setTitle(SLANG.define_header);
		} else {
			this.defineTabs.removeAll();
			if(firstPage && oddEven) {
				this.defineTabs.add([{
					title: SLANG.first_page_footer,
					name: "firstFooter",
					border: false
				}, {
					title: SLANG.odd_page_footer,
					name: "oddFooter",
					border: false
				}, {
					title: SLANG.even_page_footer,
					name: "evenFooter",
					border: false
				}]);
			} else if(firstPage) {
				this.defineTabs.add([{
					title: SLANG.first_page_footer,
					name: "firstFooter",
					border: false
				}, {
					title: SLANG.footer,
					name: "footer"
				}]);
			} else if(oddEven) {
				this.defineTabs.add([{
					title: SLANG.odd_page_footer,
					name: "oddFooter",
					border: false
				}, {
					title: SLANG.even_page_footer,
					name: "evenFooter",
					border: false
				}]);
			} else {
				this.defineTabs.add({
					title: SLANG.footer,
					name: "footer"
				});
			}
			this.customerDefineWin.setTitle(SLANG.define_footer);
		}
		this.defineTabs.setActiveTab(0);
		this.customerDefineWin.show();
	},
	onPartFocus: function(textArea) {
		this.curFocusPart = textArea;
	},
	onPartBlur: function(textArea) {},
	insertPageNo: function() {
		if(this.curFocusPart) {
			this.curFocusPart.focus(50);
			Ext.Function.defer(function() {
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)) {
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre + "&[" + SLANG.page_no + "]" + pos);
				} else {
					this.curFocusPart.setValue(val + "&[" + SLANG.page_no + "]");
				}
			}, 100, this);
		}
	},
	insertTotalPage: function() {
		if(this.curFocusPart) {
			this.curFocusPart.focus(50);
			Ext.Function.defer(function() {
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)) {
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre + "&[" + SLANG.total_page + "]" + pos);
				} else {
					this.curFocusPart.setValue(val + "&[" + SLANG.total_page + "]");
				}
			}, 100, this);
		}
	},
	insertDate: function() {
		if(this.curFocusPart) {
			this.curFocusPart.focus(50);
			Ext.Function.defer(function() {
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)) {
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre + "&[" + SLANG.date + "]" + pos);
				} else {
					this.curFocusPart.setValue(val + "&[" + SLANG.date + "]");
				}
			}, 100, this);
		}
	},
	insertFile: function() {
		if(this.curFocusPart) {
			this.curFocusPart.focus(50);
			Ext.Function.defer(function() {
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)) {
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre + "&[" + SLANG.file + "]" + pos);
				} else {
					this.curFocusPart.setValue(val + "&[" + SLANG.file + "]");
				}
			}, 100, this);
		}
	},
	insertSheet: function() {
		if(this.curFocusPart) {
			this.curFocusPart.focus(50);
			Ext.Function.defer(function() {
				var p = SCOM.getCursorPosition(this.curFocusPart.getFocusEl().dom);
				var val = this.curFocusPart.getValue();
				if(Ext.isNumber(p)) {
					var pre = val.slice(0, p);
					var pos = val.slice(p);
					this.curFocusPart.setValue(pre + "&[" + SLANG.tab + "]" + pos);
				} else {
					this.curFocusPart.setValue(val + "&[" + SLANG.tab + "]");
				}
			}, 100, this);
		}
	},
	getCustomSetting: function() {
		var me = this;
		var fn = function(part, pre) {
			var val = part.getValue();
			if(SCOM.isEmptyValue(val)) {
				return "";
			}
			val = me.transferDisplay2Val(val);
			val = pre + val;
			return val;
		};
		var val = fn(this.leftPart, "&L");
		val += fn(this.centerPart, "&C");
		val += fn(this.rightPart, "&R");
		return {
			val: val,
			setting: {
				l: this.leftPart.getValue() || "",
				c: this.centerPart.getValue() || "",
				r: this.rightPart.getValue() || ""
			}
		};
	},
	onDefineTabChange: function(tabs, activeTab, preActiveTab) {
		this.tabSettingCache = this.tabSettingCache || {};
		this.tabSettingLookup = this.tabSettingLookup || {};
		if(preActiveTab) {
			var name = preActiveTab.name;
			var obj = this.getCustomSetting();
			this.tabSettingCache[name] = obj.val;
			this.tabSettingLookup[name] = obj.setting;
		}
		if(activeTab) {
			var found = this.tabSettingLookup[activeTab.name];
			if(found) {
				this.leftPart.setValue(this.transferVal2Display(found.l));
				this.centerPart.setValue(this.transferVal2Display(found.c));
				this.rightPart.setValue(this.transferVal2Display(found.r));
			} else {
				this.leftPart.setValue("");
				this.centerPart.setValue("");
				this.rightPart.setValue("");
			}
		}
	},
	onDoneCustomDefine: function() {
		this.onDefineTabChange(this.defineTabs, null, this.defineTabs.getActiveTab());
		this.customerDefineWin.hide();
		this.setupHeaderFooterTabs();
	},
	prepareParam: function() {
		var obj = {};
		obj.pageSetup = {
			scaling: this.scaleAdjustRD.getValue() ? "adjust2" : "fit2",
			scaleAdjust2: this.scaleAdjustField.getValue(),
			scaleFit2: this.scaleFit2Field.getValue(),
			scaleFit2Tall: this.scaleFit2TallField.getValue(),
			orientation: this.portraitRD.getValue() ? "portrait" : "landscape",
			paperSize: this.paperSizeCombo.getValue(),
			printQuality: this.printQualityCombo.getValue()
		};
		obj.pageMargins = this.tabs.items.get(1).getValues();
		for(var p in obj.pageMargins) {
			if(obj.pageMargins.hasOwnProperty(p)) {
				obj.pageMargins[p] = Number(obj.pageMargins[p]);
			}
		}
		var differentFirst = this.firstPageCB.getValue();
		var differentOddEven = this.oddEvenCB.getValue();
		obj.headerFooter = {
			differentFirst: differentFirst,
			differentOddEven: differentOddEven,
			scaleWithDoc: this.scaleWithDocCB.getValue(),
			alignWithMargins: this.alignWithMarginsCB.getValue()
		};
		obj.sheet = {
			printArea: this.printAreaRangeField.getValue(),
			rows2RepeatTop: this.rows2RepeatTopField.getValue(),
			cols2RepeatLeft: this.cols2RepeatLeftField.getValue(),
			gridlines: this.gridlinesCB.getValue(),
			blackAndWhite: this.blackWhiteCB.getValue(),
			draftQuality: this.draftQualityCB.getValue(),
			rowColHeadings: this.rowColHeadingsCB.getValue()
		};
		if(differentFirst && differentOddEven) {
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, "firstHeader,oddHeader,evenHeader,firstFooter,oddFooter,evenFooter");
		} else if(differentFirst) {
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, "firstHeader,header,firstFooter,footer");
			if(obj.headerFooter.header) {
				obj.headerFooter.oddHeader = obj.headerFooter.header;
				delete obj.headerFooter.header;
			}
			if(obj.headerFooter.footer) {
				obj.headerFooter.oddFooter = obj.headerFooter.footer;
				delete obj.headerFooter.footer;
			}
		} else if(differentOddEven) {
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, "oddHeader,evenHeader,oddFooter,evenFooter");
		} else {
			Ext.copyTo(obj.headerFooter, this.tabSettingCache, "header,footer");
			if(obj.headerFooter.header) {
				obj.headerFooter.oddHeader = obj.headerFooter.header;
				delete obj.headerFooter.header;
			}
			if(obj.headerFooter.footer) {
				obj.headerFooter.oddFooter = obj.headerFooter.footer;
				delete obj.headerFooter.footer;
			}
		}
		return obj;
	},
	addBackground: function() {
		this.backgroundWin = Ext.create("EnterpriseSheet.sheet.pop.BackgroundWin", {});
		this.backgroundWin.bindSheet(this.sheet);
		this.backgroundWin.popup();
		this.close();
	},
	transferVal2Display: function(val) {
		if(val) {
			val = val.replace("&P", "&[" + SLANG.page_no + "]");
			val = val.replace("&N", "&[" + SLANG.total_page + "]");
			val = val.replace("&D", "&[" + SLANG.date + "]");
			val = val.replace("&A", "&[" + SLANG.tab + "]");
			val = val.replace("&F", "&[" + SLANG.file + "]");
		}
		return val;
	},
	transferDisplay2Val: function(val) {
		if(val) {
			val = val.replace("&[" + SLANG.page_no + "]", "&P");
			val = val.replace("&[" + SLANG.total_page + "]", "&N");
			val = val.replace("&[" + SLANG.date + "]", "&D");
			val = val.replace("&[" + SLANG.tab + "]", "&A");
			val = val.replace("&[" + SLANG.file + "]", "&F");
		}
		return val;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.FileDetailWin", {
	extend: "Ext.menu.Menu",
	requires: ["Ext.form.field.Text"],
	cls: "ss-flat-ui",
	width: 300,
	initComponent: function() {
		this.nameField = Ext.create("Ext.form.field.Text", {
			height: 30,
			allowBlank: false,
			emptyText: SLANG.title,
			name: "name"
		});
		this.descField = Ext.create("Ext.form.field.TextArea", {
			allowBlank: true,
			emptyText: SLANG.description,
			height: 100,
			anchor: "100%"
		});
		//2018 6.28去除选择颜色功能
/*		this.cssColorField = Ext.create("Ext.picker.Color", {
			height: 37,
			colors: SCOM.darkThemeColors,
			border: true
		});*/
		this.items = [this.nameField, this.descField, this.cssColorField];
		this.saveBtn = Ext.create("Ext.button.Button", {
			text: SLANG.save,
			handler: this.onOK,
			scope: this
		});
		this.buttonAlign = "center";
		this.buttons = [this.saveBtn];
		this.callParent();
/*		this.cssColorField.on("select", function(picker, selColor) {
			var o = this.updateCssColorCallback;
			o.fn.call(o.scope || this, {
				color: selColor
			}, this);
		}, this);*/
	},
	popup: function(config) {
		var filename = Ext.util.Format.trim(config.file.name);
		this.nameField.setValue(filename);
		this.showBy(config.sender, "tc-bc?");
		Ext.apply(this, config);
		Ext.Ajax.request({
			url: SCONFIG.urls.documentInfo,
			params: {
				id: config.file.id,
				//2018 3.30 增加是否模板参数
				isTpl:isTplfile
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if("true" == json.success || json.success == true) {
					this.descField.setValue(json.description);
				}
			},
			scope: this
		});
	},
	onOK: function() {
		var filename = this.nameField.getValue();
		var desc = this.descField.getValue();
		if(filename) {
			var o = this.applyCallback;
			o.fn.call(o.scope || this, {
				fileName: filename,
				description: desc
			}, this);
			TOPMINDER.showMsg("", SLANG.change_saved);
		}
		this.hide();
	}
});

Ext.define("EnterpriseSheet.sheet.pop.KeyShortcuts", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	alias: "widget.keyshortcuts",
	requires: [],
	layout: "anchor",
	autoScroll: true,
	initComponent: function() {
		if(!this.originHint) {
			this.originHint = SLANG.keyboard_shortcuts_desc;
		}
		this.html = this.originHint;
		if(!this.title) {
			this.title = SLANG.keyboard_shortcuts;
		}
		this.buttons = [{
			text: SLANG.close,
			handler: function() {
				this.close();
			},
			scope: this
		}];
		this.callParent(arguments);
	},
	popup: function(config) {
		this.show();
	}
});

Ext.define("EnterpriseSheet.sheet.pop.FormulaFunctionWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	width: 400,
	height: 500,
	layout: "border",
	labelWidth: 90,
	bodyStyle: "background-color:white;",
	initComponent: function() {
		this.functionTypeCombo = Ext.create("Ext.form.field.ComboBox", {
			editable: false,
			store: new Ext.data.SimpleStore({
				fields: ["type", "text"]
			}),
			listeners: {
				select: {
					fn: this._onFunctionTypeComboSelectFn,
					scope: this
				}
			},
			displayField: "text",
			valueField: "type",
			queryMode: "local",
			triggerAction: "all",
			width: 200,
			selectOnFocus: true
		});
		this.listView = Ext.create("Ext.grid.Panel", {
			listeners: {
				itemmouseenter: this._onMouseenterFn,
				itemclick: this._onSelectionchangeFn,
				scope: this
			},
			border: false,
			hideHeaders: true,
			region: "center",
			store: new Ext.data.ArrayStore({
				fields: ["name", "example", "description", "type"],
				sortInfo: {
					field: "name",
					direction: "ASC"
				},
				data: []
			}),
			reserveScrollOffset: false,
			columns: [{
				dataIndex: "name",
				flex: 1
			}, {
				dataIndex: "type",
				flex: 1,
				renderer: function(value) {
					return "<font color=\"gray\">" + SLANG[value] + "</font>";
				}
			}],
			tbar: [this.functionTypeCombo, "->", {
				text: SLANG.help,
				handler: function() {
					var newWindow = window.open("http://www.enterprisesheet.com/api/docs/formula/index.html", "_blank");
					newWindow.focus();
				}
			}]
		});
		this.descriptionPanel = new Ext.Container({
			region: "south",
			height: 120,
			cls: "ss-formula-win-desc",
			autoScroll: true,
			frame: true
		});
		this.items = [this.listView, this.descriptionPanel];
		this.callParent();
	},
	_initData: function() {
		var formulaData = EnterpriseSheet.sheet.floating.CalculateHint.prototype.hintData;
		var typeBoxData = [],
			tmpAry = [];
		for(var i = 0; i < formulaData.length; i++) {
			var typeValue = formulaData[i][3];
			if(!this._arrayContain(tmpAry, typeValue)) {
				tmpAry.push(typeValue);
				typeBoxData.push([typeValue, SLANG[typeValue]]);
			}
		}
		typeBoxData = [
			["all", SLANG.all]
		].concat(typeBoxData);
		this.functionTypeCombo.store.loadData(typeBoxData);
		this.listView.store.loadData(formulaData);
		this.functionTypeCombo.setValue("all");
	},
	_arrayContain: function(array, item) {
		var i, ln;
		for(i = 0, ln = array.length; i < ln; i++) {
			if(array[i] === item) {
				return true;
			}
		}
		return false;
	},
	_onFunctionTypeComboSelectFn: function(combo, rd, index) {
		var resultData = this._filterFormulaData(combo.getValue());
		this.listView.store.loadData(resultData);
	},
	_filterFormulaData: function(type) {
		var formulaData = EnterpriseSheet.sheet.floating.CalculateHint.prototype.hintData;
		if(type == "all") {
			return formulaData;
		}
		var resultData = [];
		for(var i = 0; i < formulaData.length; i++) {
			var tmpDta = formulaData[i];
			if(tmpDta[3] == type) {
				resultData.push(tmpDta);
			}
		}
		return resultData;
	},
	_onMouseenterFn: function(view, record, item, index, e, options) {
		this.descriptionPanel.update(record.data.description);
	},
	_onSelectionchangeFn: function(view, record, item, index, e, options) {
		var ss = this.spreadsheet;
		var editor = ss.editor;
		editor.setValue("=" + record.data.name + "(");
		var region = this.spreadsheet.getCurrentRegion();
		var sm = region.getSelectionModel();
		var fc = sm.getFocusCell();
		editor.startEdit(fc.row, fc.col, region, e, false, true);
		this.hide();
	},
	popup: function(sheet) {
		this.nameChanged = false;
		this.show();
		if(this.listView.store.getCount() == 0) {
			this._initData();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.CellOptionWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Radio"],
	boxLabel1: "",
	boxLabel2: "",
	boxLabel3: "",
	boxLabel4: "",
	title: "",
	bodyStyle: "padding:10px;",
	width: 250,
	layout: "anchor",
	autoHeight: true,
	initComponent: function() {
		this.defaults = {
			anchor: "100%"
		};
		this.items = [{
			xtype: "radio",
			checked: this.box1Disabled ? false : true,
			boxLabel: this.boxLabel1,
			disabled: this.box1Disabled,
			name: "cell-option"
		}, {
			xtype: "radio",
			boxLabel: this.boxLabel2,
			disabled: this.box2Disabled,
			name: "cell-option"
		}, {
			xtype: "radio",
			boxLabel: this.boxLabel3,
			disabled: this.box3Disabled,
			name: "cell-option"
		}, {
			xtype: "radio",
			boxLabel: this.boxLabel4,
			disabled: this.box4Disabled,
			name: "cell-option"
		}];
		this.callParent();
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.title) {
			this.setTitle(config.title);
		}
		var total = 0;
		if(config.boxLabel1) {
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId() + "-boxLabelEl");
			boxEl.update(config.boxLabel1);
			total = total + 1;
		}
		if(config.boxLabel2) {
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId() + "-boxLabelEl");
			boxEl.update(config.boxLabel2);
			total = total + 1;
		}
		if(config.boxLabel3) {
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId() + "-boxLabelEl");
			boxEl.update(config.boxLabel3);
			total = total + 1;
		}
		if(config.boxLabel4) {
			var radio = this.items.get(total);
			var boxEl = Ext.get(radio.getId() + "-boxLabelEl");
			boxEl.update(config.boxLabel4);
			total = total + 1;
		}
	},
	prepareParam: function() {
		var opt, i = 0;
		this.items.each(function(it) {
			if(it.getValue()) {
				opt = i;
				return false;
			}
			i++;
		}, this);
		return opt;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.ChartSettingWin", {
	extend: "Ext.window.Window",
	requires: ["EnterpriseSheet.common.menu.ScaleMenu", "Ext.form.RadioGroup", "Ext.form.FieldSet", "Ext.form.field.Text"],
	title: SLANG.chart_setting,
	closable: true,
	closeAction: "hide",
	bodyStyle: "background:white;padding:10px;",
	layout: "anchor",
	ghost: function(cls) {
		if(!Ext.getVersion("core").isLessThan("4.0.9")) {
			var me = this;
			me.ghostPanel = new Ext.panel.Panel({
				renderTo: document.body,
				floating: {
					shadow: false
				},
				frame: Ext.supports.CSS3BorderRadius && !me.isWindow ? me.frame : false,
				overlapHeader: me.overlapHeader,
				headerPosition: me.headerPosition,
				baseCls: me.baseCls,
				cls: me.baseCls + "-ghost " + (cls || "")
			});
		}
		return this.callParent(arguments);
	},
	initComponent: function() {
		this.chartTypeBtn = new Ext.button.Button({
			scale: "large",
			style: "margin-bottom:10px;",
			iconCls: "icon-column32",
			iconAlign: "top",
			minWidth: 70,
			text: SLANG.chart_type,
			menu: new EnterpriseSheet.common.menu.ScaleMenu({
				scale: "large",
				defaults: {
					scope: this,
					handler: this.changeChartType
				},
				items: [{
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-column32",
					text: SLANG.column,
					chartType: "column"
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-area32",
					text: SLANG.area,
					chartType: "area"
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-pie32",
					text: SLANG.pie,
					chartType: "pie"
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-line32",
					text: SLANG.line,
					chartType: "line"
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-bar32",
					text: SLANG.bar,
					chartType: "bar"
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-scatter32",
					text: SLANG.scatter,
					chartType: "scatter"
				}, {
					xtype: "scaleitem",
					scale: "large",
					iconCls: "icon-radar32",
					text: SLANG.radar,
					chartType: "radar"
				}]
			})
		});
		this.seriesPositionGroup = new Ext.form.RadioGroup({
			columns: 2,
			items: [{
				boxLabel: SLANG.row,
				name: "series-dir",
				inputValue: "row"
			}, {
				boxLabel: SLANG.column,
				name: "series-dir",
				inputValue: "col"
			}]
		});
		this.seriesFieldSet = new Ext.form.FieldSet({
			title: SLANG.series_position,
			items: [this.seriesPositionGroup],
			anchor: "100%"
		});
		this.legendPositionGroup = new Ext.form.RadioGroup({
			columns: 2,
			items: [{
				boxLabel: SLANG.top,
				name: "legend-position",
				inputValue: "top"
			}, {
				boxLabel: SLANG.bottom,
				name: "legend-position",
				inputValue: "bottom"
			}, {
				boxLabel: SLANG.left,
				name: "legend-position",
				inputValue: "left"
			}, {
				boxLabel: SLANG.right,
				name: "legend-position",
				inputValue: "right"
			}]
		});
		this.legendFieldSet = new Ext.form.FieldSet({
			title: SLANG.legend_position,
			items: [this.legendPositionGroup],
			anchor: "100%"
		});
		this.firstAsLabelGroup = new Ext.form.CheckboxGroup({
			columns: 1,
			items: [{
				boxLabel: SLANG.first_row_as_label,
				inputValue: true,
				name: "first_row_as_label"
			}, {
				boxLabel: SLANG.first_col_as_label,
				inputValue: true,
				name: "first_col_as_label"
			}]
		});
		this.labelFieldSet = new Ext.form.FieldSet({
			title: SLANG.label_setting,
			items: [this.firstAsLabelGroup],
			anchor: "100%"
		});
		this.xTitleField = new Ext.form.field.Text({
			labelAlign: "top",
			enableKeyEvents: true,
			fieldLabel: SLANG.title_x_axis,
			anchor: "100%"
		});
		this.yTitleField = new Ext.form.field.Text({
			labelAlign: "top",
			enableKeyEvents: true,
			fieldLabel: SLANG.title_y_axis,
			anchor: "100%"
		});
		this.deleteBtn = new Ext.button.Button({
			iconCls: "icon-delete",
			style: "margin-top:10px;",
			text: SLANG.delete_chart,
			handler: this.deleteChart,
			scope: this
		});
		this.items = [this.chartTypeBtn, this.seriesFieldSet, this.legendFieldSet, this.labelFieldSet, this.xTitleField, this.yTitleField, this.deleteBtn];
		this.callParent();
		this.on("hide", function() {
			if(this.chart) {
				this.chart.removeCls("ss-chart-actived");
			}
		}, this);
		if(this.sheet) {
			this.mon(this.sheet, {
				scope: this,
				deletechart: this.onDeleteChart
			});
		}
		this.mon(this.seriesPositionGroup, "change", this.onSeriesPositionChange, this, {
			buffer: 100
		});
		this.mon(this.legendPositionGroup, "change", this.onLegendPositionChange, this, {
			buffer: 100
		});
		this.mon(this.firstAsLabelGroup, "change", this.onLabelChange, this, {
			buffer: 100
		});
		this.mon(this.xTitleField, "keyup", this.onXTitleKeyUp, this, {
			buffer: 100
		});
		this.mon(this.yTitleField, "keyup", this.onYTitleKeyUp, this, {
			buffer: 100
		});
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.title) {
			this.setTitle(config.title);
		}
	},
	bindChart: function(chart) {
		if(this.chart && this.chart != chart) {
			this.chart.removeCls("ss-chart-actived");
		}
		chart.addCls("ss-chart-actived");
		this.chart = chart;
		this.syncSetting();
	},
	syncSetting: function() {
		this.syncSettingFlag = true;
		var setting = this.chart.getChartSetting();
		this.chartTypeBtn.setIconCls("icon-" + setting.chartType + "32");
		if("row" == setting.seriesPosition) {
			this.seriesPositionGroup.items.get(0).setValue(true);
		} else {
			this.seriesPositionGroup.items.get(1).setValue(true);
		}
		if("top" == setting.legendPosition) {
			this.legendPositionGroup.items.get(0).setValue(true);
		} else if("bottom" == setting.legendPosition) {
			this.legendPositionGroup.items.get(1).setValue(true);
		} else if("left" == setting.legendPosition) {
			this.legendPositionGroup.items.get(2).setValue(true);
		} else {
			this.legendPositionGroup.items.get(3).setValue(true);
		}
		this.firstAsLabelGroup.items.get(0).setValue(setting.firstRowLabel || false);
		this.firstAsLabelGroup.items.get(1).setValue(setting.firstColLabel || false);
		this.xTitleField.setValue(setting.xTitle);
		this.yTitleField.setValue(setting.yTitle);
		this.switchSeriesPosition();
		this.switchTitleField();
		delete this.syncSettingFlag;
	},
	switchSeriesPosition: function() {
		if(this.isSeriesRect()) {
			this.seriesFieldSet.show();
		} else {
			this.seriesFieldSet.hide();
		}
	},
	switchTitleField: function() {
		if("pie" == this.chart.chartType || "radar" == this.chart.chartType) {
			this.xTitleField.hide();
			this.yTitleField.hide();
		} else {
			this.xTitleField.show();
			this.yTitleField.show();
		}
	},
	isSeriesRect: function() {
		var rangeStore = this.chart.getRangeStore();
		return rangeStore.isSeriesRect();
	},
	popup: function(config) {
		this.bindChart(config.chart);
		if(!this.isVisible()) {
			if(config.xy) {
				this.showAt(config.xy);
			} else {
				this.show();
			}
		}
	},
	deleteChart: function() {
		if(this.chart) {
			this.chart.destroy();
			this.hide();
		}
	},
	changeChartType: function(item) {
		var chartType = item.chartType;
		this.chartTypeBtn.setIconCls(item.iconCls);
		this.chartTypeBtn.setText(item.text);
		if(this.chart) {
			this.chart.changeChartType(chartType);
		}
		this.syncSetting();
	},
	onDeleteChart: function(chartType, chart, rangeStore, posize, sheet) {
		if(this.chart == chart) {
			var floorSet = sheet.getFloorSet();
			for(var p in floorSet) {
				var it = floorSet[p];
				if(it != chart && it instanceof EnterpriseSheet.sheet.floating.chart.ChartFloor) {
					this.bindChart(it);
					return;
				}
			}
			this.hide();
		}
	},
	onLegendPositionChange: function(fieldSet, newVal, oldVal) {
		if(this.syncSettingFlag) {
			return;
		}
		var oldPos = oldVal['legend-position'];
		var pos = newVal['legend-position'];
		if(oldPos) {
			this.chart.changeLegendPosition(pos);
		}
	},
	onSeriesPositionChange: function(fieldSet, newVal, oldVal) {
		if(this.syncSettingFlag) {
			return;
		}
		var oldPos = oldVal['series-dir'];
		var pos = newVal['series-dir'];
		if(oldPos) {
			var rangeStore = this.chart.getRangeStore();
			rangeStore.changeSeriesPosition(pos);
			if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
				this.chart.changeChartType(this.chart.chartType, true);
			}
		}
	},
	onLabelChange: function(fieldSet, newVal, oldVal) {
		if(this.syncSettingFlag) {
			return;
		}
		var rangeStore = this.chart.getRangeStore();
		if(rangeStore.isRectangleCoord()) {
			rangeStore.refreshAsLabelChange(newVal.first_row_as_label || false, newVal.first_col_as_label || false);
			this.chart.changeChartType(this.chart.chartType, true);
		} else {
			Ext.Msg.alert(SLANG.hint, SLANG.not_rectangle_range);
		}
	},
	onXTitleKeyUp: function(textField, e, options) {
		if(this.chart) {
			this.chart.updateXTitle(textField.getValue());
		}
	},
	onYTitleKeyUp: function(textField, e, options) {
		if(this.chart) {
			this.chart.updateYTitle(textField.getValue());
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.CommentWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	width: 400,
	height: 300,
	layout: "anchor",
	labelWidth: 90,
	fieldLabel: SLANG.comment,
	bodyStyle: "padding:20px;background-color:white;",
	initComponent: function() {
		this.commentField = new Ext.form.field.TextArea({
			labelAlign: "top",
			fieldLabel: this.fieldLabel,
			allowBlank: false,
			enableKeyEvents: true,
			value: this.comment,
			height: 200,
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			},
			anchor: "100%"
		});
		this.items = [this.commentField];
		this.callParent();
		this.on("show", this._onShow, this);
	},
	_onShow: function() {
		if(!SCOM.nullOrUndefined(this.commentField._value)) {
			this.commentField.setValue(this.commentField._value);
		}
		this.commentField.focus(true, 100);
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.fieldLabel) {
			var El = this.commentField.getEl();
			var labelel = Ext.DomQuery.selectNode("label", El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		if(config.comment) {
			this.commentField._value = config.comment;
			this.commentField.setValue(config.comment);
		} else {
			delete this.commentField._value;
		}
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	onOK: function() {
		if(this.commentField.isValid()) {
			var comment = this.commentField.getValue();
			if(this.applyCallback) {
				var fn = this.applyCallback.fn,
					scope = this.applyCallback.scope;
				fn.call(scope, comment);
			}
			this.hide();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.CopiedCellOptionWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Radio"],
	boxLabel1: "",
	boxLabel2: "",
	title: "",
	bodyStyle: "padding:10px;",
	width: 250,
	layout: "anchor",
	autoHeight: true,
	initComponent: function() {
		this.defaults = {
			anchor: "100%"
		};
		this.items = [{
			xtype: "radio",
			checked: true,
			boxLabel: this.boxLabel1,
			name: "cell-option"
		}, {
			xtype: "radio",
			boxLabel: this.boxLabel2,
			name: "cell-option"
		}];
		this.callParent();
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.title) {
			this.setTitle(config.title);
		}
		if(config.boxLabel1) {
			var radio = this.items.get(0);
			var boxEl = Ext.get(radio.getId() + "-boxLabelEl");
			boxEl.update(config.boxLabel1);
		}
		if(config.boxLabel2) {
			var radio = this.items.get(1);
			var boxEl = Ext.get(radio.getId() + "-boxLabelEl");
			boxEl.update(config.boxLabel2);
		}
	},
	prepareParam: function() {
		var opt, i = 0;
		this.items.each(function(it) {
			if(it.getValue()) {
				opt = i;
				return false;
			}
			i++;
		}, this);
		return opt;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.FloatingContainer", {
	extend: "Ext.container.Container",
	floating: true,
	delayHideInterval: 1000,
	showBy: function(cmp, pos, off) {
		var me = this;
		me.showTimeStamp = new Date;
		if(me.floating && cmp) {
			me.show();
			me.setPagePosition(me.el.getAlignToXY(cmp.el || cmp, pos || me.defaultAlign, off));
		}
		return me;
	},
	delayHide: function() {
		Ext.Function.defer(function() {
			var me = this.me,
				timestamp = this.timestamp;
			if(!me.showTimeStamp || me.showTimeStamp.valueOf() <= timestamp.valueOf()) {
				me.hide();
			}
		}, this.delayHideInterval, {
			me: this,
			timestamp: new Date
		});
	}
});

Ext.define("EnterpriseSheet.sheet.pop.LinkWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text"],
	width: 270,
	minHeight: 100,
	layout: "anchor",
	labelWidth: 70,
	invalidMsg: SLANG.not_valid_url,
	initComponent: function() {
		this.urlField = new Ext.form.field.Text({
			fieldLabel: this.fieldLabel,
			msgTarget: "side",
			allowBlank: false,
			enableKeyEvents: true,
			invalidMsg: this.invalidMsg,
			validator: this.urlValidator,
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			},
			anchor: "100%"
		});
		this.cellSelectField = Ext.create("EnterpriseSheet.sheet.range.RangeField", {
			fieldLabel: this.fieldLabel,
			sheet: this.sheet,
			singleSelect: true,
			simpleSelect: true,
			disabled: true,
			hidden: true,
			anchor: "100%",
			allowBlank: false,
			listeners: {
				minimode: {
					scope: this,
					fn: function() {
						this.hide();
					}
				},
				normalmode: {
					scope: this,
					fn: function() {
						this.show();
						this.placeInDocCheck.setValue(true);
					}
				}
			}
		});
		this.placeInDocCheck = Ext.create("Ext.form.field.Checkbox", {
			fieldLabel: " ",
			labelSeparator: "",
			boxLabel: SLANG.placeInDoc
		});
		this.items = [this.urlField, this.cellSelectField, this.placeInDocCheck];
		this.callParent();
		this.on("show", this._onShow, this);
		this.placeInDocCheck.on({
			scope: this,
			change: this.onPlaceInDocChange
		});
	},
	_onShow: function() {
		this.urlField.focus(true, 100);
	},
	onPlaceInDocChange: function() {
		var placeInDoc = this.placeInDocCheck.getValue();
		if(placeInDoc) {
			this.urlField.setDisabled(true);
			this.cellSelectField.setDisabled(false);
			this.urlField.hide();
			this.cellSelectField.show();
		} else {
			this.urlField.setDisabled(false);
			this.cellSelectField.setDisabled(true);
			this.urlField.show();
			this.cellSelectField.hide();
		}
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.fieldLabel) {
			var El = this.urlField.getEl();
			var labelel = Ext.DomQuery.selectNode("label", El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title) {
			this.setTitle(config.title);
		}
	},
	prepareParam: function() {
		var val = this.urlField.getValue();
		if(this.placeInDocCheck.getValue()) {
			val = this.cellSelectField.getValue();
		}
		if(!SCONST.urlProReg.test(val) && !EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val)) {
			val = "http://" + val;
		}
		return val;
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	urlValidator: function(val) {
		if(SCONST.urlReg.test(val)) {
			return true;
		} else {
			return EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.LinkWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text"],
	width: 270,
	minHeight: 100,
	layout: "anchor",
	labelWidth: 70,
	invalidMsg: SLANG.not_valid_url,
	initComponent: function() {
		this.urlField = new Ext.form.field.Text({
			fieldLabel: this.fieldLabel,
			msgTarget: "side",
			allowBlank: false,
			enableKeyEvents: true,
			invalidMsg: this.invalidMsg,
			validator: this.urlValidator,
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			},
			anchor: "100%"
		});
		this.cellSelectField = Ext.create("EnterpriseSheet.sheet.range.RangeField", {
			fieldLabel: this.fieldLabel,
			sheet: this.sheet,
			singleSelect: true,
			simpleSelect: true,
			disabled: true,
			hidden: true,
			anchor: "100%",
			allowBlank: false,
			listeners: {
				minimode: {
					scope: this,
					fn: function() {
						this.hide();
					}
				},
				normalmode: {
					scope: this,
					fn: function() {
						this.show();
						this.placeInDocCheck.setValue(true);
					}
				}
			}
		});
		this.placeInDocCheck = Ext.create("Ext.form.field.Checkbox", {
			fieldLabel: " ",
			labelSeparator: "",
			boxLabel: SLANG.placeInDoc
		});
		this.items = [this.urlField, this.cellSelectField, this.placeInDocCheck];
		this.callParent();
		this.on("show", this._onShow, this);
		this.placeInDocCheck.on({
			scope: this,
			change: this.onPlaceInDocChange
		});
	},
	_onShow: function() {
		this.urlField.focus(true, 100);
	},
	onPlaceInDocChange: function() {
		var placeInDoc = this.placeInDocCheck.getValue();
		if(placeInDoc) {
			this.urlField.setDisabled(true);
			this.cellSelectField.setDisabled(false);
			this.urlField.hide();
			this.cellSelectField.show();
		} else {
			this.urlField.setDisabled(false);
			this.cellSelectField.setDisabled(true);
			this.urlField.show();
			this.cellSelectField.hide();
		}
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.fieldLabel) {
			var El = this.urlField.getEl();
			var labelel = Ext.DomQuery.selectNode("label", El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title) {
			this.setTitle(config.title);
		}
	},
	prepareParam: function() {
		var val = this.urlField.getValue();
		if(this.placeInDocCheck.getValue()) {
			val = this.cellSelectField.getValue();
		}
		if(!SCONST.urlProReg.test(val) && !EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val)) {
			val = "http://" + val;
		}
		return val;
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	urlValidator: function(val) {
		if(SCONST.urlReg.test(val)) {
			return true;
		} else {
			return EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.ReferenceNameList", {
	extend: "EnterpriseSheet.sheet.pop.FloatingContainer",
	requires: ["Ext.menu.Manager", "Ext.form.field.Text"],
	width: 250,
	height: 250,
	layout: "fit",
	style: "border:1px solid silver;padding:10px;background-color:rgb(250,250,250);",
	listEmptyText: SLANG.no_reference_name,
	withSheetName: true,
	initComponent: function() {
		var prefix = Ext.baseCSSPrefix;
		this.cls = this.cls || "";
		this.cls += " " + prefix + "menu";
		this.initStore();
		this.posField = new Ext.form.field.Text({
			emptyText: SLANG.input_pos,
			flex: 1,
			enableKeyEvents: true,
			allowBlank: false,
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			}
		});
		this.listView = new Ext.grid.Panel({
			region: "center",
			store: this.store,
			multiSelect: false,
			hideHeaders: true,
			viewConfig: {
				emptyText: "<div style=\"padding:10px;\">" + this.listEmptyText + "</div>",
				deferEmptyText: false
			},
			columns: [{
				text: "Name",
				flex: 40,
				dataIndex: "name"
			}, {
				text: "Range",
				flex: 60,
				dataIndex: "coord"
			}],
			bbar: {
				layout: "hbox",
				items: [this.posField, {
					xtype: "button",
					iconCls: "icon-popout",
					text: SLANG['goto'],
					handler: this.go2Pos,
					scope: this
				}]
			}
		});
		this.items = [this.listView];
		this.callParent();
		Ext.menu.Manager.register(this);
		this.mon(this.listView, {
			scope: this,
			itemclick: this.onItemClick
		});
	},
	initStore: function() {
		this.store = Ext.create("Ext.data.Store", {
			fields: ["id", "name", "ctype", "coord", "coordObj"]
		});
		if(this.refList) {
			this.loadRefList(this.refList);
		}
	},
	loadRefList: function(refList) {
		var store = this.store,
			sheetStore = this.sheet.getStore(),
			arr = [];
		store.removeAll();
		for(var i = 0, len = refList.length; i < len; i++) {
			var it = refList[i],
				ctype = it.ctype;
			if("ref" === ctype) {
				var obj = Ext.decode(it.json),
					coordStr;
				if(Ext.isArray(obj)) {
					var tmp = [];
					for(var k = 0, size = obj.length; k < size; k++) {
						var span = obj[k].span;
						span[0] = sheetStore.getSheetNameById(span[0]);
						tmp.push(EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
							span: span,
							type: SCONST.ABSOLUTE_COORD
						}], undefined, true));
					}
					coordStr = tmp.join(",");
				} else {
					var span = obj.span;
					span[0] = sheetStore.getSheetNameById(span[0]);
					coordStr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
						span: span,
						type: SCONST.ABSOLUTE_COORD
					}], undefined, true);
				}
				arr.push({
					id: it.id,
					name: it.name,
					ctype: ctype,
					coord: coordStr,
					coordObj: obj
				});
			}
		}
		store.add(arr);
		if(this.deleteBtn) {
			this.deleteBtn.disable();
		}
	},
	onItemClick: function(grid, rec) {
		var coordObj = rec.data.coordObj;
		var span;
		if(Ext.isArray(coordObj)) {
			span = coordObj[0].span;
		} else {
			span = coordObj.span;
		}
		var sheet = this.sheet,
			store = sheet.getStore(),
			sm = sheet.getSelectionModel();
		var sheetId = span[0];
		if(Ext.isString(sheetId)) {
			sheetId = store.getSheetIdByName(sheetId);
		}
		var curSheetId = sheet.getSheetId();
		if(curSheetId === sheetId) {
			sheet.go2Pos(span[1], span[2]);
			sm.selectRange({
				row: span[1],
				col: span[2]
			}, {
				row: span[3],
				col: span[4]
			});
		} else {
			sheet.go2Sheet(sheetId, function() {
				sheet.go2Pos(span[1], span[2]);
				sm.selectRange({
					row: span[1],
					col: span[2]
				}, {
					row: span[3],
					col: span[4]
				});
			});
		}
	},
	go2Pos: function() {
		if(!this.posField.isValid()) {
			return;
		}
		var val = this.posField.getValue();
		var sheet = this.sheet,
			store = sheet.getStore();
		try {
			sheet.go2CoordSpan(val);
		} catch(e) {}
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		e.stopPropagation();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.go2Pos();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.ReferenceNameWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text", "EnterpriseSheet.sheet.calculate.Coordinate"],
	width: 600,
	height: 400,
	layout: "border",
	labelWidth: 90,
	fieldLabel: SLANG.input_name,
	bodyStyle: "padding:15px;background-color:white;",
	prepareButton: Ext.emptyFn,
	cancelText: SLANG.close,
	deleteText: SLANG['delete'],
	listEmptyText: SLANG.no_reference_name,
	rangeLabelText: SLANG.refersTo,
	sheetLabelText: SLANG.scope,
	withSheetName: true,
	checkValid: function() {
		return true;
	},
	initComponent: function() {
		var me = this;
		this.nameField = new Ext.form.field.Text({
			labelAlign: "top",
			fieldLabel: this.fieldLabel,
			allowBlank: false,
			enableKeyEvents: true,
			value: this.nameValue,
			vtype: "alphanum",
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			},
			anchor: "100%"
		});
		this.initStore();
		this.sheetField = new Ext.form.field.ComboBox({
			labelAlign: "top",
			forceSelection: true,
			fieldLabel: this.sheetLabelText,
			allowBlank: false,
			store: this.scopeStore,
			valueField: "id",
			displayField: "name",
			queryMode: "local",
			value: -1,
			anchor: "100%"
		});
		this.listView = new Ext.grid.Panel({
			region: "center",
			store: this.store,
			multiSelect: false,
			viewConfig: {
				emptyText: "<div style=\"padding:10px;\">" + this.listEmptyText + "</div>",
				deferEmptyText: false
			},
			columns: [{
				text: SLANG.name,
				flex: 40,
				dataIndex: "name"
			}, {
				text: SLANG.scope,
				flex: 40,
				dataIndex: "scope",
				renderer: function(val) {
					var rec = me.scopeStore.getById(val);
					if(rec) {
						return rec.data.name;
					}
					return "";
				}
			}, {
				text: SLANG.refersTo,
				flex: 60,
				dataIndex: "coord"
			}]
		});
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({
			labelAlign: "top",
			fieldLabel: this.rangeLabelText,
			sheet: this.sheet,
			withSheetName: this.withSheetName,
			simpleSelect: this.simpleSelect,
			value: this.refValue,
			allowBlank: false,
			anchor: "100%"
		});
		this.commentField = Ext.create("Ext.form.field.TextArea", {
			labelAlign: "top",
			fieldLabel: SLANG.comment,
			height: 75,
			anchor: "100%"
		});
		this.items = [{
			xtype: "container",
			region: "north",
			layout: "anchor",
			items: [this.nameField]
		}, this.listView, {
			xtype: "container",
			region: "south",
			layout: "anchor",
			style: "padding-top:10px;",
			items: [this.sheetField, this.rangeField, this.commentField]
		}];
		this.deleteBtn = new Ext.button.Button({
			disabled: true,
			iconCls: "icon-delete",
			style: "margin-top:10px;",
			text: this.deleteText,
			handler: this.onDelete,
			scope: this
		});
		this.dockedItems = [{
			xtype: "container",
			dock: "right",
			width: 100,
			style: "padding:0px 10px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				text: this.okText,
				handler: this.onOK,
				scope: this
			}, {
				xtype: "button",
				text: this.cancelText,
				style: "margin-top:10px;",
				handler: this.onCancel,
				scope: this
			}, this.deleteBtn]
		}];
		this.callParent();
		this.on("show", this._onShow, this);
		this.on("hide", this._onHide, this);
		this.mon(this.listView, {
			scope: this,
			selectionchange: this.onSelectionChange
		});
		this.mon(this.rangeField, {
			scope: this,
			minimode: this.onRangeMiniMode,
			normalmode: this.onRangeNormalMode
		});
	},
	_onShow: function() {
		if(!SCOM.nullOrUndefined(this.nameField._nameValue)) {
			this.nameField.setValue(this.nameField._nameValue);
		}
		if(!SCOM.nullOrUndefined(this.rangeField._refValue)) {
			this.rangeField.setValue(this.rangeField._refValue);
		}
		this.nameField.focus(true, 100);
	},
	_onHide: function() {
		var rm = this.sheet.getReferenceModel();
		rm.hide();
	},
	initStore: function() {
		this.store = Ext.create("Ext.data.Store", {
			fields: ["fid", "name", "ctype", "scope", "coord", "comment"]
		});
		if(this.refList) {
			this.loadRefList(this.refList);
		}
		this.scopeStore = Ext.create("Ext.data.Store", {
			fields: ["id", "name"]
		});
		this.loadScopeList();
	},
	loadScopeList: function() {
		var sheetStore = this.sheet.getStore(),
			sheets = sheetStore.getSheets();
		var data = [{
			id: -1,
			name: SLANG.current_document
		}];
		for(var i = 0, len = sheets.length; i < len; i++) {
			var it = sheets[i];
			data.push({
				id: it.id,
				name: it.name
			});
		}
		this.scopeStore.removeAll();
		this.scopeStore.add(data);
	},
	loadRefList: function(refList) {
		var store = this.store,
			sheetStore = this.sheet.getStore(),
			arr = [],
			funcs = [];
		store.removeAll();
		for(var i = 0, len = refList.length; i < len; i++) {
			var it = refList[i],
				ctype = it.ctype;
			if("named_func" == ctype) {
				var cal = it.json,
					scope, flag = true;
				try {
					var jsonObj = Ext.decode(it.json);
					if(!Ext.isArray(jsonObj)) {
						jsonObj = [jsonObj];
					}
					for(var k = 0, size = jsonObj.length; k < size; k++) {
						var jsonIt = jsonObj[k];
						scope = jsonIt.scope;
						cal = jsonIt.cal;
						funcs.push({
							fid: it.id,
							name: it.name,
							scope: !Ext.isDefined(scope) ? -1 : Number(scope),
							ctype: ctype,
							coord: "=" + cal,
							comment: jsonIt.comment
						});
					}
				} catch(e) {
					funcs.push({
						fid: it.id,
						name: it.name,
						scope: !Ext.isDefined(scope) ? -1 : Number(scope),
						ctype: ctype,
						coord: "=" + cal
					});
				}
			}
		}
		store.add(arr.concat(funcs));
		if(this.deleteBtn) {
			this.deleteBtn.disable();
		}
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.fieldLabel) {
			var El = this.nameField.getEl();
			var labelel = Ext.DomQuery.selectNode("label", El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		if(config.nameValue) {
			this.nameField._nameValue = config.nameValue;
			this.nameField.setValue(config.nameValue);
		} else {
			delete this.nameField._nameValue;
		}
		if(config.refValue) {
			this.rangeField._refValue = config.refValue;
			this.rangeField.setValue(config.refValue);
		} else {
			delete this.rangeField._nameValue;
		}
		if(config.refList) {
			this.loadRefList(config.refList);
		}
		this.loadScopeList();
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	onOK: function() {
		if(this.nameField.isValid() && this.rangeField.isValid() && this.checkValid(this)) {
			var name = this.nameField.getValue(),
				comment = this.commentField.getValue();
			if(this.applyCallback) {
				var fn = this.applyCallback.fn,
					scope = this.applyCallback.scope,
					sheetId = this.sheetField.getValue();
				if(-1 === sheetId) {
					sheetId = undefined;
				}
				var v = this.rangeField.getValue();
				if("=" === v[0]) {
					var func = v.slice(1, v.length);
					fn.call(scope, name, func, "named_func", sheetId, comment);
				}
			}
			this.hide();
		}
	},
	onSelectionChange: function(sm, selection) {
		if(0 < selection.length) {
			this.deleteBtn.enable();
			var sel = selection[0];
			this.nameField.setValue(sel.data.name);
			this.commentField.setValue(sel.data.comment || "");
			this.sheetField.setValue(sel.data.scope || "");
			this.rangeField.setValue(sel.data.coord || "");
		} else {
			this.deleteBtn.disable();
		}
	},
	onDelete: function() {
		var sm = this.listView.getSelectionModel();
		var sel = sm.getLastSelected();
		this.store.remove(sel);
		if(this.deleteCallback) {
			var fn = this.deleteCallback.fn,
				scope = this.deleteCallback.scope;
			fn.call(scope, sel.data.ctype, sel.data.name, -1 === sel.data.scope ? undefined : sel.data.scope);
		}
		this.nameField.reset();
	},
	onRangeMiniMode: function(miniWin, rangeField) {
		this.nameField._nameValue = this.nameField.getValue();
		this.hide();
	},
	onRangeNormalMode: function(miniWin, rangeField) {
		this.show();
	}
});

Ext.define("EnterpriseSheet.sheet.pop.SizeWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Number"],
	width: 270,
	minHeight: 80,
	layout: "anchor",
	labelWidth: 90,
	invalidMsg: "Can not be a negative number",
	initComponent: function() {
		this.numberField = new Ext.form.NumberField({
			fieldLabel: this.fieldLabel,
			msgTarget: "side",
			allowBlank: false,
			enableKeyEvents: true,
			invalidMsg: this.invalidMsg,
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			},
			validator: function(v) {
				if(0 <= v) {
					return true;
				} else {
					return this.invalidMsg;
				}
			},
			anchor: "100%"
		});
		this.items = [this.numberField];
		this.callParent();
		this.on("show", this._onShow, this);
	},
	_onShow: function() {
		this.numberField.focus(true, 100);
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.fieldLabel) {
			var El = this.numberField.getEl();
			var labelel = Ext.DomQuery.selectNode("label", El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title) {
			this.setTitle(config.title);
		}
	},
	prepareParam: function() {
		return this.numberField.getValue();
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.SortOptionWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Radio"],
	boxLabel1: "",
	boxLabel2: "",
	title: "",
	bodyStyle: "padding:10px;",
	width: 250,
	layout: "anchor",
	autoHeight: true,
	initComponent: function() {
		var disableSortRange = false;
		if(SCONFIG.DISABLE_SORT_CURRENT_RANGE) {
			disableSortRange = true;
		}
		this.defaults = {
			anchor: "100%"
		};
		this.items = [{
			xtype: "radio",
			checked: true,
			boxLabel: this.boxLabel1,
			name: "cell-option"
		}, {
			xtype: "radio",
			disabled: disableSortRange,
			boxLabel: this.boxLabel2,
			name: "cell-option"
		}];
		this.callParent();
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.title) {
			this.setTitle(config.title);
		}
		if(config.boxLabel1) {
			var labelEl = this.items.get(0).labelEl;
			labelEl.update(config.boxLabel1);
		}
		if(config.boxLabel2) {
			var labelEl = this.items.get(1).labelEl;
			labelEl.update(config.boxLabel2);
		}
	},
	prepareParam: function() {
		var opt, i = 0;
		this.items.each(function(it) {
			if(it.getValue()) {
				opt = i;
				return false;
			}
			i++;
		}, this);
		return opt;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.TextWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text"],
	width: 400,
	layout: "anchor",
	labelWidth: 90,
	fieldLabel: SLANG.input_name,
	bodyStyle: "padding:25px;background-color:white;",
	initComponent: function() {
		this.nameField = new Ext.form.field.Text({
			labelAlign: "top",
			fieldLabel: this.fieldLabel,
			allowBlank: false,
			enableKeyEvents: true,
			value: this.value,
			vtype: this.filedVtype,
			listeners: {
				keypress: {
					fn: this.onKeyPress,
					scope: this
				}
			},
			anchor: "100%"
		});
		this.items = [this.nameField];
		this.callParent();
		this.on("show", this._onShow, this);
	},
	_onShow: function() {
		if(!SCOM.nullOrUndefined(this.nameField._value)) {
			this.nameField.setValue(this.nameField._value);
		}
		this.nameField.focus(true, 100);
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
		if(config.fieldLabel) {
			var El = this.nameField.getEl();
			var labelel = Ext.DomQuery.selectNode("label", El.dom.parentNode.parentNode);
			labelel.innerHTML = this.fieldLabel;
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		if(config.value) {
			this.nameField._value = config.value;
			this.nameField.setValue(config.value);
		} else {
			delete this.nameField._value;
		}
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK();
		}
	},
	onOK: function() {
		if(this.nameField.isValid()) {
			var name = this.nameField.getValue();
			var flag = false;
			if(this.applyCallback) {
				var fn = this.applyCallback.fn,
					scope = this.applyCallback.scope;
				flag = fn.call(scope, name);
			}
			if(true !== flag) {
				this.hide();
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.BackgroundWin", {
	extend: "Ext.window.Window",
	requires: ["Ext.form.field.Text"],
	width: 600,
	height: 500,
	cls: "ss-popup-win",
	layout: "anchor",
	title: SLANG.background,
	bodyStyle: "padding:20px;background-color:white;",
	closeAction: "hide",
	initComponent: function() {
		this.uploadForm = Ext.create("Ext.form.Panel", {
			padding: "10 20 10 20",
			border: false,
			fileUpload: true,
			url: SCONFIG.urls.uploadFile,
			width: 300,
			layout: {
				type: "hbox",
				align: "middle"
			},
			items: [{
				xtype: "filefield",
				buttonOnly: true,
				name: "filePath",
				buttonConfig: {
					iconCls: "icon-add",
					text: SLANG.upload_image,
					ui: "default-toolbar"
				},
				listeners: {
					change: {
						fn: this.onSelectLocalFile,
						scope: this
					}
				}
			}]
		});
		this.uploadFieldSet = Ext.create("Ext.form.FieldSet", {
			title: SLANG.browser,
			items: [this.uploadForm]
		});
		this.previewBox = new Ext.Component({
			cls: "sc-preview-box",
			style: "margin-top:10px;",
			height: 250,
			html: "<img src=\"\">"
		});
		this.urlField = new Ext.form.field.TextArea({
			labelAlign: "top",
			fieldLabel: SLANG.picture_link,
			anchor: "100%",
			height: 100,
			allowBlank: false
		});
		this.items = [this.uploadFieldSet, this.urlField, {
			xtype: "component",
			style: "padding-top:20px;color:gray;",
			html: SLANG.preview_img_below
		}, this.previewBox];
		this.buttons = [{
			xtype: "button",
			minWidth: 80,
			text: SLANG.preview,
			handler: this.previewPicture,
			scope: this
		}, "->", {
			xtype: "button",
			minWidth: 80,
			iconCls: "icon-delete",
			text: SLANG.remove,
			handler: this.removeBackground,
			scope: this
		}, {
			xtype: "button",
			minWidth: 80,
			text: SLANG.insert,
			handler: this.insertBackground,
			scope: this
		}, {
			text: SLANG.cancel,
			minWidth: 80,
			handler: function() {
				this.hide();
			},
			scope: this
		}];
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	popup: function() {
		this.show();
		this.urlField.reset();
		var img = this.previewBox.getEl().down("img");
		img.dom.src = "";
	},
	previewPicture: function() {
		if(this.urlField.isValid()) {
			var url = this.urlField.getValue();
			var img = this.previewBox.getEl().down("img");
			img.dom.src = url;
		}
	},
	insertBackground: function() {
		if(this.urlField.isValid()) {
			var url = this.urlField.getValue();
			this.sheet.insertSheetTabBackground(undefined, url);
			this.hide();
		}
	},
	removeBackground: function() {
		Ext.Msg.show({
			title: SLANG.hint,
			msg: SLANG.wanna_reomve_background,
			buttons: Ext.Msg.YESNO,
			fn: function(bid) {
				if("yes" === bid) {
					this.sheet.insertSheetTabBackground();
					this.hide();
				}
			},
			scope: this
		});
	},
	onSelectLocalFile: function() {
		this.uploadForm.submit({
			failure: function(form, action) {
				alert("Something wrong, please try again");
			},
			success: function(form, action) {
				var jsonData = action.result;
				if(jsonData.success && jsonData.success != "false") {
					var fileId = jsonData.attachId,
						fileName = jsonData.fileName;
					var url = SCONFIG.urls.downloadFile + "?attachId=" + fileId;
					this.urlField.setValue(url);
				}
			},
			scope: this
		});
	}
});

Ext.define("EnterpriseSheet.sheet.pop.ValidationWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Date"],
	title: SLANG.validation,
	width: 680,
	autoHeight: true,
	modal: false,
	itemSepChar: ",",
	layout: "anchor",
	fieldLabel: SLANG.comment,
	listEmptyText: SLANG.new_validation,
	skipResetOnShow: true,
	bodyStyle: "padding:40px 20px 10px 20px;background-color:white;",
	initStore: function() {
		this.store = Ext.create("Ext.data.Store", {
			fields: ["vid", "coord", "json"]
		});
	},
	initComponent: function() {
		this.initStore();
		this.listView = new Ext.view.View({
			dock: "left",
			width: 120,
			cls: "ss-validation-list",
			store: this.store,
			multiSelect: false,
			tpl: new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"item\">", "{coord}", "</div>", "</tpl>"].join(""), {
				compile: true
			}),
			itemSelector: "div.item",
			overItemCls: "x-item-over",
			emptyText: "<div style=\"padding:10px;\">" + this.listEmptyText + "</div>"
		});
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({
			fieldLabel: SLANG.cell_range,
			labelWidth: 70,
			sheet: this.sheet,
			flex: 1,
			anchor: "100%",
			value: this.value,
			margin: "0 0 15 0",
			allowBlank: false
		});
		this.dataTypeBtn = new Ext.button.Button({
			text: SLANG.number,
			dtype: SCONST.validateDataType.number,
			width: 90,
			menu: [{
				text: SLANG.number,
				dtype: SCONST.validateDataType.number,
				handler: this.selectNumber,
				scope: this
			}, {
				text: SLANG.text,
				dtype: SCONST.validateDataType.text,
				handler: this.selectText,
				scope: this
			}, {
				text: SLANG.date,
				dtype: SCONST.validateDataType.date,
				handler: this.selectDate,
				scope: this
			}, {
				text: SLANG.item_list,
				dtype: SCONST.validateDataType.list,
				handler: this.selectItem,
				scope: this
			}],
			margin: "0 5 0 0"
		});
		this.optionBtn = new Ext.button.Button({
			text: SLANG.between,
			option: SCONST.validateOption.between,
			width: 100,
			menu: {
				defaults: {
					handler: this.selectOption,
					scope: this
				},
				items: [{
					option: SCONST.validateOption.between,
					dtype: SCONST.validateDataType.number,
					text: SLANG.between
				}, {
					option: SCONST.validateOption.not_between,
					dtype: SCONST.validateDataType.number,
					text: SLANG.not_between
				}, {
					option: SCONST.validateOption.less,
					dtype: SCONST.validateDataType.number,
					text: "<"
				}, {
					option: SCONST.validateOption.less_equal,
					dtype: SCONST.validateDataType.number,
					text: "<="
				}, {
					option: SCONST.validateOption.greater,
					dtype: SCONST.validateDataType.number,
					text: ">"
				}, {
					option: SCONST.validateOption.greater_equal,
					dtype: SCONST.validateDataType.number,
					text: ">="
				}, {
					option: SCONST.validateOption.equal,
					dtype: SCONST.validateDataType.number,
					text: "="
				}, {
					option: SCONST.validateOption.not_equal,
					dtype: SCONST.validateDataType.number,
					text: "!="
				}, {
					option: SCONST.validateOption.contain,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.contain
				}, {
					option: SCONST.validateOption.not_contain,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.not_contain
				}, {
					option: SCONST.validateOption.equal,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.equal
				}, {
					option: SCONST.validateOption.is_email,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.is_valid_email
				}, {
					option: SCONST.validateOption.is_url,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.is_valid_url
				}, {
					option: SCONST.validateOption.is_date,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.is_valid_date
				}, {
					option: SCONST.validateOption.equal,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.equal
				}, {
					option: SCONST.validateOption.date_before,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.before
				}, {
					option: SCONST.validateOption.date_on_before,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.on_before
				}, {
					option: SCONST.validateOption.date_after,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.after
				}, {
					option: SCONST.validateOption.date_on_after,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.on_after
				}, {
					option: SCONST.validateOption.between,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.between
				}, {
					option: SCONST.validateOption.not_between,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.not_between
				}, {
					option: SCONST.validateOption.any_number,
					dtype: SCONST.validateDataType.number,
					hidden: true,
					text: SLANG.any_number
				}]
			},
			margin: "0 5 0 0"
		});
		this.hintField = new Ext.form.field.Text({
			fieldLabel: SLANG.hint_text,
			labelWidth: 70,
			labelSeparator: "",
			anchor: "100%",
			margin: "0 0 15 0"
		});
		this.allowInvalidCheckbox = new Ext.form.field.Checkbox({
			fieldLabel: "&nbsp;",
			labelWidth: 70,
			checked: true,
			labelSeparator: "",
			boxLabel: SLANG.allow_invalid,
			margin: "0 0 15 0"
		});
		this.ignoreBlankCheckbox = new Ext.form.field.Checkbox({
			fieldLabel: "&nbsp;",
			labelWidth: 70,
			checked: true,
			labelSeparator: "",
			boxLabel: SLANG.ignore_blank,
			margin: "0 0 15 0"
		});
		this.numField = new Ext.form.field.Number({
			hidden: true,
			flex: 1,
			margin: "0 5 0 0",
			allowBlank: false
		});
		this.intCheckbox = new Ext.form.field.Checkbox({
			hidden: true,
			labelSeparator: "",
			hideLabel: true,
			width: 100,
			boxLabel: SLANG.integer_only,
			margin: "0 0 0 5"
		});
		this.minField = new Ext.form.field.Number({
			margin: "0 5 0 0",
			flex: 1,
			allowBlank: false
		});
		this.maxField = new Ext.form.field.Number({
			flex: 1,
			allowBlank: false
		});
		this.textField = new Ext.form.field.Text({
			hidden: true,
			flex: 2,
			allowBlank: false
		});
		this.dateField = new Ext.form.field.Date({
			hidden: true,
			flex: 2,
			allowBlank: false
		});
		this.minDateField = new Ext.form.field.Date({
			hidden: true,
			margin: "0 5 0 0",
			allowBlank: false
		});
		this.maxDateField = new Ext.form.field.Date({
			hidden: true,
			allowBlank: false
		});
		this.emptyBox = new Ext.Component({
			hidden: true,
			flex: 2
		});
		this.fieldCt = new Ext.form.FieldContainer({
			fieldLabel: SLANG.criteria,
			labelWidth: 70,
			combineErrors: true,
			msgTarget: "qtip",
			layout: "hbox",
			defaults: {
				hideLabel: true
			},
			items: [this.dataTypeBtn, this.optionBtn, this.minField, this.maxField, this.numField, this.intCheckbox, this.textField, this.dateField, this.minDateField, this.maxDateField, this.emptyBox],
			margin: "0 0 15 0"
		});
		this.itemField = new Ext.form.field.Text({
			style: "margin-top:10px;",
			width: "100%",
			allowBlank: false
		});
		this.itemListCt = new Ext.form.FieldContainer({
			fieldLabel: "&nbsp;",
			labelWidth: 70,
			labelSeparator: "",
			combineErrors: true,
			msgTarget: "qtip",
			hidden: true,
			layout: "fit",
			items: [{
				xtype: "component",
				cls: "sc-item-list-hint",
				html: SLANG.item_hint
			}, this.itemField],
			margin: "0 0 15 0"
		});
		this.items = [this.rangeField, this.fieldCt, this.itemListCt, this.hintField, this.allowInvalidCheckbox, this.ignoreBlankCheckbox, {
			xtype: "container",
			layout: {
				type: "hbox",
				pack: "end"
			},
			style: "padding-top:30px;",
			items: [{
				xtype: "button",
				margins: "0 10 0 0",
				minWidth: 70,
				text: SLANG.save,
				handler: this.onSave,
				scope: this
			}, {
				xtype: "button",
				text: SLANG.remove_validation,
				margins: "0 10 0 0",
				handler: this.onRemoveValidation,
				scope: this
			}, {
				xtype: "button",
				text: SLANG.close,
				minWidth: 70,
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.dockedItems = [this.listView];
		this.callParent();
		this.on("show", this._onShow, this);
		this.mon(this.rangeField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: function() {
				this.show();
			}
		});
		this.mon(this.listView, {
			scope: this,
			selectionchange: this.onValidateSelectionChange
		});
		this.mon(this.minField, {
			scope: this,
			change: this.onMinChange
		});
		this.mon(this.maxField, {
			scope: this,
			change: this.onMaxChange
		});
		this.mon(this.minDateField, {
			scope: this,
			change: this.onMinDateChange
		});
		this.mon(this.maxDateField, {
			scope: this,
			change: this.onMaxDateChange
		});
	},
	setDataTypeOption: function(dt, op) {
		var found;
		var menu = this.dataTypeBtn.menu;
		if(!SCOM.nullOrUndefined(dt)) {
			this.dataTypeBtn.dtype = dt;
			menu.items.each(function(it) {
				if(dt === it.dtype) {
					found = it;
					this.dataTypeBtn.setText(it.text);
					return false;
				}
			}, this);
		} else {
			var it = menu.items.first();
			found = it;
			this.dataTypeBtn.dtype = it.dtype;
			this.dataTypeBtn.setText(it.text);
		}
		found.handler.call(this, found);
		menu = this.optionBtn.menu;
		if(!SCOM.nullOrUndefined(op)) {
			this.optionBtn.option = op;
			menu.items.each(function(it) {
				if(op === it.option) {
					this.optionBtn.setText(it.text);
					found = it;
					return false;
				}
			}, this);
		} else {
			var it = menu.items.first();
			this.optionBtn.option = it.option;
			this.optionBtn.setText(it.text);
			found = it;
		}
		this.selectOption(found);
	},
	popup: function() {
		this.show();
		var sheet = this.sheet;
		if(sheet) {
			this.prepareValidation();
		}
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			sheet.disableSelect();
			sheet.disableEdit();
			sheet.enableRefer(true);
		}
		this.rangeField.focus(null, 10);
	},
	isValid: function() {
		var valid = true;
		if(!this.rangeField.isValid()) {
			valid = false;
		}
		if(!this.hintField.isValid()) {
			valid = false;
		}
		if(this.minField.isVisible() && !this.minField.isValid()) {
			valid = false;
		}
		if(this.maxField.isVisible() && !this.maxField.isValid()) {
			valid = false;
		}
		if(this.numField.isVisible() && !this.numField.isValid()) {
			valid = false;
		}
		if(this.textField.isVisible() && !this.textField.isValid()) {
			valid = false;
		}
		if(this.dateField.isVisible() && !this.dateField.isValid()) {
			valid = false;
		}
		if(this.minDateField.isVisible() && !this.minDateField.isValid()) {
			valid = false;
		}
		if(this.maxDateField.isVisible() && !this.maxDateField.isValid()) {
			valid = false;
		}
		if(this.itemListCt.isVisible() && !this.itemField.isValid()) {
			valid = false;
		}
		return valid;
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true);
		}
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
	},
	prepareButton: function() {
		delete this.buttons;
	},
	getValidSetting: function() {
		var sels = this.listView.getSelectionModel().getSelection();
		var sel = sels[0];
		var dts = SCONST.validateDataType,
			ops = SCONST.validateOption;
		var dataType = this.dataTypeBtn.dtype;
		var option = this.optionBtn.option;
		var json = {
			id: sel.data.vid,
			dt: dataType,
			op: option
		};
		if(dts.number === dataType) {
			if(ops.between === option || ops.not_between === option) {
				var min = this.minField.getValue();
				var max = this.maxField.getValue();
				json.min = min;
				json.max = max;
			} else {
				var num = this.numField.getValue();
				json.num = num;
			}
			if(this.intCheckbox.getValue()) {
				json.io = true;
			}
		} else if(dts.text === dataType) {
			if(ops.is_email !== option && ops.is_url !== option) {
				var text = this.textField.getValue();
				json.txt = text;
			}
		} else if(dts.date === dataType) {
			if(ops.between === option || ops.not_between === option) {
				var mind = this.minDateField.getValue();
				var maxd = this.maxDateField.getValue();
				json.mind = Ext.Date.format(mind, "Y-m-d");
				json.maxd = Ext.Date.format(maxd, "Y-m-d");
			} else if(ops.is_date !== option) {
				var date = this.dateField.getValue();
				json.date = Ext.Date.format(date, "Y-m-d");
			}
		} else if(dts.list === dataType) {
			json.list = this.getItemList();
		}
		json.hint = this.hintField.getValue();
		json.allow = this.allowInvalidCheckbox.getValue();
		json.ignoreBlank = this.ignoreBlankCheckbox.getValue();
		var coord = this.rangeField.getCoord();
		var arr = [];
		for(var i = 0, len = coord.length; i < len; i++) {
			arr.push(coord[i].span);
		}
		json.coord = arr;
		return json;
	},
	onSave: function() {
		if(this.isValid()) {
			var setting = this.getValidSetting();
			var id = setting.id;
			delete setting.id;
			this.sheet.setValidation(setting, false, false, id);
			this.hide();
		}
	},
	onRemoveValidation: function() {
		var sels = this.listView.getSelectionModel().getSelection();
		var sel = sels[0];
		var id = sel.data.vid;
		if(id) {
			Ext.Msg.show({
				title: SLANG.confirm,
				msg: SLANG.do_u_really_wanna_delete,
				icon: Ext.Msg.QUESTION,
				buttons: Ext.Msg.YESNO,
				fn: function(btn) {
					if("yes" == btn) {
						this.sheet.setValidation(null, false, false, id, "delete");
						this.hide();
					}
				},
				scope: this
			});
		} else {
			this.hide();
		}
	},
	switchOptions: function(dtype) {
		var items = this.optionBtn.menu.items;
		var first;
		items.each(function(it) {
			if(it.dtype === dtype) {
				if(!first) {
					first = it;
				}
				it.show();
			} else {
				it.hide();
			}
		});
		if(first) {
			this.selectOption(first);
		}
	},
	selectNumber: function(item) {
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectText: function(item) {
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectDate: function(item) {
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectItem: function(item) {
		this.intCheckbox.hide();
		this.minField.hide();
		this.maxField.hide();
		this.textField.hide();
		this.dateField.hide();
		this.minDateField.hide();
		this.maxDateField.hide();
		this.emptyBox.show();
		this.optionBtn.hide();
		this.itemListCt.show();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectOption: function(item) {
		var option = item.option;
		this.optionBtn.option = option;
		this.optionBtn.setText(item.text);
		var dtype = this.dataTypeBtn.dtype;
		var dts = SCONST.validateDataType,
			ops = SCONST.validateOption;
		if(dts.number == dtype) {
			this.intCheckbox.show();
			if(ops.between === option || ops.not_between === option) {
				this.minField.show();
				this.maxField.show();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			} else if(ops.any_number === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			} else {
				this.minField.hide();
				this.maxField.hide();
				this.numField.show();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			}
		} else if(dts.text == dtype) {
			this.intCheckbox.hide();
			if(ops.is_email === option || ops.is_url === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.show();
			} else {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.show();
				this.emptyBox.hide();
			}
		} else if(dts.date == dtype) {
			this.intCheckbox.hide();
			if(ops.is_date === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.show();
			} else if(ops.between === option || ops.not_between === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.show();
				this.maxDateField.show();
				this.textField.hide();
				this.emptyBox.hide();
			} else {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.show();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			}
		} else {
			this.intCheckbox.hide();
		}
	},
	prepareValidation: function() {
		var store = this.store;
		var sheet = this.sheet;
		var sheetId = sheet.getSheetId();
		var sm = sheet.getSelectionModel();
		var sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;
		store.removeAll();
		var sheetStore = sheet.getStore();
		var vds = sheetStore.getValidationBySheet(sheetId) || [];
		var lookup = {};
		for(var i = 0, len = vds.length; i < len; i++) {
			var it = vds[i];
			var coord = it.coord;
			var coordStr = sheet.coord2StringWithSheetName(coord, sep, true);
			lookup[coordStr] = store.add({
				vid: it.id,
				coord: coordStr,
				json: it
			});
		}
		var coord = sm.selection2Coord();
		var coordStr = sheet.coord2StringWithSheetName(coord, sep, true);
		if(!lookup[coordStr]) {
			store.insert(0, {
				coord: coordStr,
				json: {
					coord: coord
				}
			});
		} else {
			store.remove(lookup[coordStr]);
			store.insert(0, lookup[coordStr]);
		}
		this.rangeField.focus(null, 10);
		this.rangeField.setValue(coord);
		this.listView.select(0);
	},
	onValidateSelectionChange: function() {
		var list = this.listView;
		var sels = list.selModel.getSelection();
		if(0 < sels.length) {
			var rec = sels[0];
			var json = rec.data.json;
			this.presetFields(json);
			this.rangeField.focus(100);
		}
	},
	presetFields: function(json) {
		var coord = json.coord;
		this.rangeField.setValue(coord);
		var dt = json.dt,
			op = json.op,
			io = json.io;
		this.setDataTypeOption(dt, op);
		this.intCheckbox.setValue(io ? true : false);
		if(Ext.isNumber(json.min)) {
			this.minField.setValue(json.min);
		} else {
			this.minField.reset();
		}
		if(Ext.isNumber(json.max)) {
			this.maxField.setValue(json.max);
		} else {
			this.maxField.reset();
		}
		if(Ext.isNumber(json.num)) {
			this.numField.setValue(json.num);
		} else {
			this.numField.reset();
		}
		if(json.txt) {
			this.textField.setValue(json.txt);
		} else {
			this.textField.reset();
		}
		if(json.date) {
			this.dateField.setValue(json.date);
		} else {
			this.dateField.reset();
		}
		if(json.mind) {
			this.minDateField.setValue(json.mind);
		} else {
			this.minDateField.reset();
		}
		if(json.maxd) {
			this.maxDateField.setValue(json.maxd);
		} else {
			this.maxDateField.reset();
		}
		if(json.list) {
			var str = json.list.join(this.itemSepChar);
			this.itemField.setValue(str);
		} else {
			this.itemField.reset();
		}
		if(json.hint) {
			this.hintField.setValue(json.hint);
		} else {
			this.hintField.reset();
		}
		if(false === json.allow) {
			this.allowInvalidCheckbox.setValue(false);
		} else {
			this.allowInvalidCheckbox.setValue(true);
		}
		if(false === json.ignoreBlank) {
			this.ignoreBlankCheckbox.setValue(false);
		} else {
			this.ignoreBlankCheckbox.setValue(true);
		}
	},
	onMinChange: function(field, newVal, oldVal) {
		var other = this.maxField.getValue();
		if(other < newVal) {
			this.maxField.setValue(newVal);
		}
	},
	onMaxChange: function(field, newVal, oldVal) {
		var other = this.minField.getValue();
		if(other > newVal) {
			this.minField.setValue(newVal);
		}
	},
	onMinDateChange: function(field, newVal, oldVal) {
		var other = this.maxDateField.getValue();
		if(0 < newVal - other) {
			this.maxDateField.setValue(newVal);
		}
	},
	onMaxDateChange: function(field, newVal, oldVal) {
		var other = this.minDateField.getValue();
		if(0 > newVal - other) {
			this.minDateField.setValue(newVal);
		}
	},
	getItemList: function() {
		var val = this.itemField.getValue();
		var arr = val.split(this.itemSepChar);
		var list = [];
		for(var i = 0, len = arr.length; i < len; i++) {
			var it = Ext.String.trim(arr[i]);
			if(it) {
				list.push(it);
			}
		}
		return list;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.ValidationWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Date"],
	title: SLANG.validation,
	width: 680,
	autoHeight: true,
	modal: false,
	itemSepChar: ",",
	layout: "anchor",
	fieldLabel: SLANG.comment,
	listEmptyText: SLANG.new_validation,
	skipResetOnShow: true,
	bodyStyle: "padding:40px 20px 10px 20px;background-color:white;",
	initStore: function() {
		this.store = Ext.create("Ext.data.Store", {
			fields: ["vid", "coord", "json"]
		});
	},
	initComponent: function() {
		this.initStore();
		this.listView = new Ext.view.View({
			dock: "left",
			width: 120,
			cls: "ss-validation-list",
			store: this.store,
			multiSelect: false,
			tpl: new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"item\">", "{coord}", "</div>", "</tpl>"].join(""), {
				compile: true
			}),
			itemSelector: "div.item",
			overItemCls: "x-item-over",
			emptyText: "<div style=\"padding:10px;\">" + this.listEmptyText + "</div>"
		});
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({
			fieldLabel: SLANG.cell_range,
			labelWidth: 70,
			sheet: this.sheet,
			flex: 1,
			anchor: "100%",
			value: this.value,
			margin: "0 0 15 0",
			allowBlank: false
		});
		this.dataTypeBtn = new Ext.button.Button({
			text: SLANG.number,
			dtype: SCONST.validateDataType.number,
			width: 90,
			menu: [{
				text: SLANG.number,
				dtype: SCONST.validateDataType.number,
				handler: this.selectNumber,
				scope: this
			}, {
				text: SLANG.text,
				dtype: SCONST.validateDataType.text,
				handler: this.selectText,
				scope: this
			}, {
				text: SLANG.date,
				dtype: SCONST.validateDataType.date,
				handler: this.selectDate,
				scope: this
			}, {
				text: SLANG.item_list,
				dtype: SCONST.validateDataType.list,
				handler: this.selectItem,
				scope: this
			}],
			margin: "0 5 0 0"
		});
		this.optionBtn = new Ext.button.Button({
			text: SLANG.between,
			option: SCONST.validateOption.between,
			width: 100,
			menu: {
				defaults: {
					handler: this.selectOption,
					scope: this
				},
				items: [{
					option: SCONST.validateOption.between,
					dtype: SCONST.validateDataType.number,
					text: SLANG.between
				}, {
					option: SCONST.validateOption.not_between,
					dtype: SCONST.validateDataType.number,
					text: SLANG.not_between
				}, {
					option: SCONST.validateOption.less,
					dtype: SCONST.validateDataType.number,
					text: "<"
				}, {
					option: SCONST.validateOption.less_equal,
					dtype: SCONST.validateDataType.number,
					text: "<="
				}, {
					option: SCONST.validateOption.greater,
					dtype: SCONST.validateDataType.number,
					text: ">"
				}, {
					option: SCONST.validateOption.greater_equal,
					dtype: SCONST.validateDataType.number,
					text: ">="
				}, {
					option: SCONST.validateOption.equal,
					dtype: SCONST.validateDataType.number,
					text: "="
				}, {
					option: SCONST.validateOption.not_equal,
					dtype: SCONST.validateDataType.number,
					text: "!="
				}, {
					option: SCONST.validateOption.contain,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.contain
				}, {
					option: SCONST.validateOption.not_contain,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.not_contain
				}, {
					option: SCONST.validateOption.equal,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.equal
				}, {
					option: SCONST.validateOption.is_email,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.is_valid_email
				}, {
					option: SCONST.validateOption.is_url,
					dtype: SCONST.validateDataType.text,
					hidden: true,
					text: SLANG.is_valid_url
				}, {
					option: SCONST.validateOption.is_date,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.is_valid_date
				}, {
					option: SCONST.validateOption.equal,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.equal
				}, {
					option: SCONST.validateOption.date_before,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.before
				}, {
					option: SCONST.validateOption.date_on_before,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.on_before
				}, {
					option: SCONST.validateOption.date_after,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.after
				}, {
					option: SCONST.validateOption.date_on_after,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.on_after
				}, {
					option: SCONST.validateOption.between,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.between
				}, {
					option: SCONST.validateOption.not_between,
					dtype: SCONST.validateDataType.date,
					hidden: true,
					text: SLANG.not_between
				}, {
					option: SCONST.validateOption.any_number,
					dtype: SCONST.validateDataType.number,
					hidden: true,
					text: SLANG.any_number
				}]
			},
			margin: "0 5 0 0"
		});
		this.hintField = new Ext.form.field.Text({
			fieldLabel: SLANG.hint_text,
			labelWidth: 70,
			labelSeparator: "",
			anchor: "100%",
			margin: "0 0 15 0"
		});
		this.allowInvalidCheckbox = new Ext.form.field.Checkbox({
			fieldLabel: "&nbsp;",
			labelWidth: 70,
			checked: true,
			labelSeparator: "",
			boxLabel: SLANG.allow_invalid,
			margin: "0 0 15 0"
		});
		this.ignoreBlankCheckbox = new Ext.form.field.Checkbox({
			fieldLabel: "&nbsp;",
			labelWidth: 70,
			checked: true,
			labelSeparator: "",
			boxLabel: SLANG.ignore_blank,
			margin: "0 0 15 0"
		});
		this.numField = new Ext.form.field.Number({
			hidden: true,
			flex: 1,
			margin: "0 5 0 0",
			allowBlank: false
		});
		this.intCheckbox = new Ext.form.field.Checkbox({
			hidden: true,
			labelSeparator: "",
			hideLabel: true,
			width: 100,
			boxLabel: SLANG.integer_only,
			margin: "0 0 0 5"
		});
		this.minField = new Ext.form.field.Number({
			margin: "0 5 0 0",
			flex: 1,
			allowBlank: false
		});
		this.maxField = new Ext.form.field.Number({
			flex: 1,
			allowBlank: false
		});
		this.textField = new Ext.form.field.Text({
			hidden: true,
			flex: 2,
			allowBlank: false
		});
		this.dateField = new Ext.form.field.Date({
			hidden: true,
			flex: 2,
			allowBlank: false
		});
		this.minDateField = new Ext.form.field.Date({
			hidden: true,
			margin: "0 5 0 0",
			allowBlank: false
		});
		this.maxDateField = new Ext.form.field.Date({
			hidden: true,
			allowBlank: false
		});
		this.emptyBox = new Ext.Component({
			hidden: true,
			flex: 2
		});
		this.fieldCt = new Ext.form.FieldContainer({
			fieldLabel: SLANG.criteria,
			labelWidth: 70,
			combineErrors: true,
			msgTarget: "qtip",
			layout: "hbox",
			defaults: {
				hideLabel: true
			},
			items: [this.dataTypeBtn, this.optionBtn, this.minField, this.maxField, this.numField, this.intCheckbox, this.textField, this.dateField, this.minDateField, this.maxDateField, this.emptyBox],
			margin: "0 0 15 0"
		});
		this.itemField = new Ext.form.field.Text({
			style: "margin-top:10px;",
			width: "100%",
			allowBlank: false
		});
		this.itemListCt = new Ext.form.FieldContainer({
			fieldLabel: "&nbsp;",
			labelWidth: 70,
			labelSeparator: "",
			combineErrors: true,
			msgTarget: "qtip",
			hidden: true,
			layout: "fit",
			items: [{
				xtype: "component",
				cls: "sc-item-list-hint",
				html: SLANG.item_hint
			}, this.itemField],
			margin: "0 0 15 0"
		});
		this.items = [this.rangeField, this.fieldCt, this.itemListCt, this.hintField, this.allowInvalidCheckbox, this.ignoreBlankCheckbox, {
			xtype: "container",
			layout: {
				type: "hbox",
				pack: "end"
			},
			style: "padding-top:30px;",
			items: [{
				xtype: "button",
				margins: "0 10 0 0",
				minWidth: 70,
				text: SLANG.save,
				handler: this.onSave,
				scope: this
			}, {
				xtype: "button",
				text: SLANG.remove_validation,
				margins: "0 10 0 0",
				handler: this.onRemoveValidation,
				scope: this
			}, {
				xtype: "button",
				text: SLANG.close,
				minWidth: 70,
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.dockedItems = [this.listView];
		this.callParent();
		this.on("show", this._onShow, this);
		this.mon(this.rangeField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: function() {
				this.show();
			}
		});
		this.mon(this.listView, {
			scope: this,
			selectionchange: this.onValidateSelectionChange
		});
		this.mon(this.minField, {
			scope: this,
			change: this.onMinChange
		});
		this.mon(this.maxField, {
			scope: this,
			change: this.onMaxChange
		});
		this.mon(this.minDateField, {
			scope: this,
			change: this.onMinDateChange
		});
		this.mon(this.maxDateField, {
			scope: this,
			change: this.onMaxDateChange
		});
	},
	setDataTypeOption: function(dt, op) {
		var found;
		var menu = this.dataTypeBtn.menu;
		if(!SCOM.nullOrUndefined(dt)) {
			this.dataTypeBtn.dtype = dt;
			menu.items.each(function(it) {
				if(dt === it.dtype) {
					found = it;
					this.dataTypeBtn.setText(it.text);
					return false;
				}
			}, this);
		} else {
			var it = menu.items.first();
			found = it;
			this.dataTypeBtn.dtype = it.dtype;
			this.dataTypeBtn.setText(it.text);
		}
		found.handler.call(this, found);
		menu = this.optionBtn.menu;
		if(!SCOM.nullOrUndefined(op)) {
			this.optionBtn.option = op;
			menu.items.each(function(it) {
				if(op === it.option) {
					this.optionBtn.setText(it.text);
					found = it;
					return false;
				}
			}, this);
		} else {
			var it = menu.items.first();
			this.optionBtn.option = it.option;
			this.optionBtn.setText(it.text);
			found = it;
		}
		this.selectOption(found);
	},
	popup: function() {
		this.show();
		var sheet = this.sheet;
		if(sheet) {
			this.prepareValidation();
		}
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			sheet.disableSelect();
			sheet.disableEdit();
			sheet.enableRefer(true);
		}
		this.rangeField.focus(null, 10);
	},
	isValid: function() {
		var valid = true;
		if(!this.rangeField.isValid()) {
			valid = false;
		}
		if(!this.hintField.isValid()) {
			valid = false;
		}
		if(this.minField.isVisible() && !this.minField.isValid()) {
			valid = false;
		}
		if(this.maxField.isVisible() && !this.maxField.isValid()) {
			valid = false;
		}
		if(this.numField.isVisible() && !this.numField.isValid()) {
			valid = false;
		}
		if(this.textField.isVisible() && !this.textField.isValid()) {
			valid = false;
		}
		if(this.dateField.isVisible() && !this.dateField.isValid()) {
			valid = false;
		}
		if(this.minDateField.isVisible() && !this.minDateField.isValid()) {
			valid = false;
		}
		if(this.maxDateField.isVisible() && !this.maxDateField.isValid()) {
			valid = false;
		}
		if(this.itemListCt.isVisible() && !this.itemField.isValid()) {
			valid = false;
		}
		return valid;
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true);
		}
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
	},
	prepareButton: function() {
		delete this.buttons;
	},
	getValidSetting: function() {
		var sels = this.listView.getSelectionModel().getSelection();
		var sel = sels[0];
		var dts = SCONST.validateDataType,
			ops = SCONST.validateOption;
		var dataType = this.dataTypeBtn.dtype;
		var option = this.optionBtn.option;
		var json = {
			id: sel.data.vid,
			dt: dataType,
			op: option
		};
		if(dts.number === dataType) {
			if(ops.between === option || ops.not_between === option) {
				var min = this.minField.getValue();
				var max = this.maxField.getValue();
				json.min = min;
				json.max = max;
			} else {
				var num = this.numField.getValue();
				json.num = num;
			}
			if(this.intCheckbox.getValue()) {
				json.io = true;
			}
		} else if(dts.text === dataType) {
			if(ops.is_email !== option && ops.is_url !== option) {
				var text = this.textField.getValue();
				json.txt = text;
			}
		} else if(dts.date === dataType) {
			if(ops.between === option || ops.not_between === option) {
				var mind = this.minDateField.getValue();
				var maxd = this.maxDateField.getValue();
				json.mind = Ext.Date.format(mind, "Y-m-d");
				json.maxd = Ext.Date.format(maxd, "Y-m-d");
			} else if(ops.is_date !== option) {
				var date = this.dateField.getValue();
				json.date = Ext.Date.format(date, "Y-m-d");
			}
		} else if(dts.list === dataType) {
			json.list = this.getItemList();
		}
		json.hint = this.hintField.getValue();
		json.allow = this.allowInvalidCheckbox.getValue();
		json.ignoreBlank = this.ignoreBlankCheckbox.getValue();
		var coord = this.rangeField.getCoord();
		var arr = [];
		for(var i = 0, len = coord.length; i < len; i++) {
			arr.push(coord[i].span);
		}
		json.coord = arr;
		return json;
	},
	onSave: function() {
		if(this.isValid()) {
			var setting = this.getValidSetting();
			var id = setting.id;
			delete setting.id;
			this.sheet.setValidation(setting, false, false, id);
			this.hide();
		}
	},
	onRemoveValidation: function() {
		var sels = this.listView.getSelectionModel().getSelection();
		var sel = sels[0];
		var id = sel.data.vid;
		if(id) {
			Ext.Msg.show({
				title: SLANG.confirm,
				msg: SLANG.do_u_really_wanna_delete,
				icon: Ext.Msg.QUESTION,
				buttons: Ext.Msg.YESNO,
				fn: function(btn) {
					if("yes" == btn) {
						this.sheet.setValidation(null, false, false, id, "delete");
						this.hide();
					}
				},
				scope: this
			});
		} else {
			this.hide();
		}
	},
	switchOptions: function(dtype) {
		var items = this.optionBtn.menu.items;
		var first;
		items.each(function(it) {
			if(it.dtype === dtype) {
				if(!first) {
					first = it;
				}
				it.show();
			} else {
				it.hide();
			}
		});
		if(first) {
			this.selectOption(first);
		}
	},
	selectNumber: function(item) {
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectText: function(item) {
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectDate: function(item) {
		this.optionBtn.show();
		this.itemListCt.hide();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectItem: function(item) {
		this.intCheckbox.hide();
		this.minField.hide();
		this.maxField.hide();
		this.textField.hide();
		this.dateField.hide();
		this.minDateField.hide();
		this.maxDateField.hide();
		this.emptyBox.show();
		this.optionBtn.hide();
		this.itemListCt.show();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
		this.dataTypeBtn.setText(item.text);
		this.dataTypeBtn.dtype = item.dtype;
		this.switchOptions(item.dtype);
	},
	selectOption: function(item) {
		var option = item.option;
		this.optionBtn.option = option;
		this.optionBtn.setText(item.text);
		var dtype = this.dataTypeBtn.dtype;
		var dts = SCONST.validateDataType,
			ops = SCONST.validateOption;
		if(dts.number == dtype) {
			this.intCheckbox.show();
			if(ops.between === option || ops.not_between === option) {
				this.minField.show();
				this.maxField.show();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			} else if(ops.any_number === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			} else {
				this.minField.hide();
				this.maxField.hide();
				this.numField.show();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			}
		} else if(dts.text == dtype) {
			this.intCheckbox.hide();
			if(ops.is_email === option || ops.is_url === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.show();
			} else {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.show();
				this.emptyBox.hide();
			}
		} else if(dts.date == dtype) {
			this.intCheckbox.hide();
			if(ops.is_date === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.show();
			} else if(ops.between === option || ops.not_between === option) {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.hide();
				this.minDateField.show();
				this.maxDateField.show();
				this.textField.hide();
				this.emptyBox.hide();
			} else {
				this.minField.hide();
				this.maxField.hide();
				this.numField.hide();
				this.dateField.show();
				this.minDateField.hide();
				this.maxDateField.hide();
				this.textField.hide();
				this.emptyBox.hide();
			}
		} else {
			this.intCheckbox.hide();
		}
	},
	prepareValidation: function() {
		var store = this.store;
		var sheet = this.sheet;
		var sheetId = sheet.getSheetId();
		var sm = sheet.getSelectionModel();
		var sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;
		store.removeAll();
		var sheetStore = sheet.getStore();
		var vds = sheetStore.getValidationBySheet(sheetId) || [];
		var lookup = {};
		for(var i = 0, len = vds.length; i < len; i++) {
			var it = vds[i];
			var coord = it.coord;
			var coordStr = sheet.coord2StringWithSheetName(coord, sep, true);
			lookup[coordStr] = store.add({
				vid: it.id,
				coord: coordStr,
				json: it
			});
		}
		var coord = sm.selection2Coord();
		var coordStr = sheet.coord2StringWithSheetName(coord, sep, true);
		if(!lookup[coordStr]) {
			store.insert(0, {
				coord: coordStr,
				json: {
					coord: coord
				}
			});
		} else {
			store.remove(lookup[coordStr]);
			store.insert(0, lookup[coordStr]);
		}
		this.rangeField.focus(null, 10);
		this.rangeField.setValue(coord);
		this.listView.select(0);
	},
	onValidateSelectionChange: function() {
		var list = this.listView;
		var sels = list.selModel.getSelection();
		if(0 < sels.length) {
			var rec = sels[0];
			var json = rec.data.json;
			this.presetFields(json);
			this.rangeField.focus(100);
		}
	},
	presetFields: function(json) {
		var coord = json.coord;
		this.rangeField.setValue(coord);
		var dt = json.dt,
			op = json.op,
			io = json.io;
		this.setDataTypeOption(dt, op);
		this.intCheckbox.setValue(io ? true : false);
		if(Ext.isNumber(json.min)) {
			this.minField.setValue(json.min);
		} else {
			this.minField.reset();
		}
		if(Ext.isNumber(json.max)) {
			this.maxField.setValue(json.max);
		} else {
			this.maxField.reset();
		}
		if(Ext.isNumber(json.num)) {
			this.numField.setValue(json.num);
		} else {
			this.numField.reset();
		}
		if(json.txt) {
			this.textField.setValue(json.txt);
		} else {
			this.textField.reset();
		}
		if(json.date) {
			this.dateField.setValue(json.date);
		} else {
			this.dateField.reset();
		}
		if(json.mind) {
			this.minDateField.setValue(json.mind);
		} else {
			this.minDateField.reset();
		}
		if(json.maxd) {
			this.maxDateField.setValue(json.maxd);
		} else {
			this.maxDateField.reset();
		}
		if(json.list) {
			var str = json.list.join(this.itemSepChar);
			this.itemField.setValue(str);
		} else {
			this.itemField.reset();
		}
		if(json.hint) {
			this.hintField.setValue(json.hint);
		} else {
			this.hintField.reset();
		}
		if(false === json.allow) {
			this.allowInvalidCheckbox.setValue(false);
		} else {
			this.allowInvalidCheckbox.setValue(true);
		}
		if(false === json.ignoreBlank) {
			this.ignoreBlankCheckbox.setValue(false);
		} else {
			this.ignoreBlankCheckbox.setValue(true);
		}
	},
	onMinChange: function(field, newVal, oldVal) {
		var other = this.maxField.getValue();
		if(other < newVal) {
			this.maxField.setValue(newVal);
		}
	},
	onMaxChange: function(field, newVal, oldVal) {
		var other = this.minField.getValue();
		if(other > newVal) {
			this.minField.setValue(newVal);
		}
	},
	onMinDateChange: function(field, newVal, oldVal) {
		var other = this.maxDateField.getValue();
		if(0 < newVal - other) {
			this.maxDateField.setValue(newVal);
		}
	},
	onMaxDateChange: function(field, newVal, oldVal) {
		var other = this.minDateField.getValue();
		if(0 > newVal - other) {
			this.minDateField.setValue(newVal);
		}
	},
	getItemList: function() {
		var val = this.itemField.getValue();
		var arr = val.split(this.itemSepChar);
		var list = [];
		for(var i = 0, len = arr.length; i < len; i++) {
			var it = Ext.String.trim(arr[i]);
			if(it) {
				list.push(it);
			}
		}
		return list;
	}
});

Ext.define("EnterpriseSheet.sheet.pop.AttachmentWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.common.PhotoViewer"],
	width: 600,
	height: 500,
	labelWidth: 90,
	title: SLANG.attachment,
	layout: "border",
	bodyStyle: "background-color:white;",
	initComponent: function() {
		this.uploadForm = Ext.create("Ext.form.Panel", {
			border: false,
			fileUpload: true,
			url: SCONFIG.urls.uploadFile,
			width: 100,
			layout: {
				type: "hbox",
				align: "middle"
			},
			items: [{
				xtype: "filefield",
				buttonOnly: true,
				name: "filePath",
				buttonConfig: {
					iconCls: "icon-attach",
					text: SLANG.upload_file,
					ui: "default-toolbar"
				},
				listeners: {
					change: {
						fn: this.onSelectLocalFile,
						scope: this
					}
				}
			}]
		});
		this.dockedItems = [{
			xtype: "toolbar",
			layout: {
				type: "hbox",
				padding: "5"
			},
			style: "background:white;",
			items: [this.uploadForm, {
				xtype: "component",
				flex: 1,
				cls: "ss-attach-hint",
				html: SLANG.upload_linke_attachment
			}, {
				xtype: "container",
				width: 100,
				layout: {
					type: "hbox",
					align: "middle",
					pack: "end"
				},
				items: [{
					xtype: "button",
					iconCls: "icon-link",
					hidden: true,
					text: SLANG.link_file,
					ui: "default-toolbar"
				}]
			}]
		}];
		this.hintBox = Ext.create("Ext.Component", {
			cls: "ss-upload-hint",
			region: "north",
			html: SLANG.uploading,
			hidden: true
		});
		this.store = this.store || Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "aid",
				type: "string"
			}, {
				name: "url",
				type: "string"
			}, {
				name: "name",
				type: "string"
			}, {
				name: "type",
				type: "string"
			}]
		});
		var listTpl = new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"ss-attach-item {[\"file\"==values.type?\"ss-attach-file\":\"\"]}\">", "<tpl if=\"this.isImg(type)\">", "<img src=\"{url}\">", "</tpl>", "<tpl if=\"!this.isImg(type)\">", "<img src=\"", SCONFIG.ATTACH_ICON32, "\">", "</tpl>", "<div class=\"ss-attach-delete\"></div>", "<div class=\"ss-attach-name\" data-qtip=\"{name}\">{name}</div>", "</div>", "</tpl>"].join(""), {
			isImg: function(type) {
				return "img" === type;
			}
		});
		this.listView = Ext.create("Ext.view.View", {
			cls: "ss-attach-list ss-attach-view",
			region: "center",
			store: this.store,
			autoScroll: true,
			tpl: listTpl,
			itemSelector: "div.ss-attach-item",
			selectedItemCls: "ss-attach-item-selected",
			overItemCls: "ss-attach-item-over"
		});
		this.items = [this.hintBox, this.listView];
		this.callParent();
		this.listView.on("itemclick", function(view, rec, item, index, e) {
			var target = Ext.get(e.getTarget());
			if(target.hasCls("ss-attach-delete")) {
				this.store.remove(rec);
			} else {
				this.viewAttach(view, rec, item, index, e);
			}
		}, this);
	},
	onSelectLocalFile: function() {
		this.hintBox.show();
		this.uploadForm.submit({
			params: {
				parentId: this.folderId || 0
			},
			failure: function(form, action) {},
			success: function(form, action) {
				var jsonData = action.result;
				if(jsonData.success && jsonData.success != "false") {
					var fileId = jsonData.attachId,
						fileName = jsonData.fileName;
					var url = SCONFIG.urls.downloadFile + "?attachId=" + fileId;
					var o = {
						url: url,
						aid: fileId,
						name: fileName
					};
					var imgEl = Ext.DomHelper.append(Ext.getBody(), "<img src=\"" + url + "\" />", true);
					imgEl.on("error", function() {
						o.type = "file";
						this.store.add(o);
						Ext.removeNode(imgEl.dom);
						this.hintBox.hide();
						this.listView.scrollBy([0, 100000], true);
					}, this);
					imgEl.on("load", function() {
						o.type = "img";
						this.store.add(o);
						Ext.removeNode(imgEl.dom);
						this.hintBox.hide();
						this.listView.scrollBy([0, 100000], true);
					}, this);
				} else {}
			},
			scope: this
		});
	},
	prepareParam: function() {
		var arr = [];
		this.store.each(function(rec) {
			arr.push({
				aid: rec.data.aid,
				url: rec.data.url,
				type: rec.data.type,
				name: rec.data.name
			});
		}, this);
		return arr;
	},
	viewAttach: function(view, rec, item, index, e) {
		var photos = [];
		this.store.each(function(rd) {
			photos.push(rd.data);
		}, this);
		PHOTOVIEWER.showPhotos(photos, index);
	},
	prepareButton: function() {
		delete this.buttons;
	},
	quit: function() {
		if(this.applyCallback) {
			var o = this.applyCallback;
			o.fn.call(o.scope || this, this.prepareParam(), this);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.ErrorReportWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Text"],
	width: 400,
	layout: "anchor",
	labelWidth: 90,
	plain: true,
	border: false,
	bodyStyle: "padding:25px;background-color:transparent;",
	initComponent: function() {
		this.title = SLANG.error;
		this.memoField = Ext.create("Ext.form.field.TextArea", {
			height: 100,
			hidden: true,
			style: "margin-top:10px;",
			emptyText: SLANG.add_comment_for_error,
			anchor: "100%"
		});
		this.items = [{
			xtype: "component",
			html: SLANG.backend_error_occur
		}, this.memoField];
		this.callParent();
	},
	prepareButton: function() {
		this.reportBtn = new Ext.Button({
			text: SLANG.report,
			handler: this.onReport,
			scope: this
		});
		this.buttons = [this.reportBtn, {
			text: this.cancelText,
			handler: this.onCancel,
			scope: this
		}];
	},
	popup: function() {
		this.memoField.hide();
		this.memoField.reset();
		this.reportBtn.setText(SLANG.report);
		this.show();
	},
	onReport: function() {
		if(!this.memoField.isVisible()) {
			this.memoField.show();
			this.reportBtn.setText(SLANG.submit);
			return;
		}
		if(this.reportCallback) {
			this.reportCallback.fn.call(this.reportCallback.scope, this.memoField.getValue());
		}
		this.hide();
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.CellRender", {
	singleton: true,
	cellDataRenders: {
		contactRender: function(sheetId, row, col, data) {
			var itms = data.itms,
				arr = [];
			if(itms) {
				itms = Ext.decode(itms);
				for(var i = 0, len = itms.length; i < len; i++) {
					var it = itms[i];
					arr.push("<span class=\"ss-contact\" data-qtip=\"" + it.email + "\">" + it.name + "</span>");
				}
				return arr.join("");
			}
		},
		dropRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-list\">" + data + "</span>";
			}
		},
		itemRender: function(sheetId, row, col, data) {
			var itms = data.itms,
				arr = [];
			if(itms) {
				itms = Ext.decode(itms);
				if(itms == null || itms.length == 0) {
					return;
				}
				for(var i = 0, len = itms.length; i < len; i++) {
					var it = itms[i];
					if(Ext.isObject(it)) {
						var color = SCOM.colors[it.idx];
						arr.push("<span class=\"ss-item\" style=\"background-color:" + color + ";\">" + it.data + "</span>");
					} else {
						var color = SCOM.colors[i % SCOM.colors.length];
						arr.push("<span class=\"ss-item\" style=\"background-color:" + color + ";\">" + it + "</span>");
					}
				}
				return arr.join("");
			}
		},
		attachRender: function(sheetId, row, col, data) {
			var itms = data.itms,
				arr = [];
			if(itms) {
				if(typeof itms === "string" || itms instanceof String) {
					itms = Ext.decode(itms);
				}
				if(itms == null || itms.length == 0) {
					return;
				}
				for(var i = 0, len = itms.length; i < len; i++) {
					var it = itms[i];
					var cls = "normal" == data.ws ? "ss-incell-attach-ww" : "ss-incell-attach";
					if("img" === it.type) {
						arr.push("<img class=\"" + cls + "\" src=\"" + it.url + "\" />");
					} else {
						arr.push("<div class=\"ss-attach-file\"></div>");
					}
				}
				return arr.join("");
			}
		},
		purpleRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-purple\">" + data + "</span>";
			}
		},
		moccasinRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-moccasin\">" + data + "</span>";
			}
		},
		greenRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-green\">" + data + "</span>";
			}
		},
		navyRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-navy\">" + data + "</span>";
			}
		},
		maroonRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-maroon\">" + data + "</span>";
			}
		},
		redRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-red\">" + data + "</span>";
			}
		},
		oliveRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-olive\">" + data + "</span>";
			}
		},
		cyanRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-cyan\">" + data + "</span>";
			}
		},
		pinkRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-pink\">" + data + "</span>";
			}
		},
		orangeRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-orange\">" + data + "</span>";
			}
		},
		blueRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-blue\">" + data + "</span>";
			}
		},
		tealRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-teal\">" + data + "</span>";
			}
		},
		limeRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-lime\">" + data + "</span>";
			}
		},
		fuchsiaRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-fuchsia\">" + data + "</span>";
			}
		},
		greyRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-grey\">" + data + "</span>";
			}
		},
		lightGreenRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-light-green\">" + data + "</span>";
			}
		},
		lightPurpleRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-light-purple\">" + data + "</span>";
			}
		},
		s_lightBlueRender: function(sheetId, row, col, cell) {
			var data = cell.data;
			if(data) {
				return "<span class=\"ss-item-square-light-blue\">" + data + "</span>";
			}
		}
	},
	addRender: function(obj) {
		Ext.apply(this.cellDataRenders, obj);
	},
	getRender: function(name) {
		return this.cellDataRenders[name];
	}
}, function() {
	SCRENDER = EnterpriseSheet.sheet.plugin.CellRender;
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.AbstractEditor", {
	extend: "Ext.container.Container",
	cls: "ss-abstract-editor",
	hidden: true,
	floating: true,
	shadow: false,
	focusDelay: 500,
	initComponent: function() {
		if(!this.renderTo) {
			this.renderTo = Ext.getBody();
		}
		this.callParent(arguments);
	},
	getEditResult: function() {
		return {
			data: ""
		};
	},
	setupEditor: function(data, cell) {},
	onEditorBlur: function(e) {
		this.onDoneEdit();
		return false;
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false;
			} else if(keyObj.ENTER == key) {
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}
	},
	isValid: function() {
		return true;
	},
	onDoneEdit: function() {
		if(this.isValid()) {
			this.hide();
			var modified = this.getEditResult();
			this.fireEvent("done", modified.data, modified, this);
			if(this.sheet) {
				var pos = this.editingCellPos;
				this.sheet.setCell(pos.sheetId, pos.row, pos.col, modified);
			}
		}
	},
	onCancel: function() {
		this.hide();
	},
	showEditor: function(data, el, cell, pos) {
		this.editingCellPos = pos;
		this.showBy(el, "tl-tl?");
		this.setupEditor(data, cell);
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.DateEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-date-editor",
	width: 250,
	floating: true,
	shadow: false,
	focusDelay: 500,
	layout: {
		type: "hbox",
		align: "middle",
		padding: 5
	},
	initComponent: function() {
		this.dateField = Ext.create("Ext.form.field.Date", {
			format: "Y-m-d",
			allowBlank: false,
			flex: 1,
			enableKeyEvents: true,
			listeners: {
				keydown: {
					fn: function(field, e) {
						this.onEditorKeydown(e);
					},
					scope: this
				}
			}
		});
		this.timeField = Ext.create("Ext.form.field.Time", {
			format: "H:i",
			allowBlank: false,
			margin: "0 0 0 5",
			flex: 1,
			enableKeyEvents: true,
			listeners: {
				keydown: {
					fn: function(field, e) {
						this.onEditorKeydown(e);
					},
					scope: this
				}
			}
		});
		this.items = [this.dateField, this.timeField, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-tick",
			ui: "default-toolbar",
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-cross",
			ui: "default-toolbar",
			handler: function() {
				this.hide();
			},
			scope: this
		}];
		this.callParent(arguments);
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false;
			} else if(keyObj.ENTER == key) {
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}
	},
	onDoneEdit: function() {
		var dateField = this.dateField,
			timeField = this.timeField;
		if(dateField.isValid() && (!timeField.isVisible() || timeField.isValid())) {
			var date = dateField.getValue(),
				time = timeField.getValue();
			date = Ext.Date.format(date, "Y-m-d");
			time = Ext.Date.format(time, "H:i");
			var data;
			if(timeField.isVisible()) {
				data = date + " " + time;
			} else {
				data = date;
			}
			this.hide();
			this.fireEvent("done", data, undefined, this);
		}
	},
	showEditor: function(date, time, el, withTime, expand) {
		var dateField = this.dateField;
		var timeField = this.timeField;
		if(withTime) {
			dateField.setValue(date);
			timeField.setValue(time);
			timeField.show();
		} else {
			dateField.setValue(date);
			timeField.hide();
		}
		this.showBy(el, "tl-tl?");
		if(expand) {
			Ext.Function.defer(function() {
				dateField.expand();
			}, 10, this);
		}
		dateField.focus(undefined, this.focusDelay);
	},
	collapsePicker: function() {
		this.dateField.collapse();
		this.timeField.collapse();
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.ListRefEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-list-editor",
	width: 200,
	floating: true,
	focusDelay: 500,
	shadow: false,
	layout: {
		type: "hbox",
		align: "middle",
		padding: 5
	},
	initComponent: function() {
		var me = this;
		this.listStore = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "val",
				type: "string"
			}]
		});
		this.listField = Ext.create("Ext.form.field.ComboBox", {
			queryMode: "local",
			store: this.listStore,
			displayField: "val",
			valueField: "val",
			allowBlank: false,
			flex: 1,
			enableKeyEvents: true,
			forceSelection: true,
			validator: function(val) {
				if(val) {
					return -1 !== me.listStore.find("val", val);
				}
				return true;
			},
			listeners: {
				keydown: {
					fn: function(field, e) {
						if(!field.isExpanded) {
							this.onEditorKeydown(e);
						}
					},
					scope: this
				},
				select: {
					fn: this.onDoneEdit,
					scope: this
				}
			}
		});
		this.items = [this.listField, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-tick",
			ui: "default-toolbar",
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-cross",
			ui: "default-toolbar",
			handler: function() {
				this.hide();
			},
			scope: this
		}];
		this.callParent(arguments);
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false;
			} else if(keyObj.ENTER == key) {
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}
	},
	onDoneEdit: function() {
		var listField = this.listField;
		if(listField.isValid()) {
			var data = listField.getValue();
			this.hide();
			this.fireEvent("done", data, undefined, this);
		}
	},
	showEditor: function(cell, el, obj, expand) {
		var list, me = this;
		list = obj.data;
		var setupVal = function(arr) {
			var data = "";
			if(cell && cell.data) {
				if(-1 === arr.indexOf(cell.data)) {
					data = "";
				} else {
					data = cell.data;
				}
				me.listField.setValue(data);
			}
			me.showBy(el, "tl-tl?");
			Ext.Function.defer(function() {
				me.listField.expand();
			}, 10);
			me.listField.focus(undefined, me.focusDelay);
		};
		if(list) {
			var ds = [];
			for(var i = 0, len = list.length; i < len; i++) {
				ds.push({
					val: list[i]
				});
			}
			this.listStore.loadData(ds);
			setupVal(list);
		}
	},
	collapsePicker: function() {
		this.listField.collapse();
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.ListRemoteEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-list-editor",
	width: 270,
	floating: true,
	focusDelay: 500,
	shadow: false,
	layout: {
		type: "hbox",
		align: "middle",
		padding: 5
	},
	initComponent: function() {
		var me = this;
		Ext.define("DropListModel", {
			extend: "Ext.data.Model",
			fields: [{
				name: "value",
				type: "string"
			}, {
				name: "id",
				type: "int"
			}]
		});
		this.listStore = Ext.create("Ext.data.Store", {
			model: "DropListModel",
			proxy: {
				type: "ajax",
				url: "",
				reader: {
					type: "json",
					root: "results"
				}
			}
		});
		this.listField = Ext.create("Ext.form.field.ComboBox", {
			width: 200,
			minChars: 2,
			emptyText: SLANG.enter_char_search,
			store: this.listStore,
			displayField: "value",
			valueField: "id",
			allowBlank: false,
			enableKeyEvents: true,
			forceSelection: true,
			listeners: {
				select: {
					fn: this.onDoneEdit,
					scope: this
				},
				keydown: {
					fn: function(field, e) {
						if(!field.isExpanded) {
							this.onEditorKeydown(e);
						}
					},
					scope: this
				}
			}
		});
		this.items = [this.listField, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-tick",
			ui: "default-toolbar",
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-cross",
			ui: "default-toolbar",
			handler: function() {
				this.hide();
			},
			scope: this
		}];
		this.callParent(arguments);
	},
	onDoneEdit: function() {
		var listField = this.listField;
		if(listField.isValid()) {
			var id = listField.getValue();
			var data = listField.getRawValue();
			this.hide();
			this.fireEvent("done", data, {
				dropId: id,
				render: "dropRender"
			}, this);
		}
	},
	showEditor: function(cell, el, obj) {
		var me = this,
			listField = this.listField;
		this.showBy(el, "tl-tl?");
		this.listStore.getProxy().url = obj.url;
		this.listStore.on("load", function() {
			listField.setValue(cell.dropId);
		});
		this.listStore.load();
		Ext.Function.defer(function() {
			listField.expand();
		}, 100);
		listField.focus(undefined, me.focusDelay);
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.ListEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-list-editor",
	width: 200,
	floating: true,
	focusDelay: 500,
	shadow: false,
	layout: {
		type: "hbox",
		align: "middle",
		padding: 5
	},
	initComponent: function() {
		var me = this;
		this.listStore = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "val",
				type: "string"
			}]
		});
		this.listField = Ext.create("Ext.form.field.ComboBox", {
			queryMode: "local",
			store: this.listStore,
			displayField: "val",
			valueField: "val",
			allowBlank: false,
			flex: 1,
			enableKeyEvents: true,
			forceSelection: true,
			validator: function(val) {
				if(val) {
					return -1 !== me.listStore.find("val", val);
				}
				return true;
			},
			listeners: {
				keydown: {
					fn: function(field, e) {
						if(!field.isExpanded) {
							this.onEditorKeydown(e);
						}
					},
					scope: this
				},
				select: {
					fn: this.onDoneEdit,
					scope: this
				}
			}
		});
		this.items = [this.listField, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-tick",
			ui: "default-toolbar",
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-cross",
			ui: "default-toolbar",
			handler: function() {
				this.hide();
			},
			scope: this
		}];
		this.callParent(arguments);
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false;
			} else if(keyObj.ENTER == key) {
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}
	},
	onDoneEdit: function() {
		var listField = this.listField;
		if(listField.isValid()) {
			var data = listField.getValue();
			this.hide();
			this.fireEvent("done", data, undefined, this);
		}
	},
	showEditor: function(data, el, obj, expand) {
		var list, me = this;
		if(Ext.isString(obj)) {
			obj = Ext.decode(obj);
		}
		list = obj.data;
		var setupVal = function(arr) {
			if(-1 === arr.indexOf(data)) {
				data = "";
			}
			me.listField.setValue(data);
			me.showBy(el, "tl-tl?");
			Ext.Function.defer(function() {
				me.listField.expand();
			}, 10);
			me.listField.focus(undefined, me.focusDelay);
		};
		if(list) {
			var ds = [],
				newList = [];
			for(var i = 0, len = list.length; i < len; i++) {
				ds.push({
					val: list[i].trim()
				});
				newList.push(list[i].trim());
			}
			this.listStore.loadData(ds);
			setupVal(newList);
		} else {
			var id = obj.id;
			if(Ext.isDefined(id)) {
				Ext.Ajax.request({
					timeout: SCONST.PULLING_TIMEOUT,
					url: SCONFIG.urls.loadDataset,
					params: {
						id: id
					},
					success: function(response, options) {
						var json = Ext.decode(response.responseText);
						if(true === json.success || "true" === json.success) {
							obj = json.object;
							var arr = Ext.decode(obj.data),
								ds = [];
							for(var i = 0, len = arr.length; i < len; i++) {
								ds.push({
									val: arr[i].trim()
								});
							}
							this.listStore.loadData(ds);
							setupVal(arr);
						}
					},
					failure: function(response) {},
					scope: this
				});
			}
		}
	},
	collapsePicker: function() {
		this.listField.collapse();
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.MultiOptionEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-list-editor",
	width: 250,
	floating: true,
	shadow: false,
	focusDelay: 500,
	layout: {
		type: "hbox",
		align: "middle",
		padding: 5
	},
	initComponent: function() {
		var me = this;
		this.listStore = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "val",
				type: "string"
			}]
		});
		this.listField = Ext.create("Ext.form.field.ComboBox", {
			queryMode: "local",
			store: this.listStore,
			displayField: "val",
			valueField: "val",
			flex: 1,
			allowBlank: false,
			enableKeyEvents: true,
			multiSelect: true,
			forceSelection: true,
			listConfig: {
				cls: "ss-combo-picker"
			},
			validator: function(val) {
				val = me.listField.getRawValue();
				if(val) {
					var parts = val.split(",");
					for(var i = 0, len = parts.length; i < len; i++) {
						var p = Ext.String.trim(parts[i]);
						if(-1 === me.listStore.find("val", p)) {
							return false;
						}
					}
					return true;
				} else {
					return false;
				}
			},
			listeners: {
				keydown: {
					fn: function(field, e) {
						if(!field.isExpanded) {
							this.onEditorKeydown(e);
						}
					},
					scope: this
				}
			}
		});
		this.items = [this.listField, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-tick",
			ui: "default-toolbar",
			handler: this.onDoneEdit,
			scope: this
		}, {
			xtype: "button",
			margin: "0 0 0 5",
			iconCls: "icon-cross",
			ui: "default-toolbar",
			handler: function() {
				this.hide();
			},
			scope: this
		}];
		this.callParent(arguments);
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false;
			} else if(keyObj.ENTER == key) {
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}
	},
	onDoneEdit: function() {
		var listField = this.listField;
		if(listField.isValid()) {
			var arr = listField.getValue(),
				data = arr;
			this.hide();
			if(Ext.isArray(arr)) {
				data = arr.join(",");
			}
			var itms = [];
			for(var i = 0, len = arr.length; i < len; i++) {
				var p = Ext.String.trim(arr[i]);
				var idx = this.listStore.find("val", p);
				itms.push({
					idx: idx,
					data: p
				});
			}
			itms.sort(function(a, b) {
				return a.idx - b.idx;
			});
			this.fireEvent("done", data, {
				itms: Ext.encode(itms),
				render: "itemRender"
			}, this);
		}
	},
	showEditor: function(data, el, obj, expand) {
		var list, me = this;
		if(Ext.isString(obj)) {
			obj = Ext.decode(obj);
		}
		list = obj.data;
		var setupVal = function() {
			if(data) {
				var parts = data.split(","),
					flag = true;
				for(var i = 0, len = parts.length; i < len; i++) {
					var p = Ext.String.trim(parts[i]);
					if(-1 === me.listStore.find("val", p)) {
						flag = false;
						break;
					}
				}
				if(flag) {
					me.listField.setValue(parts);
				} else {
					me.listField.reset();
				}
			} else {
				me.listField.reset();
			}
			me.showBy(el, "tl-tl?");
			Ext.Function.defer(function() {
				me.listField.expand();
			}, 10);
			me.listField.focus(undefined, me.focusDelay);
		};
		if(list) {
			var arr = [];
			for(var i = 0, len = list.length; i < len; i++) {
				arr.push({
					val: list[i]
				});
			}
			this.listStore.loadData(arr);
			setupVal();
		} else {
			var id = obj.id;
			if(Ext.isDefined(id)) {
				Ext.Ajax.request({
					timeout: SCONST.PULLING_TIMEOUT,
					url: SCONFIG.urls.loadDataset,
					params: {
						id: id
					},
					success: function(response, options) {
						var json = Ext.decode(response.responseText);
						if(true === json.success || "true" === json.success) {
							obj = json.object;
							var arr = Ext.decode(obj.data),
								ds = [];
							for(var i = 0, len = arr.length; i < len; i++) {
								ds.push({
									val: arr[i]
								});
							}
							this.listStore.loadData(ds);
							setupVal();
						}
					},
					failure: function(response) {},
					scope: this
				});
			}
		}
	},
	collapsePicker: function() {
		this.listField.collapse();
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.MultiCheckboxEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-list-editor",
	width: 550,
	floating: true,
	shadow: false,
	focusDelay: 500,
	initComponent: function() {
		var me = this;
		this.okBtn = Ext.create("Ext.button.Button", {
			text: SLANG.ok,
			minWidth: 60,
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			handler: this.onDoneEdit,
			scope: this
		});
		this.cancelBtn = Ext.create("Ext.button.Button", {
			minWidth: 60,
			text: SLANG.cancel,
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			handler: function() {
				this.hide()
			},
			scope: this
		});
		this.otherBtn = Ext.create("Ext.button.Button", {
			hidden: true,
			minWidth: 100,
			margins: "0 5 0 0",
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			text: SLANG.addOther,
			handler: this.onAddOther,
			scope: this
		});
		this.itemStore = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "val",
				type: "string"
			}, {
				name: "desc",
				type: "string"
			}, {
				name: "isOther",
				type: "boolean"
			}]
		});
		var selModel = Ext.create("Ext.selection.CheckboxModel");
		this.listGrid = Ext.create("Ext.grid.Panel", {
			height: 200,
			selModel: selModel,
			style: "padding:10px 10px 10px 10px;",
			store: this.itemStore,
			border: true,
			autoScroll: true,
			columns: [{
				menuDisabled: true,
				text: SLANG.name,
				flex: 1,
				dataIndex: "val",
				sortable: false
			}, {
				menuDisabled: true,
				text: LANG.description,
				width: 200,
				dataIndex: "desc",
				sortable: false
			}],
			bbar: [this.cancelBtn, "->", this.otherBtn, this.okBtn]
		});
		this.items = [this.listGrid];
		this.callParent(arguments)
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false
			} else {
				if(keyObj.ENTER == key) {
					e.stopEvent();
					this.onDoneEdit();
					return false
				}
			}
		}
	},
	onDoneEdit: function() {
		var rows = this.listGrid.getSelectionModel().getSelection();
		if(rows) {
			var itms = [],
				data = null,
				dataArr = [];
			for(var i = 0, len = rows.length; i < len; i++) {
				var row = rows[i];
				if(row) {
					var val = row.data.val;
					var idx = this.itemStore.find("val", val);
					itms.push({
						idx: idx,
						data: val,
						desc: row.data.desc
					});
					dataArr.push(val)
				}
			}
			data = dataArr.join(",");
			this.fireEvent("done", data, {
				itms: Ext.encode(itms),
				render: "itemRender"
			}, this)
		}
		this.hide()
	},
	showEditor: function(data, el, obj, expand) {
		var selectedItms = Ext.decode(data);
		var list = obj.data,
			me = this;
		if(obj.otherOption) {
			this.otherBtn.show()
		} else {
			this.otherBtn.hide()
		}
		if(list) {
			var arr = [];
			for(var i = 0, len = list.length; i < len; i++) {
				arr.push({
					val: list[i].name,
					desc: list[i].desc,
					isOther: false
				})
			}
			this.itemStore.loadData(arr);
			if(selectedItms != null && selectedItms.length > 0) {
				for(var i = 0, len = selectedItms.length; i < len; i++) {
					var item = selectedItms[i];
					var desired_record = me.itemStore.findRecord("val", item.data, 0, false, true, true);
					if(desired_record == null) {
						desired_record = me.itemStore.add({
							val: item.data,
							desc: item.desc,
							isOther: true
						})
					}
					me.listGrid.getSelectionModel().select(desired_record, true)
				}
			}
			me.showBy(el, "tl-tl?")
		}
	},
	onAddOther: function() {
		var newItemField = new Ext.form.field.Text({
			fieldLabel: SLANG.name,
			width: 350,
			allowBlank: false
		});
		var descField = Ext.create("Ext.form.field.Text", {
			style: "margin-top: 10px;",
			fieldLabel: SLANG.description,
			width: 350,
			allowBlank: true
		});
		var existingOther = null;
		this.itemStore.each(function(record, id) {
			if(record.data.isOther) {
				existingOther = record;
				newItemField.setValue(record.data.val);
				descField.setValue(record.data.desc)
			}
		});
		this.newItemWin = Ext.create("Ext.window.Window", {
			modal: true,
			title: SLANG.addOther,
			width: 400,
			closeAction: "hide",
			bodyStyle: "background:white;padding:20px;",
			layout: "anchor",
			items: [newItemField, descField],
			buttons: [{
				text: SLANG.cancel,
				handler: function() {
					this.newItemWin.hide()
				},
				scope: this
			}, {
				text: SLANG.add,
				handler: function() {
					if(newItemField.isValid()) {
						if(existingOther != null) {
							this.itemStore.remove(existingOther)
						}
						var rec = this.itemStore.add({
							val: newItemField.getValue(),
							desc: descField.getValue(),
							isOther: true
						});
						this.listGrid.getSelectionModel().select(rec, true);
						this.newItemWin.hide()
					}
				},
				scope: this
			}]
		});
		this.newItemWin.show()
	}
});
Ext.define("EnterpriseSheet.sheet.plugin.editor.MultiRadioEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-list-editor",
	width: 550,
	floating: true,
	shadow: false,
	focusDelay: 500,
	initComponent: function() {
		var me = this;
		this.okBtn = Ext.create("Ext.button.Button", {
			text: SLANG.ok,
			minWidth: 60,
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			handler: this.onDoneEdit,
			scope: this
		});
		this.cancelBtn = Ext.create("Ext.button.Button", {
			minWidth: 60,
			text: SLANG.cancel,
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			handler: function() {
				this.hide()
			},
			scope: this
		});
		this.otherBtn = Ext.create("Ext.button.Button", {
			hidden: true,
			minWidth: 100,
			margins: "0 5 0 0",
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			text: SLANG.addOther,
			handler: this.onAddOther,
			scope: this
		});
		this.itemStore = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "val",
				type: "string"
			}, {
				name: "desc",
				type: "string"
			}, {
				name: "isOther",
				type: "boolean"
			}]
		});
		var selModel = selModel = Ext.create("Ext.selection.CheckboxModel", {
			mode: "SINGLE",
			allowDeselect: true,
			toggleOnClick: true
		});
		this.listGrid = Ext.create("Ext.grid.Panel", {
			height: 200,
			selModel: selModel,
			style: "padding:10px 10px 10px 10px;",
			store: this.itemStore,
			border: true,
			autoScroll: true,
			columns: [{
				menuDisabled: true,
				text: SLANG.name,
				flex: 1,
				dataIndex: "val",
				sortable: false
			}, {
				menuDisabled: true,
				text: LANG.description,
				width: 200,
				dataIndex: "desc",
				sortable: false
			}],
			bbar: [this.cancelBtn, "->", this.otherBtn, this.okBtn]
		});
		this.items = [this.listGrid];
		this.callParent(arguments)
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false
			} else {
				if(keyObj.ENTER == key) {
					e.stopEvent();
					this.onDoneEdit();
					return false
				}
			}
		}
	},
	onDoneEdit: function() {
		var rows = this.listGrid.getSelectionModel().getSelection();
		if(rows) {
			var itms = [],
				data = null,
				dataArr = [];
			for(var i = 0, len = rows.length; i < len; i++) {
				var row = rows[i];
				if(row) {
					var val = row.data.val;
					var idx = this.itemStore.find("val", val);
					itms.push({
						idx: idx,
						data: val,
						desc: row.data.desc
					});
					dataArr.push(val)
				}
			}
			data = dataArr.join(",");
			this.fireEvent("done", data, {
				itms: Ext.encode(itms),
				render: "itemRender"
			}, this)
		}
		this.hide()
	},
	showEditor: function(data, el, obj, expand) {
		var selectedItms = Ext.decode(data);
		var list = obj.data,
			me = this;
		if(obj.otherOption) {
			this.otherBtn.show()
		} else {
			this.otherBtn.hide()
		}
		if(list) {
			var arr = [];
			for(var i = 0, len = list.length; i < len; i++) {
				arr.push({
					val: list[i].name,
					desc: list[i].desc,
					isOther: false
				})
			}
			this.itemStore.loadData(arr);
			if(selectedItms != null && selectedItms.length > 0) {
				for(var i = 0, len = selectedItms.length; i < len; i++) {
					var item = selectedItms[i];
					var desired_record = me.itemStore.findRecord("val", item.data, 0, false, true, true);
					if(desired_record == null) {
						desired_record = me.itemStore.add({
							val: item.data,
							desc: item.desc,
							isOther: true
						})
					}
					me.listGrid.getSelectionModel().select(desired_record, true)
				}
			}
			me.showBy(el, "tl-tl?")
		}
	},
	onAddOther: function() {
		var newItemField = new Ext.form.field.Text({
			fieldLabel: SLANG.name,
			width: 350,
			allowBlank: false
		});
		var descField = Ext.create("Ext.form.field.Text", {
			style: "margin-top: 10px;",
			fieldLabel: SLANG.description,
			width: 350,
			allowBlank: true
		});
		var existingOther = null;
		this.itemStore.each(function(record, id) {
			if(record.data.isOther) {
				existingOther = record;
				newItemField.setValue(record.data.val);
				descField.setValue(record.data.desc)
			}
		});
		this.newItemWin = Ext.create("Ext.window.Window", {
			modal: true,
			title: SLANG.addOther,
			width: 400,
			closeAction: "hide",
			bodyStyle: "background:white;padding:20px;",
			layout: "anchor",
			items: [newItemField, descField],
			buttons: [{
				text: SLANG.cancel,
				handler: function() {
					this.newItemWin.hide()
				},
				scope: this
			}, {
				text: SLANG.add,
				handler: function() {
					if(newItemField.isValid()) {
						if(existingOther != null) {
							this.itemStore.remove(existingOther)
						}
						var rec = this.itemStore.add({
							val: newItemField.getValue(),
							desc: descField.getValue(),
							isOther: true
						});
						this.listGrid.getSelectionModel().select(rec, true);
						this.newItemWin.hide()
					}
				},
				scope: this
			}]
		});
		this.newItemWin.show()
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.LongTextEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-date-editor",
	width: 350,
	floating: true,
	shadow: false,
	focusDelay: 500,
	layout: {
		type: "hbox",
		align: "top",
		padding: 5
	},
	initComponent: function() {
		this.longTextField = Ext.create("Ext.form.field.TextArea", {
			flex: 1,
			height: 200,
			enableKeyEvents: true,
			listeners: {
				keydown: {
					fn: function(field, e) {
						this.onEditorKeydown(e);
					},
					scope: this
				},
				blur: {
					fn: function(field, e) {
						this.onEditorBlur(e);
					},
					scope: this
				}
			}
		});
		this.items = [this.longTextField, {
			xtype: "container",
			dock: "right",
			width: 40,
			style: "padding:0px 8px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				margin: "5 0 0 0",
				iconCls: "icon-tick",
				ui: "default-toolbar",
				handler: this.onDoneEdit,
				scope: this
			}, {
				xtype: "button",
				margin: "5 0 0 0",
				iconCls: "icon-cross",
				ui: "default-toolbar",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent(arguments);
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false;
			} else if(keyObj.ENTER == key) {
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}
	},
	onEditorBlur: function(e) {
		this.onDoneEdit();
		return false;
	},
	onDoneEdit: function() {
		var textField = this.longTextField;
		this.hide();
		this.fireEvent("done", textField.getValue(), undefined, this);
	},
	onCancel: function() {
		this.hide();
	},
	showEditor: function(data, el, cell) {
		this.longTextField.setValue(data);
		var textField = this.longTextField;
		this.showBy(el, "tl-tl?");
		textField.focus(undefined, this.focusDelay);
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.HtmlTextEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	cls: "ss-date-editor",
	width: 400,
	floating: true,
	shadow: false,
	focusDelay: 1000,
	layout: {
		type: "hbox",
		align: "top",
		padding: 5
	},
	initComponent: function() {
		this.htmlTextField = Ext.create("Ext.form.field.HtmlEditor", {
			flex: 1,
			height: 200
		});
		this.items = [this.htmlTextField, {
			xtype: "container",
			dock: "right",
			width: 40,
			style: "padding:0px 8px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				margin: "5 0 0 0",
				iconCls: "icon-tick",
				ui: "default-toolbar",
				handler: this.onDoneEdit,
				scope: this
			}, {
				xtype: "button",
				margin: "5 0 0 0",
				iconCls: "icon-cross",
				ui: "default-toolbar",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent(arguments);
	},
	onDoneEdit: function() {
		this.hide();
		this.fireEvent("done", this.htmlTextField.getValue(), {
			datatype: "html"
		}, this);
	},
	onCancel: function() {
		this.hide();
	},
	showEditor: function(data, el, cell) {
		this.remove(this.htmlTextField);
		this.htmlTextField = Ext.create("Ext.form.field.HtmlEditor", {
			flex: 1,
			height: 200
		});
		this.insert(0, this.htmlTextField);
		this.doLayout();
		this.showBy(el, "tl-tl?");
		try {
			this.htmlTextField.setValue(data);
			this.htmlTextField.focus(undefined, this.focusDelay);
		} catch(e) {}
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.editor.AttachEditor", {
	extend: "EnterpriseSheet.sheet.plugin.editor.AbstractEditor",
	requires: ["EnterpriseSheet.sheet.pop.AttachmentWin"],
	cls: "ss-attach-editor",
	width: 300,
	autoHeight: true,
	floating: true,
	shadow: false,
	focusDelay: 500,
	initComponent: function() {
		var me = this;
		this.store = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "aid",
				type: "string"
			}, {
				name: "name",
				type: "string"
			}, {
				name: "url",
				type: "string"
			}, {
				name: "type",
				type: "string"
			}]
		});
		var listTpl = new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"ss-attach-item {[\"file\"==values.type?\"ss-attach-file\":\"\"]}\">", "<tpl if=\"this.isImg(type)\">", "<img src=\"{url}\">", "</tpl>", "<tpl if=\"!this.isImg(type)\">", "<img src=\"", SCONFIG.ATTACH_ICON32, "\">", "</tpl>", "<div class=\"ss-attach-delete\"></div>", "</div>", "</tpl>"].join(""), {
			isImg: function(type) {
				return "img" === type;
			}
		});
		this.listView = Ext.create("Ext.view.View", {
			cls: "ss-attach-list ss-attach-preview",
			region: "center",
			maxHeight: 500,
			store: this.store,
			tpl: listTpl,
			itemSelector: "div.ss-attach-item",
			selectedItemCls: "ss-attach-item-selected",
			overItemCls: "ss-attach-item-over",
			deferEmptyText: false,
			emptyText: "<div class=\"empty-text\">" + SLANG.no_attach_yet + "</div>"
		});
		this.displayBox = Ext.create("Ext.Component", {
			cls: "empty-text"
		});
		this.items = [{
			xtype: "toolbar",
			border: false,
			style: "background:transparent;",
			items: [this.displayBox, "->", {
				xtype: "button",
				iconCls: "icon-popout",
				handler: this.onAddAttach,
				scope: this
			}]
		}, this.listView];
		this.callParent(arguments);
		this.listView.on("itemclick", function(view, rec, item, index, e) {
			var target = Ext.get(e.getTarget());
			if(target.hasCls("ss-attach-delete")) {
				this.store.remove(rec);
				var arr = [];
				this.store.each(function(rec) {
					arr.push({
						type: rec.data.type,
						url: rec.data.url,
						aid: rec.data.aid,
						name: rec.data.name
					});
				}, this);
				this.fireEvent("done", undefined, {
					itms: Ext.encode(arr),
					render: "attachRender"
				}, this);
			} else {
				this.viewAttach(view, rec, item, index, e);
			}
		}, this);
		this.store.on("datachanged", function() {
			var len = this.store.getCount();
			if(0 === len) {
				this.displayBox.update("");
			} else {
				this.displayBox.update(SLANG.attachment + " : " + len);
			}
		}, this);
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.hide();
				return false;
			} else if(keyObj.ENTER == key) {
				e.stopEvent();
				this.onDoneEdit();
				return false;
			}
		}
	},
	onDoneEdit: function() {
		this.hide();
	},
	showEditor: function(data, el, cell) {
		this.store.removeAll();
		var display = "";
		if(cell.itms) {
			var itms = Ext.decode(cell.itms),
				len = itms.length;
			for(var i = 0; i < len; i++) {
				var it = itms[i];
				this.store.add(it);
			}
			display = SLANG.attachment + " : " + len;
		}
		this.displayBox.update(display);
		this.showBy(el, "tl-tl?");
	},
	onAddAttach: function() {
		if(!this.addAttachWin) {
			this.addAttachWin = Ext.create("EnterpriseSheet.sheet.pop.AttachmentWin", {
				modal: true,
				store: this.store,
				applyCallback: {
					fn: function(param) {
						this.fireEvent("done", undefined, {
							itms: Ext.encode(param),
							render: "attachRender"
						}, this);
					},
					scope: this
				}
			});
		}
		this.addAttachWin.show();
	},
	viewAttach: function(view, rec, item, index, e) {
		var photos = [];
		this.store.each(function(rd) {
			photos.push(rd.data);
		}, this);
		PHOTOVIEWER.showPhotos(photos, index);
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.DataTypeProcessor", {
	requires: ["EnterpriseSheet.sheet.plugin.editor.LongTextEditor", "EnterpriseSheet.sheet.plugin.editor.HtmlTextEditor", "EnterpriseSheet.sheet.plugin.editor.ListRemoteEditor", "EnterpriseSheet.sheet.plugin.editor.DateEditor", "EnterpriseSheet.sheet.plugin.editor.ListRefEditor", "EnterpriseSheet.sheet.plugin.editor.ListEditor", "EnterpriseSheet.sheet.plugin.editor.MultiOptionEditor", "EnterpriseSheet.sheet.plugin.editor.MultiCheckboxEditor", "EnterpriseSheet.sheet.plugin.editor.AttachEditor"],
	init: function(sheet) {
		this.sheet = sheet;
		sheet.on({
			scope: this,
			cellclick: this.onCellClick,
			clickcelltrigger: this.onClickCellTrigger,
			rowscrolling: this.hideCurEditor,
			colscrolling: this.hideCurEditor
		});
		var sm = sheet.getSelectionModel(),
			editor = sheet.getEditor();
		sm.on("selectionchange", function() {
			if(this.curEditor && this.curEditor.isVisible()) {
				this.curEditor.hide();
			}
		}, this);
		editor.on("keydown", this.onEditorKeydown, this);
	},
	onClickCellTrigger: function(sheetId, row, col, region) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var cell = store.getCell(sheetId, row, col);
		if(Ext.isDefined(cell.minrow)) {
			row += cell.minrow;
			col += cell.mincol;
		}
		var cell = sheet.getCellValue(sheetId, row, col);
		if(cell.drop) {
			if("date" === cell.drop) {} else if("list" === cell.drop) {
				var obj = undefined;
				if(cell.dcfg) {
					var dcfg = Ext.decode(cell.dcfg);
					if(dcfg.url) {
						this.showListRemoteEditor(sheetId, row, col, region, cell, {
							url: dcfg.url
						});
						return;
					}
					if(dcfg.refList) {
						this.showListRefEditor(sheetId, row, col, region, cell, {
							refList: dcfg.refList
						});
						return;
					}
					obj = dcfg.list;
				} else if(cell.list) {
					obj = cell.list;
				}
				this.showListEditor(sheetId, row, col, region, cell, {
					data: obj
				});
			}
		}
	},
	onCellClick: function(row, col, region, e) {
		if(this.sheet.isReadOnly()) {
			return;
		}
		var target = e.getTarget();
		var tgEl = Ext.get(target);
		if(Ext.supports.ClassList && !target.classList) {
			return;
		}
		if(tgEl.hasCls("ss-trigger")) {
			this.onClickCellTrigger(region.getSheetId(), row, col, region);
		}
	},
	onEditorKeydown: function(e) {
		var key = e.getKey();
		if(this.curEditor && this.curEditor.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ESC == key) {
				e.stopEvent();
				this.curEditor.hide();
				this.sheet.refreshFocus();
				return false;
			}
		}
	},
	getDateEditor: function() {
		if(!this.dateEditor) {
			this.dateEditor = Ext.create("EnterpriseSheet.sheet.plugin.editor.DateEditor", {
				hidden: true,
				renderTo: Ext.getBody(),
				listeners: {
					done: {
						fn: this.onDoneEdit,
						scope: this
					}
				}
			});
		}
		return this.dateEditor;
	},
	getListEditor: function() {
		this.listEditor = this.listEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.ListEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.listEditor;
	},
	getListRemoteEditor: function() {
		this.listRemoteEditor = this.listRemoteEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.ListRemoteEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.listRemoteEditor;
	},
	getListRefEditor: function() {
		this.listRefEditor = this.listRefEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.ListRefEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.listRefEditor;
	},
	getMultiOptionEditor: function() {
		this.multiOptionEditor = this.multiOptionEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.MultiOptionEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.multiOptionEditor;
	},
	getMultiCheckboxEditor: function() {
		this.multiCheckboxEditor = this.multiCheckboxEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.MultiCheckboxEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.multiCheckboxEditor;
	},
	getMultiRadioEditor: function() {
		this.multiRadioEditor = this.multiRadioEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.MultiRadioEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.multiRadioEditor;
	},
	getAttachEditor: function() {
		this.attachEditor = this.attachEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.AttachEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.attachEditor;
	},
	getLongTextEditor: function() {
		this.longTextEditor = this.longTextEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.LongTextEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.longTextEditor;
	},
	getHtmlTextEditor: function() {
		this.htmlTextEditor = this.htmlTextEditor || Ext.create("EnterpriseSheet.sheet.plugin.editor.HtmlTextEditor", {
			hidden: true,
			renderTo: Ext.getBody(),
			listeners: {
				done: this.onDoneEdit,
				scope: this
			}
		});
		return this.htmlTextEditor;
	},
	onDoneEdit: function(data, modified, editor) {
		var pos = this.editPos;
		if(this.attachEditor === editor) {
			var range = Ext.create("EnterpriseSheet.sheet.range.Range", {
				sheet: this.sheet,
				coord: [
					[pos.sheetId, pos.row, pos.col, pos.row, pos.col]
				]
			});
			range.setProperty(modified);
		} else {
			this.sheet.setCell(pos.sheetId, pos.row, pos.col, Ext.apply({
				data: data
			}, modified));
		}
		this.sheet.refreshFocus();
	},
	hideCurEditor: function() {
		if(this.curEditor && this.curEditor.isVisible() && Ext.isFunction(this.curEditor.collapsePicker)) {
			this.curEditor.collapsePicker();
		}
	},
	processCellDataConfig: function(cell, scope) {
		if(cell.dcfg) {
			var DTS = SCONST.validateDataType;
			var cfg = Ext.decode(cell.dcfg);
			if(cfg) {
				var dt = cfg.dt;
				cell.it = "";
				cell.itn = "";
				if(DTS.checkbox === dt) {
					cell.it = "checkbox";
					cell.itn = "";
					delete cell.data;
				} else if(DTS.radio === dt) {
					cell.it = "radio";
					cell.itn = cfg.itn;
					delete cell.data;
				} else if(DTS.date === dt) {
					if(cfg.wt) {
						cell.fm = SCONST.FORMAT_DATE_TIME;
						cell.dfm = SCONST.DEFAULT_DATE_FORMAT + " H:i" || "Y-m-d H:i";
					} else {
						cell.fm = SCONST.FORMAT_DATE;
						cell.dfm = cfg.dfm || SCONST.DEFAULT_DATE_FORMAT;
					}
				} else if(DTS.currency === dt) {
					cell.fm = cfg.format;
				} else if(DTS.percent === dt) {
					cell.fm = SCONST.FORMAT_PERCENT;
					cell.dfm = cfg.format;
				}
				var dv = cfg.dv;
				if(Ext.isDefined(dv) && SCOM.isEmptyValue(cell.data)) {
					cell.data = dv;
				}
			}
		}
		return cell;
	},
	useCustomizedEditor: function(cellProperty, sheetId, row, col, region) {
		var sheet = this.sheet;
		if(region && sheetId === region.getSheetId()) {
			var customizedEditor = sheet.getCustomizedEditorForCell(sheetId, row, col, cellProperty);
			if(customizedEditor) {
				var cellEl = region.getCellEl(row, col);
				this.editPos = {
					sheetId: sheetId,
					row: row,
					col: col
				};
				if(this.curEditor) {
					this.curEditor.hide();
				}
				this.curEditor = customizedEditor;
				var data = cellProperty.data;
				customizedEditor.getEl().appendTo(region.ifbodyEl);
				customizedEditor.showEditor(data, cellEl, cellProperty, this.editPos);
				return true;
			}
		}
	},
	showRelatedEditor: function(sheetId, row, col, region, cellData, dcfg) {
		var dt = dcfg.dt,
			type = dcfg.type;
		var DTS = SCONST.validateDataType;
		if(DTS.date === dt) {
			this.showDateEditor(sheetId, row, col, region, cellData, dcfg.wt);
			return false;
		} else if(DTS.single_select === dt) {
			this.showListEditor(sheetId, row, col, region, cellData, {
				data: dcfg.list
			});
			return false;
		} else if(DTS.multi_options === dt) {
			this.showMultiOptionEditor(sheetId, row, col, region, cellData, {
				data: dcfg.list
			});
			return false;
		} else if(DTS.attachment === dt) {
			this.showAttachEditor(sheetId, row, col, region, cellData);
			return false;
		} else if(DTS.long_text === dt) {
			this.showLongTextEditor(sheetId, row, col, region, cellData);
			return false;
		} else if(DTS.remote_select === dt) {
			this.showListRemoteEditor(sheetId, row, col, region, cellData, {
				url: dcfg.url
			});
			return false;
		} else if(DTS.ref_select === dt) {
			sheet.getDataArrayFromCal(dcfg.refList, function(listData) {
				this.showListRefEditor(sheetId, row, col, region, cellData, {
					data: listData
				});
			}, this);
			return false;
		} else if(DTS.html_text === dt) {
			this.showHtmlTextEditor(sheetId, row, col, region, cellData);
			return false;
		} else if(DTS.checkbox === dt || DTS.radio === dt) {
			return false;
		} else if(DTS.multi_checkbox === dt) {
			this.showMultiCheckboxEditor(sheetId, row, col, region, cellData, {
				data: dcfg.list,
				otherOption: dcfg.otherOption
			});
			return false;
		} else if(DTS.multi_radio === dt) {
			this.showMultiRadioEditor(sheetId, row, col, region, cellData, {
				data: dcfg.list,
				otherOption: dcfg.otherOption
			});
			return false;
		}
	},
	checkBeforeEdit: function(sheetId, row, col, region) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var DTS = SCONST.validateDataType;
		var cellData = sheet.getCellProperty(sheetId, row, col);
		if(true === this.useCustomizedEditor(cellData, sheetId, row, col, region)) {
			return false;
		}
		var dcfg = cellData.dcfg;
		if(dcfg) {
			dcfg = Ext.decode(dcfg);
			if(false === this.showRelatedEditor(sheetId, row, col, region, cellData, dcfg)) {
				return false;
			}
		}
		var cdts = store.getConditionOfCell(sheetId, row, col);
		for(var i = 0, len = cdts.length; i < len; i++) {
			var it = cdts[i];
			if("vd" === it.name) {
				var opt = it.opt;
				if(opt.dt === DTS.single_select || DTS.list === opt.dt) {
					this.showListEditor(sheetId, row, col, region, cellData, {
						data: opt.list
					});
					return false;
				} else if(DTS.date === opt.dt) {
					this.showDateEditor(sheetId, row, col, region, cellData, opt.wt);
					return false;
				}
			}
		}
		if(cellData.drop) {
			if("date" === cellData.drop) {
				this.showDateEditor(sheetId, row, col, region, cellData);
				return false;
			} else if("list" === cellData.drop) {
				this.showListEditor(sheetId, row, col, region, cellData, cellData.drop);
				return false;
			}
		}
	},
	getDataTypeConfigForCell: function(sheetId, row, col) {
		var store = this.sheet.getStore();
		var o = store.getCell(sheetId, 0, col);
		if(o.dcfg) {
			var obj = Ext.decode(o.dcfg);
			return obj;
		}
	},
	showDateEditor: function(sheetId, row, col, region, cell, withTime, expand) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getDateEditor();
			var date, time;
			if(withTime) {
				if(Ext.isString(cell.data)) {
					var arr = cell.data.split(" ");
					date = arr[0];
					time = arr[1];
				}
			} else if(cell.data) {
				date = cell.data;
			}
			this.dateEditor.getEl().appendTo(region.ifbodyEl);
			this.dateEditor.showEditor(date, time, cellEl, withTime, expand);
		}
	},
	showListEditor: function(sheetId, row, col, region, cell, obj, expand) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getListEditor();
			var data = cell.data;
			this.listEditor.getEl().appendTo(region.ifbodyEl);
			this.listEditor.showEditor(data, cellEl, obj, expand);
		}
	},
	showListRemoteEditor: function(sheetId, row, col, region, cell, obj) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getListRemoteEditor();
			this.listRemoteEditor.getEl().appendTo(region.ifbodyEl);
			this.listRemoteEditor.showEditor(cell, cellEl, obj);
		}
	},
	showListRefEditor: function(sheetId, row, col, region, cell, obj) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getListRefEditor();
			this.listRefEditor.getEl().appendTo(region.ifbodyEl);
			this.listRefEditor.showEditor(cell, cellEl, obj);
		}
	},
	showMultiOptionEditor: function(sheetId, row, col, region, cell, obj, expand) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getMultiOptionEditor();
			var data = cell.data;
			this.multiOptionEditor.getEl().appendTo(region.ifbodyEl);
			this.multiOptionEditor.showEditor(data, cellEl, obj, expand);
		}
	},
	showMultiCheckboxEditor: function(sheetId, row, col, region, cell, obj, expand) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getMultiCheckboxEditor();
			this.multiCheckboxEditor.getEl().appendTo(region.ifbodyEl);
			this.multiCheckboxEditor.showEditor(cell.itms, cellEl, obj, expand);
		}
	},
	showMultiRadioEditor: function(sheetId, row, col, region, cell, obj, expand) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getMultiRadioEditor();
			this.multiRadioEditor.getEl().appendTo(region.ifbodyEl);
			this.multiRadioEditor.showEditor(cell.itms, cellEl, obj, expand);
		}
	},
	showAttachEditor: function(sheetId, row, col, region, cell) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getAttachEditor();
			var data = cell.data;
			this.attachEditor.getEl().appendTo(region.ifbodyEl);
			this.attachEditor.showEditor(data, cellEl, cell);
		}
	},
	showLongTextEditor: function(sheetId, row, col, region, cell) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getLongTextEditor();
			var data = cell.data;
			this.longTextEditor.getEl().appendTo(region.ifbodyEl);
			this.longTextEditor.showEditor(data, cellEl, cell);
		}
	},
	showHtmlTextEditor: function(sheetId, row, col, region, cell) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getHtmlTextEditor();
			var data = cell.data;
			this.htmlTextEditor.getEl().appendTo(region.ifbodyEl);
			this.htmlTextEditor.showEditor(data, cellEl, cell);
		}
	},
	showCustomerEditor: function(sheetId, row, col, region, cell) {
		if(region && sheetId === region.getSheetId()) {
			var cellEl = region.getCellEl(row, col);
			this.editPos = {
				sheetId: sheetId,
				row: row,
				col: col
			};
			if(this.curEditor) {
				this.curEditor.hide();
			}
			this.curEditor = this.getHtmlTextEditor();
			var data = cell.data;
			var editorEl = this.htmlTextEditor.getEl();
			editorEl.appendTo(region.ifbodyEl);
			this.htmlTextEditor.showEditor(data, cellEl, cell);
		}
	}
}, function() {});

Ext.define("EnterpriseSheet.sheet.plugin.DropList", {
	requires: ["EnterpriseSheet.common.CONST"],
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent(arguments);
		this.initListView();
		this.initDatePicker();
	},
	initListView: function() {
		this.store = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "id",
				type: "string"
			}, {
				name: "val",
				type: "string"
			}]
		});
		var listTpl = new Ext.XTemplate("<tpl for=\".\">", "<div class=\"ss-droplist-item\">", "{val}", "</div>", "</tpl>");
		this.listView = Ext.create("Ext.view.View", {
			cls: "ss-droplist",
			style: "z-index:" + SCONST.CORNER_Z_INDEX,
			store: this.store,
			tpl: listTpl,
			itemSelector: "div.ss-droplist-item",
			selectedItemCls: "ss-sdl-item",
			overItemCls: "ss-odl-item",
			emptyText: "<div class=\"empty-text\">" + SLANG.no_match_item + "</div>",
			renderTo: Ext.getBody()
		});
		this.listView.on({
			scope: this,
			itemclick: this.onListItemClick,
			itemkeydown: function(listView, record, item, index, e, eOpts) {
				var key = e.getKey();
				var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
				if(keyObj.ESC === key) {
					this.hideListView();
					e.stopEvent();
					return false;
				} else if(keyObj.ENTER === key) {
					var sels = this.listView.getSelectionModel().getSelection();
					if(0 < sels.length) {
						this.onListItemClick(this.listView, sels[0]);
						e.stopEvent();
						return false;
					}
				} else {
					e.stopEvent();
					return false;
				}
			}
		});
		this.hideListView();
	},
	hideListView: function() {
		if(this.sheet) {
			this.sheet.focus();
		}
		this.listView.hide();
		delete this.listView.available;
	},
	initDatePicker: function() {
		this.datePicker = Ext.create("Ext.picker.Date", {
			style: "z-index:" + SCONST.CORNER_Z_INDEX,
			handler: this.onSelectDate,
			scope: this,
			renderTo: Ext.getBody()
		});
		this.hideDatePicker();
	},
	hideDatePicker: function() {
		if(this.sheet) {
			this.sheet.focus();
		}
		this.datePicker.hide();
		delete this.datePicker.available;
	},
	init: function(sheet) {
		this.sheet = sheet;
		sheet.on({
			scope: this,
			cellclick: this.onCellClick,
			clickcelltrigger: this.onClickCellTrigger,
			beforestartedit: this.beforeStartEdit,
			editorkeyup: this.onEditorKeyup,
			beforeeditorspecialkey: this.beforeEditorSpecialkey,
			preparekeydown: function(e) {
				var key = e.getKey();
				return this.beforeEditorSpecialkey(key);
			},
			cellmousedown: this.onMouseDownViewEl,
			beforeswitchsheet: function() {
				this.hideListView();
				this.hideDatePicker();
			}
		});
		var editor = sheet.getEditor();
		sheet.on({
			scope: this,
			beforecompleteedit: this.beforeCompleteEdit
		});
	},
	onMouseDownViewEl: function(e) {
		this.hideListView();
		this.hideDatePicker();
	},
	onClickCellTrigger: function(sheetId, row, col, region) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var cell = store.getCell(sheetId, row, col);
		if(Ext.isDefined(cell.minrow)) {
			row += cell.minrow;
			col += cell.mincol;
		}
		this.showListView(sheetId, row, col, region);
	},
	onCellClick: function(row, col, region, e) {
		if(this.sheet.isReadOnly()) {
			return;
		}
		var target = e.getTarget();
		var tgEl = Ext.get(target);
		if(Ext.supports.ClassList && !target.classList) {
			return;
		}
		if(tgEl.hasCls("ss-trigger")) {
			this.onClickCellTrigger(region.getSheetId(), row, col, region);
		}
	},
	onListItemClick: function(list, rec) {
		var sheetId = this.cellPos[0],
			row = this.cellPos[1],
			col = this.cellPos[2],
			drop = this.cellPos[3];
		var md = {
			data: rec.data.val
		};
		if(!SCOM.isEmptyValue(rec.data.id)) {
			md.valId = rec.data.id;
		}
		this.sheet.setCellData(sheetId, row, col, md);
		this.hideListView();
		var editor = this.sheet.getEditor();
		editor.cancelEdit();
		if(drop) {
			this.sheet.fireEvent("comboselectionchange", rec.data, drop, this.store, sheetId, row, col, this);
		}
	},
	onSelectDate: function(picker, date) {
		var sheetId = this.cellPos[0],
			row = this.cellPos[1],
			col = this.cellPos[2];
		this.sheet.setCellData(sheetId, row, col, {
			data: Ext.Date.format(date, "Y-m-d"),
			fm: "date"
		});
		this.hideDatePicker();
		var editor = this.sheet.getEditor();
		editor.cancelEdit();
	},
	loadDropListById: function(id) {
		var obj = this.getDatasetById(id);
		if(obj) {
			var arr = Ext.decode(obj.data),
				data = [];
			for(var i = 0, len = arr.length; i < len; i++) {
				data.push({
					val: arr[i]
				});
			}
			this.store.loadData(data);
		} else {
			Ext.Ajax.request({
				timeout: SCONST.PULLING_TIMEOUT,
				url: SCONFIG.urls.loadDataset,
				params: {
					id: id
				},
				success: function(response, options) {
					var json = Ext.decode(response.responseText);
					if(true === json.success || "true" === json.success) {
						obj = json.object;
						this.addDataset2Lookup(obj);
						var arr = Ext.decode(obj.data),
							data = [];
						for(var i = 0, len = arr.length; i < len; i++) {
							data.push({
								val: arr[i]
							});
						}
						this.store.loadData(data);
					}
				},
				failure: function(response) {},
				scope: this
			});
		}
	},
	loadDropListByDataSource: function(url) {
		var ds = this.getDatasetById(url);
		var loadDataFn = function(obj) {
			var arr = obj.results,
				data = [];
			for(var i = 0, len = arr.length; i < len; i++) {
				var it = arr[i];
				var item = {
					val: it.value
				};
				if(Ext.isDefined(it.id)) {
					item.id = it.id;
				}
				data.push(item);
			}
			this.store.loadData(data);
		};
		if(ds) {
			loadDataFn.call(this, ds);
		} else {
			var lookup = this.dataSourceFuncLookup;
			var processDataFn = function(obj) {
				this.addDataset2Lookup(obj, url);
				loadDataFn.call(this, obj);
			};
			if(lookup[url]) {
				processDataFn.call(this, lookup[url]());
			} else {
				Ext.Ajax.request({
					timeout: SCONST.PULLING_TIMEOUT,
					url: url,
					success: function(response, options) {
						var json = Ext.decode(response.responseText);
						if(true === json.success || "true" === json.success) {
							processDataFn.call(this, json);
						}
					},
					failure: function(response) {},
					scope: this
				});
			}
		}
	},
	loadDropListByStore: function(store) {
		var loadDataFn = function(obj) {
			var arr = obj,
				data = [];
			for(var i = 0, len = arr.length; i < len; i++) {
				var it = arr[i];
				var item = {
					val: it.value
				};
				if(Ext.isDefined(it.id)) {
					item.id = it.id;
				}
				data.push(item);
			}
			this.store.loadData(data);
		};
		loadDataFn.call(this, store);
	},
	showListView: function(sheetId, row, col, region) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var cellEl = region.getCellEl(row, col);
		if(cellEl) {
			var regionCtEl = cellEl.up(".ss-region-ct");
			var ifCtEl = regionCtEl.down(".ss-ifct");
			var bodyEl = regionCtEl.down(".ss-ifbody");
			var cell = store.getCellData(sheetId, row, col);
			if("date" === cell.drop) {
				this.cellPos = [sheetId, row, col];
				if(cellEl) {
					this.datePicker.show();
					this.datePicker.getEl().appendTo(bodyEl);
					this.datePicker.alignTo(cellEl.down(".ss-date-picker"), "tl-bl?");
					this.datePicker.available = true;
					this.ifCtEl = ifCtEl;
				}
			} else if(cell.drop) {
				var drop = Ext.decode(cell.drop);
				this.cellPos = [sheetId, row, col, drop];
				if(drop.data) {
					var arr;
					if(Ext.isString(drop.data)) {
						arr = drop.data.split(",");
					} else {
						arr = drop.data;
					}
					var data = [];
					for(var i = 0, len = arr.length; i < len; i++) {
						data.push({
							val: arr[i]
						});
					}
					this.store.loadData(data);
				} else if(Ext.isDefined(drop.id)) {
					this.store.removeAll();
					this.loadDropListById(drop.id);
				} else if(Ext.isDefined(drop.dataSource)) {
					this.store.removeAll();
					this.loadDropListByDataSource(drop.dataSource);
				} else if(Ext.isDefined(drop.store)) {
					this.store.removeAll();
					this.loadDropListByStore(drop.store);
				}
				if(cellEl) {
					this.listView.getEl().appendTo(bodyEl);
					this.listView.show();
					this.listView.alignTo(cellEl.down(".ss-trigger"), "tl-bl?");
					this.listView.available = true;
					this.ifCtEl = ifCtEl;
				}
			}
		}
	},
	beforeStartEdit: function(editor, sheet, sheetId, row, col, region) {
		this.showListView(sheetId, row, col, region);
	},
	onEditorKeyup: function(e, row, col, region, editor, isCal) {
		if(this.listView.available) {
			var val = editor.getValue();
			this.store.filterBy(function(rec) {
				var display = Ext.String.trim(rec.data.val.toLowerCase());
				if(Ext.isString(val)) {
					val = Ext.String.trim(val.toLowerCase());
				}
				return 0 === display.indexOf(val);
			});
		}
	},
	beforeEditorSpecialkey: function(key) {
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(this.listView.available) {
			var sm = this.listView.getSelectionModel();
			var sels = sm.getSelection();
			if(keyObj.DOWN === key || keyObj.RIGHT === key || keyObj.UP === key || keyObj.LEFT === key) {
				if(0 === sels.length) {
					sm.select(0);
				}
				return false;
			} else if(keyObj.ESC === key) {
				this.hideListView();
				var editor = this.sheet.getEditor();
				editor.cancelEdit();
				return false;
			} else if(keyObj.ENTER === key) {
				if(0 < sels.length) {
					this.onListItemClick(this.listView, sels[0]);
					return false;
				} else {
					var nodes = this.listView.getNodes(0, 0);
					if(0 < nodes.length) {
						sm.select(0);
						return false;
					} else {
						this.hideListView();
					}
				}
			}
		}
		if(this.datePicker.available) {
			if(keyObj.ESC === key) {
				this.hideDatePicker();
				var editor = this.sheet.getEditor();
				editor.cancelEdit();
				return false;
			} else if(keyObj.ENTER === key) {
				this.hideDatePicker();
			}
		}
	},
	beforeCompleteEdit: function(sheetId, row, col, editor) {
		var store = this.sheet.getStore();
		var cell = store.getCell(sheetId, row, col);
		if(cell.ovil) {
			var rawValue = editor.getRawTextValue();
			if(-1 == this.store.find("val", rawValue)) {
				editor.cancelEdit();
				return false;
			}
		}
	}
}, function() {
	Ext.apply(EnterpriseSheet.sheet.plugin.DropList.prototype, {
		datasetLookup: {},
		dataSourceFuncLookup: {},
		addDataset2Lookup: function(ds, id) {
			var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.datasetLookup;
			id = id || ds.id;
			lookup[id] = ds;
		},
		getDatasetById: function(id) {
			var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.datasetLookup;
			return lookup[id];
		},
		deleteDatasetFromLookup: function(ds, id) {
			var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.datasetLookup;
			id = id || ds.id;
			delete lookup[id];
		},
		refreshDataSource: function(url) {
			var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.datasetLookup;
			var funcLookup = EnterpriseSheet.sheet.plugin.DropList.prototype.dataSourceFuncLookup;
			if(funcLookup[url]) {
				lookup[url] = funcLookup[url]();
			} else {
				Ext.Ajax.request({
					timeout: SCONST.PULLING_TIMEOUT,
					url: url,
					success: function(response, options) {
						delete lookup[url];
						var json = Ext.decode(response.responseText);
						if(true === json.success || "true" === json.success) {
							lookup[url] = json;
						}
					},
					failure: function(response) {},
					scope: this
				});
			}
		},
		addDataSourceFunc: function(dataSourceName, func) {
			var lookup = EnterpriseSheet.sheet.plugin.DropList.prototype.dataSourceFuncLookup;
			lookup[dataSourceName] = func;
		}
	});
});

Ext.define("EnterpriseSheet.sheet.pop.droplist.RadioListContainer", {
	extend: "Ext.container.Container",
	requires: ["Ext.form.field.Text"],
	initComponent: function() {
		this.itemStore = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "name",
				type: "string"
			}, {
				name: "desc",
				type: "string"
			}]
		});
		this.addBtn = Ext.create("Ext.button.Button", {
			border: true,
			text: " + " + SLANG.add,
			handler: this.onAddFn,
			style: "margin: 0 5px 0 5px;",
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			scope: this
		});
		this.deleteBtn = Ext.create("Ext.button.Button", {
			border: true,
			hidden: true,
			text: " - " + SLANG["delete"],
			handler: this.onDelFn,
			style: "margin: 0 5px 0 5px;",
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			scope: this
		});
		var selModel = Ext.create("Ext.selection.CheckboxModel", {
			mode: "SINGLE",
			allowDeselect: true
		});
		this.listGrid = Ext.create("Ext.grid.Panel", {
			height: 200,
			selModel: selModel,
			plugins: [Ext.create("Ext.grid.plugin.CellEditing", {
				clicksToEdit: 1
			})],
			region: "center",
			style: "padding:10px 0 10px 0;",
			store: this.itemStore,
			border: true,
			autoScroll: true,
			columns: [{
				menuDisabled: true,
				text: SLANG.name,
				flex: 1,
				dataIndex: "name",
				sortable: false,
				editor: {
					xtype: "textfield",
					allowBlank: false
				}
			}, {
				menuDisabled: true,
				text: SLANG.description,
				width: 200,
				dataIndex: "desc",
				sortable: false,
				editor: {
					xtype: "textfield",
					allowBlank: true
				}
			}],
			bbar: {
				layout: "hbox",
				items: [this.deleteBtn, "->", this.addBtn]
			}
		});
		this.items = [this.listGrid];
		this.callParent();
		selModel.on({
			scope: this,
			selectionchange: this.onSelectionChange
		})
	},
	onAddFn: function() {
		this.newItemField = Ext.create("Ext.form.field.Text", {
			fieldLabel: SLANG.name,
			width: 350,
			allowBlank: false
		});
		this.descField = Ext.create("Ext.form.field.Text", {
			style: "margin-top: 10px;",
			fieldLabel: SLANG.description,
			width: 350,
			allowBlank: true
		});
		this.newItemWin = Ext.create("Ext.window.Window", {
			modal: true,
			title: SLANG.add,
			width: 400,
			closeAction: "hide",
			bodyStyle: "background:white;padding:20px;",
			layout: "anchor",
			items: [this.newItemField, this.descField],
			buttons: [{
				text: SLANG.cancel,
				handler: function() {
					this.newItemWin.hide()
				},
				scope: this
			}, {
				text: SLANG.add,
				handler: function() {
					if(this.newItemField.isValid()) {
						this.itemStore.add({
							name: this.newItemField.getValue(),
							desc: this.descField.getValue()
						});
						this.newItemWin.hide()
					}
				},
				scope: this
			}]
		});
		this.newItemWin.show()
	},
	onSelectionChange: function(sm, sels) {
		if(1 == sels.length) {
			this.deleteBtn.show()
		} else {
			this.deleteBtn.hide()
		}
	},
	onDelFn: function() {
		var sm = this.listGrid.getSelectionModel();
		var sels = sm.getSelection();
		var store = this.itemStore;
		FEYAMSG.show({
			topbarCls: "lite-group-topbar",
			title: SLANG.confirm,
			msg: SLANG.do_u_really_wanna_delete,
			buttons: FEYAMSG.YESNO,
			fn: function(bid) {
				if("yes" == bid) {
					store.remove(sels[0])
				}
			},
			scope: this
		})
	},
	prepareParam: function() {
		var list = [];
		this.itemStore.each(function(rec) {
			list.push({
				name: rec.data.name,
				desc: rec.data.desc
			})
		});
		return list
	},
	setup: function(cfg) {
		var list = [];
		for(var i = 0; i < cfg.list.length; i++) {
			list.push({
				name: cfg.list[i].name,
				desc: cfg.list[i].desc
			})
		}
		this.itemStore.loadData(list, false)
	}
});
Ext.define("EnterpriseSheet.sheet.pop.droplist.CheckboxListContainer", {
	extend: "Ext.container.Container",
	requires: ["Ext.form.field.Text"],
	initComponent: function() {
		this.itemStore = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "name",
				type: "string"
			}, {
				name: "desc",
				type: "string"
			}]
		});
		this.addBtn = Ext.create("Ext.button.Button", {
			border: true,
			text: " + " + SLANG.add,
			handler: this.onAddFn,
			style: "margin: 0 5px 0 5px;",
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			scope: this
		});
		this.deleteBtn = Ext.create("Ext.button.Button", {
			border: true,
			hidden: true,
			text: " - " + SLANG["delete"],
			handler: this.onDelFn,
			style: "margin: 0 5px 0 5px;",
			style: {
				borderColor: "grey",
				borderStyle: "solid"
			},
			scope: this
		});
		var selModel = Ext.create("Ext.selection.CheckboxModel");
		this.listGrid = Ext.create("Ext.grid.Panel", {
			height: 200,
			selModel: selModel,
			plugins: [Ext.create("Ext.grid.plugin.CellEditing", {
				clicksToEdit: 1
			})],
			region: "center",
			style: "padding:10px 0 10px 0;",
			store: this.itemStore,
			border: true,
			autoScroll: true,
			columns: [{
				menuDisabled: true,
				text: SLANG.name,
				flex: 1,
				dataIndex: "name",
				sortable: false,
				editor: {
					xtype: "textfield",
					allowBlank: false
				}
			}, {
				menuDisabled: true,
				text: SLANG.description,
				width: 200,
				dataIndex: "desc",
				sortable: false,
				editor: {
					xtype: "textfield",
					allowBlank: true
				}
			}],
			bbar: {
				layout: "hbox",
				items: [this.deleteBtn, "->", this.addBtn]
			}
		});
		this.items = [this.listGrid];
		this.callParent();
		selModel.on({
			scope: this,
			selectionchange: this.onSelectionChange
		})
	},
	onAddFn: function() {
		this.newItemField = Ext.create("Ext.form.field.Text", {
			fieldLabel: SLANG.name,
			width: 350,
			allowBlank: false
		});
		this.descField = Ext.create("Ext.form.field.Text", {
			style: "margin-top: 10px;",
			fieldLabel: SLANG.description,
			width: 350,
			allowBlank: true
		});
		this.newItemWin = Ext.create("Ext.window.Window", {
			modal: true,
			title: SLANG.add,
			width: 400,
			closeAction: "hide",
			bodyStyle: "background:white;padding:20px;",
			layout: "anchor",
			items: [this.newItemField, this.descField],
			buttons: [{
				text: SLANG.cancel,
				handler: function() {
					this.newItemWin.hide()
				},
				scope: this
			}, {
				text: SLANG.add,
				handler: function() {
					if(this.newItemField.isValid()) {
						this.itemStore.add({
							name: this.newItemField.getValue(),
							desc: this.descField.getValue()
						});
						this.newItemWin.hide()
					}
				},
				scope: this
			}]
		});
		this.newItemWin.show()
	},
	onSelectionChange: function(sm, sels) {
		if(1 == sels.length) {
			this.deleteBtn.show()
		} else {
			this.deleteBtn.hide()
		}
	},
	onDelFn: function() {
		var sm = this.listGrid.getSelectionModel();
		var sels = sm.getSelection();
		var store = this.itemStore;
		FEYAMSG.show({
			topbarCls: "lite-group-topbar",
			title: SLANG.confirm,
			msg: SLANG.do_u_really_wanna_delete,
			buttons: FEYAMSG.YESNO,
			fn: function(bid) {
				if("yes" == bid) {
					store.remove(sels[0])
				}
			},
			scope: this
		})
	},
	prepareParam: function() {
		var list = [];
		this.itemStore.each(function(rec) {
			list.push({
				name: rec.data.name,
				desc: rec.data.desc
			})
		});
		return list
	},
	setup: function(cfg) {
		var list = [];
		for(var i = 0; i < cfg.list.length; i++) {
			list.push({
				name: cfg.list[i].name,
				desc: cfg.list[i].desc
			})
		}
		this.itemStore.loadData(list, false)
	}
});

Ext.define("EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer", {
	extend: "Ext.container.Container",
	requires: ["Ext.form.field.Text", "EnterpriseSheet.sheet.plugin.DropList"],
	initComponent: function() {
		this.optionBtn = Ext.create("Ext.button.Button", {
			text: SLANG.select_data_source,
			menu: [{
				text: SLANG.input_drop_list,
				handler: this.selectInputOption,
				scope: this
			}, {
				text: SLANG.select_data_source,
				handler: this.selectDatasourceOption,
				scope: this
			}]
		});
		this.store = Ext.create("Ext.data.ArrayStore", {
			fields: [{
				name: "id",
				type: "string"
			}, {
				name: "name",
				type: "string"
			}, {
				name: "data",
				type: "string"
			}],
			proxy: {
				type: "ajax",
				timeout: SCONST.PULLING_TIMEOUT,
				url: SCONFIG.urls.listDataset
			}
		});
		this.store.on({
			scope: this,
			load: this.afterDroplistStoreLoad
		});
		var listTpl = new Ext.XTemplate("<tpl for=\".\">", "<div class=\"ss-droplist-item\">", "{name}", "</div>", "</tpl>");
		this.dataSourceList = Ext.create("Ext.view.View", {
			cls: "ss-droplist ss-dataset-list",
			store: this.store,
			deferEmptyText: false,
			tpl: listTpl,
			itemSelector: "div.ss-droplist-item",
			selectedItemCls: "ss-sdl-item",
			overItemCls: "ss-odl-item",
			emptyText: "<div class=\"empty-text\">" + SLANG.no_dataset_available + "</div>"
		});
		this.listItemCt = Ext.create("Ext.container.Container", {
			cls: "ss-datasource-item",
			region: "east",
			width: 200,
			html: "<div class=\"empty-text\">" + SLANG.select_from_left_list + "</div>"
		});
		this.deleteDroplistBtn = Ext.create("Ext.button.Button", {
			text: SLANG['delete'],
			disabled: true,
			handler: this.onDeleteDropList,
			scope: this
		});
		this.editDroplistBtn = Ext.create("Ext.button.Button", {
			text: SLANG.edit,
			disabled: true,
			handler: this.onEditDropList,
			scope: this
		});
		this.addBtn = Ext.create("Ext.button.Button", {
			iconCls: "icon-add",
			text: SLANG.add_new_dataset,
			handler: this.onAddNewDataset,
			scope: this
		});
		this.dataSourceCt = Ext.create("Ext.container.Container", {
			layout: "border",
			height: 150,
			cls: "ss-datasource-detail",
			style: "margin-top:10px;",
			items: [{
				xtype: "panel",
				region: "center",
				layout: "fit",
				items: [this.dataSourceList],
				bbar: [this.addBtn, "->", this.editDroplistBtn, "-", this.deleteDroplistBtn]
			}, this.listItemCt]
		});
		this.itemField = new Ext.form.field.Text({
			fieldLabel: SLANG.item_hint,
			labelSeparator: "",
			labelAlign: "top",
			style: "margin-top:10px;",
			width: "100%",
			hidden: true,
			allowBlank: false
		});
		this.onlyValueInListCB = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.only_allow_data_in_droplist,
			hidden: this.hideOnlyValueInList,
			checked: this.checkOnlyValueInList
		});
		this.items = [this.optionBtn, this.dataSourceCt, this.itemField, {
			xtype: "container",
			cls: "ss-dl-setting",
			items: [this.onlyValueInListCB]
		}];
		this.callParent();
		var sm = this.dataSourceList.getSelectionModel();
		sm.on({
			scope: this,
			selectionchange: this.onDatasetSelectionChange
		});
	},
	loadDropListStore: function() {
		var docId = this.sheet.getStore().fileId;
		if(docId) {
			this.store.load({
				params: {
					documentId: docId
				}
			});
			this.addBtn.enable();
		} else {
			this.addBtn.disable();
		}
	},
	selectInputOption: function() {
		this.optionBtn.setText(SLANG.input_drop_list);
		this.dataSourceCt.hide();
		this.itemField.show();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
	},
	selectDatasourceOption: function() {
		this.optionBtn.setText(SLANG.select_data_source);
		this.dataSourceCt.show();
		this.itemField.hide();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
	},
	isValid: function() {
		if(this.dataSourceCt.isVisible()) {
			var sm = this.dataSourceList.getSelectionModel();
			if(sm.hasSelection()) {
				this.dataSourceList.removeCls("ss-dataset-list-invalid");
				return true;
			}
			this.dataSourceList.addCls("ss-dataset-list-invalid");
			return false;
		} else {
			return this.itemField.isValid();
		}
	},
	popupDatasetEdior: function(dataset) {
		if(!this.newDataSetWin) {
			this.newDatasetNameField = Ext.create("Ext.form.field.Text", {
				anchor: "100%",
				fieldLabel: SLANG.new_dataset_name,
				labelSeparator: "",
				labelAlign: "top",
				allowBlank: false
			});
			this.newDatasetItemField = Ext.create("Ext.form.field.Text", {
				anchor: "100%",
				fieldLabel: SLANG.new_dataset_hint,
				labelSeparator: "",
				labelAlign: "top",
				style: "margin-top:10px;",
				allowBlank: false
			});
			this.newDataSetWin = Ext.create("Ext.window.Window", {
				modal: true,
				title: SLANG.add_new_dateset,
				width: 400,
				closeAction: "hide",
				bodyStyle: "background:white;padding:20px;",
				layout: "anchor",
				items: [this.newDatasetNameField, this.newDatasetItemField],
				buttons: [{
					text: SLANG.add,
					handler: function() {
						if(this.newDatasetNameField.isValid() && this.newDatasetItemField.isValid()) {
							this.saveNewDataset();
							this.newDataSetWin.hide();
						}
					},
					scope: this
				}, {
					text: SLANG.cancel,
					handler: function() {
						this.newDataSetWin.hide();
					},
					scope: this
				}]
			});
		}
		if(dataset) {
			this.newDatasetNameField.setValue(dataset.data.name);
			var str = Ext.decode(dataset.data.data).join(",");
			this.newDatasetItemField.setValue(str);
		} else {
			this.newDatasetNameField.reset();
			this.newDatasetItemField.reset();
		}
		this.newDataSetWin.editDataset = dataset;
		this.newDataSetWin.show();
	},
	onAddNewDataset: function() {
		this.popupDatasetEdior();
	},
	saveNewDataset: function() {
		var name = this.newDatasetNameField.getValue(),
			content = this.newDatasetItemField.getValue();
		var arr = content.split(","),
			dataArr = [];
		for(var i = 0; i < arr.length; i++) {
			dataArr.push(arr[i].trim());
		}
		var fileId = this.sheet.getStore().fileId;
		this.sheet.addDropdownStore(name, dataArr, function(success, json) {
			if(success) {
				this.store.on("load", function() {
					this.onDatasetSelectionChange();
				}, this, {
					single: true
				});
				this.store.load({
					params: {
						documentId: fileId
					}
				});
			}
		}, this);
	},
	onDatasetSelectionChange: function() {
		var sm = this.dataSourceList.getSelectionModel();
		var sels = sm.getSelection();
		if(0 < sels.length) {
			var rec = sels[0];
			rec = this.store.getById(rec.data.id);
			var json = Ext.decode(rec.data.data);
			var html = json.join("<br>");
			this.listItemCt.update(html);
			this.deleteDroplistBtn.enable();
			this.editDroplistBtn.enable();
			this.dataSourceList.removeCls("ss-dataset-list-invalid");
		} else {
			this.listItemCt.update("<div class=\"empty-text\">" + SLANG.select_from_left_list + "</div>");
			this.deleteDroplistBtn.disable();
			this.editDroplistBtn.disable();
			this.dataSourceList.addCls("ss-dataset-list-invalid");
		}
	},
	prepareParam: function() {
		if(this.dataSourceCt.isVisible()) {
			var sm = this.dataSourceList.getSelectionModel();
			var sels = sm.getSelection();
			var rec = sels[0];
			var list = [];
			this.store.each(function(rec) {
				list = Ext.decode(rec.data.data);
			});
			return {
				drop: Ext.encode({
					id: rec.data.id
				}),
				ovil: this.onlyValueInListCB.getValue(),
				list: list
			};
		} else {
			var json = this.itemField.getValue();
			json = json.split(",");
			return {
				drop: Ext.encode({
					data: json
				}),
				ovil: this.onlyValueInListCB.getValue(),
				list: json
			};
		}
	},
	onDeleteDropList: function() {
		var sm = this.dataSourceList.getSelectionModel();
		var sels = sm.getSelection();
		var rec = sels[0];
		var fileId = this.sheet.getStore().fileId;
		Ext.Msg.show({
			title: SLANG.confirm,
			msg: SLANG.want2delete_dataset,
			buttons: Ext.Msg.YESNO,
			fn: function(bid) {
				if("yes" === bid) {
					this.sheet.deleteDropdownStore(rec.data, function(success) {
						if(success) {
							this.store.load({
								params: {
									documentId: fileId
								}
							});
						}
					}, this);
				}
			},
			icon: Ext.Msg.QUESTION,
			scope: this
		});
	},
	onEditDropList: function() {
		var sm = this.dataSourceList.getSelectionModel();
		var sels = sm.getSelection();
		var rec = sels[0];
		this.popupDatasetEdior(rec);
	},
	afterDroplistStoreLoad: function() {
		var recs = this.store.getRange();
		for(var i = 0, len = recs.length; i < len; i++) {
			var it = recs[i];
			EnterpriseSheet.sheet.plugin.DropList.prototype.addDataset2Lookup(it.data);
		}
	},
	setup: function(cfg) {
		var drop = cfg.drop;
		if(drop.id) {
			this.selectDatasourceOption();
			var sm = this.dataSourceList.getSelectionModel(),
				store = this.dataSourceList.getStore();
			var rec = store.getById(drop.id);
			if(rec) {
				sm.select([rec]);
			} else {
				store.on("load", function() {
					rec = store.getById(drop.id);
					sm.select([rec]);
				}, this, {
					single: true
				});
			}
		} else {
			this.selectInputOption();
			var list = cfg.list;
			this.itemField.setValue(list.join(","));
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.droplist.DropListConfigWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer"],
	bodyStyle: "padding:25px;background-color:white;",
	width: 500,
	initComponent: function() {
		this.dropListConfigCt = Ext.create("EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer", {
			sheet: this.sheet
		});
		this.items = [this.dropListConfigCt];
		this.callParent();
		this.dropListConfigCt.loadDropListStore();
	},
	isValid: function() {
		return this.dropListConfigCt.isValid();
	},
	prepareParam: function() {
		return this.dropListConfigCt.prepareParam();
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
	}
});

Ext.define("EnterpriseSheet.sheet.pop.datatype.GeneralDataTypeContainer", {
	extend: "Ext.container.Container",
	requires: ["Ext.form.field.ComboBox", "EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer"],
	layout: "border",
	initComponent: function() {
		var DTS = SCONST.validateDataType;
		this.dataTypeCombo = Ext.create("Ext.form.ComboBox", {
			region: "north",
			emptyText: SLANG.pick_data_type,
			store: Ext.create("Ext.data.Store", {
				fields: ["name", "display", "icon"],
				data: this.dataTypeShowList || [{
					display: SLANG.text,
					name: DTS.text,
					icon: SCONFIG.TITLE_ICONS_PATH + "/text.png"
				}, {
					display: SLANG.text_long,
					name: DTS.long_text,
					icon: SCONFIG.TITLE_ICONS_PATH + "/textLong.png"
				}, {
					display: SLANG.text_html,
					name: DTS.html_text,
					icon: SCONFIG.TITLE_ICONS_PATH + "/textHtml.png"
				}, {
					display: SLANG.number,
					name: DTS.number,
					icon: SCONFIG.TITLE_ICONS_PATH + "/number.png"
				}, {
					display: SLANG.date,
					name: DTS.date,
					icon: SCONFIG.TITLE_ICONS_PATH + "/date.png"
				}, {
					display: SLANG.phone,
					name: DTS.phone,
					icon: SCONFIG.TITLE_ICONS_PATH + "/phone.png"
				}, {
					display: SLANG.email,
					name: DTS.email,
					icon: SCONFIG.TITLE_ICONS_PATH + "/email.png"
				}, {
					display: SLANG.url,
					name: DTS.url,
					icon: SCONFIG.TITLE_ICONS_PATH + "/link.png"
				}, {
					display: SLANG.checkbox,
					name: DTS.checkbox,
					icon: SCONFIG.TITLE_ICONS_PATH + "/checkbox.png"
				}, {
					display: SLANG.multi_checkbox,
					name: DTS.multi_checkbox,
					icon: SCONFIG.TITLE_ICONS_PATH + "/checkbox.png"
				}, {
					display: SLANG.multi_radio,
					name: DTS.multi_radio,
					icon: SCONFIG.TITLE_ICONS_PATH + "/radio.png"
				}, {
					display: SLANG.single_radio,
					name: DTS.radio,
					icon: SCONFIG.TITLE_ICONS_PATH + "/radio.png"
				}, {
					display: SLANG.ref_select,
					name: DTS.ref_select,
					icon: SCONFIG.TITLE_ICONS_PATH + "/remoteList.png"
				}, {
					display: SLANG.remote_select,
					name: DTS.remote_select,
					icon: SCONFIG.TITLE_ICONS_PATH + "/remoteList.png"
				}, {
					display: SLANG.single_select,
					name: DTS.single_select,
					icon: SCONFIG.TITLE_ICONS_PATH + "/dropdown.png"
				}, {
					display: SLANG.multi_options,
					name: DTS.multi_options,
					icon: SCONFIG.TITLE_ICONS_PATH + "/dropdown.png"
				}, {
					display: SLANG.attachment,
					name: DTS.attachment,
					icon: SCONFIG.TITLE_ICONS_PATH + "/attach.png"
				}, {
					display: SLANG.currency,
					name: DTS.currency,
					icon: SCONFIG.TITLE_ICONS_PATH + "/money_dollar.png"
				}, {
					display: SLANG.percent,
					name: DTS.percent,
					icon: SCONFIG.TITLE_ICONS_PATH + "/percent.png"
				}, {
					display: SLANG.displayText,
					name: DTS.display_text,
					icon: SCONFIG.TITLE_ICONS_PATH + "/text.png"
				}]
			}),
			tpl: Ext.create("Ext.XTemplate", ['<tpl for=".">', '<div class="x-boundlist-item"><img src="{icon}" style="vertical-align: middle;" />&nbsp;&nbsp;&nbsp;{display}</div>', "</tpl>"].join(""), {
				compile: true
			}),
			queryMode: "local",
			displayField: "display",
			valueField: "name",
			editable: false,
			anchor: "100%",
			allowBlank: false,
			listeners: {
				select: {
					fn: this.onSelectDataType,
					scope: this
				}
			}
		});
		this.cardCt = this.createCardCt();
		this.items = [this.dataTypeCombo, this.cardCt];
		this.callParent(arguments);
		this.on("hide", function() {
			if(this.hideCallback && !this.disableHideCallback) {
				this.hideCallback.fn.call(this.hideCallback.scope)
			}
		}, this)
	},
	createCardCt: function() {
		return Ext.create("Ext.container.Container", {
			region: "center",
			layout: "card",
			activeItem: 0,
			padding: "20 0",
			items: [{
				xtype: "component"
			}, this.getTextConfigCt(), this.getTextLongConfigCt(), this.getTextHtmlConfigCt(), this.getPhoneConfigCt(), this.getUrlConfigCt(), this.getEmailConfigCt(), this.getSingleSelectConfigCt(), this.getNumberConfigCt(), this.getDateConfigCt(), this.getCheckboxConfigCt(), this.getMultipleCheckboxConfigCt(), this.getMultipleRadioConfigCt(), this.getRadioConfigCt(), this.getAttachConfigCt(), this.getCurrencyConfigCt(), this.getPercentConfigCt(), this.getRemoteSelectConfigCt(), this.getDisplayTextConfigCt(), this.getRefSelectConfigCt()]
		})
	},
	setup: function(cfg, callback, scope) {
		if(cfg) {
			var DTS = SCONST.validateDataType;
			var dt = cfg.dt;
			if(-1 !== this.dataTypeCombo.store.find("name", dt)) {
				this.dataTypeCombo.setValue(dt);
				this.onSelectDataType();
				if(DTS.text === dt) {
					this.textConfigCt.setValues(cfg)
				} else {
					if(DTS.date === dt) {
						this.dateConfigCt.setValues(cfg)
					} else {
						if(DTS.number === dt) {
							this.numberConfigCt.setValues(cfg)
						} else {
							if(DTS.single_select === dt || DTS.multi_options === dt) {
								this.singleSelectConfigCt.setValues(cfg)
							} else {
								if(DTS.phone === dt) {
									this.phoneConfigCt.setValues(cfg)
								} else {
									if(DTS.email === dt) {
										this.emailConfigCt.setValues(cfg)
									} else {
										if(DTS.attachment === dt) {
											this.attachConfigCt.setValues(cfg)
										} else {
											if(DTS.url === dt) {
												this.urlConfigCt.setValues(cfg)
											} else {
												if(DTS.radio === dt) {
													this.radioConfigCt.setValues(cfg)
												} else {
													if(DTS.checkbox === dt) {
														this.checkboxConfigCt.setValues(cfg)
													} else {
														if(DTS.currency === dt) {
															this.currencyConfigCt.setValues(cfg)
														} else {
															if(DTS.percent === dt) {
																this.percentConfigCt.setValues(cfg)
															} else {
																if(DTS.long_text === dt) {
																	this.longTextConfigCt.setValues(cfg)
																} else {
																	if(DTS.html_text === dt) {
																		this.htmlTextConfigCt.setValues(cfg)
																	} else {
																		if(DTS.remote_select === dt) {
																			this.remoteSelectConfigCt.setValues(cfg)
																		} else {
																			if(DTS.ref_select === dt) {
																				this.refSelectConfigCt.setValues(cfg)
																			} else {
																				if(DTS.multi_checkbox === dt) {
																					this.multiCheckboxConfigCt.setValues(cfg)
																				} else {
																					if(DTS.multi_radio === dt) {
																						this.multiRadioConfigCt.setValues(cfg)
																					} else {
																						if(DTS.display_text === dt) {
																							this.displayTextConfigCt.setValues(cfg)
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if(callback) {
					callback.call(scope, true)
				}
				return
			}
		}
		if(callback) {
			callback.call(scope, false)
		}
	},
	reset: function() {
		this.cardCt.getLayout().setActiveItem(0)
	},
	getTextConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.textConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.text,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.text_type_hint
			}, {
				xtype: "textfield",
				checked: true,
				emptyText: SLANG.input_default_value,
				anchor: "100%"
			}],
			getValues: function() {
				var dv = me.textConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.text
				};
				if(Ext.isDefined(dv)) {
					o.dv = dv
				}
				return o
			},
			setValues: function(cfg) {
				if(cfg.dv) {
					me.textConfigCt.items.get(1).setValue(cfg.dv)
				}
			}
		});
		return this.textConfigCt
	},
	getTextLongConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.longTextConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.long_text,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.text_type_hint2
			}, {
				xtype: "checkbox",
				boxLabel: SLANG.add_text_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.longTextConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.long_text,
					titleIcon: titleIcon == true ? "textLong" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.longTextConfigCt.items.get(1).setValue(true)
				} else {
					me.longTextConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.longTextConfigCt
	},
	getTextHtmlConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.htmlTextConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.html_text,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.text_type_hint2
			}, {
				xtype: "checkbox",
				boxLabel: SLANG.add_text_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.htmlTextConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.html_text,
					titleIcon: titleIcon == true ? "textHtml" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.htmlTextConfigCt.items.get(1).setValue(true)
				} else {
					me.htmlTextConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.htmlTextConfigCt
	},
	getDisplayTextConfigCt: function() {
		var DTS = SCONST.validateDataType,
			me = this;
		this.displayTextConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.display_text,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.text_display_type_hint
			}, {
				xtype: "htmleditor",
				emptyText: SLANG.description,
				height: 250,
				anchor: "100%"
			}, {
				xtype: "checkbox",
				boxLabel: SLANG.add_text_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var desc = me.displayTextConfigCt.items.get(1).getValue();
				var titleIcon = me.displayTextConfigCt.items.get(2).getValue();
				var o = {
					dt: DTS.display_text,
					titleIcon: titleIcon == true ? "text" : null
				};
				if(Ext.isDefined(desc)) {
					o.desc = desc
				}
				return o
			},
			setValues: function(cfg) {
				if(cfg.desc) {
					me.displayTextConfigCt.items.get(1).setValue(cfg.desc)
				}
				if(cfg.titleIcon) {
					me.displayTextConfigCt.items.get(2).setValue(true)
				} else {
					me.displayTextConfigCt.items.get(2).setValue(false)
				}
			}
		});
		return this.displayTextConfigCt
	},
	getRemoteSelectConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.urlField = Ext.create("Ext.form.field.Text", {
			allowBlank: false,
			value: "sheetDropdown/remoteExample",
			anchor: "100%"
		});
		this.remoteSelectConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.remote_select,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.remote_select_type_hint + '<br/><pre>{"results":[{"id":1,"value":"HR Dept"},{"id":2,"value":"QA Dept"},\n{"id":3,"value":"Sale Dept"}],"success":"true"}</pre>'
			}, this.urlField, {
				xtype: "checkbox",
				boxLabel: SLANG.add_drop_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var dt = me.dataTypeCombo.getValue();
				var titleIcon = me.remoteSelectConfigCt.items.get(2).getValue();
				var o = {
					dt: dt,
					url: me.urlField.getValue(),
					titleIcon: titleIcon == true ? "remoteList" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.remoteSelectConfigCt.items.get(2).setValue(true)
				} else {
					me.remoteSelectConfigCt.items.get(2).setValue(false)
				}
				me.remoteSelectConfigCt.items.get(2).setValue(cfg.url)
			}
		});
		return this.remoteSelectConfigCt
	},
	getRefSelectConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.rangeField = new EnterpriseSheet.sheet.range.RangeField({
			fieldLabel: SLANG.cell_range,
			labelWidth: 70,
			sheet: this.sheet,
			flex: 1,
			anchor: "100%",
			margin: "0 0 15 0",
			allowBlank: false
		});
		this.refSelectConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.ref_select,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.ref_select_type_hint
			}, this.rangeField, {
				xtype: "checkbox",
				boxLabel: SLANG.add_drop_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var dt = me.dataTypeCombo.getValue();
				var titleIcon = me.refSelectConfigCt.items.get(2).getValue();
				var o = {
					dt: dt,
					refList: me.rangeField.getValue(),
					titleIcon: titleIcon == true ? "remoteList" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.refSelectConfigCt.items.get(2).setValue(true)
				} else {
					me.refSelectConfigCt.items.get(2).setValue(false)
				}
				me.refSelectConfigCt.items.get(1).setValue(cfg.refList)
			}
		});
		this.relayEvents(this.rangeField, ["minimode", "normalmode"]);
		return this.refSelectConfigCt
	},
	getSingleSelectConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.dropListConfigCt = Ext.create("EnterpriseSheet.sheet.pop.droplist.DropListConfigContainer", {
			sheet: this.sheet,
			hideOnlyValueInList: true,
			checkOnlyValueInList: true
		});
		this.singleSelectConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.single_select,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.single_select_type_hint
			}, this.dropListConfigCt, {
				xtype: "checkbox",
				boxLabel: SLANG.add_drop_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var dt = me.dataTypeCombo.getValue();
				var titleIcon = me.singleSelectConfigCt.items.get(2).getValue();
				var o = {
					dt: dt,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "remoteList" : null
				};
				var param = me.dropListConfigCt.prepareParam();
				o.list = param.list;
				o.drop = Ext.decode(param.drop);
				return o
			},
			setValues: function(cfg) {
				if(DTS.single_select === cfg.dt) {
					me.singleSelectConfigCt.items.get(0).update(SLANG.single_select_type_hint)
				} else {
					if(DTS.multi_options === cfg.dt) {
						me.singleSelectConfigCt.items.get(0).update(SLANG.multi_options_type_hint)
					}
				}
				if(cfg.titleIcon) {
					me.refSelectConfigCt.items.get(2).setValue(true)
				} else {
					me.refSelectConfigCt.items.get(2).setValue(false)
				}
				me.dropListConfigCt.setup(cfg)
			}
		});
		return this.singleSelectConfigCt
	},
	getPhoneConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.phoneConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.phone,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.phone_type_hint
			}, {
				xtype: "checkbox",
				boxLabel: SLANG.add_phone_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.phoneConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.phone,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "phone" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.phoneConfigCt.items.get(1).setValue(true)
				} else {
					me.phoneConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.phoneConfigCt
	},
	getUrlConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.urlConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.url,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.url_type_hint
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_url_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.urlConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.url,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "link" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.urlConfigCt.items.get(1).setValue(true)
				} else {
					me.urlConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.urlConfigCt
	},
	getEmailConfigCt: function() {
		var DTS = SCONST.validateDataType;
		var me = this;
		this.emailConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.email,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.email_type_hint
			}, {
				xtype: "checkbox",
				boxLabel: SLANG.add_email_icon,
				checked: true,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.emailConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.email,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "email" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.emailConfigCt.items.get(1).setValue(true)
				} else {
					me.emailConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.emailConfigCt
	},
	getNumberConfigCt: function() {
		var me = this;
		var DTS = SCONST.validateDataType;
		var minField = Ext.create("Ext.form.field.Number", {
			flex: 1,
			margin: "0 0 0 10",
			disabled: true,
			allowBlank: false
		});
		var maxField = Ext.create("Ext.form.field.Number", {
			flex: 1,
			margin: "0 0 0 10",
			disabled: true,
			allowBlank: false,
			validator: function(val) {
				if(!minField.disabled && val < minField.getValue()) {
					return false
				}
				return true
			}
		});
		var minCheckbox = Ext.create("Ext.form.Checkbox", {
			boxLabel: SLANG.min_value,
			width: 120,
			handler: function(comp, checked) {
				if(checked) {
					minField.enable()
				} else {
					minField.disable()
				}
			},
			scope: this
		});
		var maxCheckbox = Ext.create("Ext.form.Checkbox", {
			boxLabel: SLANG.max_value,
			width: 120,
			handler: function(comp, checked) {
				if(checked) {
					maxField.enable()
				} else {
					maxField.disable()
				}
			}
		});
		this.numberConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.number,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.number_type_hint
			}, {
				xtype: "numberfield",
				emptyText: SLANG.input_default_value,
				anchor: "100%",
				validator: function(val) {
					if(val && !minField.disabled && val < minField.getValue()) {
						return false
					}
					if(val && !maxField.disabled && val > maxField.getValue()) {
						return false
					}
					return true
				}
			}, {
				xtype: "checkbox",
				boxLabel: SLANG.integer_only,
				anchor: "100%"
			}, {
				xtype: "container",
				layout: {
					type: "hbox"
				},
				anchor: "100%",
				items: [minCheckbox, minField]
			}, {
				xtype: "container",
				layout: {
					type: "hbox"
				},
				anchor: "100%",
				margin: "10 0 10 0",
				items: [maxCheckbox, maxField]
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_number_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var dv = me.numberConfigCt.items.get(1).getValue(),
					intOnly = me.numberConfigCt.items.get(2).getValue(),
					numberIcon = me.numberConfigCt.items.get(5).getValue();
				var op = SCONST.validateOption["any_number"];
				var o = {
					dt: DTS.number,
					io: intOnly,
					ignoreBlank: true,
					titleIcon: numberIcon == true ? "number" : null
				};
				if(!minField.disabled && !maxField.disabled) {
					o.min = minField.getValue();
					o.max = maxField.getValue();
					op = SCONST.validateOption["between"]
				} else {
					if(!minField.disabled) {
						o.num = minField.getValue();
						op = SCONST.validateOption["greater_equal"]
					} else {
						if(!maxField.disabled) {
							o.num = maxField.getValue();
							op = SCONST.validateOption["less_equal"]
						}
					}
				}
				o.op = op;
				if(Ext.isDefined(dv)) {
					o.dv = dv
				}
				return o
			},
			setValues: function(cfg) {
				if(Ext.isDefined(cfg.dv)) {
					me.numberConfigCt.items.get(1).setValue(cfg.dv)
				} else {
					me.numberConfigCt.items.get(1).reset()
				}
				if(cfg.io) {
					me.numberConfigCt.items.get(2).setValue(true)
				} else {
					me.numberConfigCt.items.get(2).setValue(false)
				}
				if(cfg.titleIcon) {
					me.numberConfigCt.items.get(5).setValue(true)
				} else {
					me.numberConfigCt.items.get(5).setValue(false)
				}
				if(SCONST.validateOption["between"] === cfg.op) {
					minField.setValue(cfg.min);
					minCheckbox.setValue(true);
					maxField.setValue(cfg.max);
					maxCheckbox.setValue(true)
				} else {
					if(SCONST.validateOption["greater_equal"] === cfg.op) {
						minField.setValue(cfg.num);
						minCheckbox.setValue(true);
						maxCheckbox.setValue(false);
						maxField.reset()
					} else {
						if(SCONST.validateOption["less_equal"] === cfg.op) {
							maxField.setValue(cfg.num);
							maxCheckbox.setValue(true);
							minCheckbox.setValue(false);
							minField.reset()
						} else {
							minCheckbox.setValue(false);
							minField.reset();
							maxCheckbox.setValue(false);
							maxField.reset()
						}
					}
				}
			}
		});
		return this.numberConfigCt
	},
	getDateConfigCt: function() {
		var me = this,
			DTS = SCONST.validateDataType;
		var date_list = [],
			formats = SCONST.jsDateFm,
			today = new Date();
		for(var i = 0, len = formats.length; i < len; i++) {
			var fm = formats[i];
			date_list.push({
				name: Ext.Date.format(today, fm),
				fm: fm
			})
		}
		var dateFms = Ext.create("Ext.data.Store", {
			fields: ["name", "fm"],
			data: date_list
		});
		this.dateCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.format,
			editable: false,
			store: dateFms,
			displayField: "name",
			valueField: "fm",
			queryMode: "local",
			triggerAction: "all",
			width: 355,
			value: SCONST.DEFAULT_DATE_FORMAT,
			forceSelection: true
		});
		this.dateConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.date,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.date_type_hint
			}, this.dateCombo, {
				xtype: "checkbox",
				boxLabel: SLANG.add_time_field,
				anchor: "100%"
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_date_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var withTime = me.dateConfigCt.items.get(2).getValue(),
					titleIcon = me.dateConfigCt.items.get(3).getValue(),
					dateFm = me.dateConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.date,
					op: SCONST.validateOption["is_date"],
					dfm: dateFm,
					titleIcon: titleIcon == true ? "date" : null
				};
				if(Ext.isDefined(withTime)) {
					o.wt = withTime
				}
				return o
			},
			setValues: function(cfg) {
				if(cfg.wt) {
					me.dateConfigCt.items.get(2).setValue(true)
				} else {
					me.dateConfigCt.items.get(2).setValue(false)
				}
				if(cfg.titleIcon) {
					me.dateConfigCt.items.get(3).setValue(true)
				} else {
					me.dateConfigCt.items.get(3).setValue(false)
				}
				if(cfg.dfm) {
					me.dateCombo.setValue(cfg.dfm)
				}
			}
		});
		return this.dateConfigCt
	},
	getCheckboxConfigCt: function() {
		var me = this;
		var DTS = SCONST.validateDataType;
		this.checkboxConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.checkbox,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.checkbox_type_hint
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_checkbox_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.checkboxConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.checkbox,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "checkbox" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.checkboxConfigCt.items.get(1).setValue(true)
				} else {
					me.checkboxConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.checkboxConfigCt
	},
	getMultipleCheckboxConfigCt: function() {
		var me = this,
			DTS = SCONST.validateDataType;
		this.multiCheckbox = Ext.create("EnterpriseSheet.sheet.pop.droplist.CheckboxListContainer", {
			sheet: this.sheet
		});
		this.multiCheckboxConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.multi_checkbox,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.multi_checkbox_type_hint
			}, this.multiCheckbox, {
				xtype: "checkbox",
				checked: false,
				boxLabel: SLANG.add_other_fill,
				anchor: "100%"
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_checkbox_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var otherOption = me.multiCheckboxConfigCt.items.get(2).getValue();
				var titleIcon = me.multiCheckboxConfigCt.items.get(3).getValue();
				var o = {
					dt: DTS.multi_checkbox,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "checkbox" : null,
					otherOption: otherOption
				};
				o.list = me.multiCheckbox.prepareParam();
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.multiCheckboxConfigCt.items.get(3).setValue(true)
				}
				if(cfg.otherOption) {
					me.multiCheckboxConfigCt.items.get(2).setValue(true)
				}
				me.multiCheckbox.setup(cfg)
			}
		});
		return this.multiCheckboxConfigCt
	},
	getCurrencyConfigCt: function() {
		var me = this;
		var DTS = SCONST.validateDataType;
		this.currencyCt = Ext.create("EnterpriseSheet.sheet.pop.money.MoneySelectContainer", {
			sheet: this.sheet
		});
		this.currencyConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.currency,
			layout: "anchor",
			items: [this.currencyCt, {
				style: "margin-top:5px;",
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_currency_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.currencyConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.currency,
					format: me.currencyCt.getFormat(),
					titleIcon: titleIcon == true ? "money_dollar" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.currencyConfigCt.items.get(1).setValue(true)
				} else {
					me.currencyConfigCt.items.get(1).setValue(false)
				}
				if(cfg.format) {
					me.currencyCt.setFormat(cfg.format)
				}
			}
		});
		return this.currencyConfigCt
	},
	getMultipleRadioConfigCt: function() {
		var me = this,
			DTS = SCONST.validateDataType;
		this.multiRadio = Ext.create("EnterpriseSheet.sheet.pop.droplist.RadioListContainer", {
			sheet: this.sheet
		});
		this.multiRadioConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.multi_radio,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.multi_radio_type_hint
			}, this.multiRadio, {
				xtype: "checkbox",
				checked: false,
				boxLabel: SLANG.add_other_fill,
				anchor: "100%"
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_checkbox_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var otherOption = me.multiRadioConfigCt.items.get(2).getValue();
				var titleIcon = me.multiRadioConfigCt.items.get(3).getValue();
				var o = {
					dt: DTS.multi_radio,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "radio" : null,
					otherOption: otherOption
				};
				o.list = me.multiRadio.prepareParam();
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.multiRadioConfigCt.items.get(3).setValue(true)
				}
				if(cfg.otherOption) {
					me.multiRadioConfigCt.items.get(2).setValue(true)
				}
				me.multiRadio.setup(cfg)
			}
		});
		return this.multiRadioConfigCt
	},
	getRadioConfigCt: function() {
		var me = this;
		var DTS = SCONST.validateDataType;
		this.radioConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.radio,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.radio_type_hint
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_radio_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.radioConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.radio,
					itn: "radio-" + SCOM.genTimeStamp(),
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "radio" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.radioConfigCt.items.get(1).setValue(true)
				} else {
					me.radioConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.radioConfigCt
	},
	getAttachConfigCt: function() {
		var me = this;
		var DTS = SCONST.validateDataType;
		this.attachConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.attachment,
			layout: "anchor",
			items: [{
				xtype: "component",
				anchor: "100%",
				style: "padding-bottom:10px;",
				html: SLANG.attach_type_hint
			}, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_attach_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.attachConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.attachment,
					ignoreBlank: true,
					titleIcon: titleIcon == true ? "attach" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.attachConfigCt.items.get(1).setValue(true)
				} else {
					me.attachConfigCt.items.get(1).setValue(false)
				}
			}
		});
		return this.attachConfigCt
	},
	getPercentConfigCt: function() {
		var me = this;
		var DTS = SCONST.validateDataType;
		var percents = Ext.create("Ext.data.Store", {
			fields: ["name"],
			data: SCONST.percent_list
		});
		this.percentCombo = Ext.create("Ext.form.field.ComboBox", {
			fieldLabel: SLANG.percent,
			editable: false,
			store: percents,
			displayField: "name",
			valueField: "name",
			queryMode: "local",
			triggerAction: "all",
			width: 355,
			value: "0%",
			forceSelection: true
		});
		this.percentConfigCt = Ext.create("Ext.container.Container", {
			name: DTS.percent,
			layout: "anchor",
			items: [this.percentCombo, {
				xtype: "checkbox",
				checked: true,
				boxLabel: SLANG.add_perent_icon,
				anchor: "100%"
			}],
			getValues: function() {
				var titleIcon = me.percentConfigCt.items.get(1).getValue();
				var o = {
					dt: DTS.percent,
					format: me.percentCombo.getValue(),
					titleIcon: titleIcon == true ? "percent" : null
				};
				return o
			},
			setValues: function(cfg) {
				if(cfg.titleIcon) {
					me.percentConfigCt.items.get(1).setValue(true)
				} else {
					me.percentConfigCt.items.get(1).setValue(false)
				}
				if(cfg.format) {
					me.percentCombo.setValue(cfg.format)
				}
			}
		});
		return this.percentConfigCt
	},
	onSelectDataType: function() {
		var DTS = SCONST.validateDataType;
		var name = this.dataTypeCombo.getValue(),
			found;
		if(DTS.multi_options === name || DTS.single_select === name) {
			found = this.singleSelectConfigCt;
			if(DTS.single_select === name) {
				this.singleSelectConfigCt.items.get(0).update(SLANG.single_select_type_hint)
			} else {
				this.singleSelectConfigCt.items.get(0).update(SLANG.multi_options_type_hint)
			}
			if(!this.firstDropListFlag) {
				this.firstDropListFlag = true;
				this.dropListConfigCt.loadDropListStore()
			}
		} else {
			if(DTS.currency === name) {
				this.currencyCt.initCt(SCONFIG.default_currency)
			}
			this.cardCt.items.each(function(it) {
				if(it.name === name) {
					found = it;
					return false
				}
			}, this)
		}
		if(found) {
			this.cardCt.getLayout().setActiveItem(found)
		}
	},
	prepareParam: function() {
		var ct = this.cardCt.getLayout().getActiveItem();
		if(Ext.isFunction(ct.getValues)) {
			var o = ct.getValues();
			return o
		}
	}
});
Ext.define("EnterpriseSheet.sheet.pop.datatype.DataTypeConfigWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.sheet.pop.datatype.GeneralDataTypeContainer"],
	modal: true,
	closeAction: "hide",
	width: 600,
	height: 550,
	layout: "border",
	initComponent: function() {
		this.generalCt = Ext.create("EnterpriseSheet.sheet.pop.datatype.GeneralDataTypeContainer", {
			title: SLANG.select_general_column_data_type,
			padding: 20,
			sheet: this.sheet,
			dataTypeShowList: this.dataTypeShowList
		});
		this.titleField = Ext.create("Ext.form.field.Text", {
			fieldLabel: this.titleFieldLabel || SLANG.column_title,
			allowBlank: !this.titleFieldRequired,
			anchor: "100%"
		});
		this.tabCt = Ext.create("Ext.container.Container", {
			region: "center",
			plain: true,
			layout: "card",
			activeItem: 0,
			items: [this.generalCt]
		});
		this.tabbar = Ext.create("Ext.container.Container", {
			region: "north",
			layout: "hbox",
			cls: "ss-dt-tabbar",
			items: [{
				html: SLANG.select_general_column_data_type,
				xtype: "component",
				cls: "ss-dt-tab ss-dt-activetab",
				index: 0
			}]
		});
		this.items = [{
			xtype: "container",
			region: "north",
			layout: "anchor",
			padding: "10 20",
			items: [this.titleField]
		}, this.tabbar, this.tabCt];
		this.callParent(arguments);
		this.on("hide", function() {
			if(this.hideCallback && !this.disableHideCallback) {
				this.hideCallback.fn.call(this.hideCallback.scope)
			}
		}, this);
		this.generalCt.on({
			scope: this,
			minimode: this.onRangeMiniMode,
			normalmode: this.onRangeNormalMode
		})
	},
	isValid: function() {
		return this.titleField.isValid() && this.callParent()
	},
	popup: function(cfg) {
		this.show();
		var activeTab = 0,
			tab;
		if(cfg) {
			if(this.generalCt.setup(cfg, function(flag) {
					if(flag) {
						this.cleanBtn.show()
					} else {
						this.cleanBtn.hide()
					}
				}, this)) {}
		} else {
			this.cleanBtn.hide()
		}
	},
	reset: function() {
		this.callParent(arguments);
		this.generalCt.reset()
	},
	prepareParam: function() {
		var params;
		if(this.generalCt === this.tabCt.getLayout().activeItem) {
			params = this.generalCt.prepareParam()
		} else {
			params = this.templateCt.prepareParam()
		}
		var title = this.titleField.getValue();
		if(title) {
			params.title = title
		}
		return params
	},
	prepareButton: function() {
		this.cleanBtn = Ext.create("Ext.button.Button", {
			text: SLANG.clean_data_type,
			handler: this.cleanDataType,
			scope: this
		});
		this.buttons = [this.cleanBtn, "->", {
			text: this.okText,
			handler: this.onOK,
			scope: this
		}, {
			text: this.cancelText,
			handler: this.onCancel,
			scope: this
		}]
	},
	cleanDataType: function() {
		if(this.cleanCallback) {
			this.cleanCallback.fn.call(this.cleanCallback.scope)
		}
		this.hide()
	},
	onRangeMiniMode: function(miniWin, rangeField) {
		this.skipResetOnShow = true;
		this.disableHideCallback = true;
		this.hide()
	},
	onRangeNormalMode: function(miniWin, rangeField) {
		this.sheet.switchSheet(this.sheetId, function() {
			this.show();
			delete(this.skipResetOnShow);
			delete(this.disableHideCallback)
		}, this)
	}
});
Ext.define("EnterpriseSheet.sheet.pop.condition.MoreConditionWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.sheet.range.RangeField", "EnterpriseSheet.sheet.range.CalculateField", "Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 550,
	height: 180,
	initComponent: function() {
		this.typeField = Ext.create("Ext.form.field.ComboBox", {
			style: "margin-top:10px;",
			width: 517,
			fieldLabel: SLANG.type,
			allowBlank: false,
			name: "type",
			displayField: "text",
			valueField: "value",
			editable: false,
			value: "greaterEqual",
			store: Ext.create("Ext.data.Store", {
				fields: ["value", "text"],
				data: [{
					value: "greaterEqual",
					text: SLANG.greater_equal
				}, {
					value: "lessEqual",
					text: SLANG.less_equal
				}, {
					value: "notEqual",
					text: SLANG.not_equal
				}, {
					value: "notBetween",
					text: SLANG.not_between
				}, {
					value: "inXY",
					text: SLANG.in_x_y
				}, {
					value: "true",
					text: SLANG.is_true
				}]
			}),
			listeners: {
				change: function(combo, value) {
					this.showHideBtn(value)
				},
				scope: this
			},
			scope: this
		});
		this.rangeField = new EnterpriseSheet.sheet.range.CalculateField({
			sheet: this.sheet,
			flex: 1,
			value: this.value,
			allowBlank: false,
			listeners: {
				focus: {
					fn: function() {
						this.minField.quit();
						this.maxField.quit()
					},
					scope: this
				}
			}
		});
		this.minField = new EnterpriseSheet.sheet.range.CalculateField({
			hidden: true,
			sheet: this.sheet,
			flex: 1,
			value: this.min,
			allowBlank: false,
			listeners: {
				focus: {
					fn: function() {
						this.maxField.quit();
						this.rangeField.quit()
					},
					scope: this
				}
			}
		});
		this.maxField = new EnterpriseSheet.sheet.range.CalculateField({
			hidden: true,
			sheet: this.sheet,
			flex: 1,
			value: this.max,
			allowBlank: false,
			listeners: {
				focus: {
					fn: function() {
						this.minField.quit();
						this.rangeField.quit()
					},
					scope: this
				}
			}
		});
		this.toField = new Ext.form.Label({
			hidden: true,
			style: "padding:5px;",
			text: SLANG.to
		});
		this.styleField = new Ext.form.field.ComboBox({
			flex: 1.5,
			value: 1,
			store: SCOM.boolStyleStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all"
		});
		this.labelField = new Ext.form.Label({
			style: "margin-top:10px;",
			text: SLANG.chooseMoreCdt
		});
		this.items = [this.labelField, this.typeField, {
			xtype: "container",
			style: "padding-top:5px;",
			layout: {
				type: "hbox"
			},
			items: [this.rangeField, this.minField, this.toField, this.maxField, {
				xtype: "label",
				style: "padding:5px;",
				text: SLANG.set_as
			}, this.styleField]
		}];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
		this.mon(this.rangeField, {
			scope: this,
			minimode: function() {
				this.fieldVals = this.getFieldVals();
				this.hide()
			},
			normalmode: function() {
				this.show()
			}
		});
		this.mon(this.minField, {
			scope: this,
			minimode: function() {
				this.fieldVals = this.getFieldVals();
				this.hide()
			},
			normalmode: function() {
				this.show()
			}
		});
		this.mon(this.maxField, {
			scope: this,
			minimode: function() {
				this.fieldVals = this.getFieldVals();
				this.hide()
			},
			normalmode: function() {
				this.show()
			}
		})
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(this.fieldVals) {
			this.showHideBtn(this.fieldVals.type);
			this.setFieldVals(this.fieldVals)
		}
		this.rangeField.setValue("");
		this.rangeField.focus(null, 100);
		Ext.Function.defer(function() {
			if(sheet) {
				sheet.disableSelect();
				sheet.disableEdit()
			}
		}, 200)
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true)
		}
	},
	showHideBtn: function(value) {
		if(value == "notBetween" || value == "inXY") {
			this.minField.show();
			this.maxField.show();
			this.toField.show();
			this.rangeField.hide();
			if(value == "notBetween") {
				this.toField.setText(SLANG.to)
			} else {
				this.toField.setText(SLANG.or)
			}
		} else {
			this.minField.hide();
			this.maxField.hide();
			this.toField.hide();
			this.rangeField.show()
		}
	},
	updateConfig: function(config) {
		if(config.value) {
			this.rangeValue = config.value;
			this.rangeField.setValue(config.value)
		} else {
			delete(this.rangeValue);
			this.rangeField.reset()
		}
		if(config.label) {
			this.labelField.setText(config.label)
		}
		if(config.title) {
			this.setTitle(config.title)
		}
		Ext.apply(this, config)
	},
	prepareParam: function() {
		var type = this.typeField.getValue();
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find("id", id));
		if(type == "notBetween" || type == "inXY") {
			var base = {
				min: this.minField.getValue() || 0,
				max: this.maxField.getValue() || 0
			}
		} else {
			var base = this.rangeField.getCoord();
			base = this.rangeField.getValue() || 0
		}
		var type = this.typeField.getValue();
		var ret = {
			type: type,
			base: base,
			style: rd.data.style
		};
		return ret
	},
	getFieldVals: function() {
		var vals = {
			type: this.typeField.getValue(),
			style: this.styleField.getValue(),
			min: this.minField.getValue(),
			max: this.maxField.getValue(),
			range: this.rangeField.getValue()
		};
		return vals
	},
	setFieldVals: function(fieldVals) {
		this.typeField.setValue(fieldVals.type);
		this.styleField.setValue(fieldVals.style);
		this.minField.setValue(fieldVals.min);
		this.maxField.setValue(fieldVals.max);
		this.rangeField.setValue(fieldVals.range)
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.AverageWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 400,
	height: 140,
	initComponent: function() {
		this.styleField = new Ext.form.field.ComboBox({
			flex: 1.5,
			value: 1,
			store: SCOM.boolStyleStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all"
		});
		this.labelField = new Ext.form.Label({
			text: this.label
		});
		this.items = [this.labelField, {
			xtype: "container",
			style: "padding-top:5px;",
			layout: {
				type: "hbox"
			},
			items: [{
				xtype: "label",
				style: "padding:5px 25px 5px 5px;",
				text: SLANG.set_as
			}, this.styleField]
		}];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			sheet.disableSelect();
			sheet.disableEdit();
		}
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
		}
	},
	updateConfig: function(config) {
		if(config.label) {
			this.labelField.setText(config.label);
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	prepareParam: function() {
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find("id", id));
		return {
			style: rd.data.style
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.IconSetRuleWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.ComboBox", "EnterpriseSheet.common.IconField", "EnterpriseSheet.common.IconSetField"],
	modal: false,
	width: 640,
	height: 400,
	skipResetOnShow: true,
	bodyStyle: "padding: 20px 40px;background:white;",
	initComponent: function() {
		this.title = this.title || this.getStr("iconset_rule");
		var labelWidth = 80;
		this.defaults = {
			labelWidth: labelWidth
		};
		this.iconSetField = Ext.create("EnterpriseSheet.common.IconSetField", {
			allowBlank: true
		});
		this.reverseIconField = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.reverse_icon_set,
			style: "margin-top:20px;"
		});
		this.showIconOnlyField = Ext.create("Ext.form.field.Checkbox", {
			boxLabel: SLANG.show_icon_only,
			style: "margin-bottom:20px;"
		});
		var iconSet = this.iconSetField.getIconValue();
		this.items = [this.iconSetField, this.reverseIconField, this.showIconOnlyField].concat(this.generateLines(iconSet));
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
		this.iconSetField.on({
			scope: this,
			valuechange: this.onIconSetChange
		});
	},
	onIconSetChange: function(oldVal, val, iconSetField) {
		var count = this.items.getCount();
		var icons = val.icons,
			ilen = icons.length,
			setIndex = val.set;
		if(count - 3 === ilen) {
			for(var i = 0; i < ilen; i++) {
				var line = this.items.get(3 + i);
				var iconField = line.items.get(0);
				iconField.setValue({
					set: setIndex,
					idx: icons[i]
				}, true);
			}
		} else {
			var arr = [];
			for(var i = 3; i < count; i++) {
				arr.push(this.items.get(i));
			}
			for(var i = 0, len = arr.length; i < len; i++) {
				this.remove(arr[i]);
			}
			this.add(this.generateLines(val));
		}
		var line = this.items.get(3),
			valField = line.items.get(2);
		valField.focus(null, 100);
	},
	onIconChange: function() {
		this.iconSetField.setValue(undefined, true);
	},
	generateLines: function(iconSet) {
		var icons = iconSet.icons,
			setIndex = iconSet.set,
			level = iconSet.level,
			arr = [];
		var len = icons.length;
		for(var i = len - 1; i >= 0; i--) {
			arr.push(this.getIconLine(setIndex, icons[i], level));
		}
		var per = Math.round(100 / len);
		for(var i = 0; i < len; i++) {
			var it = arr[i];
			if(i === len - 1) {
				var display = it.items.get(1);
				display.setFieldLabel(SLANG.when_value_is + " < " + (100 - per * i));
			} else {
				var optField = it.items.get(1),
					unitField = it.items.get(3),
					valField = it.items.get(2);
				var val = 100 - per * (i + 1);
				if(0 !== i) {
					optField.setFieldLabel(SLANG.when_value_is + " < " + (100 - per * i) + " " + SLANG.and + " ");
				}
				unitField.setValue("percent");
				valField.setValue(val);
			}
		}
		return arr;
	},
	getIconLine: function(setIndex, iconIndex, level) {
		var iconField = Ext.create("EnterpriseSheet.common.IconField", {
			iconValue: {
				set: setIndex,
				idx: iconIndex
			},
			listeners: {
				valuechange: {
					fn: this.onIconChange,
					scope: this
				}
			}
		});
		var items = [];
		if(0 < iconIndex) {
			var optField = Ext.create("Ext.form.field.ComboBox", {
				style: "margin-left:20px;",
				width: 260,
				labelWidth: 200,
				fieldLabel: SLANG.when_value_is,
				labelSeparator: "",
				valueField: "value",
				displayField: "value",
				editable: false,
				value: ">=",
				store: new Ext.data.ArrayStore({
					fields: ["value"],
					data: [
						[">="],
						[">"]
					]
				})
			});
			var valField = Ext.create("EnterpriseSheet.sheet.range.RangeField", {
				style: "margin-left:20px;",
				width: 80,
				sheet: this.sheet,
				singleSelect: true,
				simpleSelect: true,
				allowBlank: false,
				listeners: {
					minimode: {
						scope: this,
						fn: function() {
							this.hide();
						}
					},
					normalmode: {
						scope: this,
						fn: function() {
							this.show();
						}
					},
					blur: {
						scope: this,
						fn: function(field) {
							var line = field.up("container[cls~=icon-rule-line]");
							if(line) {
								var index = this.items.indexOf(line);
								var nextLine = this.items.get(index + 1);
								if(nextLine) {
									var label = nextLine.items.get(1);
									var val = line.items.get(2).getValue();
									if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(val)) {
										val = SLANG.formula;
									}
									label.setFieldLabel(SLANG.when_value_is + " < " + val);
								}
							}
						}
					}
				}
			});
			var unitField = Ext.create("Ext.form.field.ComboBox", {
				style: "margin-left:10px;",
				width: 80,
				valueField: "value",
				displayField: "display",
				editable: false,
				value: "percent",
				store: new Ext.data.ArrayStore({
					fields: ["value", "display"],
					data: [
						["percent", SLANG.percent],
						["number", SLANG.number]
					]
				})
			});
			items = [iconField, optField, valField, unitField];
		} else {
			var display = Ext.create("Ext.form.field.Display", {
				width: 260,
				labelWidth: 200,
				style: "margin-left:20px;",
				labelSeparator: "",
				fieldLabel: SLANG.when_value_is
			});
			items = [iconField, display];
		}
		var ct = Ext.create("Ext.container.Container", {
			cls: "icon-rule-line",
			style: "margin-top:20px;",
			layout: {
				type: "hbox"
			},
			items: items
		});
		return ct;
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			sheet.disableSelect();
			sheet.disableEdit();
			sheet.enableRefer(true, true);
		}
	},
	popup: function() {
		this.show();
		var arr = [];
		for(var i = 3, len = this.items.getCount(); i < len; i++) {
			arr.push(this.items.get(i));
		}
		for(var i = 0, len = arr.length; i < len; i++) {
			this.remove(arr[i]);
		}
		this.iconSetField.setValue(this.iconSetField.iconSetStore.getAt(0).data, true);
		this.onIconSetChange(undefined, this.iconSetField.getIconValue(), this.iconSetField);
		var line = this.items.get(3),
			valField = line.items.get(2);
		valField.focus(null, 100);
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true);
		}
	},
	updateConfig: function(config) {
		Ext.apply(this, config);
	},
	prepareParam: function() {
		var iconSet = this.iconSetField.getIconValue();
		var reverse = this.reverseIconField.getValue(),
			showIconOnly = this.showIconOnlyField.getValue();
		var arr = [],
			count = this.items.getCount();
		for(var i = count - 2; i >= 3; i--) {
			var line = this.items.get(i);
			var val = line.items.get(2).getCoord();
			arr.push({
				v: val,
				c: ">" == line.items.get(1).getValue() ? "<=" : "<",
				u: line.items.get(3).getValue()
			});
		}
		if(!iconSet) {
			iconSet = [];
			for(var i = count - 1; i >= 3; i--) {
				var line = this.items.get(i);
				var val = line.items.get(0).getIconValue();
				iconSet.push(val);
			}
		}
		return {
			is: iconSet,
			rv: reverse,
			only: showIconOnly,
			ths: arr
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.BetweenWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.sheet.range.RangeField", "Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 550,
	height: 140,
	initComponent: function() {
		this.minField = new EnterpriseSheet.sheet.range.CalculateField({
			sheet: this.sheet,
			flex: 1,
			value: this.min,
			allowBlank: false,
			listeners: {
				focus: {
					fn: function() {
						this.maxField.quit();
					},
					scope: this
				}
			}
		});
		this.maxField = new EnterpriseSheet.sheet.range.CalculateField({
			sheet: this.sheet,
			flex: 1,
			value: this.max,
			allowBlank: false,
			listeners: {
				focus: {
					fn: function() {
						this.minField.quit();
					},
					scope: this
				}
			}
		});
		this.styleField = new Ext.form.field.ComboBox({
			flex: 1.5,
			value: 1,
			store: SCOM.boolStyleStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all"
		});
		this.labelField = new Ext.form.Label({
			text: this.label
		});
		this.items = [this.labelField, {
			xtype: "container",
			style: "padding-top:5px;",
			layout: {
				type: "hbox"
			},
			items: [this.minField, {
				xtype: "label",
				style: "padding:5px;",
				text: SLANG.to
			}, this.maxField, {
				xtype: "label",
				style: "padding:5px;",
				text: SLANG.set_as
			}, this.styleField]
		}];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
		this.mon(this.minField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: function() {
				this.show();
			}
		});
		this.mon(this.maxField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: function() {
				this.show();
			}
		});
	},
	_onShow: function() {
		var sheet = this.sheet;
		this.minField.focus(null, 100);
		if(this.minRangeValue) {
			this.minField.setValue(this.minRangeValue);
		}
		Ext.Function.defer(function() {
			if(sheet) {
				sheet.disableSelect();
				sheet.disableEdit();
			}
		}, 200);
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true);
		}
	},
	updateConfig: function(config) {
		if(config.min) {
			this.minRangeValue = config.min;
			this.minField.setValue(config.min);
		} else {
			delete this.minRangeValue;
			this.minField.reset();
		}
		if(config.max) {
			this.maxField.setValue(config.max);
		} else {
			this.maxField.reset();
		}
		if(config.label) {
			this.labelField.setText(config.label);
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	prepareParam: function() {
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find("id", id));
		var base = {
			min: this.minField.getValue() || 0,
			max: this.maxField.getValue() || 0
		};
		return {
			base: base,
			style: rd.data.style
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.BoolWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.sheet.range.RangeField", "Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 400,
	height: 140,
	initComponent: function() {
		this.rangeField = new EnterpriseSheet.sheet.range.CalculateField({
			sheet: this.sheet,
			flex: 1,
			value: this.value,
			allowBlank: false
		});
		this.styleField = new Ext.form.field.ComboBox({
			flex: 1.5,
			value: 1,
			store: SCOM.boolStyleStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all"
		});
		this.labelField = new Ext.form.Label({
			text: this.label
		});
		this.items = [this.labelField, {
			xtype: "container",
			style: "padding-top:5px;",
			layout: {
				type: "hbox"
			},
			items: [this.rangeField, {
				xtype: "label",
				style: "padding:5px;",
				text: SLANG.set_as
			}, this.styleField]
		}];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
		this.mon(this.rangeField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: function() {
				this.show();
			}
		});
	},
	_onShow: function() {
		var sheet = this.sheet;
		this.rangeField.focus(null, 100);
		Ext.Function.defer(function() {
			if(sheet) {
				sheet.disableSelect();
				sheet.disableEdit();
			}
		}, 200);
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true);
		}
	},
	updateConfig: function(config) {
		if(config.value) {
			this.rangeValue = config.value;
			this.rangeField.setValue(config.value);
		} else {
			delete this.rangeValue;
			this.rangeField.reset();
		}
		if(config.label) {
			this.labelField.setText(config.label);
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	prepareParam: function() {
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find("id", id));
		var base = this.rangeField.getValue() || 0;
		return {
			base: base,
			style: rd.data.style
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.DateWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.sheet.range.RangeField", "Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 400,
	height: 140,
	initComponent: function() {
		this.typeField = new Ext.form.field.ComboBox({
			store: SCOM.dateOptionStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all",
			value: 0
		});
		this.styleField = new Ext.form.field.ComboBox({
			flex: 1.5,
			value: 1,
			store: SCOM.boolStyleStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all"
		});
		this.labelField = new Ext.form.Label({
			text: this.label
		});
		this.items = [this.labelField, {
			xtype: "container",
			style: "padding-top:5px;",
			layout: {
				type: "hbox"
			},
			items: [this.typeField, {
				xtype: "label",
				style: "padding:5px;",
				text: SLANG.set_as
			}, this.styleField]
		}];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			sheet.disableSelect();
			sheet.disableEdit();
		}
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
		}
	},
	updateConfig: function(config) {
		if(config.value) {
			this.typeField.setValue(config.value);
		}
		if(config.label) {
			this.labelField.setText(config.label);
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	prepareParam: function() {
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find("id", id));
		return {
			base: this.typeField.getValue(),
			style: rd.data.style
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.PositionWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.Number", "Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 400,
	height: 140,
	setAsTxt: "Set as",
	initComponent: function() {
		this.posField = new Ext.form.field.Number({
			value: this.value || 10,
			minValue: this.minValue || 1,
			maxValue: this.maxValue
		});
		this.styleField = new Ext.form.field.ComboBox({
			flex: 1.5,
			value: 1,
			store: SCOM.boolStyleStore,
			listWidth: 200,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all"
		});
		this.labelField = new Ext.form.Label({
			text: this.label
		});
		this.setAsLabel = new Ext.form.Label({
			style: "padding:5px;",
			text: this.setAsTxt
		});
		this.items = [this.labelField, {
			xtype: "container",
			style: "padding-top:5px;",
			layout: {
				type: "hbox"
			},
			items: [this.posField, this.setAsLabel, this.styleField]
		}];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			sheet.disableSelect();
			sheet.disableEdit();
		}
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
		}
	},
	updateConfig: function(config) {
		if(config.value) {
			this.posField.setValue(config.value);
		}
		if(false != SCOM.typeOf(config.minValue)) {
			this.posField.minValue = config.minValue;
		}
		if(false != SCOM.typeOf(config.maxValue)) {
			this.posField.maxValue = config.maxValue;
		}
		if(config.setAsTxt) {
			this.setAsLabel.setText(config.setAsTxt);
		}
		if(config.label) {
			this.labelField.setText(config.label);
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	prepareParam: function() {
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find("id", id));
		return {
			base: this.posField.getValue(),
			style: rd.data.style
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.RangeWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["EnterpriseSheet.sheet.range.RangeField", "Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 400,
	height: 140,
	layout: "form",
	initComponent: function() {
		this.labelField = new Ext.form.Label({
			text: this.label
		});
		this.rangeField = new EnterpriseSheet.sheet.range.CalculateField({
			sheet: this.sheet,
			value: this.value,
			allowBlank: false,
			anchor: "100%"
		});
		this.items = [this.labelField, this.rangeField];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
		this.mon(this.rangeField, {
			scope: this,
			minimode: function() {
				this.hide();
			},
			normalmode: function() {
				this.show();
			}
		});
	},
	_onShow: function() {
		var sheet = this.sheet;
		this.rangeField.focus(null, 100);
		if(this.rangeValue) {
			this.rangeField.setValue(this.rangeValue);
		}
		Ext.Function.defer(function() {
			if(sheet) {
				sheet.disableSelect();
				sheet.disableEdit();
			}
		}, 200);
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true);
		}
	},
	updateConfig: function(config) {
		if(config.value) {
			this.rangeValue = config.value;
			this.rangeField.setValue(config.value);
		} else {
			delete this.rangeValue;
			this.rangeField.reset();
		}
		this.rangeField.simpleSelect = config.simpleSelect;
		if(config.label) {
			this.labelField.setText(config.label);
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	prepareParam: function() {
		return {
			base: this.rangeField.getValue() || 0
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.RepeatWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.form.field.ComboBox", "Ext.form.Label"],
	modal: false,
	width: 400,
	height: 140,
	initComponent: function() {
		this.typeField = new Ext.form.field.ComboBox({
			store: SCOM.repeatStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all",
			value: SCONST.REPEAT_VALUE
		});
		this.styleField = new Ext.form.field.ComboBox({
			flex: 1.5,
			value: 1,
			store: SCOM.boolStyleStore,
			valueField: "id",
			displayField: "text",
			typeAhead: true,
			mode: "local",
			triggerAction: "all"
		});
		this.labelField = new Ext.form.Label({
			text: this.label
		});
		this.items = [this.labelField, {
			xtype: "container",
			style: "padding-top:5px;",
			layout: {
				type: "hbox"
			},
			items: [this.typeField, {
				xtype: "label",
				style: "padding:5px;",
				text: SLANG.set_as
			}, this.styleField]
		}];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
	},
	_onShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			sheet.disableSelect();
			sheet.disableEdit();
		}
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
		}
	},
	updateConfig: function(config) {
		if(config.value) {
			this.typeField.setValue(config.value);
		}
		if(config.label) {
			this.labelField.setText(config.label);
		}
		if(config.title) {
			this.setTitle(config.title);
		}
		Ext.apply(this, config);
	},
	prepareParam: function() {
		var id = this.styleField.getValue();
		var store = this.styleField.store;
		var rd = store.getAt(store.find("id", id));
		return {
			base: this.typeField.getValue(),
			style: rd.data.style
		};
	}
});

Ext.define("EnterpriseSheet.sheet.pop.condition.ManageWin", {
	extend: "EnterpriseSheet.common.pop.PopWin",
	requires: ["Ext.grid.Panel", "EnterpriseSheet.sheet.range.RangeField", "EnterpriseSheet.sheet.model.ConditionModel"],
	modal: false,
	width: 700,
	height: 300,
	layout: "fit",
	resizable: true,
	initComponent: function() {
		this.title = this.title || this.getStr("condition_style_manager");
		this.conditionStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.ConditionModel"
		});
		this.optionStore = new Ext.data.Store({
			fields: [{
				name: "id",
				type: "int"
			}, "name"]
		});
		this.optionCombo = new Ext.form.ComboBox({
			store: this.optionStore,
			valueField: "id",
			displayField: "name",
			typeAhead: true,
			queryMode: "local",
			triggerAction: "all",
			selectOnFocus: true,
			forceSelection: true
		});
		this.upBtn = new Ext.button.Button({
			iconCls: "fa fa-chevron-up",
			disabled: true,
			handler: this.onMoveUp,
			scope: this
		});
		this.downBtn = new Ext.button.Button({
			iconCls: "fa fa-chevron-down",
			disabled: true,
			handler: this.onMoveDown,
			scope: this
		});
		this.deleteBtn = new Ext.button.Button({
			iconCls: "icon-delete",
			disabled: true,
			text: this.getStr("delete_condition_style"),
			handler: this.onDelete,
			scope: this
		});
		this.grid = new Ext.grid.Panel({
			columns: [{
				header: this.getStr("condition"),
				dataIndex: "name",
				sortable: false,
				flex: 1,
				renderer: Ext.Function.bind(function(v) {
					return this.getStr(v);
				}, this)
			}, {
				header: this.getStr("type"),
				dataIndex: "opt",
				sortable: false,
				flex: 1,
				renderer: Ext.Function.bind(function(value, metaData, record, rowIndex, colIndex, store) {
					var coordPro = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype;
					var name = record.data.name,
						html = "";
					if("boolstyle" === name) {
						var base = value.base,
							type = value.type;
						if(Ext.isString(base)) {
							html = base;
						} else if(Ext.isObject(base)) {
							if(base.min) {
								var min = Ext.isString(base.min) ? base.min : Ext.isObject(base.min) && base.min.span ? coordPro.coord2String(base.min) : "";
								var max = Ext.isString(base.max) ? base.max : Ext.isObject(base.max) && base.max.span ? coordPro.coord2String(base.max) : "";
								if("between" === type) {
									html = this.getStr("between") + " [" + min + ", " + max + "]";
								} else if("notBetween" === type) {
									html = this.getStr("not_between") + " [" + min + ", " + max + "]";
								} else if("inXY" === type) {
									html = this.getStr("in_xy") + " [" + min + ", " + max + "]";
								}
							} else if(base.span) {
								html = coordPro.coord2String([base]);
							}
						}
					}
					return html;
				}, this)
			}, {
				header: this.getStr("range"),
				dataIndex: "rng",
				sortable: false,
				flex: 2,
				tdCls: "ss-cdt-rng",
				renderer: Ext.Function.bind(function(value, metaData, record, rowIndex, colIndex, store) {
					var html = "=" + EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String(record.data.coord, undefined, true);
					return html;
				}, this)
			}],
			selType: "rowmodel",
			store: this.conditionStore,
			tbar: [{
				xtype: "label",
				text: this.getStr("show_condition_style_of") + " : ",
				style: "padding:5px;"
			}, this.optionCombo, "->", this.upBtn, this.downBtn, "-", this.deleteBtn]
		});
		this.items = [this.grid];
		this.callParent();
		this.on({
			scope: this,
			show: this._onShow
		});
		this.mon(this.optionCombo, {
			scope: this,
			select: this.setup
		});
		this.mon(this.grid.getSelectionModel(), {
			scope: this,
			selectionchange: this.onSelectionChange
		});
		this.mon(this.grid, {
			scope: this,
			itemclick: this.onGridItemClick
		});
	},
	onMoveDown: function() {
		var sheet = this.sheet,
			sheetStore = sheet.getStore(),
			sm = this.grid.getSelectionModel(),
			store = this.grid.getStore(),
			sheetId = sheetStore.getActivedSheetId(),
			sep = sheetStore.separateChar;
		var sels = sm.getSelection();
		if(0 < sels.length) {
			var index = store.indexOf(sels[0]);
			store.remove(sels);
			store.insert(index + 1, sels);
			var cdtPriority = this.cachedCdtPriority;
			var cid = sels[0].data.id + sep + sheetId;
			var index = false;
			for(var i = 0, len = cdtPriority.length; i < len; i++) {
				var it = cdtPriority[i];
				if(it.id === cid) {
					index = i;
					break;
				}
			}
			if(Ext.isNumber(index)) {
				var it = cdtPriority[index];
				cdtPriority.splice(index, 1);
				cdtPriority.splice(index + 1, 0, it);
			}
			var lookup = {};
			for(var i = 0, len = cdtPriority.length; i < len; i++) {
				var it = cdtPriority[i];
				lookup[it.cdtId] = i + 1;
			}
			this.changedCdtPriority = lookup;
			sm.select(sels[0]);
		}
	},
	onMoveUp: function() {
		var sheet = this.sheet,
			sheetStore = sheet.getStore(),
			sm = this.grid.getSelectionModel(),
			store = this.grid.getStore(),
			sheetId = sheetStore.getActivedSheetId(),
			sep = sheetStore.separateChar;
		var sels = sm.getSelection();
		if(0 < sels.length) {
			var index = store.indexOf(sels[0]);
			store.remove(sels);
			store.insert(index - 1, sels);
			var cdtPriority = this.cachedCdtPriority;
			var cid = sels[0].data.id + sep + sheetId;
			var index = false;
			for(var i = 0, len = cdtPriority.length; i < len; i++) {
				var it = cdtPriority[i];
				if(it.id === cid) {
					index = i;
					break;
				}
			}
			if(Ext.isNumber(index)) {
				var it = cdtPriority[index];
				cdtPriority.splice(index, 1);
				cdtPriority.splice(index - 1, 0, it);
			}
			var lookup = {};
			for(var i = 0, len = cdtPriority.length; i < len; i++) {
				var it = cdtPriority[i];
				lookup[it.cdtId] = i + 1;
			}
			this.changedCdtPriority = lookup;
			sm.select(sels[0]);
		}
	},
	onSelectionChange: function(sm) {
		var sels = sm.getSelection();
		if(0 < sels.length) {
			this.deleteBtn.enable();
			var index = this.conditionStore.indexOf(sels[0]);
			if(0 < index) {
				this.upBtn.enable();
			} else {
				this.upBtn.disable();
			}
			if(index < this.conditionStore.getCount() - 1) {
				this.downBtn.enable();
			} else {
				this.downBtn.disable();
			}
		} else {
			this.deleteBtn.disable();
			this.upBtn.disable();
			this.downBtn.disable();
		}
	},
	_onShow: function() {
		if(this.sheet) {
			var sheets = this.sheet.getStore().getSheets();
			this.optionStore.removeAll();
			this.optionStore.add({
				id: -1,
				name: this.getStr("selection_range")
			});
			for(var i = 0, len = sheets.length; i < len; i++) {
				this.optionStore.add({
					id: sheets[i].id,
					name: sheets[i].name
				});
			}
			this.optionCombo.setValue(-1);
			this.sheet.disableSelect();
			this.sheet.disableEdit();
			this.sheet.enableRefer(true, false);
		}
		this.setup();
	},
	quit: function() {
		this.callParent(arguments);
		var sheet = this.sheet;
		if(sheet) {
			sheet.enableSelect();
			sheet.enableEdit();
			sheet.disableRefer(true);
		}
	},
	setup: function() {
		var sheet = this.sheet;
		if(sheet) {
			var curSheetId = sheet.getSheetId();
			var store = sheet.getStore();
			this.cachedCdtPriority = store.getCdtPriority(curSheetId);
			var opt = this.optionCombo.getValue();
			var conditions = {};
			var fn = function(rd) {
				var cdt = sheet.getConditionOfCell(rd.data.sheet, rd.data.row, rd.data.col);
				if(0 < cdt.length) {
					for(var i = 0, len = cdt.length; i < len; i++) {
						var c = cdt[i];
						if(!conditions[c.id]) {
							c = SCOM.copy(c);
							c.sheet = rd.data.sheet;
							c.coord = [];
							for(var k = 0, count = c.rng.length; k < count; k++) {
								var piece = c.rng[k];
								var span = piece.span || piece.SPAN,
									type = piece.type || piece.TYPE;
								c.rng[k] = span;
								var sheetId;
								if(span && !SCOM.nullOrUndefined(span[0]) && "" !== span[0]) {
									sheetId = span[0];
								} else {
									sheetId = curSheetId;
								}
								var sheetName = store.getSheetNameById(sheetId);
								c.coord.push({
									span: [sheetName, span[1], span[2], span[3], span[4]],
									type: SCONST.ABSOLUTE_COORD
								});
							}
							conditions[c.id] = c;
						}
					}
				}
			};
			if(-1 == opt) {
				sheet.walkSelection(fn, this);
			} else {
				store.walkWhole(opt, fn, this);
			}
			this.conditionStore.removeAll(true);
			this.grid.getView().refresh();
			var cdtPriority = store.getCdtPriority();
			for(var i = 0, len = cdtPriority.length; i < len; i++) {
				var it = cdtPriority[i],
					id = it.id,
					cdtId = it.cdtId;
				if(conditions.hasOwnProperty(cdtId)) {
					var obj = SCOM.copy(conditions[cdtId]);
					this.conditionStore.add(obj);
				}
			}
			this.conditions = conditions;
			this.changedCdts = {};
		}
	},
	prepareButton: function() {
		this.applyBtn = new Ext.Button({
			text: this.getStr("apply"),
			handler: this.onApply,
			scope: this
		});
		this.buttons = [{
			text: this.getStr("ok"),
			handler: this.onOK,
			scope: this
		}, {
			text: this.getStr("close"),
			handler: this.onCancel,
			scope: this
		}, this.applyBtn];
	},
	updateConfig: function(config) {},
	onDelete: function() {
		var sm = this.grid.getSelectionModel(),
			store = this.grid.getStore();
		var sels = sm.getSelection();
		if(0 < sels.length) {
			for(var i = 0, len = sels.length; i < len; i++) {
				var rd = sels[i];
				this.changedCdts[rd.data.id] = "deleted";
				store.remove(rd);
			}
		}
	},
	onOK: function() {
		this.onApply();
		this.hide();
	},
	onApply: function() {
		var me = this;
		var sheet = this.sheet,
			store = sheet.getStore(),
			sheetId = sheet.getSheetId();
		var cdtStore = this.conditionStore;
		if(sheet) {
			var posCdtCache = {};
			for(var p in this.changedCdts) {
				if(this.changedCdts.hasOwnProperty(p)) {
					if("deleted" !== this.changedCdts[p]) {
						var rd = cdtStore.getById(p);
						if(rd) {
							posCdtCache[p] = rd.data;
						}
					} else {
						if(this.changedCdtPriority) {
							delete this.changedCdtPriority[p];
						}
					}
				}
			}
			var flag = false;
			if(this.changedCdtPriority) {
				for(var p in this.cachedCdtPriority) {
					if(this.cachedCdtPriority.hasOwnProperty(p)) {
						if(this.cachedCdtPriority[p] !== this.changedCdtPriority[p]) {
							flag = true;
							break;
						}
					}
				}
				if(flag) {
					store.setCell(sheetId, 0, 0, {
						cdtPriority: Ext.encode(this.changedCdtPriority)
					}, undefined, true);
					store.getCdtPriority(sheetId, true);
				}
			}
			if(!SCOM.isEmptyObj(this.changedCdts)) {
				sheet.changeConditions(this.changedCdts, this.conditions, posCdtCache);
			} else if(flag) {
				sheet.refresh();
			}
		}
	},
	onGridItemClick: function(grid, rec, item, index, e) {
		var target = e.getTarget(".ss-cdt-rng");
		if(target) {
			var store = this.sheet.getStore();
			var miniBox = EnterpriseSheet.sheet.range.RangeField.prototype.getMiniRangeBox(this.sheet, this);
			var miniRangeField = miniBox.getRangeField();
			miniRangeField.setValue(rec.data.rng);
			this.hide();
			miniBox.show();
			this.on("normalmode", function() {
				var coord = miniRangeField.getCoord();
				var rng = [];
				for(var i = 0, len = coord.length; i < len; i++) {
					var span = coord[i].span;
					rng.push([].concat(span));
					span[0] = store.getSheetNameById(span[0]);
				}
				rec.set({
					rng: rng,
					coord: coord
				});
				this.changedCdts[rec.data.id] = "update";
				grid.getStore().commitChanges();
				this.un({
					scope: this,
					show: this._onShow
				});
				this.show();
				this.on({
					scope: this,
					show: this._onShow
				});
			}, this, {
				single: true
			});
		}
	}
});

Ext.define("EnterpriseSheet.sheet.pop.Popup", {
	requires: ["EnterpriseSheet.sheet.pop.CellOptionWin", "EnterpriseSheet.sheet.pop.CopiedCellOptionWin", "EnterpriseSheet.sheet.pop.SortOptionWin", "EnterpriseSheet.sheet.pop.SizeWin", "EnterpriseSheet.sheet.pop.LinkWin", "EnterpriseSheet.sheet.pop.condition.AverageWin", "EnterpriseSheet.sheet.pop.condition.BetweenWin", "EnterpriseSheet.sheet.pop.condition.BoolWin", "EnterpriseSheet.sheet.pop.condition.DateWin", "EnterpriseSheet.sheet.pop.condition.ManageWin", "EnterpriseSheet.sheet.pop.condition.PositionWin", "EnterpriseSheet.sheet.pop.condition.RepeatWin", "EnterpriseSheet.sheet.pop.condition.RangeWin", "EnterpriseSheet.sheet.pop.condition.MoreConditionWin", "EnterpriseSheet.sheet.pop.ChartSettingWin", "EnterpriseSheet.sheet.pop.CommentWin", "EnterpriseSheet.sheet.pop.TextWin", "EnterpriseSheet.sheet.pop.ReferenceNameWin", "EnterpriseSheet.sheet.pop.droplist.DropListConfigWin", "EnterpriseSheet.sheet.pop.ValidationWin"],
	constructor: function() {
		this.callParent(arguments);
	},
	showRowHeightBox: function(config) {
		var win = this.getSizeWin(Ext.apply({
			invalidMsg: SLANG.positive_number,
			fieldLabel: SLANG.row_height,
			title: SLANG.row_height,
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}, config));
		win.show();
	},
	showColumnWidthBox: function(config) {
		var win = this.getSizeWin(Ext.apply({
			invalidMsg: SLANG.positive_number,
			fieldLabel: SLANG.column_width,
			title: SLANG.column_width,
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}, config));
		win.show();
	},
	showLinkBox: function(config) {
		var win = this.getLinkWin(Ext.apply({
			invalidMsg: SLANG.invalid_url,
			fieldLabel: SLANG.hyperlink,
			title: SLANG.hyperlink,
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}, config));
		win.show();
	},
	showCommentBox: function(config) {
		var win = this.getCommentWin(Ext.apply({}, config));
		win.show();
	},
	showTextBox: function(config) {
		var win = this.getTextWin(Ext.apply({}, config));
		win.show();
	},
	showVarTextBox: function(config) {
		var win = this.getVarTextWin(Ext.apply({
			filedVtype: "varname"
		}, config));
		win.show();
	},
	showReferenceNameBox: function(config) {
		var win = this.getReferenceNameWin(Ext.apply({}, config));
		win.show();
	},
	showValidationBox: function(config) {
		var win = this.getValidationWin(Ext.apply({}, config));
		win.popup();
	},
	showInsertCellOption: function(config) {
		var win = this.getCellOptionWin(Ext.apply(config, {
			title: SLANG.insert_option,
			boxLabel1: SLANG.move_current_cell_bottom,
			boxLabel2: SLANG.move_current_cell_right,
			boxLabel3: SLANG.insert_whole_row,
			boxLabel4: SLANG.insert_whole_column,
			box1Disabled: false,
			box2Disabled: false,
			box3Disabled: false,
			box4Disabled: false,
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showRemoveCellOption: function(config) {
		var win = this.getCellOptionWin(Ext.apply(config, {
			title: SLANG.remove_option,
			boxLabel1: SLANG.bottom_side_cell_move_top,
			boxLabel2: SLANG.right_side_cell_move_left,
			boxLabel3: SLANG.remove_whole_row,
			boxLabel4: SLANG.remove_whole_column,
			box1Disabled: false,
			box2Disabled: false,
			box3Disabled: false,
			box4Disabled: false,
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showInsertCopiedCellOption: function(config) {
		var win = this.getCopiedCellOptionWin(Ext.apply(config, {
			title: SLANG.insert_copied_option,
			boxLabel1: SLANG.move_current_cell_bottom,
			boxLabel2: SLANG.move_current_cell_right,
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showSortColumnOption: function(config) {
		var win = this.getSortOptionWin(Ext.apply(config, {
			title: SLANG.sort_option,
			boxLabel1: SLANG.expand_whole_row,
			boxLabel2: SLANG.only_current_range,
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionBool: function(config) {
		var win = this.getConditionBoolWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionRange: function(config) {
		var win = this.getConditionRangeWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionBetween: function(config) {
		var win = this.getConditionBetweenWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionMore: function(config) {
		var win = this.getConditionMoreWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionRepeat: function(config) {
		var win = this.getConditionRepeatWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionAverage: function(config) {
		var win = this.getConditionAverageWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionPosition: function(config) {
		var win = this.getConditionPositionWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionDate: function(config) {
		var win = this.getConditionDateWin(Ext.apply(config, {
			okText: SLANG.ok,
			cancelText: SLANG.cancel
		}));
		win.show();
	},
	showConditionManage: function(config) {
		var win = this.getConditionManageWin(config);
		win.show();
	},
	showDropListConfig: function(config) {
		var win = this.getDropListConfigWin(config);
		win.show();
	},
	getCellOptionWin: function(config) {
		if(!this.cellOptionWin) {
			this.cellOptionWin = new EnterpriseSheet.sheet.pop.CellOptionWin(config);
			this.cellOptionWin.on("destroy", function() {
				delete this.cellOptionWin;
			}, this);
		} else {
			this.cellOptionWin.updateConfig(config);
		}
		return this.cellOptionWin;
	},
	getCopiedCellOptionWin: function(config) {
		if(!this.copiedCellOptionWin) {
			this.copiedCellOptionWin = new EnterpriseSheet.sheet.pop.CopiedCellOptionWin(config);
			this.copiedCellOptionWin.on("destroy", function() {
				delete this.copiedCellOptionWin;
			}, this);
		} else {
			this.copiedCellOptionWin.updateConfig(config);
		}
		return this.copiedCellOptionWin;
	},
	getSortOptionWin: function(config) {
		if(!this.sortOptionWin) {
			this.sortOptionWin = new EnterpriseSheet.sheet.pop.SortOptionWin(config);
			this.sortOptionWin.on("destroy", function() {
				delete this.sortOptionWin;
			}, this);
		} else {
			this.sortOptionWin.updateConfig(config);
		}
		return this.sortOptionWin;
	},
	getSizeWin: function(config) {
		if(!this.sizeWin) {
			this.sizeWin = new EnterpriseSheet.sheet.pop.SizeWin(config);
			this.sizeWin.on("destroy", function() {
				delete this.sizeWin;
			}, this);
		} else {
			this.sizeWin.updateConfig(config);
		}
		return this.sizeWin;
	},
	getLinkWin: function(config) {
		if(!this.linkWin) {
			this.linkWin = new EnterpriseSheet.sheet.pop.LinkWin(config);
			this.linkWin.on("destroy", function() {
				delete this.linkWin;
			}, this);
		} else {
			this.linkWin.updateConfig(config);
		}
		return this.linkWin;
	},
	getConditionBoolWin: function(config) {
		if(!this.conditionBoolWin) {
			this.conditionBoolWin = new EnterpriseSheet.sheet.pop.condition.BoolWin(config);
		} else {
			this.conditionBoolWin.updateConfig(config);
		}
		return this.conditionBoolWin;
	},
	getConditionRangeWin: function(config) {
		if(!this.conditionRangeWin) {
			this.conditionRangeWin = new EnterpriseSheet.sheet.pop.condition.RangeWin(config);
		} else {
			this.conditionRangeWin.updateConfig(config);
		}
		return this.conditionRangeWin;
	},
	getConditionBetweenWin: function(config) {
		if(!this.conditionBetweenWin) {
			this.conditionBetweenWin = new EnterpriseSheet.sheet.pop.condition.BetweenWin(config);
		} else {
			this.conditionBetweenWin.updateConfig(config);
		}
		return this.conditionBetweenWin;
	},
	getConditionMoreWin: function(config) {
		if(!this.conditionMoreWin) {
			this.conditionMoreWin = new EnterpriseSheet.sheet.pop.condition.MoreConditionWin(config);
		} else {
			this.conditionMoreWin.updateConfig(config);
		}
		return this.conditionMoreWin;
	},
	getConditionRepeatWin: function(config) {
		if(!this.conditionRepeatWin) {
			this.conditionRepeatWin = new EnterpriseSheet.sheet.pop.condition.RepeatWin(config);
		} else {
			this.conditionRepeatWin.updateConfig(config);
		}
		return this.conditionRepeatWin;
	},
	getConditionDateWin: function(config) {
		if(!this.conditionDateWin) {
			this.conditionDateWin = new EnterpriseSheet.sheet.pop.condition.DateWin(config);
		} else {
			this.conditionDateWin.updateConfig(config);
		}
		return this.conditionDateWin;
	},
	getConditionAverageWin: function(config) {
		if(!this.conditionAverageWin) {
			this.conditionAverageWin = new EnterpriseSheet.sheet.pop.condition.AverageWin(config);
		} else {
			this.conditionAverageWin.updateConfig(config);
		}
		return this.conditionAverageWin;
	},
	getConditionPositionWin: function(config) {
		if(!this.conditionPositionWin) {
			this.conditionPositionWin = new EnterpriseSheet.sheet.pop.condition.PositionWin(config);
		} else {
			this.conditionPositionWin.updateConfig(config);
		}
		return this.conditionPositionWin;
	},
	getConditionManageWin: function(config) {
		if(!this.conditionManageWin) {
			this.conditionManageWin = new EnterpriseSheet.sheet.pop.condition.ManageWin(config);
		} else {
			this.conditionManageWin.updateConfig(config);
		}
		return this.conditionManageWin;
	},
	getChartSettingWin: function(config) {
		if(!this.charSettingWin) {
			this.charSettingWin = new EnterpriseSheet.sheet.pop.ChartSettingWin(config);
		} else {
			this.charSettingWin.updateConfig(config);
		}
		return this.charSettingWin;
	},
	getCommentWin: function(config) {
		if(!this.commentWin) {
			this.commentWin = new EnterpriseSheet.sheet.pop.CommentWin(config);
		} else {
			this.commentWin.updateConfig(config);
		}
		return this.commentWin;
	},
	getTextWin: function(config) {
		if(!this.textWin) {
			this.textWin = new EnterpriseSheet.sheet.pop.TextWin(config);
		} else {
			this.textWin.updateConfig(config);
		}
		return this.textWin;
	},
	getVarTextWin: function(config) {
		if(!this.varTextWin) {
			this.varTextWin = new EnterpriseSheet.sheet.pop.TextWin(config);
		} else {
			this.varTextWin.updateConfig(config);
		}
		return this.varTextWin;
	},
	getReferenceNameWin: function(config) {
		if(!this.refNameWin) {
			this.refNameWin = new EnterpriseSheet.sheet.pop.ReferenceNameWin(config);
		} else {
			this.refNameWin.updateConfig(config);
		}
		return this.refNameWin;
	},
	getValidationWin: function(config) {
		if(!this.validationWin) {
			this.validationWin = new EnterpriseSheet.sheet.pop.ValidationWin(config);
		} else {
			this.validationWin.updateConfig(config);
		}
		return this.validationWin;
	},
	getDropListConfigWin: function(config) {
		if(!this.dropListConfigWin) {
			this.dropListConfigWin = new EnterpriseSheet.sheet.pop.droplist.DropListConfigWin(config);
		} else {
			this.dropListConfigWin.updateConfig(config);
		}
		return this.dropListConfigWin;
	}
}, function() {
	SPOP = new EnterpriseSheet.sheet.pop.Popup;
});

Ext.define("EnterpriseSheet.sheet.action.HotKey", {
	extend: "Ext.util.Observable",
	constructor: function() {
		this.callParent(arguments);
		Ext.getDoc().on("keydown", this.onKeyDown, this);
	},
	onKeyDown: function(e) {
		var ctrl = e.ctrlKey ? 1 : 0,
			alt = e.altKey ? 1 : 0,
			shift = e.shiftKey ? 1 : 0;
		var key = e.getKey();
		var id = [key, ctrl, alt, shift].join("-");
		this.lookup = this.lookup || {};
		var lookup = this.lookup;
		var found = lookup[id];
		if(found) {
			found.callback.call(found.scope, e);
			e.stopEvent();
			return false;
		}
		if(ctrl || alt || found) {
			return false;
		}
	},
	bindHotKey: function(key, ctrl, alt, shift, callback, scope) {
		ctrl = ctrl ? 1 : 0;
		alt = alt ? 1 : 0;
		shift = shift ? 1 : 0;
		var id = [key, ctrl, alt, shift].join("-");
		this.lookup = this.lookup || {};
		this.lookup[id] = {
			key: key,
			ctrl: ctrl,
			alt: alt,
			shift: shift,
			callback: callback,
			scope: scope
		};
	}
}, function() {
	PHKey = (function() {
		var hkey = new EnterpriseSheet.sheet.action.HotKey;
		return {
			bindHotKey: function(key, ctrl, alt, shift, callback, scope) {
				return hkey.bindHotKey(key, ctrl, alt, shift, callback, scope);
			}
		};
	})();
});

Ext.define("EnterpriseSheet.pop.OpenFileWin", {
	extend: "Ext.window.Window",
	requires: ["Ext.form.field.Text", "Ext.layout.container.Form", "EnterpriseSheet.model.FileModel"],
	cls: "ss-popup-win",
	bodyStyle: "background-color:white;",
	title: SLANG.open_sheet,
	plain: true,
	modal: true,
	resizable: false,
	shim: true,
	closeAction: "hide",
	layout: "fit",
	buttonAlign: "right",
	initComponent: function() {
		this.fileStore = Ext.create("Ext.data.Store", {
			pageSize: 50,
			model: EnterpriseSheet.model.FileModel,
			remoteSort: true,
			proxy: {
				type: "ajax",
				url: SCONFIG.urls.listOpen,
				reader: {
					root: "results",
					totalProperty: "totalCount"
				}
			}
		});
		this.queryField = Ext.create("Ext.form.field.Text", {
			width: 300,
			enableKeyEvents: true,
			listeners: {
				keydown: {
					fn: this.onQueryKeyDown,
					scope: this
				}
			}
		});
		this.fileGrid = Ext.create("Ext.grid.Panel", {
			store: this.fileStore,
			loadMask: true,
			border: false,
			columns: [{
				width: 56,
				dataIndex: "exname",
				menuDisabled: true,
				resizable: false,
				draggable: false,
				renderer: this.renderIcon
			}, {
				text: SLANG.file_name,
				dataIndex: "name",
				flex: 1,
				sortable: true
			}, {
				text: SLANG.update_date,
				dataIndex: "updateDate",
				style: "border-right:none;",
				minWidth: 150,
				maxWidth: 250,
				menuDisabled: true,
				resizable: false,
				draggable: false
			}],
			dockedItems: [{
				dock: "top",
				xtype: "toolbar",
				style: "padding-left:10px;background:white;",
				height: 36,
				layout: {
					type: "hbox",
					align: "middle"
				},
				items: [this.queryField, {
					style: "margin-left:2px;",
					text: SLANG.search,
					handler: this.onSearchFn,
					scope: this
				}]
			}],
			bbar: Ext.create("Ext.PagingToolbar", {
				store: this.fileStore,
				displayInfo: true,
				displayMsg: "Displaying items {0} - {1} of {2}",
				emptyMsg: "No items to display"
			})
		});
		this.fileStore.load();
		this.openBtn = Ext.create("Ext.button.Button", {
			disabled: true,
			text: SLANG.open,
			handler: this.onOpenFn,
			scope: this
		});
		this.items = [this.fileGrid];
		this.buttons = [this.openBtn];
		this.callParent(arguments);
		this.on({
			scope: this,
			hide: this.onHideFn
		});
		this.fileGrid.on({
			scope: this,
			itemclick: this.onRowSelectFn,
			itemdblclick: this.onRowDblClickFn
		})
	},
	renderIcon: function(val, meta, rec, rowIndex, colIndex, store, view) {
		var result = '<img src="' + SCONFIG.IMAGES_PATH + '/icons/open.png"></img>';
		if(rec.data.exname == "xls") {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_darkgreen.png"></img>'
		} else {
			if(rec.data.exname == "xlt") {
				result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_tpl.png"></img>'
			}
		}
		return result
	},
	onHideFn: function() {
		if(this.hideCallback) {
			this.hideCallback.call(this.scope, this)
		}
	},
	setTitle: function(title) {
		this.titleBox.update(title)
	},
	popup: function(config) {
		if(config) {
			Ext.apply(this, config)
		}
		this.show()
	},
	onOpenFn: function() {
		var sels = this.fileGrid.getSelectionModel().getSelection();
		this.hide();
		if(this.callback) {
			this.callback.call(this.scope, sels[0].data.id)
		}
	},
	onCancelFn: function() {
		this.hide()
	},
	onRowSelectFn: function(list, rec, item, index, e) {
		var selectedId = rec.data.id;
		var exname = rec.data.exname;
		if(exname == "xls" || exname == "xlt") {
			this.openBtn.enable()
		} else {
			this.openBtn.disable()
		}
	},
	onRowDblClickFn: function(list, rec, item, index, e) {
		var selectedId = rec.data.id;
		var exname = rec.data.exname;
		if(exname == "xls" || exname == "xlt") {
			this.hide();
			if(this.callback) {
				this.callback.call(this.scope, selectedId)
			}
		}
	},
	onQueryKeyDown: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER === key) {
			this.onSearchFn()
		} else {
			if(keyObj.ESC === key) {
				if("" !== this.queryField.getValue()) {
					this.queryField.setValue("");
					this.onSearchFn()
				}
			}
		}
	},
	onSearchFn: function() {
		var query = this.queryField.getValue();
		this.fileStore.load({
			params: {
				query: query
			}
		})
	}
}, function() {
	SOPEN = (function() {
		var win;
		return {
			popup: function(config) {
				if(!win) {
					win = new EnterpriseSheet.pop.OpenFileWin({
						width: 550,
						height: 400
					})
				}
				Ext.apply(win, config);
				win.popup()
			}
		}
	})()
});
Ext.define("EnterpriseSheet.pop.SaveFileWin", {
	extend: "Ext.window.Window",
	requires: ["Ext.form.field.Text", "Ext.layout.container.Form"],
	cls: "ss-popup-win",
	bodyStyle: "background-color:white;",
	title: SLANG.save_sheet_as,
	plain: true,
	modal: true,
	resizable: false,
	shim: true,
	closeAction: "hide",
	layout: "fit",
	buttonAlign: "right",
	initComponent: function() {
		this.fileStore = Ext.create("Ext.data.Store", {
			pageSize: 50,
			model: EnterpriseSheet.model.FileModel,
			remoteSort: true,
			proxy: {
				type: "ajax",
				url: SCONFIG.urls.list + "?exname=xls",
				reader: {
					root: "results",
					totalProperty: "totalCount"
				}
			}
		});
		this.saveBtn = Ext.create("Ext.button.Button", {
			text: SLANG.save,
			style: "margin-left:10px;",
			minWidth: 65,
			handler: this.onSaveFn,
			scope: this
		});
		this.fileNameField = Ext.create("Ext.form.field.Text", {
			flex: 1,
			labelWidth: 60,
			fieldLabel: SLANG.file_name,
			allowBlank: false
		});
		this.exnameField = Ext.create("Ext.form.ComboBox", {
			flex: 1,
			labelWidth: 60,
			fieldLabel: SLANG.save_as,
			queryMode: "local",
			displayField: "name",
			valueField: "name",
			value: "xls",
			allowBlank: false,
			store: Ext.create("Ext.data.Store", {
				fields: ["name"],
				data: [{
					name: "xls"
				}, {
					name: "xlt"
				}]
			})
		});
		this.fileGrid = Ext.create("Ext.grid.Panel", {
			store: this.fileStore,
			loadMask: true,
			border: false,
			columns: [{
				width: 56,
				dataIndex: "exname",
				menuDisabled: true,
				resizable: false,
				draggable: false,
				renderer: this.renderIcon
			}, {
				text: SLANG.file_name,
				dataIndex: "name",
				flex: 1,
				sortable: true
			}, {
				text: SLANG.update_date,
				dataIndex: "updateDate",
				style: "border-right:none;",
				minWidth: 150,
				maxWidth: 250,
				menuDisabled: true,
				resizable: false,
				draggable: false
			}],
			dockedItems: [{
				dock: "top",
				xtype: "container",
				style: "padding:0px 30px;background:white;",
				height: 36,
				layout: {
					type: "hbox",
					align: "bottom"
				},
				items: [this.fileNameField, this.saveBtn]
			}, {
				dock: "top",
				xtype: "container",
				style: "padding:0px 105px 10px 30px;background:white;",
				height: 50,
				layout: {
					type: "hbox",
					align: "middle"
				},
				items: [this.exnameField]
			}],
			bbar: Ext.create("Ext.PagingToolbar", {
				store: this.fileStore,
				displayInfo: true,
				displayMsg: "Displaying items {0} - {1} of {2}",
				emptyMsg: "No items to display"
			})
		});
		this.fileStore.load();
		this.items = [this.fileGrid];
		this.callParent(arguments);
		this.on({
			scope: this,
			hide: this.onHideFn
		});
		this.fileGrid.on({
			scope: this,
			itemclick: this.onRowSelectFn,
			itemdblclick: this.onRowDblClickFn
		})
	},
	renderIcon: function(val, meta, rec, rowIndex, colIndex, store, view) {
		var result = '<img src="' + SCONFIG.IMAGES_PATH + '/icons/open.png"></img>';
		if(rec.data.exname == "xls") {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_darkgreen.png"></img>'
		} else {
			if(rec.data.exname == "xlt") {
				result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_tpl.png"></img>'
			}
		}
		return result
	},
	onHideFn: function() {
		if(this.hideCallback) {
			this.hideCallback.call(this.scope, this)
		}
	},
	setTitle: function(title) {
		this.titleBox.update(title)
	},
	popup: function(config) {
		if(config) {
			Ext.apply(this, config)
		}
		this.show()
	},
	onSaveFn: function() {
		var sels = this.fileGrid.getSelectionModel().getSelection();
		this.doSaving(0 < sels.length ? sels[0].data : undefined)
	},
	doSaving: function(data) {
		if(this.fileNameField.isValid() && this.exnameField.isValid()) {
			var sels = this.fileGrid.getSelectionModel().getSelection();
			var fileId, fileName = this.fileNameField.getValue(),
				exname = this.exnameField.getValue();
			if(data && data.name === fileName && exname === data.exname) {
				fileId = sels[0].data.id
			}
			this.hide();
			if(this.callback) {
				this.callback.call(this.scope, fileName, exname, fileId)
			}
		}
	},
	onCancelFn: function() {
		this.hide()
	},
	onRowSelectFn: function(list, rec, item, index, e) {
		var selectedId = rec.data.id;
		var exname = rec.data.exname;
		if(exname == "xls" || exname == "xlt") {
			this.saveBtn.enable();
			this.fileNameField.setValue(rec.data.name)
		} else {
			this.saveBtn.disable()
		}
	},
	onRowDblClickFn: function(list, rec, item, index, e) {
		this.doSaving(rec.data)
	},
	onQueryKeyDown: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER === key) {
			this.onSearchFn()
		} else {
			if(keyObj.ESC === key) {
				if("" !== this.queryField.getValue()) {
					this.queryField.setValue("");
					this.onSearchFn()
				}
			}
		}
	},
	onSearchFn: function() {
		var query = this.queryField.getValue();
		this.fileStore.load({
			params: {
				query: query
			}
		})
	}
}, function() {
	SSAVE = (function() {
		var win;
		return {
			popup: function(config) {
				if(!win) {
					win = new EnterpriseSheet.pop.SaveFileWin({
						width: 550,
						height: 400
					})
				}
				Ext.apply(win, config);
				win.popup()
			}
		}
	})()
});
Ext.define("EnterpriseSheet.pop.ImportFileWin", {
	extend: "Ext.window.Window",
	requires: ["Ext.form.field.Text", "Ext.form.field.File", "Ext.form.Panel"],
	cls: "ss-popup-win",
	bodyStyle: "background-color:white;padding:10px;",
	width: 450,
	height: 220,
	plain: true,
	modal: true,
	resizable: false,
	shim: true,
	prepareButton: Ext.emptyFn,
	layout: "fit",
	title: SLANG.importFile,
	closeAction: "hide",
	initComponent: function() {
		this.fileLabel = Ext.create("Ext.form.field.Display", {
			hideLabel: true,
			labelSeparator: "",
			value: SLANG.file_name,
			anchor: "95%"
		});
		this.fileField = Ext.create("Ext.form.field.File", {
			emptyText: SLANG.supportImportFormat,
			hideLabel: true,
			labelSeparator: "",
			name: "filePath",
			allowBlank: false,
			style: "margin-bottom:50px;",
			anchor: "95%"
		});
		this.tipLabel = Ext.create("Ext.form.field.Display", {
			hideLabel: true,
			labelSeparator: "",
			value: SLANG.uploadHint,
			anchor: "95%"
		});
		this.okLabel = Ext.create("Ext.form.field.Display", {
			hidden: true,
			hideLabel: true,
			labelSeparator: "",
			style: "font-size:13px; margin-top: 10px;",
			value: SLANG.importedSuccess,
			anchor: "95%"
		});
		this.importForm = Ext.create("Ext.form.Panel", {
			fileUpload: true,
			baseCls: "x-plain",
			labelWidth: 70,
			url: SCONFIG.urls.importExcelUpload,
			items: [this.fileLabel, this.fileField, this.tipLabel, this.okLabel]
		});
		this.items = [this.importForm];
		this.dockedItems = [{
			xtype: "container",
			dock: "right",
			width: 100,
			style: "padding:0px 10px;",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "button",
				text: SLANG["import"],
				handler: this.onOK,
				scope: this
			}, {
				xtype: "button",
				text: SLANG.cancel,
				style: "margin-top:10px;",
				handler: this.onCancel,
				scope: this
			}]
		}];
		this.callParent()
	},
	popup: function() {
		this.show()
	},
	onCancel: function() {
		this.hide()
	},
	onOK: function() {
		if(this.importForm.form.isValid()) {
			this.importForm.form.submit({
				waitMsg: "In processing",
				failure: function(form, action) {
					Ext.MessageBox.alert("Error Message", action.result.info)
				},
				success: function(form, action) {
					var jsonData = action.result;
					if(jsonData.success) {
						var fileId = jsonData.fileId;
						this.tipLabel.hide();
						this.okLabel.show();
						if(jsonData.status == "ok") {
							this.hide();
							if(this.callback) {
								this.callback.call(this.scope, fileId)
							}
						} else {}
					} else {
						Ext.MessageBox.alert("Failed", jsonData.info)
					}
				},
				scope: this
			})
		}
	},
	onKeyPress: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER == key) {
			this.onOK()
		}
	}
}, function() {
	SIMPORT = (function() {
		var win;
		return {
			popup: function(config) {
				if(!win) {
					win = new EnterpriseSheet.pop.ImportFileWin({})
				}
				Ext.apply(win, config);
				win.popup()
			}
		}
	})()
});
Ext.define("EnterpriseSheet.pop.CreateSheetFromTpl", {
	extend: "Ext.window.Window",
	requires: ["Ext.form.field.Text", "Ext.layout.container.Form"],
	cls: "ss-popup-win",
	bodyStyle: "background-color:white;",
	title: SLANG.create_sheet_from_tpl,
	plain: true,
	modal: true,
	resizable: false,
	shim: true,
	closeAction: "hide",
	layout: "fit",
	buttonAlign: "right",
	initComponent: function() {
		this.fileStore = Ext.create("Ext.data.Store", {
			pageSize: 50,
			model: EnterpriseSheet.model.FileModel,
			remoteSort: true,
			proxy: {
				type: "ajax",
				url: SCONFIG.urls.listSheet,
				reader: {
					root: "results",
					totalProperty: "totalCount"
				}
			}
		});
		this.queryField = Ext.create("Ext.form.field.Text", {
			width: 300,
			enableKeyEvents: true,
			listeners: {
				keydown: {
					fn: this.onQueryKeyDown,
					scope: this
				}
			}
		});
		this.fileGrid = Ext.create("Ext.grid.Panel", {
			store: this.fileStore,
			loadMask: true,
			border: false,
			columns: [{
				width: 56,
				dataIndex: "exname",
				menuDisabled: true,
				resizable: false,
				draggable: false,
				renderer: this.renderIcon
			}, {
				text: SLANG.file_name,
				dataIndex: "name",
				flex: 1,
				sortable: true
			}, {
				text: SLANG.update_date,
				dataIndex: "updateDate",
				style: "border-right:none;",
				minWidth: 150,
				maxWidth: 250,
				menuDisabled: true,
				resizable: false,
				draggable: false
			}],
			dockedItems: [{
				dock: "top",
				xtype: "toolbar",
				style: "padding-left:10px;background:white;",
				height: 36,
				layout: {
					type: "hbox",
					align: "middle"
				},
				items: [this.queryField, {
					style: "margin-left:2px;",
					text: SLANG.search,
					handler: this.onSearchFn,
					scope: this
				}]
			}],
			bbar: Ext.create("Ext.PagingToolbar", {
				store: this.fileStore,
				displayInfo: true,
				displayMsg: "Displaying items {0} - {1} of {2}",
				emptyMsg: "No items to display"
			})
		});
		this.fileStore.load();
		this.openBtn = Ext.create("Ext.button.Button", {
			disabled: true,
			text: SLANG.copy,
			handler: this.onOpenTplFn,
			scope: this
		});
		this.items = [this.fileGrid];
		this.buttons = [this.openBtn];
		this.callParent(arguments);
		this.on({
			scope: this,
			hide: this.onHideFn
		});
		this.fileGrid.on({
			scope: this,
			itemclick: this.onRowSelectFn,
			itemdblclick: this.onRowDblClickFn
		})
	},
	renderIcon: function(val, meta, rec, rowIndex, colIndex, store, view) {
		var result = '<img src="' + SCONFIG.IMAGES_PATH + '/icons/open.png"></img>';
		if(rec.data.exname == "xls") {
			result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_darkgreen.png"></img>'
		} else {
			if(rec.data.exname == "xlt") {
				result = '<img src="' + SCONFIG.IMAGES_PATH + '/sheet_tpl.png"></img>'
			}
		}
		return result
	},
	onHideFn: function() {
		if(this.hideCallback) {
			this.hideCallback.call(this.scope, this)
		}
	},
	setTitle: function(title) {
		this.titleBox.update(title)
	},
	popup: function(config) {
		if(config) {
			Ext.apply(this, config)
		}
		this.show()
	},
	onOpenTplFn: function() {
		var sels = this.fileGrid.getSelectionModel().getSelection();
		var loadingMask = new Ext.LoadMask({
			target: Ext.getBody(),
			msg: SLANG.waiting
		});
		loadingMask.show();
		Ext.Ajax.request({
			url: SCONFIG.urls.copyFromTpl,
			params: {
				tplFileId: sels[0].data.id
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(true == json.success || "true" == json.success) {
					loadingMask.hide();
					this.hide();
					if(this.callback) {
						this.callback.call(this.scope, json.fileId)
					}
				}
			},
			failure: function() {
				loadingMask.hide()
			},
			scope: this
		})
	},
	onCancelFn: function() {
		this.hide()
	},
	onRowSelectFn: function(list, rec, item, index, e) {
		var selectedId = rec.data.id;
		var exname = rec.data.exname;
		if(exname == "xls" || exname == "xlt") {
			this.openBtn.enable()
		} else {
			this.openBtn.disable()
		}
	},
	onRowDblClickFn: function(list, rec, item, index, e) {
		var selectedId = rec.data.id;
		var exname = rec.data.exname;
		if(exname == "xlt") {
			this.onOpenTplFn()
		}
	},
	onQueryKeyDown: function(field, e) {
		var key = e.getKey();
		var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
		if(keyObj.ENTER === key) {
			this.onSearchFn()
		} else {
			if(keyObj.ESC === key) {
				if("" !== this.queryField.getValue()) {
					this.queryField.setValue("");
					this.onSearchFn()
				}
			}
		}
	},
	onSearchFn: function() {
		var query = this.queryField.getValue();
		this.fileStore.load({
			params: {
				query: query
			}
		})
	}
}, function() {
	STOPEN = (function() {
		var win;
		return {
			popup: function(config) {
				if(!win) {
					win = new EnterpriseSheet.pop.CreateSheetFromTpl({
						width: 550,
						height: 400
					})
				}
				Ext.apply(win, config);
				win.popup()
			}
		}
	})()
});
Ext.define("EnterpriseSheet.pop.AboutWin", {
	extend: "Ext.window.Window",
	requires: ["Ext.layout.container.Form", "EnterpriseSheet.common.CONST"],
	iconCls: "icon-sheet",
	cls: "ss-popup-win",
	title: "Enterprise Spreadsheet Solution",
	bodyStyle: "background:white;padding:20px;",
	closable: true,
	closeAction: "hide",
	resizable: false,
	modal: true,
	layout: "anchor",
	border: true,
	layoutConfig: {
		animate: false,
		deferredRender: true
	},
	initComponent: function() {
		var myHtml = '<div style="float:left;width: 321px;padding:1px 45px 10px 2px;"><img src="resource/images/enterpriseLogo.png"/></div><div style="float:left;width: 225px;padding-top:5px;">    <span style="font-size:16px;"><b>EnterpriseSheet</b></span><br/><span style="font-size:12px;">Enterprise Spreadsheet Solution</span><br/>    <font color="grey">' + SCONST.version + '    </font>    <br/><br/></div><div style="clear:left;padding: 1px 2px 10px 0px; font-size:12px;">    EnterpriseSheet provides an enterprise solution to integrate and build your business spreadsheet. It is an online spreadsheet running on your server. EnterpriseSheet makes your data visualization easier, and pop with colorful charts and graphs. Its Excel-like functions, build-in formulas, table templates, validation and conditional formatting features save your time and simplify your spreadsheet tasks.<br/><br/>    To process integration, please visit <a href="http://www.enterpriseSheet.com" TARGET=_BLANK>www.enterpriseSheet.com</a>. Any issues, please     contact us <a href="mailto: info@enterpriseSheet.com">info@enterpriseSheet.com</a>.    <br><br>EnterpriseSheet and EnterpriseSheet logos are the trademarks of the Feyasoft Inc.<br/><br/>    Copyright &copy; 2016 Feyasoft Inc. All right reserved.';
		"</div>";
		this.html = myHtml;
		this.buttons = [{
			text: SLANG.close,
			handler: function() {
				this.hide()
			},
			scope: this
		}];
		this.callParent()
	},
	popup: function() {
		this.show()
	}
}, function() {
	SABOUT = new EnterpriseSheet.pop.AboutWin({
		width: 600
	})
});

Ext.define("EnterpriseSheet.sheet.action.ActionBox", {
	requires: ["EnterpriseSheet.common.action.Action", "EnterpriseSheet.sheet.pop.Popup", "EnterpriseSheet.sheet.action.ClipBoard", "EnterpriseSheet.pop.OpenFileWin", "EnterpriseSheet.pop.SaveFileWin", "EnterpriseSheet.pop.CreateSheetFromTpl", "EnterpriseSheet.pop.ImportFileWin", "EnterpriseSheet.pop.AboutWin"],
	constructor: function(sheet) {
		this.callParent();
		//2018 6.28 新增删除按钮
		this.filedeleteAction = new EnterpriseSheet.common.action.Action({
//			iconCls: "icon-sheet",
			handler: this.filedelete,
			scope: this
		});
		
		
		this.langenAction = new EnterpriseSheet.common.action.Action({
			handler: this.langEn,
			scope: this
		});
		this.langzhAction = new EnterpriseSheet.common.action.Action({
			handler: this.langZh,
			scope: this
		});
		this.langdeAction = new EnterpriseSheet.common.action.Action({
			handler: this.langDe,
			scope: this
		});
		this.newSheetAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-sheet",
			handler: this.newSheet,
			scope: this
		});
		this.newSheetTplAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-sheet-tpl",
			handler: this.newSheetTpl,
			scope: this
		});
		this.newSheetFromTplAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-sheet",
			handler: this.newSheetFromTpl,
			scope: this
		});
		this.openFileAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-open",
			handler: this.openFile,
			scope: this
		});
		this.importFileAction = new EnterpriseSheet.common.action.Action({
			handler: this.importFile,
			scope: this
		});
		this.exportFileAction = new EnterpriseSheet.common.action.Action({
			handler: this.exportXlsx,
			scope: this
		});
		this.saveFileAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-save",
			handler: this.saveFile,
			scope: this
		});
		this.saveAsFileAction = new EnterpriseSheet.common.action.Action({
			handler: this.saveAsFile,
			scope: this
		});
		this.shareFileAction = new EnterpriseSheet.common.action.Action({
			handler: this.shareFile,
			scope: this
		});
		this.publicFileAction = new EnterpriseSheet.common.action.Action({
			handler: this.publicFile,
			scope: this
		});
		this.cutAction = new EnterpriseSheet.common.action.Action({
			handler: this.cut,
			scope: this
		});
		this.copyAction = new EnterpriseSheet.common.action.Action({
			handler: this.copy,
			scope: this
		});
		this.pasteAction = new EnterpriseSheet.common.action.Action({
			handler: this.paste,
			scope: this
		});
		this.doFreezeAction = new EnterpriseSheet.common.action.Action({
			handler: this.doFreeze,
			scope: this
		});
		this.freezeFirstRowAction = new EnterpriseSheet.common.action.Action({
			handler: this.freezeFirstRow,
			scope: this
		});
		this.freezeFirstColAction = new EnterpriseSheet.common.action.Action({
			handler: this.freezeFirstColumn,
			scope: this
		});
		this.doSplitAction = new EnterpriseSheet.common.action.Action({
			handler: this.doSplit,
			scope: this
		});
		this.insertRangeAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertRange,
			scope: this
		});
		this.insertCopiedAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertCopied,
			scope: this
		});
		this.insertRowAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertRow,
			scope: this
		});
		this.insertColumnAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertColumn,
			scope: this
		});
		this.insertCellAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertCell,
			scope: this
		});
		this.insertSheetAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertSheet,
			scope: this
		});
		this.deleteRangeAction = new EnterpriseSheet.common.action.Action({
			handler: this.deleteRange,
			scope: this
		});
		this.deleteCellAction = new EnterpriseSheet.common.action.Action({
			handler: this.deleteCell,
			scope: this
		});
		this.deleteRowAction = new EnterpriseSheet.common.action.Action({
			handler: this.deleteRow,
			scope: this
		});
		this.deleteColumnAction = new EnterpriseSheet.common.action.Action({
			handler: this.deleteColumn,
			scope: this
		});
		this.deleteSheetAction = new EnterpriseSheet.common.action.Action({
			handler: this.deleteSheet,
			scope: this
		});
		this.rowHeightAction = new EnterpriseSheet.common.action.Action({
			handler: this.setRowHeight,
			scope: this
		});
		this.columnWidthAction = new EnterpriseSheet.common.action.Action({
			handler: this.setColumnWidth,
			scope: this
		});
		this.adjustRowHeightAction = new EnterpriseSheet.common.action.Action({
			handler: this.autoAdjustRowHeight,
			scope: this
		});
		this.adjustColumnWidthAction = new EnterpriseSheet.common.action.Action({
			handler: this.autoAdjustColumnWidth,
			scope: this
		});
		this.hideRowAction = new EnterpriseSheet.common.action.Action({
			handler: this.hideRow,
			scope: this
		});
		this.hideColumnAction = new EnterpriseSheet.common.action.Action({
			handler: this.hideColumn,
			scope: this
		});
		this.showRowAction = new EnterpriseSheet.common.action.Action({
			handler: this.showRow,
			scope: this
		});
		this.showColumnAction = new EnterpriseSheet.common.action.Action({
			handler: this.showColumn,
			scope: this
		});
		this.filterAction = new EnterpriseSheet.common.action.Action({
			handler: this.filter,
			scope: this
		});
		this.sortAscAction = new EnterpriseSheet.common.action.Action({
			handler: this.sortAsc,
			scope: this
		});
		this.sortDescAction = new EnterpriseSheet.common.action.Action({
			handler: this.sortDesc,
			scope: this
		});
		this.customSortAction = new EnterpriseSheet.common.action.Action({
			handler: this.customSort,
			scope: this
		});
		this.alignLeftAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-align-left",
			handler: this.alignLeft,
			scope: this
		});
		this.alignCenterAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-align-center",
			handler: this.alignCenter,
			scope: this
		});
		this.alignRightAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-align-right",
			handler: this.alignRight,
			scope: this
		});
		this.alignTopAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-align-top",
			handler: this.alignTop,
			scope: this
		});
		this.alignMiddleAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-align-middle",
			handler: this.alignMiddle,
			scope: this
		});
		this.alignBottomAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-align-bottom",
			handler: this.alignBottom,
			scope: this
		});
		this.rotateTextUpAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-arrow-u",
			handler: this.rotateTextUp,
			scope: this
		});
		this.rotateTextDownAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-arrow-d",
			handler: this.rotateTextDown,
			scope: this
		});
		this.rotateText45Action = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-arrow-cc",
			handler: this.rotateText45,
			scope: this
		});
		this.rotateTextDown45Action = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-arrow-c",
			handler: this.rotateTextDown45,
			scope: this
		});
		this.increaseIndentAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-indent",
			handler: this.incIndent,
			scope: this
		});
		this.removeIndentAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-remove-indent",
			handler: this.removeIndent,
			scope: this
		});
		this.wordWrapAction = new EnterpriseSheet.common.action.Action({
			iconCls: "fa fi-wordwrap",
			handler: this.doWordWrap,
			scope: this
		});
		this.mergeCenterAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-merge",
			handler: this.mergeCellandAlignCenter,
			scope: this
		});
		this.mergeCellAction = new EnterpriseSheet.common.action.Action({
			iconCls: "fa fi-merge-center",
			handler: this.mergeCell,
			scope: this
		});
		this.mergeRowAction = new EnterpriseSheet.common.action.Action({
			iconCls: "fa fi-merger-row",
			handler: this.mergeCellInRow,
			scope: this
		});
		this.mergeColumnAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-merge-col",
			handler: this.mergeCellInColumn,
			scope: this
		});
		this.cancelMergeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "fa fi-cancel-merge",
			handler: this.cancelMergeCell,
			scope: this
		});
		this.incFontSizeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-sizeinc",
			handler: this.incFontSize,
			scope: this
		});
		this.descFontSizeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-sizedes",
			handler: this.desFontSize,
			scope: this
		});
		this.boldAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-bold",
			handler: this.bold,
			scope: this
		});
		this.italicAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-italic",
			handler: this.italic,
			scope: this
		});
		this.underlineAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-underline",
			handler: this.underline,
			scope: this
		});
		this.overlineAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-overline",
			handler: this.overline,
			scope: this
		});
		this.strikeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-strike",
			handler: this.strike,
			scope: this
		});
		this.fill625GrayAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-625gray",
			handler: this.fill625Gray,
			scope: this
		});
		this.fill125GrayAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-125gray",
			handler: this.fill125Gray,
			scope: this
		});
		this.fill25GrayAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-25gray",
			handler: this.fill25Gray,
			scope: this
		});
		this.fill50GrayAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-50gray",
			handler: this.fill50Gray,
			scope: this
		});
		this.fill75GrayAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-75gray",
			handler: this.fill75Gray,
			scope: this
		});
		this.thinHorizontalStripeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-ths",
			handler: this.fillTHS,
			scope: this
		});
		this.horizontalStripeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-hs",
			handler: this.fillHS,
			scope: this
		});
		this.thinVerticalStripeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-tvs",
			handler: this.fillTVS,
			scope: this
		});
		this.verticalStripeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-vs",
			handler: this.fillVS,
			scope: this
		});
		this.thinDiagonalStripeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-tds",
			handler: this.fillTDS,
			scope: this
		});
		this.thinReverseDiagonalStripeAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-trds",
			handler: this.fillTRDS,
			scope: this
		});
		this.thinDiagonalCHAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-tdc",
			handler: this.fillTDC,
			scope: this
		});
		this.diagonalCHAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-dc",
			handler: this.fillDC,
			scope: this
		});
		this.thickHorizontalCHAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-thc",
			handler: this.fillTHC,
			scope: this
		});
		this.thickDiagonalCHAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-fill-ttdc",
			handler: this.fillTTDC,
			scope: this
		});
		this.percentFormatAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-percent",
			handler: this.percentFormat,
			scope: this
		});
		this.commaFormatAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-comma",
			handler: this.commaFormat,
			scope: this
		});
		this.leftDotAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-dot-moveleft",
			handler: this.moveDot2Left,
			scope: this
		});
		this.rightDotAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-dot-moveright",
			handler: this.moveDot2Right,
			scope: this
		});
		this.cleanAction = new EnterpriseSheet.common.action.Action({
			handler: this.clean,
			scope: this
		});
		this.cleanContentAction = new EnterpriseSheet.common.action.Action({
			handler: this.cleanContent,
			scope: this
		});
		this.cleanStyleAction = new EnterpriseSheet.common.action.Action({
			handler: this.cleanStyle,
			scope: this
		});
		this.sumAction = new EnterpriseSheet.common.action.Action({
			iconCls: "icon-sum",
			handler: this.sum,
			scope: this
		});
		this.averageAction = new EnterpriseSheet.common.action.Action({
			handler: this.average,
			scope: this
		});
		this.countAction = new EnterpriseSheet.common.action.Action({
			handler: this.count,
			scope: this
		});
		this.maxValueAction = new EnterpriseSheet.common.action.Action({
			handler: this.maxValue,
			scope: this
		});
		this.minValueAction = new EnterpriseSheet.common.action.Action({
			handler: this.minValue,
			scope: this
		});
		this.insertFormulaAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertFormula,
			scope: this
		});
		this.autofillDownAction = new EnterpriseSheet.common.action.Action({
			handler: this.autofillDown,
			scope: this
		});
		this.autofillUpAction = new EnterpriseSheet.common.action.Action({
			handler: this.autofillUp,
			scope: this
		});
		this.autofillLeftAction = new EnterpriseSheet.common.action.Action({
			handler: this.autofillLeft,
			scope: this
		});
		this.autofillRightAction = new EnterpriseSheet.common.action.Action({
			handler: this.autofillRight,
			scope: this
		});
		this.insertPictureByURLAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertPictureByURL,
			scope: this
		});
		this.insertColumnChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertColumnChart,
			scope: this
		});
		this.insertPieChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertPieChart,
			scope: this
		});
		this.insertAreaChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertAreaChart,
			scope: this
		});
		this.insertLineChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertLineChart,
			scope: this
		});
		this.insertBarChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertBarChart,
			scope: this
		});
		this.insertScatterChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertScatterChart,
			scope: this
		});
		this.insertRadarChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertRadarChart,
			scope: this
		});
		this.insertColumnMiniChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertColumnMiniChart,
			scope: this
		});
		this.insertLineMiniChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertLineMiniChart,
			scope: this
		});
		this.insertGainLossMiniChartAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertGainLossMiniChart,
			scope: this
		});
		this.insertCircleShapeAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertCircleShape,
			scope: this
		});
		this.insertHyperlinkAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertHyperlink,
			scope: this
		});
		this.insertCommentAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertComment,
			scope: this
		});
		this.insertVariableAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertVariable,
			scope: this
		});
		this.deleteCommentAction = new EnterpriseSheet.common.action.Action({
			handler: this.deleteComment,
			scope: this
		});
		this.addGroupAction = new EnterpriseSheet.common.action.Action({
			handler: this.addGroup,
			scope: this
		});
		this.cancelGroupAction = new EnterpriseSheet.common.action.Action({
			handler: this.cancelGroup,
			scope: this
		});
		this.insertCheckboxAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertCheckbox,
			scope: this
		});
		this.insertRadioAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertRadio,
			scope: this
		});
		this.clearItemAction = new EnterpriseSheet.common.action.Action({
			handler: this.clearItem,
			scope: this
		});
		this.insertSequenceNoAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertSequenceNo,
			scope: this
		});
		this.insertDropListAction = new EnterpriseSheet.common.action.Action({
			handler: this.insertDropList,
			scope: this
		});
		this.markRangeAction = new EnterpriseSheet.common.action.Action({
			handler: this.markRange,
			scope: this
		});
		this.validationAction = new EnterpriseSheet.common.action.Action({
			handler: this.showValidation,
			scope: this
		});
		this.editableAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleEditable,
			scope: this
		});
		this.lockOtherEditAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleEditableForOther,
			scope: this
		});
		this.toggleGridLineAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleGridLine,
			scope: this
		});
		this.toggleRowNameAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleRowName,
			scope: this
		});
		this.toggleColNameAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleColName,
			scope: this
		});
		this.toggleTitleRegionAction = new EnterpriseSheet.common.action.Action({
			handler: this.toggleTitleRegion,
			scope: this
		});
		this.keyboardShortcutsAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG.keyboard_shortcuts,
			handler: this.keyboardShortcuts,
			scope: this
		});
		this.deleteRepeatAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG.delete_repeat_item,
			handler: this.deleteRepeatItem,
			scope: this
		});
		this.pivotTableAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG.pivot_table,
			handler: this.createPivotTable,
			scope: this
		});
		this.setHeaderTitleAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG.set_header_title,
			handler: this.setHeaderTitle,
			scope: this
		});
		this.insertDatePickerAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG.insert_date_picker,
			handler: this.insertDatePicker,
			scope: this
		});
		this.aboutSheetAction = new EnterpriseSheet.common.action.Action({
			tooltip: SLANG.aboutSheet,
			handler: this.aboutSheetWin,
			scope: this
		});
	},
	//2018 6.28 新增删除按钮
	filedelete:function(){
		var fileId = SHEET_API_HD.getStore().fileId;
		if (typeof(fileId)=='undefined') {
			Ext.Msg.alert('提示', '未选择文件');
			return;
		}
		Ext.MessageBox.confirm("提示", "是否要删除该文件？", function (btnId) {  
		    if (btnId == "yes") {  
				Ext.Ajax.request({
		        	url : basePath + 'Excel/file/delete.action',
		        	params: {
		        		id:fileId
		        	},
		        	callback : function(options,success,response){
		        		var res = new Ext.decode(response.responseText);        	
		        		if(res.success){
						var main = parent.Ext.getCmp("content-panel"),bool = false; 
						if(main){
							bool = true;
							main.getActiveTab().close();
						} else {
							var win = parent.Ext.ComponentQuery.query('window');
							if(win){
								Ext.each(win, function(){
									this.close();
								});
							} else {
								bool = true;
								window.close();
							}
						}
		        		} else if(res.exceptionInfo){
		        			Ext.MessageBox.alert("提示",res.exceptionInfo);
		        		}
		        	}
		        });		          
		    }  
		});
		
	},
	
	
	addHotKey: function(sheet) {
		var scope = {
			getSheet: function() {
				return sheet;
			},
			me: this
		};
		PHKey.bindHotKey(57, true, false, true, this.showRow, scope);
		PHKey.bindHotKey(48, true, false, true, this.showColumn, scope);
		PHKey.bindHotKey(57, true, false, false, this.hideRow, scope);
		PHKey.bindHotKey(48, true, false, false, this.hideColumn, scope);
		PHKey.bindHotKey(66, true, false, false, this.bold, scope);
		PHKey.bindHotKey(50, true, false, false, this.bold, scope);
		PHKey.bindHotKey(73, true, false, false, this.italic, scope);
		PHKey.bindHotKey(51, true, false, false, this.italic, scope);
		PHKey.bindHotKey(68, true, false, false, this.autofillDown, scope);
		PHKey.bindHotKey(82, true, false, false, this.autofillRight, scope);
		PHKey.bindHotKey(75, true, false, false, this.insertHyperlink, scope);
		PHKey.bindHotKey(122, false, false, true, this.addNewWorkbook, scope);
		PHKey.bindHotKey(84, true, false, false, this.applyTable, scope);
		PHKey.bindHotKey(36, true, false, false, this.move2TopLeft, scope);
		PHKey.bindHotKey(36, false, false, false, this.move2LeftMost, scope);
		PHKey.bindHotKey(34, false, false, false, this.movePageDown, scope);
		PHKey.bindHotKey(33, false, false, false, this.movePageUp, scope);
		PHKey.bindHotKey(35, true, false, false, this.move2BottomRight, scope);
		PHKey.bindHotKey(103, true, false, true, this.select2TopLeft, scope);
		PHKey.bindHotKey(38, true, false, true, this.select2Top, scope);
		PHKey.bindHotKey(37, true, false, true, this.select2Left, scope);
		PHKey.bindHotKey(77, true, true, false, this.insertComment, scope);
		PHKey.bindHotKey(112, false, true, false, this.insertColumnChart, scope);
		PHKey.bindHotKey(113, false, false, true, this.insertComment, scope);
		PHKey.bindHotKey(114, false, false, true, this.insertFormula, scope);
		if(!SCONFIG.file_menu_hide) {
			PHKey.bindHotKey(79, true, false, false, this.openFile, scope, true);
			PHKey.bindHotKey(83, true, false, false, this.saveFile, scope, true);
		}
		PHKey.bindHotKey(85, true, false, false, this.underline, scope);
		PHKey.bindHotKey(52, true, false, false, this.underline, scope);
		PHKey.bindHotKey(191, true, false, false, this.keyboardShortcuts, scope, true);
		PHKey.bindHotKey(186, true, false, false, this.addCurrentDate, scope);
		PHKey.bindHotKey(186, true, false, true, this.addCurrentTime, scope);
		PHKey.bindHotKey(53, false, true, true, this.strike, scope, true);
		PHKey.bindHotKey(53, true, false, false, this.strike, scope);
		PHKey.bindHotKey(69, true, false, true, this.alignCenter, scope);
		PHKey.bindHotKey(76, true, false, true, this.alignLeft, scope);
		PHKey.bindHotKey(82, true, false, true, this.alignRight, scope);
		PHKey.bindHotKey(50, true, false, true, this.applyTimeFormat, scope);
		PHKey.bindHotKey(52, true, false, true, this.applyCurrencyFormat, scope);
		PHKey.bindHotKey(53, true, false, true, this.applyPercentFormat, scope);
		PHKey.bindHotKey(49, true, false, true, this.commaFormat, scope);
		PHKey.bindHotKey(54, true, false, true, this.scienceFormat, scope);
		PHKey.bindHotKey(55, true, false, true, this.applyBorderFormat, scope);
		PHKey.bindHotKey(189, true, false, true, this.removeBorderFormat, scope);
		PHKey.bindHotKey(187, true, false, true, this.insertRange, scope);
		PHKey.bindHotKey(189, true, false, false, this.deleteRange, scope);
	},
	onKeyDown: function(e) {
		var key = e.getKey();
		if(46 == key || 8 == key) {
			this.cleanContent();
			return false;
		}
	},
	langChangeFn: function(scope, lang) {
		Ext.Ajax.request({
			url: SCONFIG.urls.updateLang,
			params: {
				lang: lang
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(true == json.success || "true" == json.success) {
					window.location.reload();
				}
			},
			scope: this
		});
	},
	langEn: function(scope) {
		var me = this.me;
		me.langChangeFn(scope, "en");
	},
	langZh: function(scope) {
		var me = this.me;
		me.langChangeFn(scope, "zh_CN");
	},
	langDe: function(scope) {
		var me = this.me;
		me.langChangeFn(scope, "de");
	},
	newSheet: function() {
		window.location = window.location.pathname;
	},
	newSheetTpl: function() {
		var sheet = this.getSheet(),
			me = this.me;
		Ext.Ajax.request({
			url: SCONFIG.urls.createFile,
			params: {
				exname: "xlt",
				initName: SLANG.sheetNewTpl
			},
			success: function(response, options) {
				var json = Ext.decode(response.responseText);
				if(true == json.success || "true" == json.success) {
					var fileId = json.fileId;
					if(me.openFileByOnlyLoadDataFlag) {
						sheet.getStore().loadFile({
							fileId: fileId
						});
					} else {
						window.location = window.location.pathname + "?editFileId=" + fileId;
					}
				}
			},
			failure: function() {},
			scope: this
		});
	},
	openFile: function() {
		var sheet = this.getSheet(),
			me = this.me;
		if(SOPEN) {
			SOPEN.popup({
				callback: function(fileId) {
					if(me.openFileByOnlyLoadDataFlag) {
						sheet.getStore().loadFile({
							fileId: fileId
						});
					} else {
						window.location = window.location.pathname + "?editFileId=" + fileId;
					}
				},
				scope: this
			});
		}
	},
	saveFile: function() {
		var sheet = this.getSheet(),
			me = this.me;
		SSAVE.popup({
			callback: function(fileName, exname, fileId) {
				sheet.saveJsonFile({
					id: fileId,
					name: fileName,
					exname: exname
				}, function(newFileId) {
					if(me.openFileByOnlyLoadDataFlag) {
						sheet.getStore().loadFile({
							fileId: newFileId
						});
						Ext.Msg.alert(SLANG.hint, SLANG.all_changes_are_saved);
					} else {
						window.location = window.location.pathname + "?editFileId=" + newFileId;
					}
				}, this);
			},
			scope: this
		});
	},
	shareFile: function() {
		var sheet = this.getSheet(),
			store = sheet.getStore(),
			file = store.getLoadedFile();
		sheet.fireEvent("sharefile", store, file, sheet, this.me);
	},
	publicFile: function() {
		var sheet = this.getSheet(),
			me = this.me,
			store = sheet.getStore(),
			file = store.getLoadedFile();
		sheet.fireEvent("publicfile", store, file, sheet, this.sender);
	},
	importFile: function() {
		var sheet = this.getSheet(),
			me = this.me;
		if(SIMPORT) {
			SIMPORT.popup({
				callback: function(fileId) {
					if(me.openFileByOnlyLoadDataFlag) {
						sheet.getStore().loadFile({
							fileId: fileId
						});
					} else {
						window.location = window.location.pathname + "?editFileId=" + fileId;
					}
				},
				scope: this
			});
		}
	},
	exportXlsx: function() {
		var sheet = this.getSheet(),
			me = this.me;
		if(sheet.getStore().fileId) {
			var loadingMask = new Ext.LoadMask({
				target: Ext.getBody(),
				msg: SLANG.waiting
			});
			loadingMask.show();
			document.location = SCONFIG.urls.exportExcel + "?documentId=" + sheet.getStore().fileId;
			setTimeout(function() {
				loadingMask.hide();
			}, 3000);
		} else {
			Ext.Msg.alert(SLANG.hint, SLANG.saveBeforeExport);
		}
	},
	newSheetFromTpl: function() {
		var sheet = this.getSheet(),
			me = this.me;
		if(STOPEN) {
			STOPEN.popup({
				callback: function(fileId) {
					if(me.openFileByOnlyLoadDataFlag) {
						sheet.getStore().loadFile({
							fileId: fileId
						});
					} else {
						window.location = window.location.pathname + "?editFileId=" + fileId;
					}
				},
				scope: this
			});
		}
	},
	cut: function() {
		var sheet = this.getSheet(),
			me = this.me;
		var clipboard = sheet.getClipboard();
		if(clipboard) {
			clipboard.cut();
		}
	},
	copy: function() {
		var sheet = this.getSheet(),
			me = this.me;
		var clipboard = sheet.getClipboard();
		if(clipboard) {
			clipboard.copy();
		}
	},
	paste: function() {
		var sheet = this.getSheet(),
			me = this.me;
		var clipboard = sheet.getClipboard();
		if(clipboard) {
			clipboard.paste();
		}
	},
	doFreeze: function() {
		var ss = this.getSheet(),
			me = this.me;
		var freezeAction = me.doFreezeAction,
			splitAction = me.doSplitAction;
		if(!ss.isFreezed()) {
			if(me.freeze(ss)) {
				if(freezeAction) {
					freezeAction.setText(SLANG.cancel_freeze);
				}
			}
		} else {
			ss.unfreeze();
			if(freezeAction) {
				freezeAction.setText(SLANG.freeze_sheet);
			}
		}
		if(splitAction) {
			splitAction.setText(SLANG.split_sheet);
		}
	},
	freeze: function(ss) {
		var me = this;
		if(ss.isSplited()) {
			var row = 1,
				col = 1;
			if(ss.ulefter.isVisible()) {
				row = ss.ulefter.rowEnd + 1;
			}
			if(ss.lheader.isVisible()) {
				col = ss.lheader.colEnd + 1;
			}
			ss.freeze(row, col);
			var splitAction = me.doSplitAction;
			if(splitAction) {
				splitAction.toggle(false, true);
			}
		} else {
			var sm = ss.getSelectionModel();
			var pos = sm.getMinMaxPos();
			ss.freeze(pos.minrow, pos.mincol);
		}
		return ss.freezePos;
	},
	freezeFirstRow: function() {
		var ss = this.getSheet(),
			me = this.me;
		ss.freeze(ss.getRowStart() + 1, ss.getColStart());
		var freezeAction = me.doFreezeAction;
		if(freezeAction) {
			freezeAction.setText(SLANG.cancel_freeze);
		}
		var splitAction = me.doSplitAction;
		if(splitAction) {
			splitAction.toggle(false, true);
		}
	},
	freezeFirstColumn: function() {
		var ss = this.getSheet(),
			me = this.me;
		ss.freeze(ss.getRowStart(), ss.getColStart() + 1);
		var splitAction = me.doSplitAction;
		if(splitAction) {
			splitAction.toggle(false, true);
		}
	},
	doSplit: function() {
		var ss = this.getSheet(),
			me = this.me;
		if(!ss.isSplited()) {
			if(ss.isFreezed()) {
				var w = 0,
					h = 0;
				if(ss.ulefter.isVisible()) {
					h = ss.ulefter.getHeight();
				}
				if(ss.lheader.isVisible()) {
					w = ss.lheader.getWidth();
				}
				ss.split(w, h);
			} else {
				var sm = ss.getSelectionModel();
				var pos = sm.getMinMaxPos();
				var row = pos.minrow,
					col = pos.mincol;
				var rowStart = ss.getRowStart(),
					colStart = ss.getColStart();
				if(row > rowStart) {
					row--;
				}
				if(col > colStart) {
					col--;
				}
				var size = ss.getCellPosition(row, col);
				ss.split(size[0], size[1]);
			}
			var splitAction = me.doSplitAction;
			if(splitAction) {
				splitAction.toggle(true, true);
				splitAction.setText(SLANG.cancel_split);
			}
		} else {
			ss.unsplit();
			var splitAction = me.doSplitAction;
			if(splitAction) {
				splitAction.toggle(false, true);
				splitAction.setText(SLANG.split_sheet);
			}
		}
		var freezeAction = me.doFreezeAction;
		if(freezeAction) {
			freezeAction.setText(SLANG.freeze_sheet);
		}
	},
	insertRange: function() {
		this.getSheet().insertRange();
	},
	insertSequenceNo: function() {
		this.getSheet().insertSequenceNo();
	},
	insertDropList: function() {
		var ss = this.getSheet(),
			me = this.me;
		SPOP.showDropListConfig({
			title: SLANG.setup_droplist,
			fileId: ss.getStore().fileId,
			sheet: ss,
			applyCallback: {
				fn: function(json) {
					ss.insertDropList(json);
				},
				scope: this
			}
		});
	},
	insertCell: function() {
		this.getSheet().insertCell();
	},
	insertRow: function() {
		this.getSheet().insertRow();
	},
	insertColumn: function() {
		this.getSheet().insertColumn();
	},
	deleteRange: function() {
		this.getSheet().deleteRange();
	},
	deleteCell: function() {
		this.getSheet().deleteCell();
	},
	deleteRow: function() {
		this.getSheet().deleteRow();
	},
	deleteColumn: function() {
		this.getSheet().deleteColumn();
	},
	setRowHeight: function() {
		var ss = this.getSheet();
		var sm = ss.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var minrow = pos.minrow,
			maxrow = pos.maxrow;
		SPOP.showRowHeightBox({
			applyCallback: {
				fn: function(h) {
					this.getSheet().setRowHeight(h, {
						minrow: minrow,
						maxrow: maxrow
					});
				},
				scope: this
			}
		});
	},
	setColumnWidth: function() {
		var ss = this.getSheet();
		var sm = ss.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var mincol = pos.mincol,
			maxcol = pos.maxcol;
		SPOP.showColumnWidthBox({
			applyCallback: {
				fn: function(w) {
					this.getSheet().setColumnWidth(w, {
						mincol: mincol,
						maxcol: maxcol
					});
				},
				scope: this
			}
		});
	},
	hideRow: function() {
		this.getSheet().hideRow();
	},
	hideColumn: function() {
		this.getSheet().hideColumn();
	},
	showRow: function() {
		this.getSheet().showRow();
	},
	showColumn: function() {
		this.getSheet().showColumn();
	},
	filter: function() {
		var sheet = this.getSheet();
		var filter = sheet.getFilter();
		if(filter) {
			filter.createFilterForSelecton();
		}
		sheet.focus();
	},
	sortAsc: function() {
		this.getSheet().sortSelection(null, "asc");
	},
	sortDesc: function() {
		this.getSheet().sortSelection(null, "desc");
	},
	alignLeft: function() {
		this.getSheet().setPropertyForSelection({
			ta: "left"
		});
	},
	alignCenter: function() {
		this.getSheet().setPropertyForSelection({
			ta: "center"
		});
	},
	alignRight: function() {
		this.getSheet().setPropertyForSelection({
			ta: "right"
		});
	},
	alignTop: function() {
		this.getSheet().setPropertyForSelection({
			va: "top"
		});
	},
	alignMiddle: function() {
		this.getSheet().setPropertyForSelection({
			va: "middle"
		});
	},
	alignBottom: function() {
		this.getSheet().setPropertyForSelection({
			va: "bottom"
		});
	},
	incIndent: function() {
		var ti = this.getSheet().getFocusCellData().ti || 0;
		ti += 5;
		this.getSheet().setPropertyForSelection({
			ti: ti
		});
	},
	removeIndent: function() {
		var ti = this.getSheet().getFocusCellData().ti || 0;
		ti -= 5;
		if(0 > ti) {
			ti = 0;
		}
		this.getSheet().setPropertyForSelection({
			ti: ti
		});
	},
	doWordWrap: function(item) {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var ws = "nowrap",
			ww = "normal";
		if(!data.ws || data.ws == ws) {
			ws = "normal";
			ww = "break-word";
		}
		ss.setPropertyForSelection({
			ws: ws,
			ww: ww
		});
	},
	mergeCellandAlignCenter: function() {
		this.getSheet().mergeCellandAlignCenter();
	},
	mergeCell: function() {
		this.getSheet().mergeSelectedCell();
	},
	mergeCellInColumn: function() {
		this.getSheet().mergeCellInColumn();
	},
	mergeCellInRow: function() {
		this.getSheet().mergeCellInRow();
	},
	cancelMergeCell: function() {
		this.getSheet().cancelMergeCell();
	},
	incFontSize: function() {
		var ss = this.getSheet(),
			store = ss.getStore();
		var data = ss.getFocusCellData();
		var fz = parseInt(data.fz);
		if(!Ext.isNumber(fz)) {
			fz = store.defaultFontSize;
		}
		fz += 2;
		ss.setPropertyForSelection({
			fz: fz
		});
	},
	desFontSize: function() {
		var ss = this.getSheet();
		var store = ss.getStore();
		var data = ss.getFocusCellData();
		var fz = parseInt(data.fz);
		if(!Ext.isNumber(fz)) {
			fz = store.defaultFontSize;
		}
		if(fz - 2 > store.minFontSize) {
			fz -= 2;
		} else {
			fz = store.minFontSize;
		}
		ss.setPropertyForSelection({
			fz: fz
		});
	},
	bold: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "bold" != data.fw;
		if(false !== ss.fireEvent("cmd", "bold", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					fw: "bold"
				});
			} else {
				ss.setPropertyForSelection({
					fw: ""
				});
			}
		}
	},
	italic: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "italic" != data.fs;
		if(false !== ss.fireEvent("cmd", "italic", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					fs: "italic"
				});
			} else {
				ss.setPropertyForSelection({
					fs: ""
				});
			}
		}
	},
	underline: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "underline" != data.u;
		if(false !== ss.fireEvent("cmd", "underline", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					u: "underline"
				});
			} else {
				ss.setPropertyForSelection({
					u: ""
				});
			}
		}
	},
	overline: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "overline" != data.o;
		if(false !== ss.fireEvent("cmd", "overline", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					o: "overline"
				});
			} else {
				ss.setPropertyForSelection({
					o: ""
				});
			}
		}
	},
	strike: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "line-through" != data.s;
		if(false !== ss.fireEvent("cmd", "strikethrough", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					s: "line-through"
				});
			} else {
				ss.setPropertyForSelection({
					s: ""
				});
			}
		}
	},
	rotateTextUp: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "270" != data.rotation;
		if(false !== ss.fireEvent("cmd", "rotation", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					rotation: "270"
				});
			} else {
				ss.setPropertyForSelection({
					rotation: ""
				});
			}
		}
	},
	rotateTextDown: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "90" != data.rotation;
		if(false !== ss.fireEvent("cmd", "rotation", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					rotation: "90"
				});
			} else {
				ss.setPropertyForSelection({
					rotation: ""
				});
			}
		}
	},
	rotateText45: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "45" != data.rotation;
		if(false !== ss.fireEvent("cmd", "rotation", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					rotation: "45"
				});
			} else {
				ss.setPropertyForSelection({
					rotation: ""
				});
			}
		}
	},
	rotateTextDown45: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		var flag = "315" != data.rotation;
		if(false !== ss.fireEvent("cmd", "rotation", flag, ss)) {
			if(flag) {
				ss.setPropertyForSelection({
					rotation: "315"
				});
			} else {
				ss.setPropertyForSelection({
					rotation: ""
				});
			}
		}
	},
	fill625Gray: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style['625Gray']
		});
	},
	fill125Gray: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style['125Gray']
		});
	},
	fill25Gray: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style['25Gray']
		});
	},
	fill50Gray: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style['50Gray']
		});
	},
	fill75Gray: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style['75Gray']
		});
	},
	fillTHS: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.thinHS
		});
	},
	fillHS: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.HS
		});
	},
	fillTVS: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.thinVS
		});
	},
	fillVS: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.VS
		});
	},
	fillTDS: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.thinDS
		});
	},
	fillTRDS: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.thinRDS
		});
	},
	fillTDC: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.thinDC
		});
	},
	fillDC: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.DC
		});
	},
	fillTTDC: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.thickDC
		});
	},
	fillTHC: function() {
		this.getSheet().setPropertyForSelection({
			bg: SCONST.fill_pattern_style.thinHC
		});
	},
	addCurrentDate: function() {
		this.getSheet().addCurrentDateOrTime(SCONST.FORMAT_DATE, SCONST.DEFAULT_DATE_FORMAT);
	},
	addCurrentTime: function() {
		this.getSheet().addCurrentDateOrTime(SCONST.FORMAT_TIME, SCONST.HIA_TIME_FORMAT);
	},
	applyCurrencyFormat: function() {
		var format = "money|$|2|negative3";
		this.getSheet().setTextFormatForSelection(format);
	},
	applyPercentFormat: function() {
		this.getSheet().setPercentFormatForSelection(SCONST.NO_DECIMAL_PERCENT_FORMAT);
	},
	applyTimeFormat: function() {
		this.getSheet().setTimeFormatForSelection(SCONST.HIA_TIME_FORMAT);
	},
	applyBorderFormat: function() {
		this.getSheet().setRangeBorder("outside", "black", 1, "solid");
	},
	removeBorderFormat: function() {
		this.getSheet().setRangeBorder("all", "", 1, "solid");
	},
	percentFormat: function() {
		this.getSheet().setPercentFormatForSelection(SCONST.DEFAULT_PERCENT_FORMAT);
	},
	commaFormat: function() {
		this.getSheet().setTextFormatForSelection(SCONST.FORMAT_COMMA);
	},
	scienceFormat: function() {
		this.getSheet().setTextFormatForSelection(SCONST.FORMAT_SCIENCE);
	},
	moveDot2Left: function() {
		this.getSheet().moveDecimalPoint(1);
	},
	moveDot2Right: function() {
		this.getSheet().moveDecimalPoint(-1);
	},
	clean: function() {
		this.getSheet().cleanSelection(undefined, true);
	},
	cleanContent: function() {
		this.getSheet().cleanSelection("content", true);
	},
	cleanStyle: function() {
		this.getSheet().cleanSelection("style", true);
	},
	sum: function() {
		this.me.insertGeneralFunction.call(this, "sum");
	},
	average: function() {
		this.me.insertGeneralFunction.call(this, "average");
	},
	count: function() {
		this.me.insertGeneralFunction.call(this, "count");
	},
	maxValue: function() {
		this.me.insertGeneralFunction.call(this, "max");
	},
	minValue: function() {
		this.me.insertGeneralFunction.call(this, "min");
	},
	insertFormula: function() {
		if(!this.insertFormulaWin) {
			this.insertFormulaWin = Ext.create("EnterpriseSheet.sheet.pop.FormulaFunctionWin", {
				title: SLANG.insert_function,
				closeAction: "hide",
				spreadsheet: this.getSheet()
			});
		}
		this.insertFormulaWin.popup();
	},
	autofillDown: function() {
		var sheet = this.getSheet();
		var autofill = sheet.getAutofill();
		if(autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if(pos.minrow != pos.maxrow) {
				pos.maxrow = pos.minrow;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},
	autofillUp: function() {
		var sheet = this.getSheet();
		var autofill = sheet.getAutofill();
		if(autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if(pos.minrow != pos.maxrow) {
				pos.minrow = pos.maxrow;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},
	autofillLeft: function() {
		var sheet = this.getSheet();
		var autofill = sheet.getAutofill();
		if(autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if(pos.mincol != pos.maxcol) {
				pos.mincol = pos.maxcol;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},
	autofillRight: function() {
		var sheet = this.getSheet();
		var autofill = sheet.getAutofill();
		if(autofill) {
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			if(pos.mincol != pos.maxcol) {
				pos.maxcol = pos.mincol;
				pos.sheet = sheet.getSheetId();
				autofill.doAutofill(pos, null, sm);
			}
		}
	},
	insertPictureByURL: function() {
		SPOP.showLinkBox({
			sheet: this.getSheet(),
			width: 400,
			height: 150,
			applyCallback: {
				fn: function(url) {
					this.getSheet().createPicture(url);
				},
				scope: this
			}
		});
	},
	insertColumnChart: function() {
		this.getSheet().createColumnChart();
	},
	insertPieChart: function() {
		this.getSheet().createPieChart();
	},
	insertAreaChart: function() {
		this.getSheet().createAreaChart();
	},
	insertLineChart: function() {
		this.getSheet().createLineChart();
	},
	insertBarChart: function() {
		this.getSheet().createBarChart();
	},
	insertScatterChart: function() {
		this.getSheet().createScatterChart();
	},
	insertRadarChart: function() {
		this.getSheet().createRadarChart();
	},
	insertGeneralFunction: function(name) {
		Ext.Function.defer(function() {
			var ss = this.getSheet();
			var editor = ss.editor;
			editor.setValue("=" + name.toUpperCase() + "(");
			var region = ss.getCurrentRegion();
			var sm = region.getSelectionModel();
			var fc = sm.getFocusCell();
			editor.startEdit(fc.row, fc.col, region, null, false, true);
		}, 100, this);
	},
	insertColumnMiniChart: function() {
		var ss = this.getSheet(),
			sm = ss.getSelectionModel(),
			sheetId = ss.getSheetId();
		var pos = sm.getMinMaxPos();
		var span = [sheetId, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol];
		SPOP.showConditionRange({
			sheet: ss,
			title: SLANG.data_range_for_mini_chart,
			label: SLANG.select_range_for_mini_chart,
			width: 400,
			height: 150,
			simpleSelect: true,
			applyCallback: {
				fn: function(param) {
					param.type = "column";
					param.pc = "rgb(0,0,128)";
					param.nc = "rgb(0,0,128)";
					ss.setConditionForRange([span], "minichart", param);
				},
				scope: this
			}
		});
	},
	insertLineMiniChart: function() {
		var ss = this.getSheet();
		SPOP.showConditionRange({
			sheet: ss,
			title: SLANG.data_range_for_mini_chart,
			label: SLANG.select_range_for_mini_chart,
			width: 400,
			height: 150,
			simpleSelect: true,
			applyCallback: {
				fn: function(param) {
					param.type = "line";
					param.sc = "rgb(0,0,128)";
					ss.setConditionForSelection("minichart", param);
				},
				scope: this
			}
		});
	},
	insertGainLossMiniChart: function() {
		var sheet = this.getSheet(),
			sm = sheet.getSelectionModel(),
			store = sheet.getStore();
		var focusCell = sm.getFocusCell();
		var sheetId = sheet.getSheetId();
		var cd = store.getCellData(sheetId, focusCell.row, focusCell.col);
		var value;
		if(sheet.isMiniChartCell(sheetId, focusCell.row, focusCell.col)) {
			var span = sheet.getMiniChartRange(sheetId, focusCell.row, focusCell.col);
			value = [span];
		}
		SPOP.showConditionRange({
			sheet: sheet,
			title: SLANG.data_range_for_mini_chart,
			label: SLANG.select_range_for_mini_chart,
			width: 400,
			height: 150,
			simpleSelect: true,
			value: value,
			applyCallback: {
				fn: function(param) {
					param.type = "gainloss";
					param.pc = "rgb(248,105,107)";
					param.nc = "rgb(90,190,123)";
					sheet.setConditionForSelection("minichart", param);
				},
				scope: this
			}
		});
	},
	insertCircleShape: function() {
		this.getSheet().createCircleShape();
	},
	insertHyperlink: function() {
		var sheetId = this.getSheet().sheetId;
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		SPOP.showLinkBox({
			sheet: this.getSheet(),
			title: SLANG.insert_hyperlink,
			width: 400,
			height: 150,
			applyCallback: {
				fn: function(url) {
					this.getSheet().createHyperlink(url, sheetId, row, col);
					if(sheetId !== this.getSheet().sheetId) {
						this.getSheet().go2Sheet(sheetId, null, this);
					}
				},
				scope: this
			},
			urlValidator: function(val) {
				if(SCONST.urlReg.test(val)) {
					return true;
				} else if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val)) {
					return true;
				} else if("=" === val.charAt(0)) {
					val = val.slice(1);
				}
				return false;
			}
		});
	},
	addNewWorkbook: function() {
		var sheet = this.getSheet(),
			store = sheet.getStore();
		store.addSheet(null, function(data) {
			var sheetId = data.id;
			sheet.loadSwitchSheet(sheetId);
		}, this);
	},
	applyTable: function() {},
	move2TopLeft: function() {
		this.getSheet().go2Pos();
	},
	move2BottomRight: function() {
		var sheet = this.getSheet(),
			store = sheet.getStore();
		var maxRow = 1,
			maxCol = 1;
		store.each(function(rd) {
			if(rd.data.row >= maxRow) {
				maxRow = rd.data.row;
				if(rd.data.col > maxCol) {
					maxCol = rd.data.col;
				}
			}
		}, this);
		this.getSheet().go2Pos(maxRow, maxCol);
	},
	move2LeftMost: function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		this.getSheet().go2Pos(row, 1);
	},
	movePageDown: function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		this.getSheet().go2Pos(row + 25, col);
	},
	movePageUp: function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		var row = row - 25;
		if(row < 1) {
			row = 1;
		}
		this.getSheet().go2Pos(row, col);
	},
	select2TopLeft: function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		sm.selectRange({
			row: 1,
			col: 1
		}, {
			row: row,
			col: col
		});
	},
	select2Top: function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		sm.selectRange({
			row: 1,
			col: col
		}, {
			row: row,
			col: col
		});
	},
	select2Left: function() {
		var sm = this.getSheet().getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		sm.selectRange({
			row: row,
			col: 1
		}, {
			row: row,
			col: col
		});
	},
	insertComment: function() {
		SPOP.showCommentBox({
			title: SLANG.insert_comment,
			applyCallback: {
				fn: function(comment) {
					this.getSheet().insertComment(comment);
				},
				scope: this
			}
		});
	},
	insertVariable: function() {
		var sheet = this.getSheet(),
			sm = sheet.getSelectionModel();
		var focusCell = sm.focusCell,
			sheetId = sheet.getSheetId();
		var str = sheet.coord2StringWithSheetName([
			[sheetId, focusCell.row, focusCell.col, focusCell.row, focusCell.col]
		], "");
		SPOP.showVarTextBox({
			title: SLANG.add_variable_for + str,
			fieldLabel: SLANG.input_variable_name,
			applyCallback: {
				fn: function(name) {
					if(sheet.isValidVariable(name)) {
						sheet.insertVariable(sheetId, focusCell.row, focusCell.col, name);
					} else {
						Ext.Msg.alert(SLANG.hint, SLANG.var_already_defined);
						return true;
					}
				},
				scope: this
			}
		});
	},
	deleteComment: function() {
		this.getSheet().deleteComment();
	},
	addGroup: function() {
		this.getSheet().addGroupForSelection();
	},
	cancelGroup: function() {
		this.getSheet().cancelGroupForSelection();
	},
	insertCheckbox: function() {
		this.getSheet().setItemForSelection("checkbox", SCOM.genTimeStamp());
	},
	insertRadio: function() {
		this.getSheet().setItemForSelection("radio", SCOM.genTimeStamp());
	},
	clearItem: function() {
		this.getSheet().clearItemForSelection();
	},
	markRange: function() {
		this.getSheet().markSelection();
	},
	insertCopied: function() {
		var ss = this.getSheet(),
			clipboard = ss.getClipboard();
		if(clipboard) {
			clipboard.insertCopyRange();
		}
	},
	showValidation: function() {
		if(SPOP) {
			var sheet = this.getSheet();
			var coord = sheet.getSelectionModel().selection2Coord();
			SPOP.showValidationBox({
				sheet: sheet,
				rangeValue: coord
			});
		}
	},
	toggleEditable: function() {
		var ss = this.getSheet();
		var data = ss.getFocusCellData();
		if("ed" === data.dsd) {
			ss.setPropertyForSelection({
				dsd: ""
			});
		} else {
			ss.setPropertyForSelection({
				dsd: "ed"
			});
		}
		var sm = ss.getSelectionModel();
		var focusCell = sm.getFocusCell();
		ss.fireEvent("refreshfocus", focusCell.row, focusCell.col, sm);
	},
	toggleEditableForOther: function() {
		var ss = this.getSheet(),
			store = ss.getStore();
		var data = ss.getFocusCellData();
		var userId = store.getUserInfo().id;
		if(data.dsd && "[" + userId + "]" === data.dsd) {
			ss.setPropertyForSelection({
				dsd: ""
			});
		} else {
			ss.setPropertyForSelection({
				dsd: Ext.encode([userId])
			});
		}
		var sm = ss.getSelectionModel();
		var focusCell = sm.getFocusCell();
		ss.fireEvent("refreshfocus", focusCell.row, focusCell.col, sm);
	},
	toggleGridLine: function() {
		var ss = this.getSheet(),
			me = this.me;
		if(ss.withGridLine()) {
			ss.hideGridLine();
			me.toggleGridLineAction.setText(SLANG.show_grid_line);
		} else {
			ss.showGridLine();
			me.toggleGridLineAction.setText(SLANG.hide_grid_line);
		}
	},
	toggleRowName: function() {
		var ss = this.getSheet(),
			store = ss.getStore(),
			me = this.me;
		if(!store.rowNameHidden) {
			ss.setRowNameVisible(false);
			me.toggleRowNameAction.setText(SLANG.hide_row_name);
		} else {
			ss.setRowNameVisible(true);
			me.toggleRowNameAction.setText(SLANG.show_row_name);
		}
	},
	toggleColName: function() {
		var ss = this.getSheet(),
			store = ss.getStore(),
			me = this.me;
		if(!store.colNameHidden) {
			ss.setColNameVisible(false);
			me.toggleColNameAction.setText(SLANG.hide_col_name);
		} else {
			ss.setColNameVisible(true);
			me.toggleColNameAction.setText(SLANG.show_col_name);
		}
	},
	toggleTitleRegion: function() {
		var ss = this.getSheet(),
			me = this.me;
		if(ss.isTitleRegionVisible()) {
			me.toggleTitleRegionAction.setText(SLANG.show_title_region);
		} else {
			me.toggleTitleRegionAction.setText(SLANG.hide_title_region);
		}
	},
	createPivotTable: function() {
		this.getSheet().createPivotTable();
	},
	setHeaderTitle: function() {
		this.getSheet().setSelectedRowAsHeaderTitle();
	},
	keyboardShortcuts: function() {
		window.open("http://www.enterprisesheet.com/api/docs/features/keyboard.html");
	},
	aboutSheetWin: function() {
		if(window.SABOUT) {
			SABOUT.popup();
		}
	},
	deleteRepeatItem: function() {
		this.getSheet().deleteRepeatItem();
	},
	insertDatePicker: function() {
		this.getSheet().insertDropList({
			drop: "date"
		});
	}
}, function() {
	SABOX = (function() {
		var actionbox = new EnterpriseSheet.sheet.action.ActionBox;
		return {
			bind2Box: function(name, ref, overwrite) {
				if(!actionbox[name] || overwrite) {
					actionbox[name] = ref;
				}
			},
			get: function(name, onceConfig) {
				if(actionbox) {
					var action = actionbox[name + "Action"];
					if(action) {
						onceConfig = onceConfig || {};
						var sender = onceConfig.sender;
						onceConfig.scope = {
							me: actionbox,
							getSheet: function() {
								return sender.sheet;
							},
							sender: sender
						};
						Ext.apply(action.initialConfig, onceConfig);
						action.onceConfig = onceConfig;
						return action;
					}
				}
			},
			updateConfig: function(config) {
				Ext.apply(actionbox, config);
			},
			addHotKey: function(sheet) {
				actionbox.addHotKey(sheet);
			}
		};
	})();
});

Ext.define("EnterpriseSheet.sheet.floating.Arrow", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.common.Common", "Ext.menu.Menu", "EnterpriseSheet.sheet.pop.Popup", "EnterpriseSheet.sheet.pop.datatype.DataTypeConfigWin"],
	constructor: function(config) {
		this.callParent(arguments);
		this.mon(Ext.getBody(), "mousewheel", function() {
			if(this.disabled) {
				if(this.arrowEl && this.arrowEl.isVisible()) {
					this.arrowEl.hide();
					if(this.menu && this.menu.isVisible()) {
						this.menu.hide();
					}
				}
				this.disabled = false;
			}
		}, this);
	},
	afterSheetRender: function() {
		var el = this.sheet.getEl();
		this.arrowEl = Ext.core.DomHelper.append(el, "<div class=\"ss-arrow-box\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"><div class=\"ss-arrow\"></div></div>", true);
		this.arrowEl.hide();
		this.mon(this.arrowEl, {
			scope: this,
			click: this.onArrowClick
		});
	},
	init: function(sheet) {
		this.sheet = sheet;
		this.mon(this.sheet, {
			scope: this,
			cellmousemove: this.cellMouseMove,
			switchsheet: this.hideArrow,
			afterrender: this.afterSheetRender
		});
		this.mon(sheet.getStore(), {
			scope: this,
			afterload: this.hideArrow
		});
	},
	hideArrow: function() {
		if(this.arrowEl) {
			this.arrowEl.hide();
		}
	},
	cellMouseMove: function(row, col, region, e) {
		if(0 === e.button && 1 === e.button) {
			if(this.arrowEl.isVisible()) {
				this.arrowEl.hide();
			}
		} else if(!this.disabled) {
			if(this.sheet.isReadOnly()) {
				this.arrowEl.hide();
				return;
			}
			var cellEl = region.getCellEl(row, col),
				pEl = this.arrowEl.parent();
			if(cellEl) {
				var w = this.arrowEl.getWidth(),
					hw = w / 2,
					h = cellEl.getHeight(),
					hh = h / 2;
				this.cellPos = [region.getSheetId(), row, col];
				if(0 == col && 0 != row) {
					this.arrowEl.setTop(cellEl.getTop() + hh - pEl.getTop() - this.arrowEl.getHeight() / 2);
					this.arrowEl.setLeft(cellEl.getRight() - hw - pEl.getLeft());
					this.arrowEl.show();
				} else if(0 == row && 0 != col) {
					var top = cellEl.getBottom() - hw - pEl.getTop();
					this.arrowEl.setTop(top);
					var left = Math.round((cellEl.getRight() + cellEl.getLeft()) / 2 - hw) - pEl.getLeft();
					this.arrowEl.setLeft(left);
					this.arrowEl.show();
				} else if(this.arrowEl.isVisible()) {
					this.arrowEl.hide();
				}
			}
		}
	},
	onArrowClick: function(e) {
		var menu = this.getMenu();
		if(menu == null) {
			return;
		}
		if(0 === this.cellPos[1]) {
			this.sortAscItem.show();
			this.sortDescItem.show();
			this.columnWidthItem.show();
			this.filterItem.show();
			this.rowHeightItem.hide();
			this.configItem.show();
			this.colTitleItem.show();
			this.iconItem.show();
			this.hideTitleItem.show();
			this.showTitleItem.show();
		} else {
			this.sortAscItem.hide();
			this.sortDescItem.hide();
			this.filterItem.hide();
			this.columnWidthItem.hide();
			this.rowHeightItem.show();
			this.configItem.hide();
			this.colTitleItem.hide();
			this.iconItem.hide();
			this.hideTitleItem.hide();
			this.showTitleItem.hide();
		}
		var col = this.cellPos[2];
		var cell = this.sheet.getStore().getCell(this.sheet.getSheetId(), 0, col);
		if(0 === this.cellPos[1]) {
			if(cell.hideTitle) {
				this.hideTitleItem.hide();
				this.showTitleItem.show();
			} else {
				this.hideTitleItem.show();
				this.showTitleItem.hide();
			}
		}
		menu.showBy(this.arrowEl);
	},
	getMenu: function() {
		if(!this.menu) {
			this.sortAscItem = new Ext.menu.Item({
				iconCls: "icon-sort-asc",
				text: SLANG.sort_asc,
				handler: this.sortAsc,
				disabled: SCONFIG.SORT_DISABLE,
				scope: this
			});
			this.sortDescItem = new Ext.menu.Item({
				iconCls: "icon-sort-desc",
				text: SLANG.sort_desc,
				handler: this.sortDesc,
				disabled: SCONFIG.SORT_DISABLE,
				scope: this
			});
			this.filterItem = new Ext.menu.Item({
				iconCls: "icon-filter",
				text: SLANG.filtering + "...",
				handler: this.doFilter,
				scope: this
			});
			this.columnWidthItem = new Ext.menu.Item({
				iconCls: "icon-column-width",
				text: SLANG.column_width,
				handler: this.changeColumnWidth,
				scope: this
			});
			this.rowHeightItem = new Ext.menu.Item({
				iconCls: "icon-row-height",
				text: SLANG.row_height,
				handler: this.changeRowHeight,
				scope: this
			});
			this.hideItem = new Ext.menu.Item({
				text: SLANG.hide,
				handler: this.hideRange,
				scope: this
			});
			this.deleteItem = new Ext.menu.Item({
				iconCls: "icon-delete",
				text: SLANG['delete'],
				handler: this.deleteRange,
				scope: this
			});
			this.colTitleField = new Ext.form.field.Text({
				width: 200,
				enableKeyEvents: true
			});
			this.mon(this.colTitleField, {
				scope: this,
				keydown: this.onColTitleFieldKeyDown
			});
			this.colTitleItem = new Ext.menu.Item({
				text: SLANG.column_title,
				menu: {
					plain: true,
					items: [{
						xtype: "label",
						cls: "sc-menu-label",
						text: SLANG.input_column_title
					}, this.colTitleField],
					listeners: {
						show: {
							fn: this.onColTitleFieldShow,
							scope: this
						}
					}
				}
			});
			this.iconView = Ext.create("Ext.view.View", {
				store: SCOM.titleIconStore,
				tpl: SCOM.titleIconTpl,
				width: 150,
				itemSelector: "div.ss-title-icon",
				overItemCls: "ss-iconset-over"
			});
			this.iconView.on("itemclick", this.onIconClick, this);
			this.iconItem = new Ext.menu.Item({
				text: SLANG.col_icon,
				menu: {
					xtype: "menu",
					plain: true,
					items: [{
						xtype: "container",
						padding: 10,
						items: [this.iconView]
					}]
				}
			});
			this.configItem = new Ext.menu.Item({
				iconCls: "icon-wrench",
				text: SLANG.dataTypeConf,
				handler: this.configColumn,
				scope: this
			});
			this.hideTitleItem = new Ext.menu.Item({
				text: SLANG.hide_title,
				handler: this.hideTitle,
				scope: this
			});
			this.showTitleItem = new Ext.menu.Item({
				text: SLANG.show_title,
				handler: this.showTitle,
				scope: this
			});
			this.items = [];
			var deafultList = SCONFIG.arrowmenu_items;
			for(var i = 0; i < deafultList.length; i++) {
				var item = deafultList[i];
				if(Ext.isObject(item)) {
					this.items.push(item);
				} else {
					if(item == "-") {
						this.items.push("-");
					} else {
						if(this[item + "Item"]) {
							this.items.push(this[item + "Item"]);
						}
					}
				}
			}
			if(this.items.length == 0) {
				return null;
			}
			this.menu = new Ext.menu.Menu({
				items: this.items
			});
			this.mon(this.menu, {
				scope: this,
				show: function() {
					this.disabled = true;
				},
				hide: function() {
					delete this.disabled;
				}
			});
		}
		return this.menu;
	},
	onColTitleFieldKeyDown: function(field, e) {
		if(e.ENTER == e.getKey()) {
			e.stopEvent();
			var title = this.colTitleField.getValue();
			this.sheet.setColumnTitle(this.cellPos[0], this.cellPos[2], title);
			this.menu.hide();
		}
	},
	onColTitleFieldShow: function() {
		var menu = this.menu;
		var col = this.cellPos[2];
		var title = this.sheet.getStore().getCell(this.sheet.getSheetId(), 0, col).data;
		this.colTitleField.setValue(title);
	},
	onIconClick: function(view, rec) {
		var data = rec.data;
		var col = this.cellPos[2];
		this.sheet.setColumnIcon(col, data.idx);
		this.menu.hide();
	},
	sortAsc: function() {
		var pos = this.cellPos;
		if(pos) {
			var col = pos[2];
			var sheet = this.sheet,
				sheetId = pos[0];
			sheet.checkSortSpan([sheetId, 0, col, 0, col], null, "asc");
		}
	},
	sortDesc: function() {
		var pos = this.cellPos;
		if(pos) {
			var col = pos[2];
			var sheet = this.sheet,
				sheetId = pos[0];
			sheet.checkSortSpan([sheetId, 0, col, 0, col], null, "desc");
		}
	},
	doFilter: function() {
		var pos = this.cellPos;
		if(pos) {
			var col = pos[2];
			var sheet = this.sheet,
				sheetId = pos[0];
			var span = [sheetId, 0, col, 0, col];
			var filter = sheet.getFilter();
			if(filter) {
				var store = sheet.getStore();
				if(store.withFilterInSheet(sheetId)) {
					filter.removeFilter();
				}
				filter.createFilterForSpan(span);
			}
		}
	},
	hideRange: function() {
		var pos = this.cellPos;
		if(pos) {
			var sheet = this.sheet,
				sheetId = pos[0];
			var row = pos[1],
				col = pos[2];
			if(0 == row) {
				sheet.hideColumn({
					mincol: col,
					maxcol: col
				});
			} else if(0 == col) {
				sheet.hideRow({
					minrow: row,
					maxrow: row
				});
			}
		}
	},
	deleteRange: function() {
		var pos = this.cellPos;
		if(pos) {
			var sheet = this.sheet,
				sheetId = pos[0];
			var row = pos[1],
				col = pos[2];
			if(0 == row) {
				sheet.deleteColumn({
					mincol: col,
					maxcol: col
				});
			} else if(0 == col) {
				sheet.deleteRow({
					minrow: row,
					maxrow: row
				});
			}
		}
	},
	changeColumnWidth: function() {
		var pos = this.cellPos;
		if(pos) {
			var sheet = this.sheet,
				sheetId = pos[0];
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			var mincol = pos.mincol,
				maxcol = pos.maxcol;
			SPOP.showColumnWidthBox({
				applyCallback: {
					fn: function(w) {
						var store = sheet.getStore();
						sheet.setColumnWidth(w, {
							mincol: mincol,
							maxcol: maxcol
						});
					},
					scope: this
				}
			});
		}
	},
	changeRowHeight: function() {
		var pos = this.cellPos;
		if(pos) {
			var sheet = this.sheet,
				sheetId = pos[0];
			var sm = sheet.getSelectionModel();
			var pos = sm.getMinMaxPos();
			var minrow = pos.minrow,
				maxrow = pos.maxrow;
			SPOP.showRowHeightBox({
				applyCallback: {
					fn: function(h) {
						var store = sheet.getStore();
						sheet.setRowHeight(h, {
							minrow: minrow,
							maxrow: maxrow
						});
					},
					scope: this
				}
			});
		}
	},
	configColumn: function() {
		if(!this.configWin) {
			this.configWin = Ext.create("EnterpriseSheet.sheet.pop.datatype.DataTypeConfigWin", {
				title: SLANG.column_data_type_config,
				sheet: this.sheet,
				sheetId: this.cellPos[0],
				applyCallback: {
					fn: function(param) {
						var pos = this.cellPos;
						var col = pos[2],
							coord = [
								[pos[0], 0, col, 0, col]
							];
						var range = new EnterpriseSheet.sheet.range.Range({
							sheet: this.sheet,
							coord: coord
						});
						if(param) {
							param.id = this.sheet.getStore().genNewColumnId();
							range.setProperty({
								dcfg: Ext.encode(param)
							}, ["it", "itn", "itchk", "fm", "dfm"], true);
						} else {
							range.setProperty(undefined, ["dcfg", "it", "itn", "itchk", "fm", "dfm"], true);
						}
						if(param && param.titleIcon) {
							this.sheet.setColumnIcon(col, param.titleIcon);
						} else {
							this.sheet.cleanColumnIcon(col);
						}
						if(param && param.title) {
							this.sheet.setColumnTitle(null, col, param.title);
						}
						range.refresh();
						this.sheet.refreshFocus();
					},
					scope: this
				},
				cleanCallback: {
					fn: function() {
						var pos = this.cellPos,
							store = this.sheet.getStore(),
							sep = store.separateChar;
						var col = pos[2],
							coord = [
								[pos[0], 0, col, 0, col]
							];
						var range = new EnterpriseSheet.sheet.range.Range({
							sheet: this.sheet,
							coord: coord
						});
						var cell = store.getCell(pos[0], 0, col),
							dcfg = cell.dcfg;
						if(dcfg) {
							dcfg = Ext.decode(dcfg);
							var spanCdtMap = {};
							for(var i = 0, len = coord.length; i < len; i++) {
								var span = coord[i];
								var spanId = span.join(sep);
								var o = {};
								o.span = span;
								o.cdtIds = {};
								o.cdtIds[dcfg.id] = true;
								spanCdtMap[spanId] = o;
							}
							range.setProperty(undefined, ["dcfg", "it", "itn", "itchk", "fm", "dfm"], true);
							this.sheet.clearCdtValForSpanCdt(spanCdtMap);
							this.sheet.cleanColumnIcon(col);
							range.refresh();
							this.sheet.refreshFocus();
						}
					},
					scope: this
				},
				hideCallback: {
					fn: function() {
						this.enable();
					},
					scope: this
				}
			});
		}
		var pos = this.cellPos;
		var cell = this.sheet.getStore().getCell(pos[0], 0, pos[2]);
		var dcfg, title;
		if(cell.dcfg) {
			dcfg = Ext.decode(cell.dcfg);
		}
		if(cell.data) {
			title = cell.data;
		}
		this.configWin.popup(dcfg, title);
		this.disable();
	},
	hideTitle: function() {
		var pos = this.cellPos;
		this.sheet.setColumnTitleVisible(false, pos[2], pos[2]);
	},
	showTitle: function() {
		var pos = this.cellPos;
		this.sheet.setColumnTitleVisible(true, pos[2], pos[2]);
	},
	disable: function() {
		this.disabled = true;
	},
	enable: function() {
		delete this.disabled;
	}
});

Ext.define("EnterpriseSheet.sheet.floating.ActionPane", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.common.Common", "Ext.menu.Menu"],
	constructor: function(config) {
		this.callParent(arguments);
		this.mon(Ext.getBody(), "mousewheel", function() {
			if(this.disabled) {
				if(this.paneEl && this.paneEl.isVisible()) {
					this.paneEl.hide();
					if(this.menu && this.menu.isVisible()) {
						this.menu.hide()
					}
				}
				this.disabled = false
			}
		}, this)
	},
	afterSheetRender: function() {
		var el = this.sheet.getEl();
		this.paneEl = Ext.core.DomHelper.append(el, '<div class="ss-action-pane ' + (this.cls || "") + '" style="z-index:' + SCONST.TOP_Z_INDEX + ';"></div>', true);
		this.paneEl.hide();
		this.mon(this.paneEl, {
			scope: this,
			click: this.onPaneClick
		})
	},
	init: function(sheet) {
		this.sheet = sheet;
		this.mon(this.sheet, {
			scope: this,
			switchsheet: this.hidePane,
			afterrender: this.afterSheetRender
		});
		this.mon(sheet.getStore(), {
			scope: this,
			afterload: this.hidePane
		})
	},
	hidePane: function() {
		if(this.paneEl) {
			this.paneEl.hide()
		}
	},
	onPaneClick: function(e) {},
	disable: function() {
		this.disabled = true
	},
	enable: function() {
		delete(this.disabled)
	}
});
Ext.define("EnterpriseSheet.sheet.floating.DynamicRangePane", {
	extend: "EnterpriseSheet.sheet.floating.ActionPane",
	requires: [],
	cls: "ss-dr-pane",
	init: function(sheet) {
		this.callParent(arguments);
		this.mon(sheet, {
			scope: this,
			cellmousemove: this.cellMouseMove
		})
	},
	afterSheetRender: function() {
		var el = this.sheet.getEl();
		this.paneEl = Ext.core.DomHelper.append(el, '<div class="ss-action-pane ' + (this.cls || "") + '" style="z-index:' + SCONST.TOP_Z_INDEX + ';"><span class="fa fa-plus-circle fa-lg"></span>&nbsp;<span class="fa fa-minus-circle fa-lg"></span></div>', true);
		this.paneEl.hide();
		this.mon(this.paneEl, {
			scope: this,
			click: this.onPaneClick
		});
		this.paneEl.down("span.fa-plus-circle").on("click", function(e) {
			var pos = this.cellPos;
			if(pos) {
				this.sheet.fireEvent("insertdynamicrange", this.drJson, pos, this)
			}
		}, this);
		this.paneEl.down("span.fa-minus-circle").on("click", function(e) {
			var pos = this.cellPos;
			if(pos) {
				this.sheet.fireEvent("deletedynamicrange", this.drJson, pos, this)
			}
		}, this)
	},
	cellMouseMove: function(row, col, region, e) {
		if(0 === e.button && 1 === e.button) {
			if(this.paneEl.isVisible()) {
				this.paneEl.hide()
			}
		} else {
			if(!this.disabled) {
				if(this.sheet.isReadOnly()) {
					this.paneEl.hide();
					return
				}
				var cellEl = region.getCellEl(row, col),
					pEl = this.paneEl.parent();
				if(cellEl) {
					var w = this.paneEl.getWidth(),
						h = cellEl.getHeight(),
						hh = h / 2;
					var sheetId = region.getSheetId();
					this.cellPos = [sheetId, row, col];
					if(0 !== col && 0 !== row) {
						var drInfo = this.isDynamicRangeHeader(sheetId, row, col);
						this.drJson = drInfo;
						if(drInfo) {
							this.paneEl.setTop(cellEl.getTop() + hh - pEl.getTop() - this.paneEl.getHeight() / 2);
							var left = Math.round((cellEl.getRight() + cellEl.getLeft()) / 2 - w) - pEl.getLeft();
							this.paneEl.setLeft(left);
							this.paneEl.show()
						} else {
							if(this.paneEl.isVisible()) {
								this.paneEl.hide()
							}
						}
					} else {
						if(this.paneEl.isVisible()) {
							this.paneEl.hide()
						}
					}
				}
			}
		}
	},
	isDynamicRangeHeader: function(sheetId, row, col) {
		var store = this.sheet.getStore();
		var cell = store.getCell(sheetId, row, col);
		var floatings = store.getFloatings(),
			arr = [];
		for(var p in floatings) {
			if(floatings.hasOwnProperty(p)) {
				var it = floatings[p];
				if("dynamicRange" === it.ftype) {
					var jsonObj = it.jsonObj || Ext.decode(it.json);
					it.jsonObj = jsonObj;
					var dir = jsonObj.type,
						span = jsonObj.span;
					if("row" === dir) {
						if(span[0] === sheetId && col === span[2] && it.name === cell.drheader) {
							return it
						}
					} else {
						if(span[0] === sheetId && row === span[1] && it.name === cell.drheader) {
							return it
						}
					}
				}
			}
		}
		if(0 < arr.length) {
			return arr
		}
	}
});

Ext.define("EnterpriseSheet.sheet.floating.CalculateHint", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.common.Common", "Ext.view.View"],
	constructor: function() {
		var picker = this.getPicker();
		picker.store.loadData(this.hintData);
		this.callParent(arguments);
		this.mon(Ext.getBody(), "mousedown", function(e) {
			var el = picker.getEl();
			var rmEl = this.readmeComp.getEl();
			if(!e.within(el.dom) && !e.within(rmEl.dom)) {
				picker.hide();
				this.readmeComp.hide();
			}
		}, this);
		this.mon(picker, {
			scope: this,
			itemclick: this.onHintItemClick,
			highlightitem: this.onHintItemHighlight,
			selectionchange: this.onHintSelectionChange
		});
		this.on("hintdatachange", function() {
			alert("hintdatachange");
		});
	},
	init: function(sheet) {
		this.sheet = sheet, store = sheet.getStore();
		this.mon(sheet, "editorkeyup", this.onEditorKeyup, this, {
			buffer: 50
		});
		this.mon(sheet, {
			scope: this,
			afterloadsheet: this.onAfterLoadSheet,
			quitedit: this.onQuitEdit,
			editornavigatedown: this.onEditorNavigateDown,
			editornavigateup: this.onEditorNavigateUp,
			beforeeditorspecialkey: this.beforeEditorSpecialKey
		});
		this.mon(store, {
			scope: this,
			namedfuncconfigchange: this.onNamedFuncConfigChange
		});
	},
	onAfterLoadSheet: function() {
		var store = this.sheet.getStore();
		this.onNamedFuncConfigChange(null, store);
	},
	onNamedFuncConfigChange: function(refConfigStr, store) {
		var picker = this.getPicker();
		var hintStore = picker.store;
		var refConfigs = store.getNamedFuncConfig(),
			curSheetId = store.getActivedSheetId();
		var map = {},
			data = [];
		for(var i = 0, len = refConfigs.length; i < len; i++) {
			var it = refConfigs[i];
			map[it.name] = it;
		}
		for(var p in map) {
			if(map.hasOwnProperty(p)) {
				var it = map[p],
					ctype = it.ctype;
				var str = "",
					json, cal, comment;
				try {
					json = it.jsonArr;
					if(Ext.isArray(json)) {
						var match;
						for(var i = 0, len = json.length; i < len; i++) {
							var o = json[i],
								scope = o.scope;
							if(!Ext.isDefined(match)) {
								match = o;
							}
							if(scope === curSheetId) {
								match = o;
								break;
							}
						}
					} else {
						match = json;
					}
					cal = !Ext.isString(match.cal) ? Ext.encode(match.cal) : match.cal;
					comment = match.comment;
				} catch(e) {
					json = it.json;
					cal = json;
				}
				if("ref" === ctype) {
					str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.transferCoordInStr(cal, function(coord) {
						var span = coord.span;
						span[0] = store.getSheetNameById(span[0]);
						var res = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([coord], undefined, true);
						return res;
					}, this);
				} else {
					str = cal;
				}
				if(comment) {
					str += "<p>" + comment + "</p>";
				}
				data.push([it.name, it.name, str, "var"]);
			}
		}
		data = data.concat(this.hintData);
		hintStore.loadData(data);
	},
	guessFunName: function(str, pos) {
		var name = [];
		var len = str.length;
		if(pos >= len) {
			pos = len - 1;
		}
		var index = 0;
		for(var i = pos; 0 <= i; i--) {
			var ch = str.charAt(i);
			if(/[\,\=\(\[\{\s\+\-\*\/\%]/g.test(ch)) {
				index = i + 1;
				break;
			}
			name.unshift(ch);
		}
		name = name.join("");
		this.startPos = index;
		this.endPos = pos;
		return name;
	},
	onEditorKeyup: function(e, row, col, region, editor, isCal) {
		if(e) {
			var key = e.getKey();
			if(e.ENTER == key || e.ESC == key || e.TAB == key) {
				return;
			}
		}
		this.editor = editor;
		if(editor.isAvailable()) {
			var cursorPos = editor.getCursorPos() - 1;
			if(Ext.isGecko) {
				cursorPos++;
			}
			var value = editor.getRawTextValue();
			var picker = this.getPicker();
			var showFlag = false;
			var store = picker.store;
			if(isCal) {
				store.clearFilter();
				var fname = this.guessFunName(value, cursorPos);
				if(fname) {
					var reg = new RegExp("^" + Ext.String.escapeRegex(fname), "i");
					store.filterBy(function(rec, id) {
						if(reg.test(rec.data.id)) {
							showFlag = true;
							return true;
						}
					}, this);
				}
			}
			if(showFlag) {
				if(!picker.isVisible()) {
					var el = editor.getEl();
					if(picker.getNodes().length) {
						var sm = picker.getSelectionModel();
						sm.deselectAll();
						picker.show();
						var prePiece = value.slice(0, cursorPos);
						var w = this.measureWidthInCell(this.sheet.getSheetId(), row, col, prePiece);
						picker.alignTo(el, undefined, [w, 0]);
						this.readmeComp.show();
						this.readmeComp.alignTo(picker.getEl(), "tl-tr?");
					}
				}
				this.highlightFirstHint();
			} else {
				if(picker.isVisible()) {
					picker.hide();
					this.readmeComp.hide();
				}
				picker.setPosition(-1000, -1000);
			}
		}
	},
	measureWidthInCell: function(sheetId, row, col, txt) {
		var store = this.sheet.getStore();
		var cellTpl = SLAYOUT.cell;
		var cell = store.getCellData(sheetId, row, col);
		cell.width = "auto";
		cell.data = txt;
		var measureEl = Ext.core.DomHelper.append(document.body, "<div class=\"ss-guess-measure\"></div>", true);
		var mel = cellTpl.overwrite(measureEl, cell, true);
		var w = mel.getWidth();
		measureEl.remove();
		return w;
	},
	onEditorNavigateDown: function(editor) {
		var picker = this.getPicker();
		if(picker.isVisible()) {
			this.highlightNext();
			return false;
		}
	},
	onEditorNavigateUp: function(editor) {
		var picker = this.getPicker();
		if(picker.isVisible()) {
			this.highlightLast();
			return false;
		}
	},
	beforeEditorSpecialKey: function(key, editor, sheet) {
		var picker = this.getPicker();
		if(picker.isVisible()) {
			var keyObj = Ext.EventObject ? Ext.EventObject : Ext.event.Event;
			if(keyObj.ENTER == key) {
				var nodes = picker.getSelectedNodes();
				if(0 < nodes.length) {
					var node = nodes[0];
					var rec = picker.getRecord(node);
					this.selectCalculate(rec.data.id, rec.data.rtype);
					return false;
				}
			} else if(keyObj.ESC == key) {
				this.getPicker().hide();
				this.readmeComp.hide();
				return false;
			}
		}
	},
	highlightFirstHint: function() {
		var picker = this.getPicker();
		var node = picker.getNodes(0, 0)[0];
		var sm = picker.getSelectionModel();
		sm.select(node);
	},
	highlightNext: function() {
		var picker = this.getPicker();
		var el = picker.getEl();
		var sm = picker.getSelectionModel();
		var sels = picker.getSelectedNodes();
		var node;
		if(0 < sels.length) {
			var index = picker.indexOf(sels[0]);
			index++;
			var nodes = picker.getNodes();
			var count = nodes.length;
			if(index < count) {
				node = nodes[index];
				sm.select(index);
			}
		} else {
			var nodes = picker.getNodes();
			node = nodes[0];
			sm.select(0);
		}
		if(node) {
			var offset = Ext.get(node).getBottom() - el.getBottom();
			if(0 < offset) {
				picker.scrollBy({
					x: 0,
					y: 30
				});
			}
		}
	},
	highlightLast: function() {
		var picker = this.getPicker();
		var el = picker.getEl();
		var sm = picker.getSelectionModel();
		var sels = picker.getSelectedNodes();
		var node;
		if(0 < sels.length) {
			var index = picker.indexOf(sels[0]);
			index--;
			var nodes = picker.getNodes();
			var count = nodes.length;
			if(0 <= index) {
				node = nodes[index];
				sm.select(index);
			}
		} else {
			var nodes = picker.getNodes();
			var index = nodes.length - 1;
			node = nodes[index];
			sm.select(index);
		}
		if(node) {
			var offset = Ext.get(node).getTop() - el.getTop();
			if(0 > offset) {
				picker.scrollBy({
					x: 0,
					y: -30
				});
			}
		}
	},
	onQuitEdit: function() {
		var picker = this.getPicker();
		picker.hide();
		this.readmeComp.hide();
	},
	getPicker: function() {
		if(!this.picker) {
			var hintStore = this.hintStore;
			var hintTpl = new Ext.XTemplate("<tpl for=\".\">", "<div class=\"ss-cal-hint-item\">", "<span class=\"{[\"var\"==values.rtype?\"ss-var-hint\":\"ss-fun-hint\"]}\">{calculate}</span>", "</div>", "</tpl>");
			this.picker = new Ext.view.View({
				cls: "ss-cal-hint",
				autoWidth: true,
				singleSelect: false,
				multiSelect: false,
				trackOver: true,
				overItemCls: "x-item-over",
				itemSelector: "div.ss-cal-hint-item",
				style: "z-index:" + SCONST.TOP_Z_INDEX + ";",
				store: hintStore,
				scrollable: "y",
				tpl: hintTpl,
				selModel: {
					preventFocus: true
				},
				renderTo: Ext.getBody()
			});
			this.picker.hide();
			this.readmeComp = new Ext.Component({
				cls: "ss-cal-readme",
				style: "z-index:" + SCONST.TOP_Z_INDEX + ";",
				renderTo: Ext.getBody()
			});
			this.readmeComp.hide();
		}
		return this.picker;
	},
	onHintItemClick: function(view, rec, node, index) {
		var fname = rec.data.id;
		this.selectCalculate(fname, rec.data.rtype);
	},
	selectCalculate: function(fname, rtype) {
		var editor = this.editor;
		var value = editor.getRawTextValue();
		var pre = value.slice(0, this.startPos),
			pos = value.slice(this.endPos + 1, value.length);
		var nv;
		if("var" == rtype) {
			nv = pre + fname;
		} else {
			nv = pre + fname + "(";
		}
		var cursorPos = nv.length;
		nv += pos;
		editor.setValue(nv, true);
		editor.focus();
		editor.setCursorPos(cursorPos, true);
		this.getPicker().hide();
		this.readmeComp.hide();
	},
	onHintItemHighlight: function(view, node) {
		var picker = this.getPicker();
		var rec = picker.getRecord(node);
		var summary = rec.data.summary;
		this.readmeComp.getEl().update(summary);
	},
	onHintSelectionChange: function(view, nodes) {
		var picker = this.getPicker();
		var nodes = picker.getSelectedNodes();
		if(0 < nodes.length) {
			var rec = picker.getRecord(nodes[0]);
			var summary = rec.data.summary;
			this.readmeComp.getEl().update(summary);
		}
	}
}, function() {
	Ext.apply(EnterpriseSheet.sheet.floating.CalculateHint.prototype, {
		addHint: function(hint) {
			if(hint) {
				if(Ext.isArray(hint[0])) {
					this.hintData = this.hintData.concat(hint);
				} else {
					this.hintData.push(hint);
				}
				this.hintStore.loadData(this.hintData);
			}
		},
		hintStore: new Ext.data.ArrayStore({
			fields: ["id", "calculate", "summary", "rtype"]
		}),
		hintData: SLANG.FORMULA_NAME_LIST
	});
});

Ext.define("EnterpriseSheet.sheet.floating.chart.ChartFloor", {
	extend: "EnterpriseSheet.sheet.floating.Floor",
	requires: ["EnterpriseSheet.sheet.pop.Popup", "Ext.chart.*"],
	constructor: function(chartType, config, suspendPulling) {
		var store = config.store;
		var yFields = [];
		for(var i = 0, len = store.cacheFields.length; i < len; i++) {
			var field = store.cacheFields[i];
			var name = field.name;
			if("category" != name) {
				yFields.push(name);
			}
		}
		if(config.source && config.source.series) {
			var slen = config.source.series.length;
			yFields.splice(slen, yFields.length - slen);
		}
		config.yFields = yFields;
		config = this.prepareConfig(chartType, config);
		var sheet = config.sheet;
		var floatingConfig = {
			resizeConfig: {
				dynamic: false,
				pinned: false,
				handles: "all"
			},
			xtype: "container",
			cls: "ss-chart-ct",
			layout: "fit",
			withTool: true
		};
		this.rangeStore = config.store;
		this.yFields = [].concat(yFields);
		this.sheet = sheet;
		var arr = ["x", "y", "width", "height", "resizeConfig", "ddConfig"];
		Ext.copyTo(floatingConfig, config, arr);
		arr.push("sheet");
		Ext.each(arr, function(it) {
			delete config[it];
		});
		config.xtype = config.xtype || "chart";
		if(!SCOM.nullOrUndefined(config.id)) {
			config.floorId = config.id;
			delete config.id;
		}
		floatingConfig.items = [config];
		this.callParent([{
			floorId: config.floorId,
			sheet: sheet,
			floatingConfig: floatingConfig
		}, suspendPulling]);
		this.mon(this.rangeStore, {
			scope: this,
			fieldtitlechange: this.onFieldTitleChange,
			relatedcoordchange: this.onRelatedCoordChange
		});
		this.addListenerForFloatings("showfloorsetting", this.showChartSetting, this);
		this.addListenerForFloatings("elmousedown", this.onFloorMouseDown, this);
	},
	prepareConfig: function(chartType, config) {
		this.chartType = chartType;
		var getConfig = "get" + Ext.util.Format.capitalize(chartType) + "Config";
		if(this[getConfig]) {
			return Ext.applyIf(config, this[getConfig](config.yFields, config));
		}
	},
	getColumnConfig: function(yFields, config) {
		config = config || {};
		if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					docked: config.legendPosition || "right"
				},
				axes: [{
					type: "numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "category",
					position: "bottom",
					title: config.xTitle,
					fields: "category"
				}],
				series: [{
					type: "bar",
					stacked: false,
					highlight: true,
					xField: "category",
					yField: yFields,
					style: {
						lineWidth: 1,
						stroke: "#666",
						opacity: 0.86
					}
				}]
			};
		} else {
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					position: config.legendPosition || "right"
				},
				axes: [{
					type: "Numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "Category",
					position: "bottom",
					title: config.xTitle,
					fields: ["category"]
				}],
				series: [{
					type: "column",
					highlight: true,
					xField: "category",
					yField: yFields,
					style: {
						lineWidth: 1,
						stroke: "#666",
						opacity: 0.86
					}
				}]
			};
		}
	},
	getAreaConfig: function(yFields, config) {
		config = config || {};
		if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					docked: config.legendPosition || "right"
				},
				axes: [{
					type: "numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "category",
					position: "bottom",
					title: config.xTitle,
					fields: "category"
				}],
				series: [{
					type: "area",
					highlight: true,
					xField: "category",
					yField: yFields,
					style: {
						lineWidth: 1,
						stroke: "#666",
						opacity: 0.86
					}
				}]
			};
		} else {
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					position: config.legendPosition || "right"
				},
				axes: [{
					type: "Numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "Category",
					position: "bottom",
					title: config.xTitle,
					fields: ["category"]
				}],
				series: [{
					type: "area",
					highlight: true,
					xField: "category",
					yField: yFields,
					style: {
						lineWidth: 1,
						stroke: "#666",
						opacity: 0.86
					}
				}]
			};
		}
	},
	getPieConfig: function(yFields, config) {
		config = config || {};
		if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
			return {
				xtype: "polar",
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					docked: config.legendPosition || "right"
				},
				series: [{
					type: "pie",
					highlight: true,
					angleField: yFields[0],
					title: config.yTitle,
					showInLegend: true,
					highlight: {
						segment: {
							margin: 20
						}
					},
					label: {
						field: "category",
						display: "rotate",
						contrast: true,
						font: "18px Arial"
					}
				}]
			};
		} else {
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					position: config.legendPosition || "right"
				},
				series: [{
					type: "pie",
					highlight: true,
					field: yFields[0],
					title: config.yTitle,
					showInLegend: true,
					highlight: {
						segment: {
							margin: 20
						}
					},
					label: {
						field: "category",
						display: "rotate",
						contrast: true,
						font: "18px Arial"
					}
				}]
			};
		}
	},
	getLineConfig: function(yFields, config) {
		config = config || {};
		var series = [],
			colors = SCOM.colors,
			clen = colors.length,
			mlen = SCONST.MARKER_SHAPES.length;
		if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
			for(var i = 0, len = yFields.length; i < len; i++) {
				var c = i % clen,
					m = i % mlen,
					marker = SCONST.MARKER_SHAPES[m];
				series.push({
					type: "line",
					marker: {
						type: marker
					},
					style: {
						opacity: 0.9,
						'stroke-width': 2
					},
					showMarkers: true,
					axis: "left",
					highlight: true,
					xField: "category",
					yField: yFields[i]
				});
			}
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					docked: config.legendPosition || "right"
				},
				axes: [{
					type: "numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "category",
					position: "bottom",
					title: config.xTitle,
					fields: ["category"]
				}],
				series: series
			};
		} else {
			for(var i = 0, len = yFields.length; i < len; i++) {
				var c = i % clen,
					marker = SCONST.MARKER_SHAPES[c];
				series.push({
					type: "line",
					markerConfig: {
						type: marker,
						radius: 3,
						size: 3
					},
					style: {
						opacity: 0.9,
						'stroke-width': 2,
						fill: colors[c]
					},
					showMarkers: false,
					axis: "left",
					highlight: true,
					xField: "category",
					yField: yFields[i]
				});
			}
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					position: config.legendPosition || "right"
				},
				axes: [{
					type: "Numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "Category",
					position: "bottom",
					title: config.xTitle,
					fields: ["category"]
				}],
				series: series
			};
		}
	},
	getBarConfig: function(yFields, config) {
		config = config || {};
		if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
			return {
				xtype: "cartesian",
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					docked: config.legendPosition || "right"
				},
				axes: [{
					type: "numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "category",
					position: "bottom",
					title: config.xTitle,
					fields: "category",
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					}
				}],
				series: [{
					type: "bar",
					highlight: true,
					xField: "category",
					yField: yFields,
					style: {
						lineWidth: 1,
						stroke: "#666",
						opacity: 0.86
					}
				}]
			};
		} else {
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					position: config.legendPosition || "right"
				},
				axes: [{
					type: "Numeric",
					position: "bottom",
					fields: yFields,
					title: config.yTitle,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "Category",
					position: "left",
					title: config.xTitle,
					fields: ["category"]
				}],
				series: [{
					type: "bar",
					highlight: true,
					xField: "category",
					yField: yFields,
					style: {
						lineWidth: 1,
						stroke: "#666",
						opacity: 0.86
					}
				}]
			};
		}
	},
	getScatterConfig: function(yFields, config) {
		config = config || {};
		var series = [],
			mlen = SCONST.MARKER_SHAPES.length,
			colors = SCOM.colors,
			clen = colors.length;
		if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
			for(var i = 0, len = yFields.length; i < len; i++) {
				var m = i % mlen,
					marker = SCONST.MARKER_SHAPES[m];
				var c = i % clen;
				series.push({
					type: "scatter",
					marker: {
						type: marker,
						radius: 5,
						size: 5
					},
					highlight: true,
					xField: "category",
					yField: yFields[i]
				});
			}
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					docked: config.legendPosition || "right"
				},
				axes: [{
					type: "numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "category",
					position: "bottom",
					title: config.xTitle,
					fields: ["category"]
				}],
				series: series
			};
		} else {
			for(var i = 0, len = yFields.length; i < len; i++) {
				var m = i % mlen,
					marker = SCONST.MARKER_SHAPES[m];
				var c = i % clen;
				series.push({
					type: "scatter",
					markerConfig: {
						type: marker,
						radius: 5,
						size: 5
					},
					style: {
						fill: colors[c]
					},
					highlight: true,
					xField: "category",
					yField: yFields[i]
				});
			}
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				legend: {
					position: config.legendPosition || "right"
				},
				axes: [{
					type: "Numeric",
					position: "left",
					title: config.yTitle,
					fields: yFields,
					label: {
						renderer: Ext.util.Format.numberRenderer("0,0.0")
					},
					grid: true
				}, {
					type: "Category",
					position: "bottom",
					title: config.xTitle,
					fields: ["category"]
				}],
				series: series
			};
		}
	},
	getRadarConfig: function(yFields, config) {
		config = config || {};
		var series = [],
			colors = SCOM.colors,
			clen = colors.length;
		if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
			for(var i = 0, len = yFields.length; i < len; i++) {
				var c = i % clen;
				series.push({
					type: "radar",
					xField: "category",
					yField: yFields[i],
					showInLegend: true,
					showMarkers: false,
					marker: {
						type: "circle",
						radius: 3,
						size: 3
					},
					style: {
						opacity: 0.4,
						'stroke-width': 2,
						fill: colors[c]
					}
				});
			}
			return {
				xtype: "polar",
				style: "background:white;",
				animate: true,
				shadow: true,
				insetPadding: 20,
				legend: {
					docked: config.legendPosition || "right"
				},
				axes: [{
					type: "numeric",
					position: "radial",
					title: config.yTitle,
					label: {
						display: true
					}
				}, {
					type: "category",
					position: "angular",
					grid: true
				}],
				series: series
			};
		} else {
			for(var i = 0, len = yFields.length; i < len; i++) {
				var c = i % clen;
				series.push({
					type: "radar",
					xField: "category",
					yField: yFields[i],
					showInLegend: true,
					showMarkers: false,
					markerConfig: {
						type: "circle",
						radius: 3,
						size: 3
					},
					style: {
						opacity: 0.4,
						'stroke-width': 2,
						fill: colors[c]
					}
				});
			}
			return {
				style: "background:white;",
				animate: true,
				shadow: true,
				insetPadding: 20,
				legend: {
					position: config.legendPosition || "right"
				},
				axes: [{
					type: "Radial",
					position: "radial",
					title: config.yTitle,
					label: {
						display: true
					}
				}],
				series: series
			};
		}
	},
	getRangeStore: function() {
		return this.rangeStore;
	},
	getChartSettingWin: function() {
		var win = SPOP.getChartSettingWin({
			width: 250,
			autoHeight: true,
			autoScroll: true,
			sheet: this.sheet
		});
		return win;
	},
	onFloorMouseDown: function() {
		var win = this.getChartSettingWin();
		if(win.isVisible()) {
			win.bindChart(this);
		}
	},
	showChartSetting: function(target, floating) {
		var sheet = this.sheet;
		var win = this.getChartSettingWin();
		if(!win.rendered) {
			win.render(Ext.getBody());
		}
		var compEl = floating.getComp().getEl();
		var right = compEl.getRight() + 5,
			top = compEl.getTop();
		var el = sheet.getEl();
		var width = win.getWidth(),
			height = win.getHeight(),
			rightLimit = el.getRight(),
			bottomLimit = el.getBottom();
		if(right + width > rightLimit) {
			right = rightLimit - width;
		}
		if(top + height > bottomLimit) {
			top = bottomLimit - height;
		}
		win.popup({
			xy: [right, top],
			chart: this
		});
	},
	onFocus: function(e) {
		if(this.sheet && this.sheet.isReadOnly()) {
			return;
		}
		if(!this.pinned) {
			for(var p in this.lookup) {
				var comp = this.lookup[p].comp;
				var el = comp.getEl();
				if(el) {
					el.addCls("x-resizable-pinned");
				}
			}
			this.sheet.fireEvent("chartfocus", this.getCoordReference(), this);
			this.pinned = true;
			this.rangeStore.monitorMoveReference(true);
		}
	},
	onBlur: function() {
		if(this.pinned) {
			var rm = this.sheet.getReferenceModel();
			rm.disableSelect();
			rm.hide();
			for(var p in this.lookup) {
				var comp = this.lookup[p].comp;
				var el = comp.getEl();
				if(el) {
					el.removeCls("x-resizable-pinned");
				}
			}
			delete this.pinned;
			this.rangeStore.monitorMoveReference(false);
		}
	},
	getCoordReference: function() {
		if("pie" == this.chartType) {
			var series = this.rangeStore.series;
			var arr = [];
			if(this.rangeStore.labels) {
				for(var i = 0, len = this.rangeStore.labels.length; i < len; i++) {
					arr.push({
						span: [].concat(this.rangeStore.labels[i]),
						cls: "ss-rm-nodot"
					});
				}
			}
			arr.push([].concat(series[0]));
			return arr;
		} else {
			return this.rangeStore.getCoordReference();
		}
	},
	onFieldTitleChange: function(fields) {
		var arr = [],
			names = [];
		for(var i = 0, len = fields.length; i < len; i++) {
			var name = fields[i].name;
			if("category" != name) {
				arr.push(fields[i]);
				names.push(name);
			}
		}
		fields = arr;
		this.yFields = [].concat(names);
		this.rangeStore.removeAll();
		if("pie" == this.chartType) {
			var getConfig = "get" + Ext.util.Format.capitalize(this.chartType) + "Config";
			if(this[getConfig]) {
				var config = this[getConfig](this.yFields);
				for(var p in this.lookup) {
					var comp = this.lookup[p].comp;
					var chart = comp.items.first();
					chart.series.removeAll();
					chart.series.addAll(config.series);
				}
			}
		} else if("line" == this.chartType || "scatter" == this.chartType || "radar" == this.chartType) {
			var getConfig = "get" + Ext.util.Format.capitalize(this.chartType) + "Config";
			if(this[getConfig]) {
				var config = this[getConfig](this.yFields);
				var titles = [];
				for(var i = 0, len = fields.length; i < len; i++) {
					var name = fields[i].name;
					titles.push(fields[i].title || name);
				}
				for(var p in this.lookup) {
					var comp = this.lookup[p].comp;
					var chart = comp.items.first();
					chart.series.removeAll();
					chart.series.addAll(config.series);
					var index = 0;
					if(Ext.isArray(chart.series)) {
						for(var i = 0, len = chart.series.length; i < len; i++) {
							var it = chart.series[i];
							it.title = titles[index++];
						}
					} else {
						chart.series.each(function(it) {
							it.title = titles[index++];
						}, this);
					}
				}
			}
		} else {
			var titles = [],
				len = fields.length;
			for(var i = 0; i < len; i++) {
				var name = fields[i].name;
				titles.push(fields[i].title || name);
			}
			for(var p in this.lookup) {
				var comp = this.lookup[p].comp;
				var chart = comp.items.first();
				if(Ext.isArray(chart.series)) {
					for(var i = 0, len = chart.series.length; i < len; i++) {
						var it = chart.series[i];
						it.yField = [].concat(names);
						it.title = titles;
					}
				} else {
					chart.series.each(function(it) {
						it.yField = [].concat(names);
						it.title = titles;
					}, this);
				}
			}
		}
	},
	getChartSetting: function() {
		var seriesPosition = this.rangeStore.getSeriesPosition();
		var legendPosition, xTitle, yTitle;
		for(var p in this.lookup) {
			var comp = this.lookup[p].comp;
			var chart = comp.items.first();
			legendPosition = chart.legend.position;
			if(chart.axes) {
				if(Ext.isArray(chart.axes)) {
					for(var i = 0, len = chart.axes.length; i < len; i++) {
						var it = chart.axes[i];
						if("left" == it.position || "right" == it.position) {
							yTitle = it.title;
						} else {
							xTitle = it.title;
						}
					}
				} else {
					chart.axes.each(function(it) {
						if("left" == it.position || "right" == it.position) {
							yTitle = it.title;
						} else {
							xTitle = it.title;
						}
					});
				}
			}
			break;
		}
		var setting = {
			seriesPosition: seriesPosition,
			legendPosition: legendPosition,
			chartType: this.chartType,
			firstRowLabel: this.rangeStore.firstRowLabel,
			firstColLabel: this.rangeStore.firstColLabel,
			xTitle: xTitle,
			yTitle: yTitle
		};
		return setting;
	},
	getFloorInfo: function() {
		var info = this.getChartSetting();
		info.floorType = "chart";
		info.source = this.rangeStore.getSourceConfig();
		Ext.apply(info, this.getPositionSize());
		info.id = this.getName();
		info.sheetId = this.sheetId;
		return info;
	},
	changeChartType: function(chartType, forceChange, suspendEvent) {
		if(this.chartType !== chartType || forceChange) {
			var setting = this.getChartSetting();
			var config, rangeStore = this.rangeStore,
				series, axes;
			this.chartType = chartType;
			var flag = false;
			if("radar" == chartType || "pie" == chartType || "area" == chartType) {
				if(!rangeStore.useAbs) {
					rangeStore.useAbs = true;
					flag = true;
				}
			} else if(rangeStore.useAbs) {
				rangeStore.useAbs = false;
				flag = true;
			}
			var getConfig = "get" + Ext.util.Format.capitalize(chartType) + "Config";
			if(this[getConfig]) {
				config = this[getConfig](this.yFields);
				config.store = rangeStore;
				config.legend = {
					position: setting.legendPosition,
					docked: setting.legendPosition
				};
				if(config.axes) {
					for(var i = 0, len = config.axes.length; i < len; i++) {
						var it = config.axes[i];
						if("left" == it.position || "right" == it.position) {
							it.title = setting.yTitle;
						} else {
							it.title = setting.xTitle;
						}
					}
				}
			}
			if(config) {
				for(var p in this.lookup) {
					var ct = this.lookup[p].comp;
					var chart = ct.items.first();
					ct.remove(chart);
					chart = new Ext.chart.Chart(Ext.apply({}, config));
					ct.add(chart);
					var region = this.sheet[p];
					if(region && region.isVisible()) {
						if(Ext.isFunction(ct.doLayout)) {
							ct.doLayout();
						} else if(Ext.isFunction(ct.updateLayout)) {
							ct.updateLayout();
						}
					}
				}
			}
			this.onFieldTitleChange(rangeStore.cacheFields);
			rangeStore.regenerateData();
			if(!suspendEvent) {
				this.sheet.fireEvent("chartchange", this, this.sheet);
			}
		}
	},
	changeLegendPosition: function(pos) {
		for(var p in this.lookup) {
			var ct = this.lookup[p].comp;
			var chart = ct.items.first();
			if(chart.legend) {
				chart.legend.position = pos;
				chart.legend.dock = pos;
				chart.legend.docked = pos;
				chart.legend.isVertical = "left|right|float".indexOf(pos) !== -1;
			}
			if(Ext.checkVersion && Ext.checkVersion("6.0.0+")) {
				this.changeChartType(this.chartType, true);
			} else {
				if(Ext.isFunction(chart.refresh)) {
					chart.refresh();
				} else {
					chart.redraw();
				}
			}
		}
		this.sheet.fireEvent("chartchange", this, this.sheet);
	},
	onRelatedCoordChange: function(rangeStore) {
		var win = this.getChartSettingWin();
		if(win.isVisible()) {
			win.switchSeriesPosition();
			win.switchTitleField();
		}
	},
	updateXTitle: function(title) {
		for(var p in this.lookup) {
			var ct = this.lookup[p].comp;
			var chart = ct.items.first();
			if(chart.axes) {
				if(Ext.isArray(chart.axes)) {
					for(var i = 0, len = chart.axes.length; i < len; i++) {
						var it = chart.axes[i];
						if("bottom" == it.position || "top" == it.position) {
							it.title = title;
							break;
						}
					}
				} else {
					chart.axes.each(function(it) {
						if("bottom" == it.position || "top" == it.position) {
							it.title = title;
							return false;
						}
					}, this);
				}
				if(Ext.isFunction(chart.refresh)) {
					chart.refresh();
				} else {
					chart.redraw();
				}
			}
		}
		this.sheet.fireEvent("chartchange", this, this.sheet);
	},
	updateYTitle: function(title) {
		for(var p in this.lookup) {
			var ct = this.lookup[p].comp;
			var chart = ct.items.first();
			if(chart.axes) {
				if(Ext.isArray(chart.axes)) {
					for(var i = 0, len = chart.axes.length; i < len; i++) {
						var it = chart.axes[i];
						if("left" == it.position || "right" == it.position) {
							it.title = title;
							break;
						}
					}
				} else {
					chart.axes.each(function(it) {
						if("left" == it.position || "right" == it.position) {
							it.title = title;
							return false;
						}
					}, this);
				}
				if(Ext.isFunction(chart.refresh)) {
					chart.refresh();
				} else {
					chart.redraw();
				}
			}
		}
		this.sheet.fireEvent("chartchange", this, this.sheet);
	},
	redrawChart: function() {
		for(var p in this.lookup) {
			var ct = this.lookup[p].comp;
			var chart = ct.items.first();
			chart.redraw();
		}
	},
	destroy: function(suspendUpdate, suspendEvent) {
		var posize = this.getPositionSize();
		this.callParent(arguments);
		this.rangeStore.monitorMoveReference(false);
		var rm = this.sheet.getReferenceModel();
		rm.clearSelection();
		rm.disableSelect();
		rm.hide();
		if(!suspendEvent) {
			this.sheet.fireEvent("deletechart", this.chartType, this, this.rangeStore, posize, this.sheet);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.floating.picture.PictureFloor", {
	extend: "EnterpriseSheet.sheet.floating.Floor",
	constructor: function(url, config, suspendPulling) {
		this.pictureUrl = url;
		config.floatingConfig = config.floatingConfig || {};
		if(!SCOM.nullOrUndefined(config.floatingConfig.id) && SCOM.nullOrUndefined(config.floatingConfig.floorId)) {
			config.floatingConfig.floorId = config.floatingConfig.id;
		}
		var width = config.floatingConfig.width || 200,
			height = config.floatingConfig.height || 200;
		config.floatingConfig.html = "<img class=\"inner-ct\" src=\"" + url + "\" style=\"width:" + (width - 10) + "px;height:" + (height - 10) + "px;\">";
		Ext.applyIf(config.floatingConfig, {
			style: "background:white;",
			resizeConfig: {
				dynamic: false,
				pinned: false,
				handles: "all"
			},
			x: 100,
			y: 100,
			width: width,
			height: height
		});
		this.callParent([config, suspendPulling]);
		this.on({
			scope: this,
			resized: this.onPictureFloorResize
		});
	},
	getFloorInfo: function() {
		var info = Ext.apply({}, this.getPositionSize());
		info.id = this.getName();
		info.url = this.pictureUrl;
		info.floorType = "picture";
		info.sheetId = this.sheetId;
		return info;
	},
	destroy: function(suspendUpdate, suspendEvent) {
		var posize = this.getPositionSize();
		this.callParent(arguments);
		if(!suspendEvent) {
			this.sheet.fireEvent("deletepicture", this.pictureUrl, this, posize, this.sheet);
		}
	},
	onPictureFloorResize: function() {
		this.eachFloating(function(comp) {
			if(comp) {
				var el = comp.getEl();
				if(el) {
					var w = comp.getWidth(),
						h = comp.getHeight();
					w -= 10;
					h -= 10;
					var innerCt = el.down(".inner-ct");
					innerCt.setWidth(w);
					innerCt.setHeight(h);
				}
			}
		}, this);
	}
});

Ext.define("EnterpriseSheet.sheet.floating.picture.PictureFloor", {
	extend: "EnterpriseSheet.sheet.floating.Floor",
	constructor: function(url, config, suspendPulling) {
		this.pictureUrl = url;
		config.floatingConfig = config.floatingConfig || {};
		if(!SCOM.nullOrUndefined(config.floatingConfig.id) && SCOM.nullOrUndefined(config.floatingConfig.floorId)) {
			config.floatingConfig.floorId = config.floatingConfig.id;
		}
		var width = config.floatingConfig.width || 200,
			height = config.floatingConfig.height || 200;
		config.floatingConfig.html = "<img class=\"inner-ct\" src=\"" + url + "\" style=\"width:" + (width - 10) + "px;height:" + (height - 10) + "px;\">";
		Ext.applyIf(config.floatingConfig, {
			style: "background:white;",
			resizeConfig: {
				dynamic: false,
				pinned: false,
				handles: "all"
			},
			x: 100,
			y: 100,
			width: width,
			height: height
		});
		this.callParent([config, suspendPulling]);
		this.on({
			scope: this,
			resized: this.onPictureFloorResize
		});
	},
	getFloorInfo: function() {
		var info = Ext.apply({}, this.getPositionSize());
		info.id = this.getName();
		info.url = this.pictureUrl;
		info.floorType = "picture";
		info.sheetId = this.sheetId;
		return info;
	},
	destroy: function(suspendUpdate, suspendEvent) {
		var posize = this.getPositionSize();
		this.callParent(arguments);
		if(!suspendEvent) {
			this.sheet.fireEvent("deletepicture", this.pictureUrl, this, posize, this.sheet);
		}
	},
	onPictureFloorResize: function() {
		this.eachFloating(function(comp) {
			if(comp) {
				var el = comp.getEl();
				if(el) {
					var w = comp.getWidth(),
						h = comp.getHeight();
					w -= 10;
					h -= 10;
					var innerCt = el.down(".inner-ct");
					innerCt.setWidth(w);
					innerCt.setHeight(h);
				}
			}
		}, this);
	}
});

Ext.define("EnterpriseSheet.sheet.floating.wedgit.WedgitFloor", {
	extend: "EnterpriseSheet.sheet.floating.Floor",
	constructor: function(url, config, suspendPulling) {
		this.wedgitUrl = url;
		config.floatingConfig = config.floatingConfig || {};
		if(!SCOM.nullOrUndefined(config.floatingConfig.id) && SCOM.nullOrUndefined(config.floatingConfig.floorId)) {
			config.floatingConfig.floorId = config.floatingConfig.id;
		}
		var width = config.floatingConfig.width || 200,
			height = config.floatingConfig.height || 200;
		height -= 25;
		config.floatingConfig.html = ["<iframe class=\"inner-ct\" src=\"", url, "\" style=\"border-left:none;border-right:none;border-bottom:none;border-top:25px solid rgb(60,60,60);width:", width - 10, "px;height:", height - 10, "px;\"></iframe>", "<div class=\"tool-refresh\" style=\"margin-right:35px;\">", SLANG.refresh, "</div>", "<div class=\"tool-close\" style=\"margin-right:10px;margin-top:8px;\"></div>"].join("");
		Ext.applyIf(config.floatingConfig, {
			style: "background:white;",
			resizeConfig: {
				dynamic: false,
				pinned: false,
				handles: "all"
			},
			x: 100,
			y: 100,
			width: width,
			height: height
		});
		this.callParent([config, suspendPulling]);
		this.on({
			scope: this,
			resized: this.onWedgitFloorResize
		});
		this.addListenerForFloatings("elmousedown", this.onFloorMouseDown, this);
	},
	getFloorInfo: function() {
		var info = Ext.apply({}, this.getPositionSize());
		info.id = this.getName();
		info.url = this.wedgitUrl;
		info.floorType = "wedgit";
		info.sheetId = this.sheetId;
		return info;
	},
	destroy: function(suspendUpdate, suspendEvent) {
		var posize = this.getPositionSize();
		this.callParent(arguments);
		if(!suspendEvent) {
			this.sheet.fireEvent("deletewedgit", this.wedgitUrl, this, posize, this.sheet);
		}
	},
	onWedgitFloorResize: function() {
		this.eachFloating(function(comp) {
			if(comp) {
				var el = comp.getEl();
				if(el) {
					var w = comp.getWidth(),
						h = comp.getHeight();
					w -= 10;
					h -= 35;
					var innerCt = el.down(".inner-ct");
					innerCt.setWidth(w);
					innerCt.setHeight(h);
				}
			}
		}, this);
	},
	onFloorMouseDown: function(e) {
		var target = Ext.get(e.getTarget());
		if(target.hasCls("tool-refresh")) {
			this.eachFloating(function(comp) {
				if(comp) {
					var el = comp.getEl();
					if(el) {
						var innerCt = el.down(".inner-ct");
						innerCt.dom.src = innerCt.dom.src;
					}
				}
			}, this);
		} else if(target.hasCls("tool-close")) {
			this.destroy();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.floating.wedgit.WedgitFloor", {
	extend: "EnterpriseSheet.sheet.floating.Floor",
	constructor: function(url, config, suspendPulling) {
		this.wedgitUrl = url;
		config.floatingConfig = config.floatingConfig || {};
		if(!SCOM.nullOrUndefined(config.floatingConfig.id) && SCOM.nullOrUndefined(config.floatingConfig.floorId)) {
			config.floatingConfig.floorId = config.floatingConfig.id;
		}
		var width = config.floatingConfig.width || 200,
			height = config.floatingConfig.height || 200;
		height -= 25;
		config.floatingConfig.html = ["<iframe class=\"inner-ct\" src=\"", url, "\" style=\"border-left:none;border-right:none;border-bottom:none;border-top:25px solid rgb(60,60,60);width:", width - 10, "px;height:", height - 10, "px;\"></iframe>", "<div class=\"tool-refresh\" style=\"margin-right:35px;\">", SLANG.refresh, "</div>", "<div class=\"tool-close\" style=\"margin-right:10px;margin-top:8px;\"></div>"].join("");
		Ext.applyIf(config.floatingConfig, {
			style: "background:white;",
			resizeConfig: {
				dynamic: false,
				pinned: false,
				handles: "all"
			},
			x: 100,
			y: 100,
			width: width,
			height: height
		});
		this.callParent([config, suspendPulling]);
		this.on({
			scope: this,
			resized: this.onWedgitFloorResize
		});
		this.addListenerForFloatings("elmousedown", this.onFloorMouseDown, this);
	},
	getFloorInfo: function() {
		var info = Ext.apply({}, this.getPositionSize());
		info.id = this.getName();
		info.url = this.wedgitUrl;
		info.floorType = "wedgit";
		info.sheetId = this.sheetId;
		return info;
	},
	destroy: function(suspendUpdate, suspendEvent) {
		var posize = this.getPositionSize();
		this.callParent(arguments);
		if(!suspendEvent) {
			this.sheet.fireEvent("deletewedgit", this.wedgitUrl, this, posize, this.sheet);
		}
	},
	onWedgitFloorResize: function() {
		this.eachFloating(function(comp) {
			if(comp) {
				var el = comp.getEl();
				if(el) {
					var w = comp.getWidth(),
						h = comp.getHeight();
					w -= 10;
					h -= 35;
					var innerCt = el.down(".inner-ct");
					innerCt.setWidth(w);
					innerCt.setHeight(h);
				}
			}
		}, this);
	},
	onFloorMouseDown: function(e) {
		var target = Ext.get(e.getTarget());
		if(target.hasCls("tool-refresh")) {
			this.eachFloating(function(comp) {
				if(comp) {
					var el = comp.getEl();
					if(el) {
						var innerCt = el.down(".inner-ct");
						innerCt.dom.src = innerCt.dom.src;
					}
				}
			}, this);
		} else if(target.hasCls("tool-close")) {
			this.destroy();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.floating.DeleteRepeatOption", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.common.Common", "Ext.view.View"],
	width: 200,
	height: 300,
	constructor: function() {
		this.initPane();
		this.callParent(arguments);
		this.mon(Ext.getBody(), "mousedown", function(e) {
			var el = this.optionPane.getEl();
			if(!e.within(el.dom)) {
				this.optionPane.hide();
			}
		}, this);
	},
	initPane: function() {
		this.columnStore = Ext.create("Ext.data.Store", {
			fields: ["col", "display"]
		});
		this.columnView = Ext.create("Ext.view.View", {
			cls: "ss-delete-repeat-view",
			region: "center",
			store: this.columnStore,
			allowDeselect: true,
			simpleSelect: true,
			tpl: Ext.create("Ext.XTemplate", ["<tpl for=\".\">", "<div class=\"ss-col-item\">{display}</div>", "</tpl>"].join("")),
			itemSelector: "div.ss-col-item"
		});
		this.deleteRepeatBtn = Ext.create("Ext.button.Button", {
			text: SLANG.delete_repeat_item,
			handler: this.onDeleteRepeat,
			scope: this
		});
		this.infoBox = Ext.create("Ext.Component", {
			cls: "delete-repeat-info-box"
		});
		this.optionPane = Ext.create("Ext.container.Container", {
			cls: "ss-delete-repeat-pane",
			floating: true,
			renderTo: Ext.getBody(),
			zIndex: SCONST.TOP_Z_INDEX,
			width: this.width,
			height: this.height,
			layout: "border",
			items: [{
				xtype: "toolbar",
				cls: "delete-repeat-toolbar",
				region: "north",
				items: [{
					text: SLANG.check_all,
					handler: this.selectAll,
					scope: this
				}, {
					text: SLANG.uncheck_all,
					handler: this.deselectAll,
					scope: this
				}]
			}, this.columnView, {
				xtype: "container",
				style: "padding-top:20px;",
				region: "south",
				items: [this.infoBox, this.deleteRepeatBtn]
			}]
		});
		var sm = this.columnView.getSelectionModel();
		sm.on({
			scope: this,
			selectionchange: this.onSelectionChange
		});
	},
	showBy: function(el, align) {
		this.optionPane.showBy(el, align);
	},
	prepare: function(data) {
		this.columnStore.loadData(data);
		this.columnView.getSelectionModel().selectAll(true);
		this.syncInfoBox();
	},
	selectAll: function() {
		this.columnView.getSelectionModel().selectAll();
	},
	deselectAll: function() {
		this.columnView.getSelectionModel().deselectAll();
	},
	onSelectionChange: function() {
		this.syncInfoBox();
	},
	syncInfoBox: function() {
		var sm = this.columnView.getSelectionModel();
		var sels = sm.getSelection(),
			cols = {};
		for(var i = 0, len = sels.length; i < len; i++) {
			var it = sels[i];
			cols[it.data.col] = true;
		}
		var rows = {},
			flags = {};
		var sheet = this.sheet,
			sheetSM = sheet.getSelectionModel(),
			coord = sheetSM.selection2Coord(),
			store = sheet.getStore();
		var span = coord[0],
			minRow = span[1],
			maxRow = span[3],
			minCol = span[2],
			maxCol = span[4];
		store.walkRange(coord, function(rd) {
			var row = rd.data.row,
				col = rd.data.col,
				json = rd.data.json;
			rows[row] = rows[row] || {};
			var rowMap = rows[row];
			if(cols[col]) {
				if(json.data) {
					var o = sheet.getCellValue(rd.data.sheet, row, col);
					rowMap[col] = o.data;
				}
			}
		}, this, true);
		for(var k in cols) {
			if(cols.hasOwnProperty(k)) {
				var lookup = {};
				for(var i = minRow; i <= maxRow; i++) {
					var row = rows[i] || {};
					var val = row[k] || "";
					flags[i] = flags[i] || {};
					if(lookup[val]) {
						flags[i][k] = true;
					} else {
						flags[i][k] = false;
						lookup[val] = true;
					}
				}
			}
		}
		var deleted = [];
		for(var p in flags) {
			if(flags.hasOwnProperty(p)) {
				var flag = flags[p],
					repeated = true;
				for(var q in flag) {
					if(flag.hasOwnProperty(q)) {
						if(!flag[q]) {
							repeated = false;
							break;
						}
					}
				}
				if(repeated) {
					deleted.push(p);
				}
			}
		}
		var count = maxRow - minRow + 1,
			dlen = deleted.length;
		this.infoBox.update(Ext.String.format(SLANG.found_repeat_value, dlen, count - dlen));
		this.repeatInfo = {
			minRow: minRow,
			maxRow: maxRow,
			minCol: minCol,
			maxCol: maxCol,
			deleted: deleted
		};
	},
	onDeleteRepeat: function() {
		var info = this.repeatInfo,
			deleted = info.deleted;
		if(0 < deleted.length) {
			var range = [];
			for(var i = 0, len = deleted.length; i < len; i++) {
				var r = Number(deleted[i]),
					rlen = range.length;
				var last = 0 < rlen ? range[rlen - 1] : false;
				if(last && last.maxrow + 1 == r) {
					last.maxrow = r;
				} else {
					range.push({
						minrow: r,
						maxrow: r,
						mincol: info.minCol,
						maxcol: info.maxCol
					});
				}
			}
			this.sheet.deleteCellRangesMoveTop(range);
		}
		this.optionPane.hide();
	}
});
Ext.define("EnterpriseSheet.sheet.autofill.Sequence", {
	requires: ["EnterpriseSheet.common.CONST"],
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent();
	},
	checkDataType: function(o) {
		if(SCOM.canbeNumber(o.data)) {
			return "number";
		} else if(Ext.isDate(o.date)) {
			return "datetime";
		} else {
			return "text";
		}
	},
	tryMatch: function(arr) {
		return Ext.Function.bind(this.grow, {
			seeds: arr
		});
	},
	grow: function(o, index) {
		var len = this.seeds.length;
		var i = index % len;
		var s = this.seeds[i];
		if(SCOM.canbeNumber(s.data)) {
			var count = Math.floor(index / len);
			o.data = Number(s.data) + count;
		}
		return o;
	}
}, function() {
	SQBOX = (function() {
		var loop = new EnterpriseSheet.sheet.autofill.Sequence;
		var me = {};
		me.anyLookup = {}, me.numberLookup = {
			arithmetic: false,
			geometric: false
		}, me.textLookup = {}, me.datetimeLookup = {};
		var checkDataType = loop.checkDataType;
		return {
			reg: function(name, type, ref) {
				type = type || "any";
				var lookup = me.anyLookup;
				if("text" == type) {
					lookup = me.textLookup;
				} else if("number" == type) {
					lookup = me.numberLookup;
				} else if("datetime" == type) {
					lookup = me.datetimeLookup;
				}
				lookup[name] = ref;
			},
			tryMatch: function(arr) {
				var obj = {
					number: false,
					datetime: false,
					text: false,
					any: false
				};
				var seeds = SCOM.copy(arr);
				for(var p in obj) {
					if(obj.hasOwnProperty(p)) {
						var lookup = me[p + "Lookup"];
						for(var q in lookup) {
							if(lookup.hasOwnProperty(q)) {
								var sq = lookup[q];
								if(sq) {
									var fn = sq.tryMatch(seeds);
									if(fn) {
										obj[p] = fn;
										break;
									}
								}
							}
						}
					}
				}
				var matchFn = function(o, index) {
					var i = index % seeds.length;
					var seed = seeds[i];
					var stype = checkDataType(seed);
					var foundFn = obj[stype];
					if(!foundFn) {
						foundFn = loop.tryMatch(seeds);
					}
					return foundFn(o, index);
				};
				return matchFn;
			}
		};
	})();
});

Ext.define("EnterpriseSheet.sheet.autofill.ArithmeticSequence", {
	extend: "EnterpriseSheet.sheet.autofill.Sequence",
	tryMatch: function(arr) {
		var num = 0,
			pre = false,
			cur = false,
			offset = false;
		for(var i = 0, len = arr.length; i < len; i++) {
			if(SCOM.canbeNumber(arr[i].data)) {
				num++;
				pre = cur;
				cur = Number(arr[i].data);
				if(false !== pre) {
					if(false !== offset) {
						if(offset !== cur - pre) {
							return;
						}
					} else {
						offset = cur - pre;
					}
				}
			}
		}
		if(1 <= num) {
			offset = offset || 0;
			return Ext.Function.bind(this.grow, {
				seeds: arr,
				offset: offset,
				num: num
			});
		}
	},
	grow: function(o, index) {
		if(0 !== this.offset) {
			var len = this.seeds.length;
			var i = index % len;
			var s = this.seeds[i];
			if(SCOM.canbeNumber(s.data)) {
				var count = Math.floor(index / len);
				o.data = Number(s.data) + count * this.num * this.offset;
			}
		}
		return o;
	}
}, function() {
	SQBOX.reg("arithmetic", "number", new EnterpriseSheet.sheet.autofill.ArithmeticSequence);
});

Ext.define("EnterpriseSheet.sheet.autofill.DateSequence", {
	extend: "EnterpriseSheet.sheet.autofill.Sequence",
	requires: ["EnterpriseSheet.sheet.data.Format"],
	tryMatch: function(arr) {
		var num = 0,
			pre = false,
			cur = false,
			offset = false;
		for(var i = 0, len = arr.length; i < len; i++) {
			var date = SFORMAT.checkingDate(arr[i].data);
			if(date) {
				arr[i].date = date;
				num++;
				pre = cur;
				cur = date;
				if(false !== pre) {
					if(false !== offset) {
						if(offset !== Ext.Date.getElapsed(cur, pre)) {
							return;
						}
					} else {
						offset = Ext.Date.getElapsed(cur, pre);
					}
				}
			}
		}
		if(1 < num) {
			offset = offset || 0;
			return Ext.Function.bind(this.grow, {
				seeds: arr,
				offset: offset,
				num: num
			});
		}
	},
	grow: function(o, index) {
		if(0 !== this.offset) {
			var len = this.seeds.length;
			var i = index % len;
			var s = this.seeds[i];
			if(Ext.isDate(s.date)) {
				var count = Math.floor(index / len);
				var date = Ext.Date.add(s.date, Ext.Date.MILLI, count * this.num * this.offset);
				if(-1 == s.data.toString().indexOf(":")) {
					o.data = Ext.Date.format(date, "Y-m-d");
				} else {
					o.data = Ext.Date.format(date, "Y-m-d H:i:s");
				}
			}
		}
		return o;
	}
}, function() {
	SQBOX.reg("date", "datetime", new EnterpriseSheet.sheet.autofill.DateSequence);
});

Ext.define("EnterpriseSheet.sheet.autofill.GeometricSequence", {
	extend: "EnterpriseSheet.sheet.autofill.Sequence",
	tryMatch: function(arr) {
		var num = 0,
			pre = false,
			cur = false,
			offset = false;
		for(var i = 0, len = arr.length; i < len; i++) {
			if(SCOM.canbeNumber(arr[i].data)) {
				num++;
				pre = cur;
				cur = Number(arr[i].data);
				if(false !== pre) {
					if(false !== offset) {
						if(offset !== cur / pre) {
							return;
						}
					} else {
						offset = cur / pre;
					}
				}
			}
		}
		offset = offset || 1;
		if(1 <= num) {
			return Ext.Function.bind(this.grow, {
				seeds: arr,
				offset: offset,
				num: num
			});
		}
	},
	grow: function(o, index) {
		if(0 !== this.offset) {
			var len = this.seeds.length;
			var i = index % len;
			var s = this.seeds[i];
			if(SCOM.canbeNumber(s.data)) {
				var count = Math.floor(index / len);
				o.data = Number(s.data) * Math.pow(this.offset, this.num * count);
			}
		}
		return o;
	}
}, function() {
	SQBOX.reg("geometric", "number", new EnterpriseSheet.sheet.autofill.GeometricSequence);
});

Ext.define("EnterpriseSheet.sheet.autofill.TextSequence", {
	extend: "EnterpriseSheet.sheet.autofill.Sequence",
	constructor: function(config) {
		Ext.apply(this, config);
		this.stack = this.stack || [];
		this.setupWeek();
		this.setupMonth();
		this.callParent();
	},
	setupWeek: function() {
		this.stack.push(SCONST.fullWeekNames);
		this.stack.push(SCONST.shortWeekNames);
	},
	setupMonth: function() {
		this.stack.push(SCONST.fullMonthNames);
		this.stack.push(SCONST.shortMonthNames);
	},
	tryMatch: function(arr) {
		for(var cursor = 0, size = this.stack.length; cursor < size; cursor++) {
			var series = this.stack[cursor];
			var num = 0,
				texts = [],
				map = {},
				start = false;
			for(var i = 0, len = arr.length; i < len; i++) {
				if("text" == this.checkDataType(arr[i])) {
					var str = arr[i].data || "";
					texts.push(str);
					if(false === start) {
						for(var k = 0, count = series.length; k < count; k++) {
							if(series[k].toLocaleLowerCase() == str.toLocaleLowerCase()) {
								start = k;
								break;
							}
						}
						if(false === start) {
							break;
						}
					}
					map[i] = num;
					num++;
				}
			}
			if(false === start) {
				continue;
			}
			var slen = series.length;
			if(num < slen) {
				var st;
				if(start + num - 1 < slen) {
					st = series.slice(start, start + num);
				} else {
					st = series.slice(start, slen);
					st = st.concat(series.slice(0, num - slen + start));
				}
				if(st.join("&").toLocaleLowerCase() == texts.join("&").toLocaleLowerCase()) {
					return Ext.Function.bind(this.grow, {
						seeds: arr,
						series: series,
						map: map,
						num: num,
						start: start,
						me: this
					});
				} else {
					if(start + 1 >= num) {
						st = series.slice(start - num + 1, start + 1);
						st.reverse();
					} else {
						st = series.slice(0, start + 1);
						st.reverse();
						st = st.concat(series.slice(slen - num + start + 1, slen).reverse());
					}
					if(st.join("&").toLocaleLowerCase() == texts.join("&").toLocaleLowerCase()) {
						return Ext.Function.bind(this.grow, {
							seeds: arr,
							series: series,
							map: map,
							num: num,
							start: start,
							reverse: true,
							me: this
						});
					}
				}
			}
		}
	},
	grow: function(o, index) {
		var me = this.me;
		var len = this.seeds.length;
		var count = Math.floor(index / len);
		var i = index % len;
		var s = this.seeds[i];
		var series = this.series;
		if("text" == me.checkDataType(s)) {
			if(this.reverse) {
				index = this.start - (count * this.num + this.map[i]);
				index = index % series.length;
				if(0 > index) {
					index += series.length;
				}
			} else {
				index = count * this.num + this.map[i] + this.start;
				index = index % series.length;
			}
			o.data = series[index];
		}
		return o;
	}
}, function() {
	SQBOX.reg("textloop", "text", new EnterpriseSheet.sheet.autofill.TextSequence);
});

Ext.define("EnterpriseSheet.sheet.autofill.TimeSequence", {
	extend: "EnterpriseSheet.sheet.autofill.Sequence",
	requires: ["EnterpriseSheet.sheet.data.Format"],
	tryMatch: function(arr) {
		var num = 0,
			pre = false,
			cur = false,
			offset = false;
		for(var i = 0, len = arr.length; i < len; i++) {
			var date = SFORMAT.checkingTime(arr[i].data);
			if(date) {
				arr[i].date = date;
				num++;
				pre = cur;
				cur = date;
				if(false !== pre) {
					if(false !== offset) {
						if(offset !== Ext.Date.getElapsed(cur, pre)) {
							return;
						}
					} else {
						offset = Ext.Date.getElapsed(cur, pre);
					}
				}
			}
		}
		if(1 < num) {
			offset = offset || 0;
			return Ext.Function.bind(this.grow, {
				seeds: arr,
				offset: offset,
				num: num
			});
		}
	},
	grow: function(o, index) {
		if(0 !== this.offset) {
			var len = this.seeds.length;
			var i = index % len;
			var s = this.seeds[i];
			if(Ext.isDate(s.date)) {
				var count = Math.floor(index / len);
				var date = Ext.Date.add(s.date, Ext.Date.MILLI, count * this.num * this.offset);
				if(-1 == s.data.toString().indexOf(":")) {
					o.data = Ext.Date.format(date, "Y-m-d");
				} else {
					o.data = Ext.Date.format(date, "Y-m-d H:i:s");
				}
			}
		}
		return o;
	}
}, function() {
	SQBOX.reg("time", "datetime", new EnterpriseSheet.sheet.autofill.TimeSequence);
});

Ext.define("EnterpriseSheet.sheet.autofill.Autofill", {
	requires: ["Ext.button.Button", "EnterpriseSheet.sheet.range.Range", "EnterpriseSheet.sheet.floating.Floor", "EnterpriseSheet.sheet.autofill.ArithmeticSequence", "EnterpriseSheet.sheet.autofill.DateSequence", "EnterpriseSheet.sheet.autofill.GeometricSequence", "EnterpriseSheet.sheet.autofill.TextSequence", "EnterpriseSheet.sheet.autofill.TimeSequence"],
	kitOffset: [5, 5],
	constructor: function(config) {
		this.initAutofilMenu();
		this.callParent();
	},
	monitorChanging: true,
	init: function(sheet) {
		if(!this.sheet) {
			this.sheet = sheet;
			sheet.on({
				scope: this,
				autofilldragend: this.doAutofill,
				changing: this.hideAutofillKit,
				changereadonly: this.onChangeReadOnly
			});
			sheet.on("beforestartedit", this.hideAutofillKit, this);
		}
	},
	prepareArray: function(span, dir, bottomup, skipHidden) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var sheetId = span[0],
			minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4];
		var lookup = {},
			o = {};
		if("col" == dir) {
			var colHidden = {};
			if(skipHidden) {
				for(var i = mincol; i <= maxcol; i++) {
					if(!store.isVisibleColumn(sheetId, i)) {
						colHidden[i] = true;
					}
				}
			}
			store.walkRange([span], function(rd) {
				var row = rd.data.row,
					col = rd.data.col;
				if(!colHidden[col]) {
					var cd = store.getCellData(rd.data.sheet, row, col);
					lookup[row] = lookup[row] || {};
					lookup[row][col] = cd;
				}
			}, this, true);
			if(bottomup) {
				for(var r in lookup) {
					if(lookup.hasOwnProperty(r)) {
						o[r] = o[r] || [];
						var rowObj = lookup[r];
						for(var j = maxcol; j >= mincol; j--) {
							if(!colHidden[j]) {
								o[r].push(rowObj[j] || {});
							}
						}
					}
				}
			} else {
				for(var r in lookup) {
					if(lookup.hasOwnProperty(r)) {
						o[r] = o[r] || [];
						var rowObj = lookup[r];
						for(var j = mincol; j <= maxcol; j++) {
							if(!colHidden[j]) {
								o[r].push(rowObj[j] || {});
							}
						}
					}
				}
			}
		} else {
			var rowHidden = {};
			if(skipHidden) {
				var count = 0;
				for(var i = minrow; i <= maxrow; i++) {
					if(!store.isVisibleRow(sheetId, i)) {
						rowHidden[i] = true;
						count++;
					}
				}
			}
			store.walkRange([span], function(rd) {
				var row = rd.data.row,
					col = rd.data.col;
				if(!rowHidden[row]) {
					var cd = store.getCellData(rd.data.sheet, row, col);
					lookup[col] = lookup[col] || {};
					lookup[col][row] = cd;
				}
			}, this, true);
			if(bottomup) {
				for(var c in lookup) {
					if(lookup.hasOwnProperty(c)) {
						o[c] = o[c] || [];
						var colObj = lookup[c];
						for(var i = maxrow; i >= minrow; i--) {
							if(!rowHidden[i]) {
								o[c].push(colObj[i] || {});
							}
						}
					}
				}
			} else {
				for(var c in lookup) {
					if(lookup.hasOwnProperty(c)) {
						o[c] = o[c] || [];
						var colObj = lookup[c];
						for(var i = minrow; i <= maxrow; i++) {
							if(!rowHidden[i]) {
								o[c].push(colObj[i] || {});
							}
						}
					}
				}
			}
		}
		return o;
	},
	doAutofill: function(originPos, region, sm) {
		var flag = originPos.flag;
		var fromSpan = [originPos.sheet, originPos.minrow, originPos.mincol, originPos.maxrow, originPos.maxcol];
		var toSpan = sm.selection2Span();
		if(toSpan) {
			this.autofilling(fromSpan, toSpan, flag);
			if(this.autofillKit) {
				this.autofillMenu.items.get(1).setChecked(true, true);
			}
		} else {
			Ext.Msg.alert(SLANG.hint, SLANG.target_range_shouldbe_same_size);
		}
	},
	autofilling: function(fromSpan, toSpan, dotFlag, fillType) {
		var sheet = this.sheet,
			store = sheet.getStore();
		if(store.withBrokenMergedCell([fromSpan, toSpan])) {
			Ext.Msg.alert(SLANG.hint, SLANG.can_not_change_part_merged_cell);
			return;
		}
		this.fromSpan = SCOM.copy(fromSpan);
		this.toSpan = SCOM.copy(toSpan);
		this.dotFlag = "lt" == dotFlag;
		var frowLen = fromSpan[3] - fromSpan[1] + 1,
			fcolLen = fromSpan[4] - fromSpan[2] + 1;
		var trowLen = toSpan[3] - toSpan[1] + 1,
			tcolLen = toSpan[4] - toSpan[2] + 1;
		var fromCoord = [fromSpan],
			toCoord = [toSpan];
		if(frowLen != trowLen || fcolLen != tcolLen) {
			var dir = frowLen != trowLen ? "row" : "col";
			var includeFlag = fromSpan[0] === toSpan[0] && fromSpan[1] <= toSpan[1] && fromSpan[3] >= toSpan[3] && fromSpan[2] <= toSpan[2] && fromSpan[4] >= toSpan[4];
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: sheet,
				coord: includeFlag ? fromCoord : toCoord
			});
			var originCdts = sheet.getCdtsFromCoord(fromCoord);
			if(false !== sheet.fireEvent("beforeautofill", range, fromCoord, sheet, originCdts)) {
				var reCalCells = sheet.getRecalculateCellsByCoord(toCoord);
				var changedHeights = {};
				sheet.fireEvent("prepareautofill", range, fromCoord, sheet, originCdts, reCalCells, changedHeights);
				if(includeFlag) {
					var offsetSpan;
					var minrow = fromSpan[1],
						mincol = fromSpan[2],
						maxrow = fromSpan[3],
						maxcol = fromSpan[4];
					if(fromSpan[1] == toSpan[1] && fromSpan[2] == toSpan[2]) {
						if(fromSpan[4] == toSpan[4]) {
							minrow = toSpan[3] + 1;
						} else {
							mincol = toSpan[4] + 1;
						}
					} else {
						if(fromSpan[2] == toSpan[2]) {
							maxrow = toSpan[1] - 1;
						} else {
							maxcol = toSpan[2] - 1;
						}
					}
					offsetSpan = [fromSpan[0], minrow, mincol, maxrow, maxcol];
					var offsetRange = new EnterpriseSheet.sheet.range.Range({
						sheet: sheet,
						coord: [offsetSpan]
					});
					offsetRange.cleanContent(true);
					this.hideAutofillKit();
				} else {
					if(fillType && this[fillType]) {
						this[fillType](fromSpan, toSpan, dir, this.dotFlag, reCalCells);
					} else {
						this.fillSequence(fromSpan, toSpan, dir, this.dotFlag, reCalCells);
					}
					this.showAutofillKit(range);
				}
				if(range.isCellCoord()) {
					Ext.apply(changedHeights, sheet.checkAutoHeightForCoord(fromCoord, range.getCoord(), false, true));
				}
				sheet.fireEvent("autofill", range, fromCoord, sheet, originCdts, reCalCells);
			}
		}
	},
	initAutofilMenu: function() {
		this.autofillMenu = this.autofillMenu || new Ext.menu.Menu({
			defaults: {
				group: "autofill-type",
				scope: this
			},
			items: [{
				checked: false,
				text: SLANG.copy_cell,
				handler: function() {
					if("copyCell" != this.curFillType) {
						this.sheet.fireEvent("undo", true, true);
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, "copyCell");
						this.monitorChanging = true;
					}
				}
			}, {
				checked: true,
				text: SLANG.fill_sequence,
				handler: function() {
					if("fillSequence" != this.curFillType) {
						this.sheet.fireEvent("undo", true, true);
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, "fillSequence");
						this.monitorChanging = true;
					}
				}
			}, {
				checked: false,
				text: SLANG.only_fill_style,
				handler: function() {
					if("fillStyle" != this.curFillType) {
						this.sheet.fireEvent("undo", true, true);
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, "fillStyle");
						this.monitorChanging = true;
					}
				}
			}, {
				checked: false,
				text: SLANG.fill_without_style,
				handler: function() {
					if("fillContent" != this.curFillType) {
						this.sheet.fireEvent("undo", true, true);
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, "fillContent");
						this.monitorChanging = true;
					}
				}
			},{
				checked: false,
				text: SLANG.copy_without_style,
				handler: function() {
					if("copyContent" != this.curFillType) {
						this.sheet.fireEvent("undo", true, true);
						this.monitorChanging = false;
						this.autofilling(this.fromSpan, this.toSpan, this.dotFlag, "copyContent");
						this.monitorChanging = true;
					}
				}
			}]
		});
	},
	showAutofillKit: function(range) {
		var maxPos = range.getMaxPos();
		var store = this.sheet.getStore(),
			sheetId = this.sheet.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, maxPos.col, undefined, true) + this.kitOffset[0];
		var y = store.getRangeHeight(sheetId, 1, maxPos.row, undefined, true) + this.kitOffset[1];
		if(!this.autofillKit) {
			this.autofillKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet: this.sheet,
				localKit: true,
				floatingConfig: {
					xtype: "button",
					iconCls: "icon-autofill",
					x: x,
					y: y,
					ddConfig: false,
					destroyMenu: false,
					resizeConfig: false,
					menu: true,
					handler: function(btn) {
						this.autofillMenu.showBy(btn);
					},
					scope: this
				}
			});
		} else {
			this.autofillKit.setXY([x, y]);
		}
		this.autofillKit.show();
	},
	hideAutofillKit: function() {
		if(this.monitorChanging && this.autofillKit) {
			this.autofillKit.hide();
		}
	},
	copyCell: function(fromSpan, toSpan, dir, dotFlag, reCalCells) {
		this.curFillType = "copyCell";
		this.sheet.apply2Span(fromSpan, toSpan, null, null, dotFlag, undefined, undefined, reCalCells, true);
	},
	fillSequence: function(fromSpan, toSpan, dir, dotFlag, reCalCells) {
		this.curFillType = "fillSequence";
		var frowLen = 0 == fromSpan[3] ? 0 : fromSpan[3] - fromSpan[1] + 1,
			fcolLen = 0 == fromSpan[4] ? 0 : fromSpan[4] - fromSpan[2] + 1;
		var trowLen = 0 == toSpan[3] ? 0 : toSpan[3] - toSpan[1] + 1,
			tcolLen = 0 == toSpan[4] ? 0 : toSpan[4] - toSpan[2] + 1;
		var sheet = this.sheet;
		var ftflag = dotFlag ? "row" == dir ? "b2t" : "r2l" : false;
		var arrObj = this.prepareArray(fromSpan, dir, dotFlag, SCONFIG.SKIP_HIDDEN_ROW_AUTOFILL),
			grows = {};
		for(var p in arrObj) {
			if(arrObj.hasOwnProperty(p)) {
				grows[p] = SQBOX.tryMatch(arrObj[p]);
			}
		}
		var tmpFn = function() {
			return arguments[0];
		};
		sheet.apply2Span(fromSpan, toSpan, null, function(cd, row, col) {
			if("row" == dir) {
				if(0 != fcolLen) {
					col = (col - fromSpan[2]) % fcolLen;
					if(0 > col) {
						col += grows.length;
					}
					col += fromSpan[2];
				}
				if(row >= fromSpan[1]) {
					row = row - fromSpan[1];
				} else {
					row = fromSpan[3] - row;
				}
				var fn = grows[col] || tmpFn;
				return fn(cd, row);
			} else {
				if(0 != frowLen) {
					row = (row - fromSpan[1]) % frowLen;
					if(0 > row) {
						row += grows.length;
					}
					row += fromSpan[1];
				}
				if(col >= fromSpan[2]) {
					col = col - fromSpan[2];
				} else {
					col = fromSpan[4] - col;
				}
				var fn = grows[row] || tmpFn;
				return fn(cd, col);
			}
		}, ftflag, undefined, undefined, reCalCells, SCONFIG.SKIP_HIDDEN_ROW_AUTOFILL);
	},
	fillStyle: function(fromSpan, toSpan, dir, dotFlag, reCalCells) {
		this.curFillType = "fillStyle";
		this.sheet.apply2Span(fromSpan, toSpan, "style", null, dotFlag, undefined, undefined, reCalCells, true);
	},
	fillContent: function(fromSpan, toSpan, dir, dotFlag, reCalCells) {
		this.curFillType = "fillContent";
		var frowLen = 0 == fromSpan[3] ? 0 : fromSpan[3] - fromSpan[1] + 1,
			fcolLen = 0 == fromSpan[4] ? 0 : fromSpan[4] - fromSpan[2] + 1;
		var trowLen = 0 == toSpan[3] ? 0 : toSpan[3] - toSpan[1] + 1,
			tcolLen = 0 == toSpan[4] ? 0 : toSpan[4] - toSpan[2] + 1;
		var sheet = this.sheet;
		var ftflag = dotFlag ? "row" == dir ? "b2t" : "r2l" : false;
		var arrObj = this.prepareArray(fromSpan, dir, dotFlag, SCONFIG.SKIP_HIDDEN_ROW_AUTOFILL),
			grows = {};
		for(var p in arrObj) {
			if(arrObj.hasOwnProperty(p)) {
				grows[p] = SQBOX.tryMatch(arrObj[p]);
			}
		}
		var tmpFn = function() {
			return arguments[0];
		};
		sheet.apply2Span(fromSpan, toSpan, "data", function(cd, row, col) {
			if("row" == dir) {
				if(0 != fcolLen) {
					col = (col - fromSpan[2]) % fcolLen;
					if(0 > col) {
						col += grows.length;
					}
					col += fromSpan[2];
				}
				if(row >= fromSpan[1]) {
					row = row - fromSpan[1];
				} else {
					row = fromSpan[3] - row;
				}
				var fn = grows[col] || tmpFn;
				return fn(cd, row);
			} else {
				if(0 != frowLen) {
					row = (row - fromSpan[1]) % frowLen;
					if(0 > row) {
						row += grows.length;
					}
					row += fromSpan[1];
				}
				if(col >= fromSpan[2]) {
					col = col - fromSpan[2];
				} else {
					col = fromSpan[4] - col;
				}
				var fn = grows[row] || tmpFn;
				return fn(cd, col);
			}
		}, ftflag, undefined, undefined, reCalCells, SCONFIG.SKIP_HIDDEN_ROW_AUTOFILL);
	},
	copyContent: function(fromSpan, toSpan, dir, dotFlag, reCalCells) {
		this.curFillType = "copyContent";
		this.sheet.apply2Span(fromSpan, toSpan, "data", null, dotFlag, undefined, undefined, reCalCells, true);
	},
	onChangeReadOnly: function(readOnly, sheet) {
		if(readOnly) {
			this.hideAutofillKit();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.resize.ColumnResizer", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.common.Tip"],
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent(arguments);
	},
	colResizerWidth: 5,
	init: function(region) {
		this.region = region;
		this.mon(region, "afterrender", this.prepareResizer, this);
		this.mon(region, "cellmousemove", this.onCellMouseMove, this);
	},
	prepareResizer: function(p) {
		var el = p.getEl();
		this.cel = Ext.core.DomHelper.append(el, "<div class=\"ss-crz ss-crzx\" style=\"width:" + this.colResizerWidth + "px;\"></div>", true);
		this.mon(this.cel, "dblclick", this.onDblClick, this);
		this.cel.addClsOnOver("ss-crzx-over");
		this.cel.hide();
		this.cdd = new Ext.dd.DD(this.cel.id, "swift", {
			scroll: false
		});
		this.cdd.b4MouseDown = Ext.Function.createSequence(Ext.dd.DD.prototype.b4MouseDown, this.b4MouseDown, this);
		this.cdd.onDrag = Ext.Function.bind(this.onColResizing, this);
		this.cdd.endDrag = Ext.Function.bind(this.onColResized, this);
		if("string" == SCOM.typeOf(this.proxy)) {
			this.proxy = Ext.get(this.proxy);
		}
		if(!this.proxy instanceof Ext.Element) {
			this.proxy = Ext.core.DomHelper.append(document.body, "<div class=\"ss-crz-xproxy\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>", true);
		}
	},
	onDblClick: function(e) {
		var region = this.getRegion(),
			store = region.getStore(),
			sheetId = region.getSheetId();
		var col = this.col;
		var w = region.guessMaxColumnWidth(sheetId, col) + 20;
		var sw = store.getColWidth(sheetId, col, true, true);
		if(w && w != sw) {
			var old = {},
				cur = {};
			old[col] = sw;
			cur[col] = w;
			region.resizeColumn(col, w, true);
			this.cel.hide();
			this.fireEvent("columnresized", col, old, cur, region, this);
			this.resetFlag();
		} else {
			delete this.disableMouseOver;
			this.region.resumeTrackMouseOver();
			this.cel.removeCls("ss-crzx-drag");
		}
	},
	resetFlag: function() {
		delete this.pos;
		delete this.spos;
		delete this.row;
		delete this.col;
		delete this.disableMouseOver;
		this.region.resumeTrackMouseOver();
		this.cel.removeCls("ss-crzx-drag");
	},
	onColResized: function(e) {
		var region = this.getRegion(),
			store = region.getStore(),
			sm = region.getSelectionModel();
		var sheetId = region.getSheetId();
		var row = this.row,
			col = this.col,
			flag = false,
			cellEl, cw;
		var mincol, maxcol, old = {},
			cur = {};
		var span = sm.selection2Span();
		if(0 === span[1] && span[2] <= col && col <= span[4]) {
			cellEl = region.getCellEl(row, col);
			cw = cellEl.getWidth();
			if(false === this.fireEvent("selectedcolumnresized", cw, span[2], span[4], this)) {
				this.cel.hide();
				this.proxy.hide();
				SQTIP.hide();
				this.resetFlag();
				return;
			}
		}
		for(var i = region.colStart; i < col; i++) {
			cellEl = region.getCellEl(row, i);
			if(cellEl) {
				cw = cellEl.getWidth();
				if(0 == cw) {
					if(!flag) {
						mincol = i;
					}
					maxcol = i;
					flag = true;
				} else {
					var sw = store.getColWidth(sheetId, i, true, true);
					if(sw != cw) {
						old[i] = store.unzoomSize(sw);
						cw = store.unzoomSize(cw);
						cur[i] = cw;
						store.setColumnWidth(sheetId, i, cw, true, true);
					}
				}
			}
		}
		cellEl = region.getCellEl(row, col);
		cw = cellEl.getWidth();
		if(0 == cw) {
			if(flag) {
				maxcol++;
			} else {
				old[col] = true;
				cur[col] = false;
				store.hideColumn(sheetId, col, col);
			}
		} else {
			var sw = store.getColWidth(sheetId, col, true, true);
			if(sw != cw) {
				old[col] = store.unzoomSize(sw);
				cw = store.unzoomSize(cw);
				cur[col] = cw;
				store.setColumnWidth(sheetId, col, cw, true, flag);
			}
		}
		if(flag) {
			for(var k = mincol; k <= maxcol; k++) {
				old[k] = true;
				cur[k] = false;
			}
			store.hideColumn(sheetId, mincol, maxcol);
		}
		this.cel.hide();
		this.proxy.hide();
		SQTIP.hide();
		this.fireEvent("columnresized", this.col, old, cur, region, this);
		this.resetFlag();
	},
	b4MouseDown: function(x, y) {
		this.region.switchTrackMouseOver(false);
		this.disableMouseOver = true;
		this.cel.addCls("ss-crzx-drag");
	},
	onColResizing: function(e) {
		var region = this.getRegion(),
			store = region.getStore();
		var sheetId = region.getSheetId();
		var row = this.row,
			col = this.col;
		var r = this.cel.getRight(),
			offset = r - this.pos[0];
		this.pos[0] = r;
		if(0 != offset) {
			var xy = region.getCellEl(row, col).getXY();
			var woff = offset,
				w = 0;
			if(0 < woff) {
				var i;
				for(i = region.colStart; i < col; i++) {
					var cellEl = region.getCellEl(row, i);
					if(cellEl) {
						var cw = cellEl.getWidth();
						var sw = store.getColWidth(sheetId, i, true, true);
						woff += cw - sw;
						if(0 >= woff) {
							region.setCellElSize(row, i, sw + woff);
							woff = 0;
							break;
						} else {
							region.setCellElSize(row, i, sw);
						}
					}
				}
				if(i == col) {
					var cellEl = region.getCellEl(row, col);
					w = cellEl.getWidth() + woff;
					region.setCellElSize(row, col, w);
				}
			} else {
				for(var i = col, low = region.colStart; i >= low; i--) {
					var cellEl = region.getCellEl(row, i);
					if(cellEl) {
						var cw = cellEl.getWidth();
						woff += cw;
						if(0 <= woff) {
							if(i == col) {
								w = woff;
							}
							region.setCellElSize(row, i, woff);
							break;
						} else {
							region.setCellElSize(row, i, 0);
						}
					}
				}
			}
			region.updateOffsetWidth(offset);
			var pEl = Ext.get(this.proxy.dom.parentNode);
			this.proxy.setLeft(0);
			this.proxy.setWidth(r - pEl.getLeft() - 1);
			this.proxy.show();
			w = store.unzoomSize(w);
			SQTIP.show(SLANG.column_width + ": " + w + "px", this.cel, xy);
		}
	},
	onCellMouseMove: function(row, col, region, e) {
		if(!this.disableMouseOver && !region.isAutofillPress() && !region.isReadOnly()) {
			var cEl = region.getCellEl(row, col);
			if(cEl) {
				if(this.cel) {
					if(row != this.row || col != this.col) {
						var xy = e.getXY();
						var r = cEl.getRight();
						var h = cEl.getHeight();
						var rEl = region.getEl();
						var minx = rEl.getLeft(),
							maxx = Ext.getBody().getWidth();
						var left = r - minx - this.colResizerWidth;
						var right = maxx - r;
						if(Math.abs(xy[0] - r) <= this.colResizerWidth) {
							this.cel.setHeight(h - 1);
							this.cel.setLeft(left);
							this.cel.setTop(0);
							this.cel.show();
							this.cdd.setInitPosition();
							this.cdd.resetConstraints();
							this.cdd.setXConstraint(left + this.colResizerWidth, right);
							this.cdd.setYConstraint(0, 0);
							this.row = row;
							this.col = col;
							right = this.cel.getRight();
							var bottom = this.cel.getBottom();
							this.pos = [right, bottom];
							this.spos = [right, bottom];
							return;
						}
					}
				}
			}
		}
	},
	getRegion: function() {
		return this.region;
	},
	destroy: function() {
		var r = this.getRegion();
		r.un("afterrender", this.prepareResizer, this);
		r.un("cellmouseover", this.onCellMouseOver, this);
		this.clearListeners();
	}
});

Ext.define("EnterpriseSheet.sheet.resize.RowResizer", {
	extend: "Ext.util.Observable",
	requires: ["EnterpriseSheet.common.Tip"],
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent(arguments);
	},
	rowResizerHeight: 5,
	init: function(region) {
		this.region = region;
		this.mon(region, "afterrender", this.prepareResizer, this);
		this.mon(region, "cellmousemove", this.onCellMouseMove, this);
	},
	prepareResizer: function(p) {
		var el = p.getEl();
		this.rel = Ext.core.DomHelper.append(el, "<div class=\"ss-crz ss-crzy\" style=\"height:" + this.rowResizerHeight + "px;\"></div>", true);
		this.mon(this.rel, "dblclick", this.onDblClick, this);
		this.rel.addClsOnOver("ss-crzy-over");
		this.rel.hide();
		this.rdd = new Ext.dd.DD(this.rel.id, "swift", {
			scroll: false
		});
		this.rdd.b4MouseDown = Ext.Function.createSequence(Ext.dd.DD.prototype.b4MouseDown, this.b4MouseDown, this);
		this.rdd.onDrag = Ext.Function.bind(this.onRowResizing, this);
		this.rdd.endDrag = Ext.Function.bind(this.onRowResized, this);
		this.rdd.setXConstraint(0, 0);
		if("string" == SCOM.typeOf(this.proxy)) {
			this.proxy = Ext.get(this.proxy);
		}
		if(!(this.proxy instanceof Ext.Element)) {
			this.proxy = Ext.core.DomHelper.append(document.body, "<div class=\"ss-crz-yproxy\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>", true);
		}
	},
	onDblClick: function(e) {
		var region = this.getRegion(),
			store = region.getStore(),
			sheetId = region.getSheetId();
		var row = this.row;
		var h = region.guessMaxRowHeight(sheetId, row);
		if(SCOM.nullOrUndefined(h)) {
			h = store.defaultProperty.height;
		}
		var sh = store.getRowHeight(sheetId, row, true, true);
		if(h && h != sh) {
			var rowPro = store.getCell(sheetId, row, 0);
			var old = {
				height: rowPro.height,
				autoHeight: rowPro.autoHeight
			};
			region.resizeRowAutoHeight(row, h, true);
			rowPro = store.getCell(sheetId, row, 0);
			var cur = {
				height: rowPro.height,
				autoHeight: rowPro.autoHeight
			};
			this.rel.hide();
			this.fireEvent("rowautoresized", row, old, cur, region, this);
			this.resetFlag();
		} else {
			delete this.disableMouseOver;
			this.region.resumeTrackMouseOver();
			this.rel.removeCls("ss-crzy-drag");
		}
	},
	onRowResized: function(e) {
		var region = this.getRegion(),
			store = region.getStore(),
			sm = region.getSelectionModel();
		var sheetId = region.getSheetId();
		var row = this.row,
			col = this.col,
			flag = false,
			rowEl, ch;
		var minrow, maxrow, old = {},
			cur = {};
		var span = sm.selection2Span();
		if(0 === span[2] && span[1] <= row && row <= span[3]) {
			rowEl = region.getRowEl(row);
			ch = rowEl.getHeight();
			if(false === this.fireEvent("selectedrowresized", ch, span[1], span[3], this)) {
				this.rel.hide();
				this.proxy.hide();
				SQTIP.hide();
				this.resetFlag();
				return;
			}
		}
		for(var i = region.rowStart; i < row; i++) {
			rowEl = region.getRowEl(i);
			if(rowEl) {
				ch = rowEl.getHeight();
				if(0 == ch) {
					if(!flag) {
						minrow = i;
					}
					maxrow = i;
					flag = true;
				} else {
					var sh = store.getRowHeight(sheetId, i, true, true);
					if(sh != ch) {
						var rowPro = store.getCell(sheetId, i, 0);
						old[i] = {
							height: rowPro.height,
							autoHeight: rowPro.autoHeight
						};
						ch = store.unzoomSize(ch);
						cur[i] = ch;
						store.setRowHeight(sheetId, i, ch, true, true);
					}
				}
			}
		}
		rowEl = region.getRowEl(row);
		ch = rowEl.getHeight();
		if(0 == ch) {
			if(flag) {
				maxrow++;
			} else {
				old[row] = true;
				cur[row] = false;
				store.hideRow(sheetId, row, row);
			}
		} else {
			var sh = store.getRowHeight(sheetId, row, true, true);
			if(sh != ch) {
				var rowPro = store.getCell(sheetId, row, 0);
				old[row] = {
					height: rowPro.height,
					autoHeight: rowPro.autoHeight
				};
				ch = store.unzoomSize(ch);
				cur[row] = ch;
				store.setRowHeight(sheetId, row, ch, true, flag);
			}
		}
		if(flag) {
			for(var k = minrow; k <= maxrow; k++) {
				old[k] = true;
				cur[k] = false;
			}
			store.hideRow(sheetId, minrow, maxrow);
		}
		this.rel.hide();
		this.proxy.hide();
		SQTIP.hide();
		this.fireEvent("rowresized", this.row, old, cur, region, this);
		this.resetFlag();
	},
	resetFlag: function() {
		delete this.pos;
		delete this.spos;
		delete this.row;
		delete this.col;
		delete this.disableMouseOver;
		this.region.resumeTrackMouseOver();
		this.rel.removeCls("ss-crzy-drag");
	},
	onRowResizing: function(e) {
		var region = this.getRegion(),
			store = region.getStore();
		var sheetId = region.getSheetId();
		var row = this.row,
			col = this.col;
		var b = this.rel.getBottom(),
			offset = b - this.pos[1];
		this.pos[1] = b;
		if(0 != offset) {
			var xy = region.getCellEl(row, col).getXY();
			var hoff = offset,
				h = 0;
			if(0 < hoff) {
				var i;
				for(i = region.rowStart; i < row; i++) {
					var rowEl = region.getRowEl(i);
					if(rowEl) {
						var ch = rowEl.getHeight();
						var sh = store.getRowHeight(sheetId, i, true, true);
						hoff += ch - sh;
						if(0 >= hoff) {
							region.setRowElHeight(i, sh + hoff);
							hoff = 0;
							break;
						} else {
							region.setRowElHeight(i, sh);
						}
					}
				}
				if(i == row) {
					var rowEl = region.getRowEl(row);
					h = rowEl.getHeight() + hoff;
					region.setRowElHeight(row, h, true);
				}
			} else {
				for(var i = row, low = region.rowStart; i >= low; i--) {
					var rowEl = region.getRowEl(i);
					if(rowEl) {
						var ch = rowEl.getHeight();
						hoff += ch;
						if(0 <= hoff) {
							if(i == row) {
								h = hoff;
							}
							region.setRowElHeight(i, hoff);
							break;
						} else {
							region.setRowElHeight(i, 0);
						}
					}
				}
			}
			region.updateOffsetHeight(offset);
			var pEl = Ext.get(this.proxy.dom.parentNode);
			this.proxy.setTop(0);
			this.proxy.setHeight(b - pEl.getTop() - 1);
			this.proxy.show();
			h = store.unzoomSize(h);
			SQTIP.show(SLANG.row_height + ": " + h + "px", this.rel);
		}
	},
	b4MouseDown: function(x, y) {
		this.region.switchTrackMouseOver(false);
		this.disableMouseOver = true;
		this.rel.addCls("ss-crzy-drag");
	},
	onCellMouseMove: function(row, col, region, e) {
		if(!this.disableMouseOver && !region.isAutofillPress() && !region.isReadOnly()) {
			var cEl = region.getCellEl(row, col);
			if(cEl) {
				if(this.rel) {
					var xy = e.getXY();
					if(row != this.row || col != this.col) {
						var b = cEl.getBottom();
						var w = cEl.getWidth();
						var rEl = region.getEl();
						var miny = rEl.getTop(),
							maxy = Ext.getBody().getHeight();
						var top = b - miny - this.rowResizerHeight;
						var bottom = maxy - b;
						if(Math.abs(xy[1] - b) <= this.rowResizerHeight) {
							this.rel.setWidth(w - 1);
							this.rel.setTop(top);
							this.rel.setLeft(0);
							this.rel.show();
							this.rdd.setInitPosition();
							this.rdd.resetConstraints();
							this.rdd.setYConstraint(top + this.rowResizerHeight, bottom);
							this.rdd.setXConstraint(0, 0);
							this.row = row;
							this.col = col;
							right = this.rel.getRight();
							var bottom = this.rel.getBottom();
							this.pos = [right, bottom];
							this.spos = [right, bottom];
						}
					}
				}
			}
		}
	},
	getRegion: function() {
		return this.region;
	},
	destroy: function() {
		var r = this.getRegion();
		r.un("afterrender", this.prepareResizer, this);
		r.un("cellmouseover", this.onCellMouseOver, this);
		this.clearListeners();
	}
});

Ext.define("EnterpriseSheet.sheet.sm.AbstractSelectionModel", {
	extend: "Ext.util.Observable",
	autofillCls: "ss-autofill",
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent([config]);
		Ext.getDoc().on("mouseup", this.resetAutofill, this);
	},
	init: function(region) {
		this.region = region;
		this.mon(region, "afterrender", this.prepareAfterRender, this);
		this.bindListener2Region(region);
	},
	calculateRowColSpan: function(fromSpan) {
		var rowSpan = 1,
			colSpan = 1;
		var hasMerged = false;
		var store = this.getRegion().getStore(),
			sm = this,
			tmpCache = {};
		store.walkRange([fromSpan], function(rd, span, store) {
			var json = rd.data.json;
			if(store.isMergedCell(json, rd.data.sheet, rd.data.row, rd.data.col)) {
				var arr = [json.maxrow - json.minrow + 1, json.maxcol - json.mincol + 1];
				var id = arr.join("$");
				tmpCache[id] = arr;
			} else {
				tmpCache.single = true;
			}
			if(1 < SCOM.countObjMember(tmpCache)) {
				hasMerged = true;
				return false;
			}
		}, this);
		if(hasMerged) {
			rowSpan = fromSpan[3] - fromSpan[1] + 1;
			colSpan = fromSpan[4] - fromSpan[2] + 1;
		} else if(1 == SCOM.countObjMember(tmpCache) && !tmpCache.single) {
			hasMerged = true;
			for(var p in tmpCache) {
				if(tmpCache.hasOwnProperty(p)) {
					var arr = tmpCache[p];
					rowSpan = arr[0];
					colSpan = arr[1];
				}
			}
		}
		return {
			hasMerged: hasMerged,
			rowSpan: rowSpan,
			colSpan: colSpan
		};
	},
	adjustToSpanForMerged: function(fromSpan, toSpan, config) {
		var me = this;
		config = config || this.calculateRowColSpan(fromSpan);
		var hasMerged = config.hasMerged,
			rowSpan = config.rowSpan,
			colSpan = config.colSpan;
		if(hasMerged) {
			if(fromSpan[3] == toSpan[3] && fromSpan[4] == toSpan[4]) {
				toSpan[1] = toSpan[3] - Math.ceil((toSpan[3] - toSpan[1] + 1) / rowSpan) * rowSpan + 1;
				toSpan[2] = toSpan[4] - Math.ceil((toSpan[4] - toSpan[2] + 1) / colSpan) * colSpan + 1;
			} else {
				toSpan[3] = Math.ceil((toSpan[3] - toSpan[1] + 1) / rowSpan) * rowSpan + toSpan[1] - 1;
				toSpan[4] = Math.ceil((toSpan[4] - toSpan[2] + 1) / colSpan) * colSpan + toSpan[2] - 1;
			}
			if(0 == toSpan[1] || 0 == toSpan[3]) {
				toSpan[1] = 0;
				toSpan[3] = 0;
			}
			if(0 == toSpan[2] || 0 == toSpan[4]) {
				toSpan[2] = 0;
				toSpan[4] = 0;
			}
			me.selectRange({
				row: toSpan[1],
				col: toSpan[2]
			}, {
				row: toSpan[3],
				col: toSpan[4]
			});
		}
		return toSpan;
	},
	prepareForAutofill: function(suspendEvent) {
		if(this.el) {
			this._clone = this.cloneSelection();
			Ext.get(this._clone).setStyle("z-index", "");
			this.el.addCls(this.autofillCls);
		}
		if(!suspendEvent) {
			this.fireEvent("prepareautofillstyle", this);
		}
	},
	bindListener2Region: function(region) {
		this.mon(region, "cellmousedown", function() {
			if(!this.disabled) {
				if(Ext.isChrome && this.el) {
					var pEl = Ext.get(this.el.dom.parentNode);
					pEl.hide();
					pEl.show();
				}
				this.onCellMouseDown.apply(this, arguments);
			}
		}, this);
		this.mon(region, "autofillmousedown", function(row, col, region, e, flag) {
			if(!this.disabled) {
				this.prepareForAutofill();
				this.autofillPos = this.getMinMaxPos();
				var res = this.calculateRowColSpan(this.selection2Span());
				this.autofillPos.rowSpan = res.rowSpan;
				this.autofillPos.colSpan = res.colSpan;
				this.autofillPos.sheet = this.getRegion().getSheetId();
				this.autofillPos.flag = flag;
			}
		}, this);
		this.mon(region, "cellmousedrag", function() {
			if(!this.disabled) {
				this.onCellMouseDrag.apply(this, arguments);
			}
		}, this);
		this.mon(region, "autofillmousedrag", function() {
			if(!this.disabled) {
				this.onAutofillDrag.apply(this, arguments);
			}
		}, this);
		this.mon(region, "cellmouseup", function() {
			if(!this.disabled) {
				this.onCellMouseUp.apply(this, arguments);
			}
		}, this);
		this.mon(region, "autofillmouseup", function() {
			if(!this.disabled) {
				this.onAutofillMouseUp.apply(this, arguments);
			}
		}, this);
	},
	initDD: function() {},
	getHtmlStr: function() {
		return "";
	},
	cloneSelection: function() {
		if(this.el) {
			var ifbody = this.getRegion().ifbodyEl.dom;
			var clone = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);
			var width = this.el.getWidth();
			if(width) {
				clone.setWidth(width);
			} else {
				clone.setStyle("width", this.el.getStyle("width"));
			}
			var height = this.el.getHeight();
			if(height) {
				clone.setHeight(this.el.getHeight());
			} else {
				clone.setStyle("height", this.el.getStyle("height"));
			}
			clone.setStyle("left", this.el.getStyle("left"));
			clone.setStyle("top", this.el.getStyle("top"));
			clone.setStyle("z-index", this.el.getStyle("z-index"));
			return clone.dom;
		}
	},
	resetAutofill: function(suspendEvent) {
		if(this.el) {
			this.el.removeCls(this.autofillCls);
		}
		if(this._clone) {
			Ext.removeNode(this._clone);
		}
		if(!suspendEvent) {
			this.fireEvent("resetautofillstyle", this);
		}
	},
	addCls: function(cls) {
		if(this.el) {
			this.el.addCls(cls);
		}
	},
	removeCls: function(cls) {
		if(this.el) {
			this.el.removeCls(cls);
		}
	},
	setMode: function(mode) {
		if(mode) {
			this.mode = mode;
		} else {
			delete this.mode;
		}
	},
	within: function(target) {
		return target.hasCls("ss-sm-inner") || target.hasCls("ss-sm") || target.hasCls("ss-sm-border2") || target.hasCls("ss-colorbar") || !target.hasCls("ss-trigger") && !target.hasCls("ss-tpl-rz") && !target.hasCls("ss-col-group") && !target.hasCls("ss-row-group") && !target.hasCls("ss-group-head") && !target.hasCls("ss-group-tail") && target.up(".ss-cell");
	},
	atDot: function(target) {
		if(Ext.supports.ClassList && !target.dom.classList) {
			return null;
		}
		if(this.el.contains(target)) {
			var ltdot = target.hasCls("ss-sm-ltdot");
			if(!ltdot) {
				rbdot = target.hasCls("ss-sm-rbdot");
				return rbdot ? "rb" : null;
			} else {
				return "lt";
			}
		}
	},
	transfer2MinMaxPos: function(startPos, endPos) {
		var minrow = startPos.row,
			mincol = startPos.col,
			maxrow = endPos.row,
			maxcol = endPos.col;
		if(minrow > maxrow) {
			var tmp = minrow;
			minrow = maxrow;
			maxrow = tmp;
		}
		if(mincol > maxcol) {
			var tmp = mincol;
			mincol = maxcol;
			maxcol = tmp;
		}
		if(0 == minrow && 0 < maxrow) {
			minrow = maxrow;
			maxrow = 0;
		}
		if(0 == mincol && 0 < maxcol) {
			mincol = maxcol;
			maxcol = 0;
		}
		return {
			minrow: minrow,
			mincol: mincol,
			maxrow: maxrow,
			maxcol: maxcol
		};
	},
	onCellMouseDrag: function(row, col, position, region, e) {},
	onAutofillDrag: function(row, col, position, region, e) {},
	onCellMouseDown: function(row, col, region, e) {},
	onCellMouseUp: function(region, e) {},
	onAutofillMouseUp: function(region, e) {
		this.onCellMouseUp(region, e);
		var autofillPos = Ext.apply({}, this.autofillPos);
		delete this.autofillPos;
		this.fireEvent("autofilldragend", autofillPos, region, this);
	},
	prepareAfterRender: function() {
		this.prepareSelectionModel.apply(this, arguments);
		if(this.el && !this.skipZIndex) {
			this.el.setStyle("z-index", SCONST.SM_Z_INDEX);
		}
		if(this.enableDD) {
			this.initDD();
		}
	},
	prepareSelectionModel: function(region) {},
	processPosForSimpleSelect: function(startPos, endPos) {
		if(0 == startPos.row) {
			startPos.row = 1;
		}
		if(0 == startPos.col) {
			startPos.col = 1;
		}
		if(0 == endPos.row) {
			endPos.row = 1;
		}
		if(0 == endPos.col) {
			endPos.col = 1;
		}
		if(Math.abs(endPos.row - startPos.row) > Math.abs(endPos.col - startPos.col)) {
			endPos.col = startPos.col;
		} else {
			endPos.row = startPos.row;
		}
	},
	hideSelection: function() {},
	pushSelection: function() {},
	selectRange: function(startPos, endPos, suspendEvent) {
		if(!this.skipHideFlag) {
			if(!EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag) {
				this.hideSelection();
			}
		}
		if(startPos) {
			if(this.singleSelect) {
				if(startPos) {
					if(0 == startPos.row) {
						startPos.row = 1;
					}
					if(0 == startPos.col) {
						startPos.col = 1;
					}
				}
				if(endPos) {
					Ext.apply(endPos, startPos);
				}
			}
			endPos = endPos || Ext.apply({}, startPos);
			if(this.simpleSelect) {
				this.processPosForSimpleSelect(startPos, endPos);
			}
			if(false !== this.fireEvent("beforeselectionchange", startPos, endPos, this)) {
				this.doSelect(startPos, endPos, suspendEvent);
				this.startPos = Ext.apply({}, startPos);
				this.endPos = Ext.apply({}, endPos);
				if(!suspendEvent) {
					this.fireEvent("selectionchange", startPos, endPos, this.getRegion(), this);
				}
			}
		} else {
			this.clearSelection(suspendEvent);
		}
	},
	doSelect: function(startPos, endPos, suspendEvent, el) {},
	isSelected: function(row, col) {},
	refreshSelection: function() {
		if(this.startPos && this.endPos) {
			this.selectRange(this.startPos, this.endPos, true);
		}
	},
	getFocusCell: function() {
		if(this.focusCell) {
			return Ext.apply({}, this.focusCell);
		}
	},
	setFocusCell: function(row, col, suspendEvent, skipMergeCheck) {
		var region = this.getRegion(),
			store = region.getStore();
		var sheetId = region.getSheetId();
		var cd = store.getCell(sheetId, row, col);
		if(!skipMergeCheck) {
			if(store.isMergedCell(cd, sheetId, row, col)) {
				row += cd.minrow;
				col += cd.mincol;
				cd = store.getCell(sheetId, row, col);
			}
		}
		var oldFocus = Ext.apply({}, this.focusCell);
		this.focusCell = {
			row: row,
			col: col
		};
		if(!suspendEvent) {
			if(oldFocus.row != row || oldFocus.col != col) {
				this.fireEvent("focuschange", row, col, this, cd);
			}
		}
	},
	getRegion: function() {
		return this.region;
	},
	getMinMaxPos: function() {
		if(this.startPos) {
			return this.transfer2MinMaxPos(this.startPos, this.endPos);
		}
	},
	getSelection: function() {
		return {
			startPos: Ext.apply({}, this.startPos),
			endPos: Ext.apply({}, this.endPos)
		};
	},
	getMultiSelections: function() {
		var sels = [];
		for(var p in this.stack) {
			var it = this.stack[p];
			var coord = it.coord;
			sels.push(coord);
		}
		if(!this.isEmpty()) {
			var coord = this.selection2Span();
			var id = coord.join("$");
			if(!this.stack || !this.stack[id]) {
				sels.push(coord);
			}
		}
		return sels;
	},
	clearSelection: function(suspendEvent) {
		delete this.startPos;
		delete this.endPos;
		if(!suspendEvent) {
			this.fireEvent("selectionchange", this.startPos, this.endPos, this.getRegion(), this);
		}
	},
	isEmpty: function() {
		return !this.startPos;
	},
	selectPrevious: function(dir, expand, suspendEvent) {
		if(this.disabled) {
			return;
		}
		if("col" !== dir) {
			dir = "row";
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, focusCell = this.getFocusCell(),
			posFlag;
		if(expand) {
			minMaxPos = this.getMinMaxPos();
			posFlag = minMaxPos.minrow == focusCell.row && "row" == dir || minMaxPos.mincol == focusCell.col && "col" == dir;
			if(posFlag) {
				pos = {
					row: minMaxPos.maxrow,
					col: minMaxPos.maxcol
				};
			} else {
				pos = {
					row: minMaxPos.minrow,
					col: minMaxPos.mincol
				};
			}
		} else {
			pos = focusCell;
		}
		if(pos) {
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true);
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if("row" == dir) {
				if(merged) {
					row = pos.row + cell.minrow;
				} else {
					row = pos.row;
				}
				for(var i = row - 1; 1 <= i; i--) {
					if(store.isVisibleRow(sheetId, i)) {
						break;
					}
				}
				if(1 <= i) {
					row = i;
				}
				col = pos.col;
			} else {
				row = pos.row;
				if(merged) {
					col = pos.col + cell.mincol;
				} else {
					col = pos.col;
				}
				for(var i = col - 1; 1 <= i; i--) {
					if(store.isVisibleColumn(sheetId, i)) {
						break;
					}
				}
				if(1 <= i) {
					col = i;
				}
			}
			if(expand) {
				if(posFlag) {
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row: row,
						col: col
					}, suspendEvent);
				} else {
					this.selectRange({
						row: row,
						col: col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}
			} else {
				this.selectRange({
					row: row,
					col: col
				}, {
					row: row,
					col: col
				}, suspendEvent);
				this.setFocusCell(row, col, suspendEvent);
			}
			return {
				row: row,
				col: col
			};
		}
	},
	selectNext: function(dir, expand, suspendEvent) {
		if(this.disabled) {
			return;
		}
		if("col" !== dir) {
			dir = "row";
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, focusCell = this.getFocusCell(),
			posFlag;
		if(expand) {
			minMaxPos = this.getMinMaxPos();
			posFlag = minMaxPos.minrow == focusCell.row && "row" == dir || minMaxPos.mincol == focusCell.col && "col" == dir;
			if(posFlag) {
				pos = {
					row: minMaxPos.maxrow,
					col: minMaxPos.maxcol
				};
			} else {
				pos = {
					row: minMaxPos.minrow,
					col: minMaxPos.mincol
				};
			}
		} else {
			pos = focusCell;
		}
		if(pos) {
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true);
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if("row" == dir) {
				if(merged) {
					row = pos.row + cell.maxrow;
				} else {
					row = pos.row;
				}
				if(row >= SCONST.MAX_ROW_NUMBER) {
					return {
						row: row,
						col: col
					};
				}
				row++;
				col = pos.col;
				for(var i = row; true; i++) {
					if(store.isVisibleRow(sheetId, i)) {
						break;
					}
				}
				row = i;
			} else {
				row = pos.row;
				if(merged) {
					col = pos.col + cell.maxcol;
				} else {
					col = pos.col;
				}
				if(col >= SCONST.MAX_COLUMN_NUMBER) {
					return {
						row: row,
						col: col
					};
				}
				col++;
				for(var i = col; true; i++) {
					if(store.isVisibleColumn(sheetId, i)) {
						break;
					}
				}
				col = i;
			}
			if(expand) {
				if(posFlag) {
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row: row,
						col: col
					}, suspendEvent);
				} else {
					this.selectRange({
						row: row,
						col: col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}
			} else {
				this.selectRange({
					row: row,
					col: col
				}, {
					row: row,
					col: col
				}, suspendEvent);
				this.setFocusCell(row, col, suspendEvent);
			}
			return {
				row: row,
				col: col
			};
		}
	},
	getDefaultSelection: function() {
		return {
			startPos: {
				row: 1,
				col: 1
			},
			endPos: {
				row: 1,
				col: 1
			}
		};
	},
	getDefaultFocusCell: function() {
		return {
			row: 1,
			col: 1
		};
	},
	enableSelect: function(clear, single, simple) {
		this.disabled = false;
		if(clear) {
			this.clearSelection(true);
		}
		this.setSingleSelect(single);
		this.setSimpleSelect(simple);
	},
	disableSelect: function(clear, single, simple) {
		this.disabled = true;
		if(clear) {
			this.clearSelection(true);
		}
		this.setSingleSelect(single);
		this.setSimpleSelect(simple);
	},
	setSingleSelect: function(single) {
		this.singleSelect = single;
	},
	setSimpleSelect: function(simple) {
		this.simpleSelect = simple;
	},
	selection2Coord: function() {
		return this.getMultiSelections();
	},
	selection2Span: function() {
		var sheetId = this.getRegion().getSheetId();
		var mm = this.transfer2MinMaxPos(this.startPos, this.endPos);
		return [sheetId, mm.minrow, mm.mincol, mm.maxrow, mm.maxcol];
	},
	destroy: function() {
		var r = this.getRegion();
		r.un("afterrender", this.prepareAfterRender, this);
		r.un("cellmousedown", this.onCellMouseDown, this);
		r.un("cellmousedrag", this.onCellMouseDrag, this);
		r.un("cellmouseup", this.onCellMouseUp, this);
		this.clearListeners();
	},
	hide: function(suspendEvent) {
		if(this.el) {
			this.el.hide();
		}
		if(!suspendEvent) {
			this.fireEvent("hide", this);
		}
	},
	getEl: function() {
		return this.el;
	},
	show: function(suspendEvent) {
		if(this.el) {
			this.el.show();
		}
		if(!suspendEvent) {
			this.fireEvent("show", this);
		}
	},
	isVisible: function() {
		if(this.el) {
			return this.el.isVisible();
		}
		return false;
	}
});

Ext.define("EnterpriseSheet.sheet.sm.CellSelectionModel", {
	extend: "EnterpriseSheet.sheet.sm.AbstractSelectionModel",
	requires: ["Ext.util.Point", "Ext.dd.DDProxy"],
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent([config]);
	},
	allowDragScrolling: true,
	dragScrolling: false,
	dragScrollingStep: Ext.isIE ? 1 : 2,
	paddingOffset: 0,
	borderOffset: 2,
	borderWidth: 2,
	start2ScrollOffset: 16,
	dragScrollingInterval: Ext.isIE ? 100 : 50,
	enableDD: true,
	getHtmlStr: function() {
		return ["<div class=\"ss-sm ", this.cls || "", "\" style=\"border-width:", this.borderWidth, "px;", this.style || "", "\">", "<div class=\"ss-sm-inner\"></div>", "<div class=\"ss-sm-ltdot\" style=\"", this.ltDotStyle || "", "\"></div>", "<div class=\"ss-sm-rbdot\" style=\"", this.rbDotStyle || "", "\"></div>", "</div>"].join("");
	},
	init: function(region) {
		this.callParent([region]);
		this.mon(region, {
			scope: this,
			columnchange: this.refreshSelection,
			rowchange: this.refreshSelection,
			rowremoved: this.onRowRemoved,
			columnremoved: this.onColumnRemoved,
			cellinserted: this.refreshSelection,
			rowinserted: this.refreshSelection,
			columninserted: this.refreshSelection,
			hiderow: this.refreshSelection,
			hidecolumn: this.refreshSelection,
			showrow: this.refreshSelection,
			showcolumn: this.refreshSelection
		});
	},
	prepareSelectionModel: function(region) {
		var ifbody = region.ifbodyEl.dom;
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);
		this.inel = this.el.down(".ss-sm-inner");
		this.ltdot = this.el.down(".ss-sm-ltdot");
		this.rbdot = this.el.down(".ss-sm-rbdot");
	},
	initDD: function() {
		var me = this,
			region = me.region,
			store = region.getStore(),
			sheetId = region.getSheetId();
		if(this.el) {
			this.ddProxy = new Ext.dd.DDProxy(this.el.id, "", {
				moveOnly: true,
				scroll: false
			});
			Ext.apply(this.ddProxy, {
				moveOnly: true,
				scroll: false
			});
			var topZIndex = SCONST.TOP_Z_INDEX;
			this.ddProxy.addInvalidHandleClass("ss-sm-inner");
			this.ddProxy.addInvalidHandleClass("ss-sm-ltdot");
			this.ddProxy.addInvalidHandleClass("ss-sm-rbdot");
			var curSpan, minrow, mincol, maxrow, maxcol, rlen, clen, near, insertDir, valid = true;
			this.ddProxy.startDrag = function(x, y) {
				if(me.disabled) {
					return false;
				}
				this.constrainTo(me.el.dom.parentNode);
				var el = Ext.get(this.getDragEl());
				el.addCls("ss-sm-proxy");
				el.setStyle("border", "none");
				el.setStyle("z-index", topZIndex);
				var info = me.getPageXYFromPos([me.startPos.row, me.startPos.col], [me.endPos.row, me.endPos.col]);
				el.setXY([info[0], info[1]]);
				curSpan = me.selection2Span();
				minrow = curSpan[1];
				mincol = curSpan[2];
				maxrow = curSpan[3];
				maxcol = curSpan[4];
				rlen = maxrow - minrow + 1;
				clen = maxcol - mincol + 1;
			};
			this.ddProxy.onDrag = function(e) {
				if(me.disabled) {
					return false;
				}
				var el = Ext.get(this.getDragEl());
				if(el) {
					if(e.shiftKey) {
						el.addCls("ss-sm-insert-proxy");
					} else {
						el.removeCls("ss-sm-insert-proxy");
					}
					var xy = e.getXY();
					var pos = region.getRowColFromPos(xy);
					if(0 == me.startPos.row && 0 == me.startPos.col) {
						pos[0] = 0;
						pos[1] = 0;
					} else if(0 == me.startPos.row) {
						pos[0] = 0;
					} else if(0 == me.startPos.col) {
						pos[1] = 0;
					}
					me.startPos.row = pos[0];
					me.startPos.col = pos[1];
					me.endPos.row = pos[0] + rlen - 1;
					me.endPos.col = pos[1] + clen - 1;
					var info = me.getPageXYFromPos(pos, [me.endPos.row, me.endPos.col]);
					el.setXY([info[0], info[1]]);
					if(e.shiftKey && 0 !== me.startPos.row && 0 !== me.startPos.col) {
						near = "y";
						if(xy[0] - info[0] < xy[1] - info[1]) {
							near = "x";
						}
					}
					insertDir = "x" === near ? "right" : "y" === near ? "down" : undefined;
					if(0 == me.startPos.row && 0 == me.startPos.col) {} else if(0 == me.startPos.row) {
						if(el.hasCls("ss-sm-insert-proxy")) {
							el.setWidth(0);
						} else {
							el.setWidth(info[2] - 1);
						}
					} else if(0 == me.startPos.col) {
						if(el.hasCls("ss-sm-insert-proxy")) {
							el.setHeight(0);
						} else {
							el.setHeight(info[3] - 1);
						}
					} else {
						if(e.shiftKey) {
							var fromSpan = curSpan,
								toSpan = me.selection2Span();
							valid = false;
							if("right" === insertDir) {
								if(toSpan[2] > fromSpan[4]) {
									valid = true;
								} else if(fromSpan[1] === toSpan[1] && fromSpan[3] === toSpan[3] && toSpan[2] <= fromSpan[2]) {
									valid = true;
								} else if(fromSpan[1] > toSpan[3] || fromSpan[3] < toSpan[1]) {
									valid = true;
								}
							} else {
								if(toSpan[1] > fromSpan[3]) {
									valid = true;
								} else if(fromSpan[2] === toSpan[2] && fromSpan[4] === toSpan[4] && toSpan[1] <= fromSpan[1]) {
									valid = true;
								} else if(fromSpan[2] > toSpan[4] || fromSpan[4] < toSpan[2]) {
									valid = true;
								}
							}
							if(!valid) {
								el.setStyle("display", "none");
							} else {
								el.setStyle("display", "block");
							}
						}
						if(el.hasCls("ss-sm-insert-proxy") && "x" == near) {
							el.setWidth(0);
						} else {
							el.setWidth(info[2] - 1);
						}
						if(el.hasCls("ss-sm-insert-proxy") && "y" == near) {
							el.setHeight(0);
						} else {
							el.setHeight(info[3] - 1);
						}
					}
				}
			};
			this.ddProxy.endDrag = function(e) {
				if(me.disabled) {
					return false;
				}
				var toSpan = me.selection2Span();
				if(valid) {
					me.fireEvent("selectionmoving", [].concat(curSpan), [].concat(toSpan), this, e.shiftKey, insertDir);
					me.selectRange(me.startPos, me.endPos);
					me.setFocusCell(me.startPos.row, me.startPos.col);
				} else {
					me.selectRange({
						row: curSpan[1],
						col: curSpan[2]
					}, {
						row: curSpan[3],
						col: curSpan[4]
					});
					me.setFocusCell(curSpan[1], curSpan[2]);
				}
			};
		}
	},
	onCellMouseUp: function() {
		if(this.task) {
			Ext.TaskManager.stop(this.task);
		}
		delete EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag;
		this.dragScrolling = false;
		delete this.task;
	},
	startDragScrolling: function(position) {
		this.position = position;
		if(!this.task) {
			this.task = {
				run: function() {
					var pos = Ext.apply({}, this.endPos),
						movePos = Ext.apply({}, pos);
					if(this.dragScrolling && this.checkDragScrolling(this.position, pos, movePos)) {
						this.dragScrolling = this.region.autoMoving(movePos);
					} else {
						this.dragScrolling = false;
					}
					if(this.dragScrolling) {
						this.selectRange(this.startPos, pos);
					} else {
						delete this.task;
					}
					return this.dragScrolling;
				},
				interval: this.dragScrollingInterval,
				scope: this
			};
			Ext.TaskManager.start(this.task);
		}
	},
	checkDragScrolling: function(position, pos, movePos) {
		movePos = movePos || {};
		var rowBoundMax = SCONST.MAX_ROW_NUMBER,
			colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		var r = this.getRegion();
		var x = position.x,
			y = position.y,
			w = position.w,
			h = position.h;
		var flag = false;
		if(0 != pos.row) {
			if(this.start2ScrollOffset > y) {
				if(pos.row > r.rowBound.low || r.rowStart > r.rowBound.low) {
					var row = pos.row - this.dragScrollingStep;
					if(row > r.rowBound.low) {
						pos.row = row;
					} else {
						pos.row = r.rowBound.low;
					}
					flag = true;
					movePos.row = pos.row;
				}
			} else if(y > h - this.start2ScrollOffset) {
				if(!r.rowBound.high) {
					pos.row += this.dragScrollingStep;
					if(pos.row <= r.rowEnd) {
						pos.row = r.rowEnd + 1;
					}
					if(rowBoundMax && pos.row > rowBoundMax) {
						pos.row = rowBoundMax;
						movePos.row = rowBoundMax + 1;
					} else {
						movePos.row = pos.row;
					}
					flag = true;
				} else {
					this.fireEvent("dragscrollinglimited", "row", "high", pos, this, r);
				}
			}
		}
		if(flag && Ext.isIE) {
			return flag;
		}
		if(0 != pos.col) {
			if(this.start2ScrollOffset > x) {
				if(pos.col > r.colBound.low || r.colStart > r.colBound.low) {
					var col = pos.col - this.dragScrollingStep;
					if(col > r.colBound.low) {
						pos.col = col;
					} else {
						pos.col = r.colBound.low;
					}
					flag = true;
					movePos.col = pos.col;
				}
			} else if(x > w - this.start2ScrollOffset) {
				if(!r.colBound.high) {
					pos.col += this.dragScrollingStep;
					if(pos.col <= r.colEnd) {
						pos.col = r.colEnd + 1;
					}
					if(colBoundMax && pos.col > colBoundMax) {
						pos.col = colBoundMax;
						movePos.col = colBoundMax + 1;
					} else {
						movePos.col = pos.col;
					}
					flag = true;
				} else {
					this.fireEvent("dragscrollinglimited", "col", "high", pos, this, r);
				}
			}
		}
		return flag;
	},
	onCellMouseDrag: function(row, col, position, region, e) {
		e.stopEvent();
		if(this.startPos) {
			if(this.mode) {
				var type = this.mode.type,
					maxrow = this.mode.maxrow,
					maxcol = this.mode.maxcol,
					minrow = this.mode.minrow,
					mincol = this.mode.mincol;
				if("bottom-right" == type) {
					if(Math.abs(row - maxrow) > Math.abs(col - maxcol)) {
						col = maxcol;
					} else {
						row = maxrow;
					}
					if(col < mincol) {
						col = mincol;
					}
					if(row < minrow) {
						row = minrow;
					}
				}
			}
			if(0 == this.startPos.row) {
				row = 0;
			}
			if(0 == this.startPos.col) {
				col = 0;
			}
			this.selectRange(this.startPos, {
				row: row,
				col: col
			});
			if(this.allowDragScrolling && 0 === e.button) {
				if(this.checkDragScrolling(position, {
						row: row,
						col: col
					})) {
					this.dragScrolling = true;
					this.startDragScrolling(position);
				} else {
					this.dragScrolling = false;
				}
			} else {
				this.dragScrolling = false;
			}
		}
	},
	onAutofillDrag: function(row, col, position, region, e) {
		e.stopEvent();
		if(this.startPos) {
			var startPos;
			var flag = this.autofillPos.flag,
				minrow = this.autofillPos.minrow,
				mincol = this.autofillPos.mincol,
				maxrow = this.autofillPos.maxrow,
				maxcol = this.autofillPos.maxcol;
			rowSpan = this.autofillPos.rowSpan, colSpan = this.autofillPos.colSpan;
			if("rb" == flag) {
				if(0 == minrow) {
					row = maxrow;
				} else if(0 == mincol) {
					col = maxcol;
				} else if(Math.abs(row - maxrow) > Math.abs(col - maxcol)) {
					col = maxcol;
				} else {
					row = maxrow;
				}
				startPos = {
					row: minrow,
					col: mincol
				};
				if(row < minrow) {
					startPos.row = maxrow;
					this.autofillPos.flag = "lt";
				}
				if(col < mincol) {
					startPos.col = maxcol;
					this.autofillPos.flag = "lt";
				}
			} else {
				if(0 == maxrow) {
					row = minrow;
				} else if(0 == maxcol) {
					col = mincol;
				} else if(Math.abs(row - minrow) > Math.abs(col - mincol)) {
					col = mincol;
				} else {
					row = minrow;
				}
				startPos = {
					row: maxrow,
					col: maxcol
				};
				if(row > maxrow) {
					startPos.row = minrow;
					this.autofillPos.flag = "rb";
				}
				if(col > maxcol) {
					startPos.col = mincol;
					this.autofillPos.flag = "rb";
				}
			}
			if(row < startPos.row) {
				row = startPos.row - Math.ceil((startPos.row - row + 1) / rowSpan) * rowSpan + 1;
			} else {
				row = startPos.row + Math.ceil((row - startPos.row + 1) / rowSpan) * rowSpan - 1;
			}
			if(col < startPos.col) {
				col = startPos.col - Math.ceil((startPos.col - col + 1) / colSpan) * colSpan + 1;
			} else {
				col = startPos.col + Math.ceil((col - startPos.col + 1) / colSpan) * colSpan - 1;
			}
			this.selectRange(startPos, {
				row: row,
				col: col
			});
			if(this.allowDragScrolling && 0 === e.button) {
				if(this.checkDragScrolling(position, {
						row: row,
						col: col
					})) {
					this.dragScrolling = true;
					this.startDragScrolling(position);
				} else {
					this.dragScrolling = false;
				}
			}
		}
	},
	isSelected: function(row, col) {
		if(this.startPos && this.endPos) {
			if(row >= this.startPos.row && row <= this.endPos.row && col >= this.startPos.col && col <= this.endPos.col) {
				return true;
			}
		}
		return false;
	},
	cloneSelection: function() {
		var dom = this.callParent(arguments);
		if(dom) {
			Ext.get(dom).addCls("ss-sm-multi");
		}
		return dom;
	},
	pushSelection: function(withoutClone) {
		if(!this.isEmpty()) {
			this.stack = this.stack || {};
			var coord = this.selection2Span();
			var id = coord.join("$");
			if(!this.stack[id]) {
				this.stack[id] = {
					coord: coord
				};
				if(!withoutClone) {
					if(this.el) {
						this.stack[id].el = this.cloneSelection();
					}
				}
			}
		}
	},
	hideSelection: function() {
		if(this.stack) {
			for(var p in this.stack) {
				var it = this.stack[p];
				if(it.el) {
					Ext.removeNode(it.el);
				}
			}
			delete this.stack;
		}
		if(this.el) {
			this.el.removeCls("ss-sm-multi");
			this.el.hide();
		}
	},
	clearSelection: function(suspendEvent) {
		this.hideSelection();
		delete this.startPos;
		delete this.endPos;
		if(!suspendEvent) {
			this.fireEvent("selectionchange", this.startPos, this.endPos, this.getRegion(), this);
		}
	},
	onCellMouseDown: function(row, col, region, e) {
		var startPos = {
				row: row,
				col: col
			},
			endPos = {
				row: row,
				col: col
			};
		if(e) {
			if(e.ctrlKey && !this.singleSelect && !this.simpleSelect) {
				EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag = true;
				this.fireEvent("pushcurrentselection", this);
			} else {
				delete EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag;
				if(e.shiftKey && !e.ctrlKey && !this.singleSelect && !this.simpleSelect) {
					if(this.startPos) {
						startPos = Ext.apply({}, this.startPos);
					}
				}
			}
		}
		this.selectRange(startPos, endPos);
	},
	coverMergedCell: function(startPos, endPos) {
		var r = this.getRegion();
		var sheetId = r.getSheetId();
		var s = r.getStore();
		var span = this.transfer2MinMaxPos(startPos, endPos);
		var minrow = span.minrow,
			mincol = span.mincol,
			maxrow = span.maxrow,
			maxcol = span.maxcol;
		var tminrow, tmincol, tmaxrow, tmaxcol, mergeLookup = s.getMergeFloatings();
		while(!(minrow == tminrow && mincol == tmincol && maxrow == tmaxrow && maxcol == tmaxcol)) {
			tminrow = minrow, tmaxrow = maxrow, tmincol = mincol, tmaxcol = maxcol;
			for(var p in mergeLookup) {
				if(mergeLookup.hasOwnProperty(p)) {
					var it = mergeLookup[p],
						json = it.jsonObj,
						sid = it.sheet;
					if(sheetId === sid) {
						if((json[0] <= tminrow && json[2] >= tmaxrow || json[0] >= tminrow && json[0] <= tmaxrow || json[2] >= tminrow && json[2] <= tmaxrow) && (json[1] <= tmincol && json[3] >= tmaxcol || json[1] >= tmincol && json[1] <= tmaxcol || json[3] >= tmincol && json[3] <= tmaxcol)) {
							if(minrow > json[0]) {
								minrow = json[0];
							}
							if(maxrow < json[2]) {
								maxrow = json[2];
							}
							if(mincol > json[1]) {
								mincol = json[1];
							}
							if(maxcol < json[3]) {
								maxcol = json[3];
							}
						}
					}
				}
			}
		}
		if(minrow < 1) {
			minrow = 1;
		}
		if(mincol < 1) {
			mincol = 1;
		}
		if(startPos.row <= endPos.row) {
			startPos.row = minrow;
			endPos.row = maxrow;
		} else {
			startPos.row = maxrow;
			endPos.row = minrow;
		}
		if(startPos.col <= endPos.col) {
			startPos.col = mincol;
			endPos.col = maxcol;
		} else {
			startPos.col = maxcol;
			endPos.col = mincol;
		}
		span = {
			minrow: minrow,
			mincol: mincol,
			maxrow: maxrow,
			maxcol: maxcol
		};
		return span;
	},
	setPosForElement: function(startPos, endPos, suspendEvent, el) {
		if(startPos && endPos) {
			el = el || this.el;
			if(el) {
				el.show();
				var r = this.getRegion();
				var sheetId = r.getSheetId();
				var s = r.getStore();
				var boffset = this.borderOffset,
					poffset = this.paddingOffset;
				var offset = boffset + poffset;
				if(0 === startPos.row && 0 === startPos.col) {
					endPos.row = 0;
					endPos.col = 0;
					var w = SCONST.MAX_LENGTH;
					var h = SCONST.MAX_LENGTH;
					var lt = -2 * offset - poffset;
					el.setStyle("left", lt + "px");
					el.setStyle("top", lt + "px");
					el.setSize(w, h);
					if(this.ltdot) {
						this.ltdot.hide();
					}
				} else if(0 === startPos.row || 0 === endPos.row) {
					var span = this.transfer2MinMaxPos(startPos, endPos);
					startPos.row = span.minrow;
					endPos.row = span.maxrow;
					var minrow = span.minrow,
						mincol = span.mincol,
						maxrow = span.maxrow,
						maxcol = span.maxcol;
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol - 1, undefined, true) - offset - poffset;
					var t;
					if(0 == minrow) {
						t = -2 * offset - poffset;
					} else {
						t = s.getRangeHeight(sheetId, r.rowBound.min, minrow - 1, undefined, true) - offset - poffset;
					}
					var xoffset = 2 * offset;
					var w = s.getRangeWidth(sheetId, mincol, maxcol, undefined, true) + xoffset - 1;
					var h = SCONST.MAX_LENGTH;
					el.setStyle("left", l + "px");
					el.setStyle("top", t + "px");
					el.setSize(w, h);
					if(this.ltdot) {
						this.ltdot.hide();
					}
				} else if(0 == startPos.col || 0 === endPos.col) {
					var span = this.transfer2MinMaxPos(startPos, endPos);
					startPos.col = span.mincol;
					endPos.col = span.maxcol;
					var minrow = span.minrow,
						mincol = span.mincol,
						maxrow = span.maxrow,
						maxcol = span.maxcol;
					var l;
					if(0 == mincol) {
						l = -2 * offset - poffset;
					} else {
						l = s.getRangeWidth(sheetId, r.colBound.min, mincol - 1, undefined, true) - offset - poffset;
					}
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow - 1, undefined, true) - offset - poffset;
					var yoffset = 2 * offset;
					var w = SCONST.MAX_LENGTH;
					var h = s.getRangeHeight(sheetId, minrow, maxrow, undefined, true) + yoffset - 1;
					el.setStyle("left", l + "px");
					el.setStyle("top", t + "px");
					el.setSize(w, h);
					if(this.ltdot) {
						this.ltdot.hide();
					}
				} else {
					var span;
					if(!this.skipCoverMergedCell) {
						span = this.coverMergedCell(startPos, endPos);
					} else {
						span = this.transfer2MinMaxPos(startPos, endPos);
					}
					var minrow = span.minrow,
						mincol = span.mincol,
						maxrow = span.maxrow,
						maxcol = span.maxcol;
					var rl = s.getRangeWidth(sheetId, r.colBound.min, mincol - 1, undefined, true),
						rt = s.getRangeHeight(sheetId, r.rowBound.min, minrow - 1, undefined, true);
					var l = rl - offset - poffset;
					var t = rt - offset - poffset;
					var xoffset = yoffset = 2 * offset + poffset,
						w, h;
					w = s.getRangeWidth(sheetId, r.colBound.min, maxcol, undefined, true) - rl + xoffset - 1;
					h = s.getRangeHeight(sheetId, r.rowBound.min, maxrow, undefined, true) - rt + yoffset - 1;
					if(this.ltdot) {
						if(mincol == r.colBound.min || minrow == r.rowBound.min) {
							this.ltdot.hide();
						} else {
							this.ltdot.show();
						}
					}
					el.setStyle("left", l + "px");
					el.setStyle("top", t + "px");
					el.setSize(w, h);
				}
			}
		}
	},
	doSelect: function(startPos, endPos, suspendEvent, el) {
		this.setPosForElement(startPos, endPos, suspendEvent, el);
	},
	getPageXYFromPos: function(pos, endPos) {
		var r = this.getRegion();
		var rxy = r.getEl().getXY();
		var sheetId = r.getSheetId();
		var s = r.getStore();
		var boffset = this.borderOffset,
			poffset = this.paddingOffset;
		var offset = boffset + poffset;
		var row = pos[0],
			col = pos[1];
		var l = s.getRangeWidth(sheetId, r.colStart, col - 1, undefined, true) - offset - poffset;
		var t = s.getRangeHeight(sheetId, r.rowStart, row - 1, undefined, true) - offset - poffset;
		var xoffset = yoffset = 2 * offset + poffset;
		l += rxy[0];
		t += rxy[1];
		var maxcol = endPos[1],
			maxrow = endPos[0];
		var w = s.getRangeWidth(sheetId, col, maxcol, undefined, true) + xoffset,
			h = s.getRangeHeight(sheetId, row, maxrow, undefined, true) + yoffset;
		return [l, t, w, h];
	},
	onRowRemoved: function(minrow, maxrow) {
		if(this.startPos && this.endPos) {
			var startPos = Ext.apply({}, this.startPos),
				endPos = Ext.apply({}, this.endPos);
			var srow = startPos.row,
				erow = endPos.row;
			if(srow <= erow) {
				if(minrow < srow) {
					if(maxrow < srow) {
						var span = maxrow - minrow + 1;
						startPos.row -= span;
						endPos.row -= span;
					} else if(maxrow < erow) {
						startPos.row = minrow;
						endPos.row = minrow + (erow - maxrow - 1);
					}
				} else if(minrow < erow) {
					if(maxrow < erow) {
						var span = maxrow - minrow + 1;
						endPos.row -= span;
					} else {
						endPos.row = minrow;
					}
				}
			} else {
				if(minrow < erow) {
					if(maxrow < erow) {
						var span = maxrow - minrow + 1;
						startPos.row -= span;
						endPos.row -= span;
					} else if(maxrow < srow) {
						startPos.row = minrow + (srow - maxrow - 1);
						endPos.row = minrow;
					}
				} else if(minrow < srow) {
					if(maxrow < srow) {
						var span = maxrow - minrow + 1;
						startPos.row -= span;
					} else {
						startPos.row = minrow;
					}
				}
			}
			this.selectRange(startPos, endPos, true);
		}
		if(this.focusCell) {
			var focusRow = this.focusCell.row;
			if(focusRow > maxrow) {
				focusRow -= span;
				this.setFocusCell(focusRow, this.focusCell.col, true, true);
			}
		}
	},
	onColumnRemoved: function(mincol, maxcol) {
		var span = maxcol - mincol + 1;
		if(this.startPos && this.endPos) {
			var startPos = Ext.apply({}, this.startPos),
				endPos = Ext.apply({}, this.endPos);
			var scol = startPos.col,
				ecol = endPos.col;
			if(scol <= ecol) {
				if(mincol < scol) {
					if(maxcol < scol) {
						startPos.col -= span;
						endPos.col -= span;
					} else if(maxcol < ecol) {
						startPos.col = mincol;
						endPos.col = mincol + (ecol - maxcol - 1);
					}
				} else if(mincol < ecol) {
					if(maxcol < ecol) {
						endPos.col -= span;
					} else {
						endPos.col = mincol;
					}
				}
			} else {
				if(mincol < ecol) {
					if(maxcol < ecol) {
						startPos.col -= span;
						endPos.col -= span;
					} else if(maxcol < scol) {
						startPos.col = mincol + (scol - maxcol - 1);
						endPos.col = mincol;
					}
				} else if(mincol < scol) {
					if(maxcol < scol) {
						startPos.col -= span;
					} else {
						startPos.col = mincol;
					}
				}
			}
			this.selectRange(startPos, endPos, true);
		}
		if(this.focusCell) {
			var focusCol = this.focusCell.col;
			if(focusCol > maxcol) {
				focusCol -= span;
				this.setFocusCell(this.focusCell.row, focusCol, true, true);
			}
		}
	},
	setSelections: function(sels, forceRefresh, supsendEvent) {
		this.stack = this.stack || {};
		var visited = {};
		var region = this.getRegion();
		var sheetId = region.getSheetId();
		var len = sels.length;
		if((0 == len || forceRefresh) && this.el) {
			this.el.setStyle("left", "-10000px");
		}
		for(var i = 0; i < len; i++) {
			var sel = sels[i];
			var coord = [].concat(sel);
			if(SCOM.nullOrUndefined(coord[0]) || "" === coord[0]) {
				coord[0] = sheetId;
			}
			var id = coord.join("$");
			visited[id] = true;
			if(sheetId == coord[0]) {
				if(!this.stack[id] || !this.stack[id].el) {
					this.selectRange({
						row: coord[1],
						col: coord[2]
					}, {
						row: coord[3],
						col: coord[4]
					}, true);
					if(i !== len - 1) {
						this.pushSelection();
					}
				}
			} else {
				if(!this.stack[id]) {
					this.stack[id] = {
						coord: coord
					};
				} else {
					if(this.stack[id].el) {
						Ext.removeNode(this.stack[id].el);
					}
				}
			}
		}
		for(var p in this.stack) {
			if(!visited[p]) {
				if(this.stack[p].el) {
					Ext.removeNode(this.stack[p].el);
				}
				delete this.stack[p];
			}
		}
		if(0 == len) {
			delete this.stack;
			delete this.startPos;
			delete this.endPos;
		}
		if(!supsendEvent) {
			this.fireEvent("selectionchange", this.startPos, this.endPos, region, this);
		}
	},
	refreshSelection: function() {
		var sels = this.getMultiSelections();
		if(sels.length) {
			this.clearSelection(true);
			EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag = true;
			this.setSelections(sels, undefined, true);
			delete EnterpriseSheet.sheet.sm.AbstractSelectionModel.prototype.holdClearFlag;
		}
	}
});

Ext.define("EnterpriseSheet.sheet.sm.ColumnSelectionModel", {
	extend: "EnterpriseSheet.sheet.sm.CellSelectionModel",
	getHtmlStr: function() {
		return ["<div class=\"ss-csm ", this.cls || "", "\" style=\"display:none;\">", "<div class=\"ss-sm-inner\"></div>", "<div class=\"ss-sm-ltdot\"></div>", "<div class=\"ss-sm-rbdot\"></div>", "</div>"].join("");
	},
	autofillCls: "ss-autofill-col",
	enableDD: false,
	skipZIndex: true,
	pushSelection: function(withoutClone) {},
	refreshSelection: function() {
		if(this.startPos && this.endPos) {
			this.selectRange(this.startPos, this.endPos, true);
		}
	},
	isSelected: function(row, col) {
		if(0 == row && this.startPos && this.endPos && 0 == this.startPos.row) {
			var minc = this.startPos.col,
				maxc = this.endPos.col;
			if(minc > maxc) {
				minc = maxc;
				maxc = this.startPos.col;
			}
			if(col >= minc && col <= maxc) {
				return true;
			}
		}
		return false;
	},
	prepareSelectionModel: function(p) {
		var ifbody = p.ifbodyEl;
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);
		this.inel = this.el.down(".ss-sm-inner");
		this.ltdot = this.el.down(".ss-sm-ltdot");
		this.rbdot = this.el.down(".ss-sm-rbdot");
	},
	checkDragScrolling: function(position, pos, movePos) {
		movePos = movePos || {};
		var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		var r = this.getRegion();
		var x = position.x,
			y = position.y,
			w = position.w,
			h = position.h;
		var flag = false;
		if(this.start2ScrollOffset > x) {
			if(pos.col > r.colBound.low || r.colStart > r.colBound.low) {
				var col = pos.col - this.dragScrollingStep;
				if(col > r.colBound.low) {
					pos.col = col;
				} else {
					pos.col = r.colBound.low;
				}
				flag = true;
				movePos.col = pos.col;
			}
		} else if(x - w > -this.start2ScrollOffset) {
			if(!r.colBound.high) {
				pos.col += this.dragScrollingStep;
				if(pos.col <= r.colEnd) {
					pos.col = r.colEnd + 1;
				}
				if(colBoundMax && pos.col > colBoundMax) {
					pos.col = colBoundMax;
					movePos.col = colBoundMax + 1;
				} else {
					movePos.col = pos.col;
				}
				flag = true;
			} else {
				this.fireEvent("dragscrollinglimited", "col", "high", pos, this, r);
			}
		}
		pos.row = 0;
		return flag;
	},
	prepareForAutofill: function(suspendEvent) {
		if(this.el) {
			this.el.addCls(this.autofillCls);
		}
		if(!suspendEvent) {
			this.fireEvent("prepareautofillstyle", this);
		}
	},
	setPosForElement: function(startPos, endPos) {
		if(startPos) {
			if(this.el) {
				var r = this.getRegion();
				var s = r.getStore();
				var sheetId = r.getSheetId();
				var boffset = this.borderOffset,
					poffset = this.paddingOffset;
				var offset = boffset + poffset;
				var span;
				if(0 == startPos.row && 0 != startPos.col) {
					this.el.removeCls("ss-sm-col");
					endPos.row = 0;
					span = this.transfer2MinMaxPos(startPos, endPos);
					var r = this.getRegion();
					var s = r.getStore();
					var minrow = span.minrow,
						mincol = span.mincol,
						maxrow = span.maxrow,
						maxcol = span.maxcol;
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol - 1, undefined, true) - offset - poffset;
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow - 1, undefined, true);
					var xoffset = 2 * offset;
					if(mincol == r.colBound.min) {
						xoffset = offset - poffset;
						l += offset + poffset;
						this.ltdot.hide();
					} else {
						this.ltdot.show();
					}
					var w = s.getRangeWidth(sheetId, mincol, maxcol, undefined, true) + xoffset + poffset - this.borderWidth,
						h = s.getRowHeight(sheetId, 0, true, true);
					w++;
					l--;
					this.el.setStyle("left", l + "px");
					this.el.setStyle("top", t + "px");
					this.el.setSize(w, h);
					this.el.show();
				} else {
					this.el.addCls("ss-sm-col");
					span = this.transfer2MinMaxPos(startPos, endPos);
					var r = this.getRegion();
					var s = r.getStore();
					var minrow = span.minrow,
						mincol = span.mincol,
						maxrow = span.maxrow,
						maxcol = span.maxcol;
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol - 1, undefined, true);
					var w = 0 === endPos.col ? SCONST.MAX_LENGTH : s.getRangeWidth(sheetId, mincol, maxcol, undefined, true),
						h = s.getRowHeight(sheetId, 0, true, true);
					l--;
					w++;
					this.el.setStyle("left", l + "px");
					this.el.setStyle("top", "");
					this.el.setStyle("bottom", "0px");
					this.el.setSize(w, h);
					this.el.show();
				}
				if(1 < span.minrow) {
					this.el.addCls("ss-sm-col-close");
				} else {
					this.el.removeCls("ss-sm-col-close");
				}
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.sm.RowSelectionModel", {
	extend: "EnterpriseSheet.sheet.sm.CellSelectionModel",
	getHtmlStr: function() {
		return ["<div class=\"ss-rsm ", this.cls || "", "\" style=\"display:none;\">", "<div class=\"ss-sm-inner\"></div>", "<div class=\"ss-sm-ltdot\"></div>", "<div class=\"ss-sm-rbdot\"></div>", "</div>"].join("");
	},
	autofillCls: "ss-autofill-row",
	enableDD: false,
	skipZIndex: true,
	pushSelection: function(withoutClone) {},
	refreshSelection: function() {
		if(this.startPos && this.endPos) {
			this.selectRange(this.startPos, this.endPos, true);
		}
	},
	isSelected: function(row, col) {
		if(this.startPos && this.endPos && 0 == col && 0 == this.startPos.col) {
			var minr = this.startPos.row,
				maxr = this.endPos.row;
			if(minr > maxr) {
				minr = maxr;
				maxr = this.startPos.row;
			}
			if(row >= minr && row <= maxr) {
				return true;
			}
		}
		return false;
	},
	prepareSelectionModel: function(p) {
		var ifbody = p.ifbodyEl;
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);
		this.inel = this.el.down(".ss-sm-inner");
		this.ltdot = this.el.down(".ss-sm-ltdot");
		this.rbdot = this.el.down(".ss-sm-rbdot");
	},
	checkDragScrolling: function(position, pos, movePos) {
		movePos = movePos || {};
		var rowBoundMax = SCONST.MAX_ROW_NUMBER;
		var r = this.getRegion();
		var x = position.x,
			y = position.y,
			w = position.w,
			h = position.h;
		var flag = false;
		if(this.start2ScrollOffset > y) {
			if(pos.row > r.rowBound.low || r.rowStart > r.rowBound.low) {
				var row = pos.row - this.dragScrollingStep;
				if(row > r.rowBound.low) {
					pos.row = row;
				} else {
					pos.row = r.rowBound.low;
				}
				flag = true;
				movePos.row = pos.row;
			}
		} else if(y - h > -this.start2ScrollOffset) {
			if(!r.rowBound.high) {
				pos.row += this.dragScrollingStep;
				if(pos.row <= r.rowEnd) {
					pos.row = r.rowEnd + 1;
				}
				if(rowBoundMax && pos.row > rowBoundMax) {
					pos.row = rowBoundMax;
					movePos.row = rowBoundMax + 1;
				} else {
					movePos.row = pos.row;
				}
				flag = true;
			} else {
				this.fireEvent("dragscrollinglimited", "row", "high", pos, this, r);
			}
		}
		pos.col = 0;
		return flag;
	},
	prepareForAutofill: function(suspendEvent) {
		if(this.el) {
			this.el.addCls(this.autofillCls);
		}
		if(!suspendEvent) {
			this.fireEvent("prepareautofillstyle", this);
		}
	},
	setPosForElement: function(startPos, endPos) {
		if(startPos) {
			if(this.el) {
				var r = this.getRegion();
				var s = r.getStore();
				var sheetId = r.getSheetId();
				var boffset = this.borderOffset,
					poffset = this.paddingOffset;
				var offset = boffset + poffset;
				var span;
				if(0 == startPos.col && 0 != startPos.row) {
					this.el.removeCls("ss-sm-row");
					endPos.col = 0;
					span = this.transfer2MinMaxPos(startPos, endPos);
					var minrow = span.minrow,
						mincol = span.mincol,
						maxrow = span.maxrow,
						maxcol = span.maxcol;
					var l = s.getRangeWidth(sheetId, r.colBound.min, mincol - 1, undefined, true);
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow - 1, undefined, true) - offset - poffset;
					var yoffset = 2 * offset;
					if(minrow == r.rowBound.min) {
						yoffset = offset - poffset;
						t += offset + poffset;
						this.ltdot.hide();
					} else {
						this.ltdot.show();
					}
					var w = s.getColWidth(sheetId, 0, true, true),
						h = s.getRangeHeight(sheetId, minrow, maxrow, undefined, true) + yoffset + poffset - this.borderWidth;
					h++;
					t--;
					this.el.setStyle("left", l + "px");
					this.el.setStyle("top", t + "px");
					this.el.setSize(w, h);
					this.el.show();
				} else {
					this.el.addCls("ss-sm-row");
					span = this.transfer2MinMaxPos(startPos, endPos);
					var minrow = span.minrow,
						mincol = span.mincol,
						maxrow = span.maxrow,
						maxcol = span.maxcol;
					var t = s.getRangeHeight(sheetId, r.rowBound.min, minrow - 1, undefined, true);
					var h = 0 === endPos.row ? SCONST.MAX_LENGTH : s.getRangeHeight(sheetId, minrow, maxrow, undefined, true),
						w = s.getColWidth(sheetId, 0, true, true);
					t--;
					h++;
					this.el.setStyle("left", "");
					this.el.setStyle("right", "0px");
					this.el.setStyle("top", t + "px");
					this.el.setSize(w, h);
					this.el.show();
				}
				if(1 < span.mincol) {
					this.el.addCls("ss-sm-row-close");
				} else {
					this.el.removeCls("ss-sm-row-close");
				}
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.sm.CellReferenceModel", {
	extend: "EnterpriseSheet.sheet.sm.CellSelectionModel",
	paddingOffset: 0,
	borderOffset: Ext.isIE ? 1 : 0,
	skipHideFlag: true,
	enableDD: true,
	getHtmlStr: function() {
		return ["<div class=\"ss-rm", this.cls || "", "\">", "<div class=\"ss-sm-inner ss-rm-inner\">", "</div>", "<div class=\"ss-rm-rbdot\"></div>", "</div>"].join("");
	},
	initComponent: function() {
		this.callParent(arguments);
	},
	prepareSelectionModel: function(region) {
		var ifbody = region.ifbodyEl;
		this.el = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);
		this.inel = this.el.down(".ss-rm-inner");
		this.dotel = this.el.down(".ss-rm-rbdot");
		this.el.hide();
	},
	initDD: function() {
		if(this.region) {
			this.region.ifbodyEl.on("mousedown", this.onRegionBodyMouseDown, this);
			Ext.getDoc().on("mousemove", this.onMouseMove, this);
			Ext.getDoc().on("mouseup", this.onMouseUp, this);
		}
	},
	startDragMoving: function(position) {
		this.position = position;
		if(!this.movingTask) {
			this.movingTask = {
				run: function() {
					var which = this.draggingCoordSpan.which;
					if("rbdot" == which) {
						this.dragDotMoving();
					} else {
						this.dragFrameMoving();
					}
					return this.dragScrolling;
				},
				interval: this.dragScrollingInterval,
				scope: this
			};
			Ext.TaskManager.start(this.movingTask);
		}
	},
	dragDotMoving: function() {
		var el = this.draggingCoordSpan.coordObj.el;
		var span = this.draggingCoordSpan.currentSpan || this.draggingCoordSpan.span;
		span = [].concat(span);
		var startPos = this.draggingCoordSpan.startPos,
			endPos = this.draggingCoordSpan.endPos;
		if(this.dragScrolling && this.checkDragScrolling(this.position, endPos)) {
			this.dragScrolling = this.region.autoMoving(endPos);
		} else {
			this.dragScrolling = false;
		}
		if(this.dragScrolling) {
			this.setPosForElement(startPos, endPos, true, el);
			this.draggingCoordSpan.startPos = Ext.apply({}, startPos);
			this.draggingCoordSpan.endPos = Ext.apply({}, endPos);
			var rt = this.transfer2MinMaxPos(startPos, endPos);
			span[1] = rt.minrow;
			span[2] = rt.mincol;
			span[3] = rt.maxrow;
			span[4] = rt.maxcol;
			this.draggingCoordSpan.currentSpan = [].concat(span);
			this.draggingCoordSpan.coordObj.coord = [].concat(span);
			this.fireEvent("movingreference", this.draggingCoordSpan, this);
		} else {
			delete this.movingTask;
		}
	},
	dragFrameMoving: function() {
		var el = this.draggingCoordSpan.coordObj.el;
		var span = this.draggingCoordSpan.currentSpan || this.draggingCoordSpan.span;
		span = [].concat(span);
		var startPos, endPos, x = this.position.x,
			y = this.position.y,
			w = this.position.w,
			h = this.position.h;
		if(x < this.start2ScrollOffset && y < this.start2ScrollOffset) {
			endPos = {
				row: span[1],
				col: span[2]
			};
			startPos = {
				row: span[3],
				col: span[4]
			};
		} else if(x < this.start2ScrollOffset) {
			endPos = {
				row: span[3],
				col: span[2]
			};
			startPos = {
				row: span[1],
				col: span[4]
			};
		} else if(y < this.start2ScrollOffset) {
			startPos = {
				row: span[3],
				col: span[2]
			};
			endPos = {
				row: span[1],
				col: span[4]
			};
		} else {
			startPos = {
				row: span[1],
				col: span[2]
			};
			endPos = {
				row: span[3],
				col: span[4]
			};
		}
		var rowOff = startPos.row - endPos.row,
			colOff = startPos.col - endPos.col;
		var oldEndPos = Ext.apply({}, endPos);
		if(this.dragScrolling && this.checkDragScrolling(this.position, endPos)) {
			var goPos = Ext.apply({}, endPos);
			if(oldEndPos.row == goPos.row) {
				goPos.row = this.region.rowStart;
			}
			if(oldEndPos.col == goPos.col) {
				goPos.col = this.region.colStart;
			}
			this.dragScrolling = this.region.autoMoving(goPos);
		} else {
			this.dragScrolling = false;
		}
		if(this.dragScrolling) {
			startPos.row = endPos.row + rowOff;
			startPos.col = endPos.col + colOff;
			this.setPosForElement(startPos, endPos, true, el);
			var rt = this.transfer2MinMaxPos(startPos, endPos);
			span[1] = rt.minrow;
			span[2] = rt.mincol;
			span[3] = rt.maxrow;
			span[4] = rt.maxcol;
			this.draggingCoordSpan.currentSpan = [].concat(span);
			this.draggingCoordSpan.coordObj.coord = [].concat(span);
			this.fireEvent("movingreference", this.draggingCoordSpan, this);
		} else {
			delete this.movingTask;
		}
		return this.dragScrolling;
	},
	onRegionBodyMouseDown: function(e) {
		var target = e.getTarget(),
			found, colorIndex, span, which;
		for(var p in this.stack) {
			var it = this.stack[p];
			if(it.el) {
				var rmEl = Ext.get(it.el);
				if(it.el == target) {
					found = rmEl;
				} else if(rmEl.down(".ss-rm-rbdot").dom == target) {
					which = "rbdot";
					found = rmEl;
				}
				if(found) {
					span = it.coord;
					colorIndex = it.colorIndex;
					break;
				}
			}
		}
		if(!found && !this.isEmpty() && this.el) {
			if(target == this.el.dom) {
				found = this.el;
			} else if(this.el.down(".ss-rm-rbdot").dom == target) {
				which = "rbdot";
				found = this.el;
			}
			if(found) {
				span = this.selection2Span();
			}
		}
		if(found) {
			span[0] = this.getRegion().getSheetId();
			var obj = {
				el: found,
				coord: [].concat(span)
			};
			found.addCls("ss-rm-actived");
			this.draggingCoordSpan = {
				el: found,
				span: span,
				colorIndex: colorIndex,
				which: which,
				coordObj: obj,
				startPos: {
					row: span[1],
					col: span[2]
				},
				endPos: {
					row: span[3],
					col: span[4]
				},
				rowSpan: span[3] - span[1] + 1,
				colSpan: span[4] - span[2] + 1
			};
			this.fireEvent("startmovereference", this.draggingCoordSpan, this);
		}
	},
	onMouseMove: function(e) {
		var region = this.region,
			sheetId = region.getSheetId();
		if(this.draggingCoordSpan && region) {
			var originSpan = [].concat(this.draggingCoordSpan.span);
			var lastSpan = [].concat(this.draggingCoordSpan.currentSpan || this.draggingCoordSpan.span);
			var which = this.draggingCoordSpan.which;
			var xy = e.getXY();
			var rc = region.getRowColFromPos(xy, true);
			var el = this.draggingCoordSpan.el;
			var startPos, endPos;
			if("rbdot" == which) {
				if(!this.singleSelect) {
					startPos = {
						row: originSpan[1],
						col: originSpan[2]
					};
					endPos = {
						row: rc[0],
						col: rc[1]
					};
					if(this.simpleSelect) {
						this.processPosForSimpleSelect(startPos, endPos);
					}
				}
			} else {
				startPos = {
					row: rc[0],
					col: rc[1]
				};
				endPos = {
					row: rc[0] + this.draggingCoordSpan.rowSpan - 1,
					col: rc[1] + this.draggingCoordSpan.colSpan - 1
				};
			}
			if(startPos && endPos) {
				this.draggingCoordSpan.startPos = Ext.apply({}, startPos);
				this.draggingCoordSpan.endPos = Ext.apply({}, endPos);
				if(false !== this.fireEvent("beforemovingreference", startPos, endPos, originSpan, rc, this.draggingCoordSpan, which, this)) {
					var mm = this.transfer2MinMaxPos(startPos, endPos);
					startPos.row = mm.minrow;
					startPos.col = mm.mincol;
					endPos.row = mm.maxrow;
					endPos.col = mm.maxcol;
					var currentSpan = [sheetId, startPos.row, startPos.col, endPos.row, endPos.col];
					if(!(lastSpan[1] == currentSpan[1] && lastSpan[2] == currentSpan[2] && lastSpan[3] == currentSpan[3] && lastSpan[4] == currentSpan[4])) {
						this.setPosForElement(startPos, endPos, true, el);
						var sheetId = this.draggingCoordSpan.coordObj.coord[0];
						this.draggingCoordSpan.currentSpan = currentSpan;
						this.fireEvent("movingreference", this.draggingCoordSpan, this);
						if(this.allowDragScrolling && 0 === e.button) {
							if(this.checkDragScrolling(rc[2], {
									row: rc[0],
									col: rc[1]
								})) {
								this.dragScrolling = true;
								this.startDragMoving(rc[2]);
							} else {
								this.dragScrolling = false;
							}
						} else {
							this.dragScrolling = false;
						}
					}
				}
			}
		}
	},
	onMouseUp: function(e) {
		if(this.draggingCoordSpan) {
			var el = this.draggingCoordSpan.el;
			el.removeCls("ss-rm-actived");
			var coordObj = this.draggingCoordSpan.coordObj;
			var lastSpan = this.draggingCoordSpan.span;
			var currentSpan = this.draggingCoordSpan.currentSpan;
			if(currentSpan && !(lastSpan[1] == currentSpan[1] && lastSpan[2] == currentSpan[2] && lastSpan[3] == currentSpan[3] && lastSpan[4] == currentSpan[4])) {
				var tmp = coordObj.coord.concat([this.draggingCoordSpan.colorIndex]);
				var id = tmp.join("$");
				if(this.stack && this.stack[id]) {
					delete this.stack[id];
					id = currentSpan.join("$");
					this.stack[id] = {
						coord: [].concat(currentSpan),
						el: el.dom
					};
				} else {
					this.startPos = {
						row: currentSpan[1],
						col: currentSpan[2]
					};
					this.endPos = {
						row: currentSpan[3],
						col: currentSpan[4]
					};
				}
				this.fireEvent("endmovereference", Ext.apply({}, this.draggingCoordSpan), this);
			}
			delete this.draggingCoordSpan;
			this.dragScrolling = false;
			if(this.movingTask) {
				Ext.TaskManager.stop(this.movingTask);
			}
			delete this.movingTask;
		}
	},
	enableSelect: function(clear, single, simple, suspendShown, onlyDDFlag) {
		this.onlyDDFlag = onlyDDFlag;
		this.callParent(arguments);
		if(!suspendShown && this.el) {
			this.el.setStyle("left", "-1000px");
			this.el.removeCls("ss-rm-disabled");
			this.el.show();
		}
	},
	disableSelect: function(clear, single, simple, suspendHidden) {
		delete this.onlyDDFlag;
		this.callParent(arguments);
		if(!suspendHidden && this.el) {
			this.el.addCls("ss-rm-disabled");
			this.el.hide();
		}
	},
	setKeepStack: function(flag) {
		this.keepStackFlag = flag;
	},
	pushSelection: function(withoutClone) {
		if(!this.isEmpty()) {
			this.stack = this.stack || {};
			var coord = this.selection2Span();
			var tmp = coord.concat([this.colorIndex]);
			var id = tmp.join("$");
			if(!this.stack[id]) {
				this.stack[id] = {
					coord: coord
				};
				this.stack[id].colorIndex = this.colorIndex;
				if(!withoutClone) {
					if(this.el) {
						this.stack[id].el = this.cloneSelection();
					}
				}
			}
		}
	},
	onCellMouseDown: function(row, col, region, e) {
		if(this.onlyDDFlag) {
			return;
		}
		if(!this.keepStackFlag) {
			if(e.ctrlKey && !this.singleSelect && !this.simpleSelect) {
				this.pushSelection();
			} else {
				this.clearSelection();
			}
		}
		this.selectRange({
			row: row,
			col: col
		}, {
			row: row,
			col: col
		});
	},
	onCellMouseDrag: function() {
		if(!this.singleSelect) {
			this.callParent(arguments);
		}
	},
	onCellMouseUp: function() {
		this.callParent(arguments);
		if(this.movingTask) {
			Ext.TaskManager.stop(this.movingTask);
		}
		delete this.movingTask;
		this.fireEvent("referencemouseup", this);
	},
	cloneSelection: function() {
		if(this.el) {
			var len = SCOM.countObjMember(this.stack);
			var colors = SCOM.colors;
			var ifbody = this.region.ifbodyEl;
			var clone = Ext.core.DomHelper.append(ifbody, this.getHtmlStr(), true);
			clone.setStyle("z-index", SCONST.SM_Z_INDEX);
			var width = this.el.getWidth();
			if(width) {
				clone.setWidth(width);
			} else {
				clone.setStyle("width", this.el.getStyle("width"));
			}
			var height = this.el.getHeight();
			if(height) {
				clone.setHeight(this.el.getHeight());
			} else {
				clone.setStyle("height", this.el.getStyle("height"));
			}
			clone.setStyle("left", this.el.getStyle("left"));
			clone.setStyle("top", this.el.getStyle("top"));
			var color = this.inel.getStyle("background-color");
			clone.setStyle("border-color", color);
			Ext.get(clone.dom.firstChild).setStyle("background-color", color);
			Ext.get(clone.dom.lastChild).setStyle("background-color", color);
			clone.show();
			var index, max = -1;
			for(var p in this.stack) {
				var colorIndex = this.stack[p].colorIndex;
				if(Ext.isNumber(colorIndex)) {
					if(max < colorIndex) {
						max = colorIndex;
					}
				}
			}
			if(Ext.isNumber(this.colorIndex)) {
				if(max < this.colorIndex) {
					max = this.colorIndex;
				}
			}
			if(-1 != max) {
				index = max + 1;
			} else {
				index = len % colors.length;
			}
			this.colorIndex = index;
			index = index % colors.length;
			this.el.setStyle("border-color", colors[index]);
			this.inel.setStyle("background-color", colors[index]);
			this.dotel.setStyle("background-color", colors[index]);
			return clone.dom;
		}
	},
	getCoordObjByElement: function(el) {
		for(var p in this.stack) {
			var it = this.stack[p];
			if(it.el == el) {
				return it;
			}
		}
		if(this.el.dom == el) {
			return {
				el: el,
				coord: this.selection2Span()
			};
		}
	},
	clearSelection: function(suspendEvent) {
		this.callParent(arguments);
		if(this.el) {
			var colors = SCOM.colors;
			this.el.setStyle("border-color", colors[0]);
			this.inel.setStyle("background-color", colors[0]);
			this.dotel.setStyle("background-color", colors[0]);
			this.colorIndex = 0;
		}
	},
	getReference: function(withCls) {
		var sels = [];
		for(var p in this.stack) {
			var it = this.stack[p];
			var coord = it.coord;
			var id = p;
			if(withCls && this.refCls && this.refCls[id]) {
				sels.push({
					cls: this.refCls[id],
					colorIndex: it.colorIndex,
					span: coord
				});
			} else {
				sels.push({
					colorIndex: it.colorIndex,
					span: coord
				});
			}
		}
		if(!this.isEmpty()) {
			var coord = this.selection2Span();
			var tmp = coord.concat([this.colorIndex]);
			var id = tmp.join("$");
			if(!this.stack || !this.stack[id]) {
				if(withCls && this.refCls && this.refCls[id]) {
					sels.push({
						colorIndex: this.colorIndex,
						cls: this.refCls[id],
						span: coord
					});
				} else {
					sels.push({
						colorIndex: this.colorIndex,
						span: coord
					});
				}
			}
		}
		return sels;
	},
	getReferenceWithoutStack: function() {
		if(!this.isEmpty()) {
			var coord = this.selection2Span();
			return [coord];
		}
	},
	setReference: function(refs, forceRefresh, supsendEvent, cls, currentColorIndex) {
		var colors = SCOM.colors;
		this.stack = this.stack || {};
		var visited = {},
			refCls = {};
		var region = this.getRegion();
		var sheetId = region.getSheetId();
		var len = refs.length;
		if((0 == len || forceRefresh) && this.el) {
			this.el.setStyle("left", "-10000px");
		}
		var colorLen = SCOM.colors.length;
		this.colorIndex = 0;
		for(var i = 0; i < len; i++) {
			var ref = refs[i],
				rcls = false,
				colorIndex = i;
			if(!Ext.isArray(ref) && ref.span) {
				rcls = ref.cls;
				if(!SCOM.nullOrUndefined(ref.colorIndex)) {
					colorIndex = ref.colorIndex;
				}
				ref = ref.span;
			}
			var coord = [].concat(ref);
			if(SCOM.nullOrUndefined(coord[0]) || "" === coord[0]) {
				coord[0] = sheetId;
			}
			var id = coord.concat([colorIndex]).join("$");
			visited[id] = true;
			refCls[id] = rcls;
			if(sheetId == coord[0]) {
				if(!this.stack[id] || !this.stack[id].el) {
					if(this.el) {
						var realColorIndex = colorIndex % colorLen;
						this.el.setStyle("border-color", colors[realColorIndex]);
						this.inel.setStyle("background-color", colors[realColorIndex]);
						this.dotel.setStyle("background-color", colors[realColorIndex]);
					}
					var skipCoverMergedCell = this.skipCoverMergedCell;
					this.skipCoverMergedCell = true;
					this.selectRange({
						row: coord[1],
						col: coord[2]
					}, {
						row: coord[3],
						col: coord[4]
					}, true);
					this.skipCoverMergedCell = skipCoverMergedCell;
					this.colorIndex = colorIndex;
					this.pushSelection();
				} else {
					var el = Ext.get(this.stack[id].el);
					this.stack[id].colorIndex = colorIndex;
					var realColorIndex = colorIndex % colorLen;
					var realColor = colors[realColorIndex];
					el.setStyle("border-color", realColor);
					el.down(".ss-rm-inner").setStyle("background-color", realColor);
					el.down(".ss-rm-rbdot").setStyle("background-color", realColor);
				}
			} else {
				if(!this.stack[id]) {
					this.stack[id] = {
						coord: coord,
						colorIndex: colorIndex
					};
				} else {
					this.stack[id].colorIndex = colorIndex;
					if(this.stack[id].el) {
						Ext.removeNode(this.stack[id].el);
					}
				}
				this.colorIndex = colorIndex + 1;
				if(this.el) {
					var realColorIndex = this.colorIndex % colorLen;
					var realColor = colors[realColorIndex];
					this.el.setStyle("border-color", realColor);
					this.inel.setStyle("background-color", realColor);
					this.dotel.setStyle("background-color", realColor);
				}
			}
		}
		for(var p in this.stack) {
			if(!visited[p]) {
				if(this.stack[p].el) {
					Ext.removeNode(this.stack[p].el);
				}
				delete this.stack[p];
			}
		}
		if(0 == len) {
			delete this.stack;
			delete this.startPos;
			delete this.endPos;
		}
		for(var p in this.stack) {
			var it = this.stack[p];
			if(it.el) {
				var el = Ext.get(it.el);
				el.dom.className = "ss-rm";
				if(this.disabled) {
					el.addCls("ss-rm-disabled");
				} else {
					el.removeCls("ss-rm-disabled");
				}
				if(refCls[p]) {
					el.addCls(refCls[p]);
				}
				if(this.curCls) {
					el.removeCls(this.curCls);
				}
				if(cls) {
					el.addCls(cls);
				}
			}
		}
		this.clearEl();
		if(this.el) {
			if(this.curCls) {
				this.el.removeCls(this.curCls);
			}
			this.el.addCls(cls);
		}
		if(!SCOM.nullOrUndefined(currentColorIndex)) {
			this.colorIndex = currentColorIndex;
		}
		this.refCls = refCls;
		this.curCls = cls;
		if(!supsendEvent) {
			this.fireEvent("selectionchange", this.startPos, this.endPos, region, this);
		}
	},
	hasCls: function(cls) {
		return cls === this.curCls;
	},
	hide: function(suspendEvent) {
		for(var p in this.stack) {
			var it = this.stack[p];
			if(it.el) {
				Ext.get(it.el).hide();
			}
		}
		this.clearSelection(true);
		this.callParent(arguments);
	},
	clearEl: function() {
		if(this.el) {
			this.el.setLeft(-1000);
			this.el.setTop(-1000);
			delete this.startPos;
			delete this.endPos;
		}
	},
	show: function(suspendEvent) {
		for(var p in this.stack) {
			var it = this.stack[p];
			if(it.el) {
				Ext.get(it.el).show();
			}
		}
		this.callParent(arguments);
	},
	setAnchorCell: function(row, col) {
		if(Ext.isDefined(row) && Ext.isDefined(col)) {
			this.anchorCell = {
				row: row,
				col: col
			};
		} else {
			delete this.anchorCell;
		}
		this.fireEvent("anchorchange", this.anchorCell, this);
	},
	getAnchorCell: function() {
		if(this.anchorCell) {
			return Ext.apply({}, this.anchorCell);
		} else {
			this.anchorCell = Ext.apply({}, this.startPos);
			return Ext.apply({}, this.anchorCell);
		}
	},
	refreshSelection: function() {
		var ref = this.getReference(true);
		var cls = this.curCls;
		var currentColorIndex = this.colorIndex;
		if(ref.length) {
			this.clearSelection(true);
			this.setReference(ref, null, true, cls, currentColorIndex);
		}
	},
	activeCoordSpan: function(coord, colorIndex) {
		var store = this.getRegion().getStore();
		if(Ext.isString(coord)) {
			coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(coord);
			if(coord && 0 < coord.length) {
				coord = coord[0].span;
				if(!Ext.isNumber(coord[0])) {
					var sheetId = store.getSheetIdByName(coord[0]);
					if(SCOM.nullOrUndefined(sheetId)) {
						sheetId = this.getRegion().getSheetId();
					}
					coord[0] = sheetId;
				}
			}
		}
		var cid = coord.concat([colorIndex]).join("$"),
			found = false;
		for(var p in this.stack) {
			var el = this.stack[p].el;
			if(p == cid) {
				found = p;
				if(el) {
					el = Ext.get(el);
					el.addCls("ss-rm-actived");
				}
			} else {
				if(el) {
					el = Ext.get(el);
					el.removeCls("ss-rm-actived");
				}
			}
		}
		if(this.el) {
			if(!found) {
				if(!this.isEmpty()) {
					var span = this.selection2Span();
					var eid = span.concat([this.colorIndex]).join("$");
					if(eid == cid) {
						this.el.addCls("ss-rm-actived");
					} else {
						this.el.removeCls("ss-rm-actived");
					}
				} else {
					this.el.removeCls("ss-rm-actived");
				}
			} else {
				this.el.removeCls("ss-rm-actived");
				this.pushSelection();
				var foundEl = Ext.get(this.stack[found].el);
				var coord = this.stack[found].coord;
				if(foundEl) {
					Ext.removeNode(this.el.dom);
					this.el = foundEl;
					this.inel = this.el.down(".ss-rm-inner");
					this.dotel = this.el.down(".ss-rm-rbdot");
				} else {
					this.clearEl();
					var colors = SCOM.colors;
					var realColor = colors[colorIndex % colors.length];
					this.el.setStyle("border-color", realColor);
					this.inel.setStyle("background-color", realColor);
					this.dotel.setStyle("background-color", realColor);
				}
				this.colorIndex = colorIndex;
				this.startPos = {
					row: coord[1],
					col: coord[2]
				};
				this.endPos = {
					row: coord[3],
					col: coord[4]
				};
				delete this.stack[found];
			}
		}
	},
	deactiveCoordSpan: function() {
		for(var p in this.stack) {
			var el = this.stack[p].el;
			if(el) {
				el = Ext.get(el);
				el.removeCls("ss-rm-actived");
			}
		}
		if(this.el) {
			this.el.removeCls("ss-rm-actived");
			this.pushSelection();
			this.clearEl();
		}
		this.setAnchorCell();
	},
	selectPrevious: function(dir, expand, suspendEvent) {
		if(this.disabled) {}
		if("col" !== dir) {
			dir = "row";
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, anchorCell = this.getAnchorCell(),
			posFlag;
		if(expand) {
			minMaxPos = this.getMinMaxPos();
			posFlag = minMaxPos.minrow == anchorCell.row && "row" == dir || minMaxPos.mincol == anchorCell.col && "col" == dir;
			if(posFlag) {
				pos = {
					row: minMaxPos.maxrow,
					col: minMaxPos.maxcol
				};
			} else {
				pos = {
					row: minMaxPos.minrow,
					col: minMaxPos.mincol
				};
			}
		} else {
			pos = anchorCell;
		}
		if(pos) {
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true);
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if("row" == dir) {
				if(merged) {
					row = pos.row + cell.minrow;
				} else {
					row = pos.row;
				}
				for(var i = row - 1; 1 <= i; i--) {
					if(store.isVisibleRow(sheetId, i)) {
						break;
					}
				}
				if(1 <= i) {
					row = i;
				}
				col = pos.col;
			} else {
				row = pos.row;
				if(merged) {
					col = pos.col + cell.mincol;
				} else {
					col = pos.col;
				}
				for(var i = col - 1; 1 <= i; i--) {
					if(store.isVisibleColumn(sheetId, i)) {
						break;
					}
				}
				if(1 <= i) {
					col = i;
				}
			}
			if(expand) {
				if(posFlag) {
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row: row,
						col: col
					}, suspendEvent);
				} else {
					this.selectRange({
						row: row,
						col: col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}
			} else {
				anchorCell = this.getAnchorCell();
				var rowOffset = row - anchorCell.row,
					colOffset = col - anchorCell.col;
				var limit = 0 < this.startPos.row ? 1 : 0;
				var newStartRow = this.startPos.row + rowOffset;
				if(limit > newStartRow) {
					newStartRow = limit;
				}
				limit = 0 < this.startPos.col ? 1 : 0;
				var newStartCol = this.startPos.col + colOffset;
				if(limit > newStartCol) {
					newStartCol = limit;
				}
				limit = 0 < this.endPos.row ? 1 : 0;
				var newEndRow = this.endPos.row + rowOffset;
				if(limit > newEndRow) {
					newEndRow = limit;
				}
				limit = 0 < this.endPos.col ? 1 : 0;
				var newEndCol = this.endPos.col + colOffset;
				if(limit > newEndCol) {
					newEndCol = limit;
				}
				this.selectRange({
					row: newStartRow,
					col: newStartCol
				}, {
					row: newEndRow,
					col: newEndCol
				}, suspendEvent);
				this.setAnchorCell(row, col);
			}
			return {
				row: row,
				col: col
			};
		}
	},
	selectNext: function(dir, expand, suspendEvent) {
		if(this.disabled) {}
		if("col" !== dir) {
			dir = "row";
		}
		var r = this.region;
		var sheetId = r.getSheetId();
		var store = r.getStore();
		var pos, minMaxPos, anchorCell = this.getAnchorCell(),
			posFlag;
		if(expand) {
			minMaxPos = this.getMinMaxPos();
			posFlag = minMaxPos.minrow == anchorCell.row && "row" == dir || minMaxPos.mincol == anchorCell.col && "col" == dir;
			if(posFlag) {
				pos = {
					row: minMaxPos.maxrow,
					col: minMaxPos.maxcol
				};
			} else {
				pos = {
					row: minMaxPos.minrow,
					col: minMaxPos.mincol
				};
			}
		} else {
			pos = anchorCell;
		}
		if(pos) {
			var row, col, cell = store.getCell(sheetId, pos.row, pos.col, true);
			var merged = store.isMergedCell(cell, sheetId, pos.row, pos.col);
			if("row" == dir) {
				if(merged) {
					row = pos.row + cell.maxrow + 1;
				} else {
					row = pos.row + 1;
				}
				col = pos.col;
				for(var i = row; true; i++) {
					if(store.isVisibleRow(sheetId, i)) {
						break;
					}
				}
				row = i;
			} else {
				row = pos.row;
				if(merged) {
					col = pos.col + cell.maxcol + 1;
				} else {
					col = pos.col + 1;
				}
				for(var i = col; true; i++) {
					if(store.isVisibleColumn(sheetId, i)) {
						break;
					}
				}
				col = i;
			}
			if(expand) {
				if(posFlag) {
					this.selectRange({
						row: minMaxPos.minrow,
						col: minMaxPos.mincol
					}, {
						row: row,
						col: col
					}, suspendEvent);
				} else {
					this.selectRange({
						row: row,
						col: col
					}, {
						row: minMaxPos.maxrow,
						col: minMaxPos.maxcol
					}, suspendEvent);
				}
			} else {
				anchorCell = this.getAnchorCell();
				var rowOffset = row - anchorCell.row,
					colOffset = col - anchorCell.col;
				var limit = 0 < this.startPos.row ? 1 : 0;
				var newStartRow = this.startPos.row + rowOffset;
				if(limit > newStartRow) {
					newStartRow = limit;
				}
				limit = 0 < this.startPos.col ? 1 : 0;
				var newStartCol = this.startPos.col + colOffset;
				if(limit > newStartCol) {
					newStartCol = limit;
				}
				limit = 0 < this.endPos.row ? 1 : 0;
				var newEndRow = this.endPos.row + rowOffset;
				if(limit > newEndRow) {
					newEndRow = limit;
				}
				limit = 0 < this.endPos.col ? 1 : 0;
				var newEndCol = this.endPos.col + colOffset;
				if(limit > newEndCol) {
					newEndCol = limit;
				}
				this.selectRange({
					row: newStartRow,
					col: newStartCol
				}, {
					row: newEndRow,
					col: newEndCol
				}, suspendEvent);
				this.setAnchorCell(row, col);
			}
			return {
				row: row,
				col: col
			};
		}
	},
	setFocusCell: function() {
		return;
	}
});

Ext.define("EnterpriseSheet.sheet.sm.ColumnReferenceModel", {
	extend: "EnterpriseSheet.sheet.sm.CellReferenceModel",
	prepareSelectionModel: Ext.emptyFn,
	doSelect: function(startPos, endPos, suspendEvent) {
		startPos.row = 0;
		endPos.row = 0;
		this.callParent(arguments);
	},
	checkDragScrolling: function(position, pos) {
		var r = this.getRegion();
		var x = position.x,
			y = position.y,
			w = position.w,
			h = position.h;
		var flag = false;
		if(this.start2ScrollOffset > x) {
			if(pos.col > r.colBound.low || r.colStart > r.colBound.low) {
				var col = pos.col - this.dragScrollingStep;
				if(col > r.colBound.low) {
					pos.col = col;
				} else {
					pos.col = r.colBound.low;
				}
				flag = true;
			}
		} else if(x - w > -this.start2ScrollOffset) {
			if(!r.colBound.high) {
				pos.col += this.dragScrollingStep;
				if(pos.col <= r.colEnd) {
					pos.col = r.colEnd + 1;
				}
			}
			flag = true;
		}
		pos.row = 0;
		return flag;
	}
});

Ext.define("EnterpriseSheet.sheet.sm.RowReferenceModel", {
	extend: "EnterpriseSheet.sheet.sm.CellReferenceModel",
	prepareSelectionModel: Ext.emptyFn,
	doSelect: function(startPos, endPos, suspendEvent) {
		startPos.col = 0;
		endPos.col = 0;
		this.callParent(arguments);
	}
});

Ext.define("EnterpriseSheet.sheet.regions.InfinateScroller", {
	extend: "Ext.util.Observable",
	constructor: function(config) {
		Ext.apply(this, config);
		this.scrolling = false;
		this.callParent([config]);
	},
	visible: true,
	scrollerLength: 17,
	lastScrollTop: 0,
	lastScrollLeft: 0,
	lastRow: 0,
	lastCol: 0,
	scrollOffset: Ext.isChrome ? 80 : 10,
	scrollStep: 1,
	disableWheel: false,
	init: function(ct) {
		this.region = ct;
		this.mon(ct, "afterrender", this.prepareScroller, this);
		this.mon(ct, "resize", this.onResize, this);
	},
	isLocked: function() {
		return this.scrolling;
	},
	lockScroll: function() {
		this.scrolling = true;
	},
	resizeScroller: function(w, h) {
		var region = this.getRegion();
		if(this.rel && this.cel) {
			if(w) {
				this.cel.setWidth(w - this.scrollerLength);
			}
			if(h) {
				h = h - this.scrollerLength;
				this.rel.setHeight(h);
			}
		} else if(this.cel) {
			if(w) {
				this.cel.setWidth(w);
			}
		} else if(this.rel) {
			if(h) {
				this.rel.setHeight(h);
			}
		}
		var rowBound = region.rowBound,
			colBound = region.colBound;
		var rowBoundMax = SCONST.MAX_ROW_NUMBER,
			colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		if(Ext.isNumber(rowBoundMax)) {
			var rowSpan = region.rowEnd - region.rowStart;
			var maxHeight = h + (rowBoundMax - rowBound.min) * this.scrollOffset;
			this.fixedRowHeight = maxHeight;
		} else {
			delete this.fixedRowHeight;
		}
		if(Ext.isNumber(colBoundMax)) {
			var colSpan = region.colEnd - region.colStart;
			var maxWidth = w + (colBoundMax - colBound.min) * this.scrollOffset;
			this.fixedColWidth = maxWidth;
		} else {
			delete this.fixedColWidth;
		}
	},
	onResize: function(c, aw, ah, w, h) {
		this.lockScroll();
		this.resizeScroller(aw, ah);
		if(this.rel || this.cel) {
			this.sysn();
		}
		this.unlockScroll();
	},
	unlockScroll: function() {
		this.scrolling = false;
	},
	prepareScroller: function(p) {
		var El = p.el,
			el = p.el.dom;
		var arr, slen = this.scrollerLength + 1;
		if("y" == this.dir) {
			arr = ["<div class=\"ss-irct\" style=\"width:", slen, "px;z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-irbody\" style=\"width:1px;\">", "</div>", "</div>"];
			this.rel = Ext.core.DomHelper.append(el, arr.join(""), true);
			this.rbody = Ext.get(this.rel.dom.firstChild);
		} else if("x" == this.dir) {
			arr = ["<div class=\"ss-icct\" style=\"height:", slen, "px;z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-icbody\" style=\"height:1px;\">", "</div>", "</div>"];
			Ext.core.DomHelper.append(el, arr.join(""), true);
			this.cel = Ext.core.DomHelper.append(el, arr.join(""), true);
			this.cbody = Ext.get(this.cel.dom.firstChild);
		} else if("xy" == this.dir) {
			var len = this.scrollerLength;
			var pack = "xy" == this.dir && (!Ext.isMac || Ext.isGecko) ? "<div class=\"ss-rbpack\" style=\"width:" + len + "px;height:" + len + "px;z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>" : "";
			arr = [pack, "<div class=\"ss-irct\" style=\"width:", slen, "px;z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-irbody\" style=\"width:1px;\">", "</div>", "</div>", "<div class=\"ss-icct\" style=\"height:", slen, "px;z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-icbody\" style=\"height:1px;\">", "</div>", "</div>"];
			Ext.core.DomHelper.append(el, arr.join(""), true);
			this.rel = El.down(".ss-irct");
			this.rbody = Ext.get(this.rel.dom.firstChild);
			this.cel = El.down(".ss-icct");
			this.cbody = Ext.get(this.cel.dom.firstChild);
		}
		if(!this.disableWheel) {
			this.mon(El, "mousewheel", this.onMouseWheel, this);
		}
		if(this.rel) {
			this.mon(this.rel, "scroll", this.onRowScroll, this);
		}
		if(this.cel) {
			this.mon(this.cel, "scroll", this.onColScroll, this);
		}
		this.setVisible(this.visible);
		this.onResize(El, El.getWidth(), El.getHeight());
	},
	getDir: function() {
		return this.dir;
	},
	limitBodyHeight: function(newHeight) {
		if(this.fixedRowHeight && newHeight > this.fixedRowHeight) {
			newHeight = this.fixedRowHeight;
		}
		this.rbody.setHeight(newHeight);
	},
	limitBodyWidth: function(newWidth) {
		if(this.fixedColWidth && newWidth > this.fixedColWidth) {
			newWidth = this.fixedColWidth;
		}
		this.cbody.setWidth(newWidth);
	},
	onRowScroll: function(e) {
		if(!this.isLocked()) {
			this.lockScroll();
			var r = this.getRegion();
			var el = this.rel.dom;
			var st = el.scrollTop,
				index;
			if(st != this.lastScrollTop) {
				index = Math.round(st / this.scrollOffset);
				if(index == this.lastRow) {
					this.unlockScroll();
					return;
				}
				var bh = this.rbody.getHeight();
				var offset = index - this.lastRow;
				st = index * this.scrollOffset;
				if(0 < offset) {
					offset = r.moveDown(offset);
				} else {
					offset = r.moveUp(-offset);
				}
				this.lastRow = index;
				if(0 != offset) {
					this.fireEvent("rowscrolling", offset, r, this);
				}
				var eh = this.rel.getHeight();
				if(bh - el.scrollTop - eh <= this.scrollOffset) {
					var newHeight = bh + this.scrollOffset;
					this.limitBodyHeight(newHeight);
				}
				el.scrollTop = st;
				this.lastScrollTop = el.scrollTop;
			}
			this.unlockScroll();
		}
	},
	onColScroll: function(e) {
		if(!this.isLocked()) {
			this.lockScroll();
			var r = this.getRegion();
			var el = this.cel.dom;
			var sl = el.scrollLeft,
				index;
			if(sl != this.lastScrollLeft) {
				index = Math.round(sl / this.scrollOffset);
				if(index == this.lastCol) {
					this.unlockScroll();
					return;
				}
				var offset = index - this.lastCol;
				sl = index * this.scrollOffset;
				if(0 < offset) {
					offset = r.moveRight(offset);
				} else {
					offset = r.moveLeft(-offset);
				}
				this.lastCol = index;
				if(0 != offset) {
					this.fireEvent("colscrolling", offset, r, this);
				}
				var bw = this.cbody.getWidth(),
					ew = this.cel.getWidth();
				if(bw - el.scrollLeft - ew <= this.scrollOffset) {
					this.limitBodyWidth(bw + this.scrollOffset);
				}
				el.scrollLeft = sl;
				this.lastScrollLeft = el.scrollLeft;
			}
			this.unlockScroll();
		}
	},
	onMouseWheel: function(e) {
		e.preventDefault();
		var delta = e.getWheelDeltas();
		if(0 > delta.y) {
			this.scrollRow(this.scrollStep);
		} else if(0 < delta.y) {
			this.scrollRow(-this.scrollStep);
		}
		if(0 > delta.x) {
			this.scrollCol(this.scrollStep);
		} else if(0 < delta.x) {
			this.scrollCol(-this.scrollStep);
		}
	},
	setVisible: function(visible) {
		this.lockScroll();
		this.visible = visible;
		if(this.rel) {
			this.rel.setVisible(visible);
		}
		if(this.cel) {
			this.cel.setVisible(visible);
		}
		this.unlockScroll();
	},
	isVisible: function() {
		return this.visible;
	},
	sysn: function(dir) {
		dir = dir || "both";
		this.lockScroll();
		var r = this.getRegion();
		var sheetId = r.getSheetId();
		var s = r.getStore();
		if(this.cel && ("x" == dir || "both" == dir)) {
			var cel = this.cel.dom;
			var w = this.cel.getWidth();
			var hiddenCol = 0;
			for(var i = r.colBound.low; i < r.colStart; i++) {
				if(!s.isVisibleColumn(sheetId, i)) {
					hiddenCol++;
				}
			}
			this.lastCol = r.colStart - r.colBound.low - hiddenCol;
			var sl = this.lastCol * this.scrollOffset;
			w += sl;
			var cw = this.cbody.getWidth();
			if(w >= cw) {
				this.limitBodyWidth(w + this.scrollOffset);
			}
			cel.scrollLeft = sl;
			this.lastScrollLeft = cel.scrollLeft;
		}
		if(this.rel && ("y" == dir || "both" == dir)) {
			var rel = this.rel.dom;
			var h = this.rel.getHeight();
			var hiddenRow = 0;
			for(var i = r.rowBound.low; i < r.rowStart; i++) {
				if(!s.isVisibleRow(sheetId, i)) {
					hiddenRow++;
				}
			}
			this.lastRow = r.rowStart - r.rowBound.low - hiddenRow;
			var st = this.lastRow * this.scrollOffset;
			h += st;
			var rh = this.rbody.getHeight();
			if(h >= rh) {
				var newHeight = h + this.scrollOffset;
				this.limitBodyHeight(newHeight);
			}
			rel.scrollTop = st;
			this.lastScrollTop = rel.scrollTop;
		}
		this.unlockScroll();
	},
	getRegion: function() {
		return this.region;
	},
	scrollRow: function(offset) {
		if(0 === offset) {
			return;
		}
		var El = this.rel;
		if(El) {
			var el = this.rel.dom,
				bEl = this.rbody;
			var st = el.scrollTop + offset * this.scrollOffset;
			if(0 > st) {
				st = 0;
			} else {
				var h = El.getHeight(),
					bh = bEl.getHeight();
				if(bh - h - st <= this.scrollOffset) {
					var newHeight = bh + this.scrollOffset;
					this.limitBodyHeight(newHeight);
				}
			}
			el.scrollTop = st;
		} else {
			var r = this.getRegion();
			if(!this.onlyRowScrollingEvent) {
				if(0 > offset) {
					offset = r.moveUp(-offset);
				} else {
					offset = r.moveDown(offset);
				}
			}
			this.fireEvent("rowscrolling", offset, r, this);
		}
	},
	scrollCol: function(offset) {
		if(0 === offset) {
			return;
		}
		var El = this.cel;
		if(El) {
			var el = this.cel.dom,
				bEl = this.cbody;
			var sl = el.scrollLeft + offset * this.scrollOffset;
			if(0 > sl) {
				sl = 0;
			} else {
				var w = El.getWidth(),
					bw = bEl.getWidth();
				if(bw - w - sl <= this.scrollOffset) {
					this.limitBodyWidth(bw + this.scrollOffset);
				}
			}
			el.scrollLeft = sl;
		} else {
			var r = this.getRegion();
			if(!this.onlyColScrollingEvent) {
				if(0 > offset) {
					offset = r.moveLeft(-offset);
				} else {
					offset = r.moveRight(offset);
				}
			}
			this.fireEvent("colscrolling", offset, r, this);
		}
	},
	getScrollerLength: function(dir) {
		var len = 0;
		if("col" == dir) {
			if(this.rel) {
				len = this.rel.getWidth();
			}
		} else {
			if(this.cel) {
				len = this.cel.getHeight();
			}
		}
		return len;
	},
	destroy: function() {
		var region = this.region;
		region.un("afterrender", this.prepareScroller, this);
		region.un("resize", this.onResize, this);
		region.getEl().un("mousewheel", this.onMouseWheel, this);
		if(this.rel) {
			this.rel.un("scroll", this.onRowScroll, this);
		}
		if(this.cel) {
			this.cel.un("scroll", this.onColScroll, this);
		}
		this.clearListeners();
	}
});

Ext.define("EnterpriseSheet.sheet.regions.ImmerseScroller", {
	extend: "Ext.util.Observable",
	pressInterval: 50,
	defaultRow: 100,
	defaultCol: 50,
	rowFactor: 1,
	colFactor: 1,
	alwaysVisible: false,
	constructor: function(config) {
		Ext.apply(this, config);
		this.scrolling = false;
		this.callParent([config]);
		this.on("checkingrowscrolling", function() {
			if(!this.alwaysVisible && this.visible && this.rel) {
				if(!this.rel.hasCls("ss-imrct-over")) {
					this.rel.fadeOut({
						remove: false,
						useDisplay: true,
						callback: function() {
							this.rel.removeCls("ss-imrct-scrolling");
							this.rel.setStyle("opacity", "");
							this.rel.setStyle("display", "");
						},
						scope: this
					});
				} else {
					this.rel.removeCls("ss-imrct-scrolling");
				}
			}
		}, this, {
			buffer: 1000
		});
		this.on("checkingcolscrolling", function() {
			if(!this.alwaysVisible && this.visible && this.cel) {
				if(!this.cel.hasCls("ss-imcct-over")) {
					this.cel.fadeOut({
						remove: false,
						useDisplay: true,
						callback: function() {
							this.cel.removeCls("ss-imcct-scrolling");
							this.cel.setStyle("opacity", "");
							this.cel.setStyle("display", "");
						},
						scope: this
					});
				} else {
					this.cel.removeCls("ss-imcct-scrolling");
				}
			}
		}, this, {
			buffer: 1000
		});
	},
	visible: true,
	scrollerLength: 6,
	lastScrollTop: 0,
	scrollTop: 0,
	lastScrollLeft: 0,
	scrollLeft: 0,
	lastRow: 0,
	lastCol: 0,
	scrollOffset: 1,
	minThumbLength: 20,
	scrollStep: 1,
	disableWheel: false,
	init: function(ct) {
		this.region = ct;
		var store = this.region.getStore();
		this.mon(ct, "afterrender", this.prepareScroller, this);
		this.mon(ct, "resize", this.onResize, this);
		store.on({
			scope: this,
			afterloadsheet: function() {
				this.sysn(undefined, true);
			},
			changeactivedsheetid: function() {
				this.sysn(undefined, true);
			},
			freezechange: function() {
				this.sysn(undefined, true);
			},
			splitchange: function() {
				this.sysn(undefined, true);
			}
		});
	},
	isLocked: function() {
		return this.scrolling;
	},
	lockScroll: function() {
		this.scrolling = true;
	},
	resizeScroller: function(w, h) {
		var region = this.getRegion();
		if(this.rel && this.cel) {
			if(w) {
				this.cel.setWidth(w - this.cel.getPadding("r"));
			}
			if(h) {
				this.rel.setHeight(h - this.rel.getPadding("b"));
			}
		} else if(this.cel) {
			if(w) {
				this.cel.setWidth(w - this.cel.getPadding("r"));
			}
		} else if(this.rel) {
			if(h) {
				this.rel.setHeight(h - this.rel.getPadding("b"));
			}
		}
		var rowBound = region.rowBound,
			colBound = region.colBound;
		var rowBoundMax = SCONST.MAX_ROW_NUMBER,
			colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		if(Ext.isNumber(rowBoundMax)) {
			var rowSpan = region.rowEnd - region.rowStart;
			var maxHeight = h + (rowBoundMax - rowBound.min) * this.scrollOffset;
			this.fixedRowHeight = maxHeight;
		} else {
			delete this.fixedRowHeight;
		}
		if(Ext.isNumber(colBoundMax)) {
			var colSpan = region.colEnd - region.colStart;
			var maxWidth = w + (colBoundMax - colBound.min) * this.scrollOffset;
			this.fixedColWidth = maxWidth;
		} else {
			delete this.fixedColWidth;
		}
	},
	onResize: function(c, aw, ah, w, h) {
		this.lockScroll();
		this.resizeScroller(aw, ah);
		if(this.rel || this.cel) {
			this.sysn(undefined, true);
		}
		this.unlockScroll();
	},
	unlockScroll: function() {
		this.scrolling = false;
	},
	prepareScroller: function(p) {
		var El = p.el,
			el = p.el.dom;
		var arr, slen = this.scrollerLength + 1;
		if("y" == this.dir) {
			arr = ["<div class=\"ss-imrct " + (this.alwaysVisible ? "ss-imrct-scrolling" : "") + "\" style=\"z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-imrbody\"></div>", "<div class=\"ss-imrup\"></div>", "<div class=\"ss-imrdown\"></div>", "</div>"];
			Ext.core.DomHelper.append(el, arr.join(""), true);
			this.rel = El.down(".ss-imrct");
			this.rbody = El.down(".ss-imrbody");
			this.rup = El.down(".ss-imrup");
			this.rdown = El.down(".ss-imrdown");
		} else if("x" == this.dir) {
			arr = ["<div class=\"ss-imcct " + (this.alwaysVisible ? "ss-imcct-scrolling" : "") + "\" style=\"z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-imcbody\"></div>", "<div class=\"ss-imcup\"></div>", "<div class=\"ss-imcdown\"></div>", "</div>"];
			Ext.core.DomHelper.append(el, arr.join(""), true);
			this.cel = El.down(".ss-imcct");
			this.cbody = El.down(".ss-imcbody");
			this.cup = El.down(".ss-imcup");
			this.cdown = El.down(".ss-imcdown");
		} else if("xy" == this.dir) {
			arr = ["<div class=\"ss-imrct " + (this.alwaysVisible ? "ss-imrct-scrolling" : "") + "\" style=\"z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-imrbody\"></div>", "<div class=\"ss-imrup\"></div>", "<div class=\"ss-imrdown\"></div>", "</div>", "<div class=\"ss-imcct " + (this.alwaysVisible ? "ss-imcct-scrolling" : "") + "\" style=\"z-index:", SCONST.TOP_Z_INDEX, ";\">", "<div class=\"ss-imcbody\"></div>", "<div class=\"ss-imcup\"></div>", "<div class=\"ss-imcdown\"></div>", "</div>"];
			Ext.core.DomHelper.append(el, arr.join(""), true);
			this.rel = El.down(".ss-imrct");
			this.rbody = El.down(".ss-imrbody");
			this.rup = El.down(".ss-imrup");
			this.rdown = El.down(".ss-imrdown");
			this.cel = El.down(".ss-imcct");
			this.cbody = El.down(".ss-imcbody");
			this.cup = El.down(".ss-imcup");
			this.cdown = El.down(".ss-imcdown");
		}
		if(!this.disableWheel) {
			this.mon(El, "mousewheel", this.onMouseWheel, this);
		}
		if(this.rel) {
			this.mon(this.rel, "mousedown", this.onMouseDownRowTrack, this);
		}
		if(this.rup) {
			this.mon(this.rup, "mousedown", this.onMouseDownRowUp, this);
		}
		if(this.rdown) {
			this.mon(this.rdown, "mousedown", this.onMouseDownRowDown, this);
		}
		if(this.cel) {
			this.mon(this.cel, "mousedown", this.onMouseDownColTrack, this);
		}
		if(this.cup) {
			this.mon(this.cup, "mousedown", this.onMouseDownColUp, this);
		}
		if(this.cdown) {
			this.mon(this.cdown, "mousedown", this.onMouseDownColDown, this);
		}
		this.setVisible(this.visible);
		this.onResize(El, El.getWidth(), El.getHeight());
		this.initDnD();
	},
	initDnD: function() {
		Ext.getDoc().on("mousedown", function(e) {
			this.downFlag = true;
			var target = e.getTarget();
			if(this.rup && this.rup.dom === target || this.rdown && this.rdown.dom === target) {
				this.adFlag = "row";
			} else if(this.cup && this.cup.dom === target || this.cdown && this.cdown.dom === target) {
				this.adFlag = "col";
			} else {
				this.adFlag = false;
			}
		}, this);
		if(this.rbody) {
			this.rbody.on("mousedown", function(e) {
				var st = this.rbody.getMargin("t");
				var step = 0 === st || 0 === this.scrollTop ? 1 : st / this.scrollTop;
				this.mdFlag = {
					dir: "row",
					el: this.rbody,
					st: this.scrollTop,
					offset: e.getY() - this.rbody.getTop(),
					bh: this.rbody.getHeight(),
					step: step
				};
			}, this);
		}
		if(this.cbody) {
			this.cbody.on("mousedown", function(e) {
				var sl = this.cbody.getMargin("l");
				var step = 0 === sl || 0 === this.scrollLeft ? 1 : sl / this.scrollLeft;
				this.mdFlag = {
					dir: "col",
					el: this.cbody,
					sl: this.scrollLeft,
					offset: e.getX() - this.cbody.getLeft(),
					bw: this.cbody.getWidth(),
					step: step
				};
			}, this);
		}
		Ext.getDoc().on("mousemove", function(e) {
			var region = this.getRegion(),
				regionEl = region.getEl();
			var xy = e.getXY(),
				x = xy[0],
				y = xy[1],
				target = Ext.get(e.getTarget());
			if(this.visible && !this.mdFlag && !this.downFlag && regionEl.contains(target)) {
				var rowFlag, colFlag;
				if(this.rel) {
					var xoff = regionEl.getRight() - x;
					var t = this.rel.getTop(),
						b = this.rel.getBottom();
					if(0 < xoff && 16 > xoff && t <= y && y <= b) {
						rowFlag = true;
					} else {
						rowFlag = false;
					}
				}
				if(this.cel) {
					var l = this.cel.getLeft(),
						r = this.cel.getRight();
					var yoff = regionEl.getBottom() - y;
					if(0 < yoff && 16 > yoff && l <= x && x <= r) {
						colFlag = true;
					} else {
						colFlag = false;
					}
				}
				if(!(rowFlag && colFlag)) {
					if(this.rel) {
						if(rowFlag) {
							this.rel.addCls("ss-imrct-over");
						} else {
							this.rel.removeCls("ss-imrct-over");
						}
					}
					if(this.cel) {
						if(colFlag) {
							this.cel.addCls("ss-imcct-over");
						} else {
							this.cel.removeCls("ss-imcct-over");
						}
					}
				}
			} else {
				if(this.rel && !(this.mdFlag && "row" === this.mdFlag.dir) && "row" !== this.adFlag) {
					this.rel.removeCls("ss-imrct-over");
				}
				if(this.cel && !(this.mdFlag && "col" === this.mdFlag.dir) && "col" !== this.adFlag) {
					this.cel.removeCls("ss-imcct-over");
				}
			}
			if(this.mdFlag) {
				var dir = this.mdFlag.dir;
				if("row" == dir) {
					var el = this.mdFlag.el,
						bh = this.mdFlag.bh,
						h = this.rel.getHeight() - this.rel.getPadding("b"),
						step = this.mdFlag.step;
					var st = y - this.rel.getTop() - this.mdFlag.offset;
					if(0 > st) {
						st = 0;
					} else if(st + bh > h) {
						st = h - bh;
					}
					el.setStyle("margin-top", st + "px");
					this.scrollTop = Math.floor(st / step);
					this.onRowScroll();
				} else {
					var el = this.mdFlag.el,
						bw = this.mdFlag.bw,
						w = this.cel.getWidth() - this.cel.getPadding("r"),
						step = this.mdFlag.step;
					var sl = x - this.cel.getLeft() - this.mdFlag.offset;
					if(0 > sl) {
						sl = 0;
					} else if(sl + bw > w) {
						sl = w - bw;
					}
					el.setStyle("margin-left", sl + "px");
					this.scrollLeft = Math.floor(sl / step);
					this.onColScroll();
				}
			}
		}, this);
		Ext.getDoc().on("mouseup", function(e) {
			if(this.mdFlag) {
				var mdFlag = this.mdFlag;
				delete this.mdFlag;
				if("row" === mdFlag.dir) {
					this.syncRowThumbPos();
					this.fireEvent("rowscrolling", 0, this.region, this);
				} else {
					this.syncColThumbPos();
					this.fireEvent("colscrolling", 0, this.region, this);
				}
			}
			delete this.bmdFlag;
			delete this.downFlag;
		}, this);
	},
	getDir: function() {
		return this.dir;
	},
	onRowScroll: function() {
		if(!this.isLocked()) {
			this.lockScroll();
			var r = this.getRegion();
			var bEl = this.rbody;
			var st = this.scrollTop,
				index;
			var rFactor = this.rowFactor || 1;
			if(st != this.lastScrollTop) {
				var nIdx = Math.round(st / this.scrollOffset);
				index = Math.round(nIdx * rFactor);
				if(index == this.lastRow) {
					this.unlockScroll();
					return;
				}
				var bh = bEl.getHeight();
				var offset = index - this.lastRow;
				st = nIdx * this.scrollOffset;
				if(0 < offset) {
					offset = r.moveDown(offset);
				} else {
					offset = r.moveUp(-offset);
				}
				this.lastRow = index;
				if(0 != offset) {
					this.rel.addCls("ss-imrct-scrolling");
					this.fireEvent("rowscrolling", offset, r, this);
					this.fireEvent("checkingrowscrolling", this);
				}
				this.lastScrollTop = st;
			}
			this.unlockScroll();
		}
	},
	onColScroll: function(e) {
		if(!this.isLocked()) {
			this.lockScroll();
			var r = this.getRegion();
			var bEl = this.cbody;
			var sl = this.scrollLeft,
				index;
			var cFactor = this.colFactor || 1;
			if(sl != this.lastScrollLeft) {
				var nIdx = Math.round(sl / this.scrollOffset);
				index = Math.round(nIdx * cFactor);
				if(index == this.lastCol) {
					this.unlockScroll();
					return;
				}
				var bw = bEl.getWidth();
				var offset = index - this.lastCol;
				sl = nIdx * this.scrollOffset;
				if(0 < offset) {
					offset = r.moveRight(offset);
				} else {
					offset = r.moveLeft(-offset);
				}
				this.lastCol = index;
				if(0 != offset) {
					this.cel.addCls("ss-imcct-scrolling");
					this.fireEvent("colscrolling", offset, r, this);
					this.fireEvent("checkingcolscrolling", this);
				}
				this.lastScrollLeft = sl;
			}
			this.unlockScroll();
		}
	},
	onMouseWheel: function(e) {
		e.stopEvent();
		if(this.mdFlag || this.bmdFlag) {
			return;
		}
		var delta = e.getWheelDeltas();
		if(0 > delta.y) {
			this.scrollRow(this.scrollStep);
		} else if(0 < delta.y) {
			this.scrollRow(-this.scrollStep);
		}
		if(0 > delta.x) {
			this.scrollCol(this.scrollStep);
		} else if(0 < delta.x) {
			this.scrollCol(-this.scrollStep);
		}
	},
	setVisible: function(visible) {
		this.lockScroll();
		this.visible = visible;
		if(this.rel) {
			this.rel.setVisible(visible);
		}
		if(this.cel) {
			this.cel.setVisible(visible);
		}
		this.unlockScroll();
	},
	isVisible: function() {
		return this.visible;
	},
	sysn: function(dir, forceSyncThumb) {
		if(this.isLocked()) {
			return;
		}
		dir = dir || "both";
		var rFactor = this.rowFactor,
			cFactor = this.colFactor;
		this.lockScroll();
		var r = this.getRegion();
		var sheetId = r.getSheetId();
		var s = r.getStore();
		if(this.cel && ("x" == dir || "both" == dir)) {
			var hiddenCol = 0;
			for(var i = r.colBound.low; i < r.colStart; i++) {
				if(!s.isVisibleColumn(sheetId, i)) {
					hiddenCol++;
				}
			}
			this.lastCol = r.colStart - r.colBound.low - hiddenCol;
			var sl = Math.round(this.lastCol / cFactor) * this.scrollOffset;
			if(sl !== this.scrollLeft) {
				this.scrollLeft = sl;
				this.lastScrollLeft = this.scrollLeft;
				this.syncColThumbPos();
				this.cel.addCls("ss-imcct-scrolling");
				this.fireEvent("checkingcolscrolling", this);
			} else if(forceSyncThumb) {
				this.syncColThumbPos();
			}
		}
		if(this.rel && ("y" == dir || "both" == dir)) {
			var hiddenRow = 0;
			for(var i = r.rowBound.low; i < r.rowStart; i++) {
				if(!s.isVisibleRow(sheetId, i)) {
					hiddenRow++;
				}
			}
			this.lastRow = r.rowStart - r.rowBound.low - hiddenRow;
			var st = Math.round(this.lastRow / rFactor) * this.scrollOffset;
			if(st !== this.scrollTop) {
				this.scrollTop = st;
				this.lastScrollTop = this.scrollTop;
				this.syncRowThumbPos();
				this.rel.addCls("ss-imrct-scrolling");
				this.fireEvent("checkingrowscrolling", this);
			} else if(forceSyncThumb) {
				this.syncRowThumbPos();
			}
		}
		this.unlockScroll();
	},
	getRegion: function() {
		return this.region;
	},
	syncRowThumbPos: function() {
		var st = this.scrollTop;
		var bEl = this.rbody,
			el = this.rel;
		var bh = bEl.getHeight(),
			h = el.getHeight() - el.getPadding("b"),
			mth = h * 0.75;
		var store = this.region.getStore(),
			sheetId = store.getActivedSheetId();
		if(Ext.isDefined(sheetId)) {
			sheetObj = store.getSheetById(sheetId);
			var maxRow = sheetObj.maxRow || 1;
			if(maxRow < this.defaultRow) {
				maxRow = this.defaultRow;
			}
			bh = h - maxRow;
			if(bh < this.minThumbLength) {
				bh = this.minThumbLength;
			}
			this.rowFactor = maxRow / (h - bh);
			if(this.rowFactor < 1) {
				this.rowFactor = 1;
			}
		}
		if(st + bh > h) {
			bh = h - st;
			if(bh < this.minThumbLength) {
				bh = this.minThumbLength;
				st = h - bh;
			}
		}
		bEl.setHeight(bh);
		bEl.setStyle("margin-top", st + "px");
	},
	syncColThumbPos: function() {
		var sl = this.scrollLeft;
		var bEl = this.cbody,
			el = this.cel;
		var bw = bEl.getWidth(),
			w = el.getWidth() - el.getPadding("r"),
			mtw = w * 0.75;
		var store = this.region.getStore(),
			sheetId = store.getActivedSheetId();
		if(Ext.isDefined(sheetId)) {
			sheetObj = store.getSheetById(sheetId);
			var maxCol = sheetObj.maxCol || 1;
			if(maxCol < this.defaultCol) {
				maxCol = this.defaultCol;
			}
			bw = w - maxCol;
			if(bw < this.minThumbLength) {
				bw = this.minThumbLength;
			}
			this.colFactor = maxCol / (w - bw);
			if(this.colFactor < 1) {
				this.colFactor = 1;
			}
		}
		if(sl + bw > w) {
			bw = w - sl;
			if(bw < this.minThumbLength) {
				bw = this.minThumbLength;
				sl = w - bw;
			}
		}
		bEl.setWidth(bw);
		bEl.setStyle("margin-left", sl + "px");
	},
	scrollRowOld: function(offset) {
		if(0 === offset) {
			return;
		}
		if(this.rel) {
			var bEl = this.rbody;
			var originTop = this.scrollTop;
			var st = originTop + offset * this.scrollOffset;
			if(0 > st) {
				st = 0;
			}
			this.scrollTop = st;
			this.syncRowThumbPos();
			this.onRowScroll();
		} else {
			var r = this.getRegion();
			if(!this.onlyRowScrollingEvent) {
				if(0 > offset) {
					offset = r.moveUp(-offset);
				} else {
					offset = r.moveDown(offset);
				}
			}
			this.lastRow += offset;
			this.fireEvent("rowscrolling", offset, r, this);
		}
	},
	scrollRow: function(offset) {
		if(0 === offset) {
			return;
		}
		var r = this.getRegion(),
			rFactor = this.rowFactor;
		if(!this.onlyRowScrollingEvent) {
			if(0 > offset) {
				offset = r.moveUp(-offset);
			} else {
				offset = r.moveDown(offset);
			}
		}
		this.lastRow += offset;
		var st = Math.round(this.lastRow / rFactor) * this.scrollOffset;
		this.scrollTop = st;
		this.lastScrollTop = this.scrollTop;
		if(this.rel) {
			this.syncRowThumbPos();
			this.rel.addCls("ss-imrct-scrolling");
			this.fireEvent("rowscrolling", offset, r, this);
			this.fireEvent("checkingrowscrolling", this);
		} else {
			this.fireEvent("rowscrolling", offset, r, this);
		}
	},
	scrollColOld: function(offset) {
		if(0 === offset) {
			return;
		}
		if(this.cel) {
			var bEl = this.cbody;
			var originLeft = this.scrollLeft;
			var sl = originLeft + offset * this.scrollOffset;
			if(0 > sl) {
				sl = 0;
			}
			this.scrollLeft = sl;
			this.syncColThumbPos();
			this.onColScroll();
		} else {
			var r = this.getRegion();
			if(!this.onlyColScrollingEvent) {
				if(0 > offset) {
					offset = r.moveLeft(-offset);
				} else {
					offset = r.moveRight(offset);
				}
			}
			this.fireEvent("colscrolling", offset, r, this);
		}
	},
	scrollCol: function(offset) {
		if(0 === offset) {
			return;
		}
		var r = this.getRegion(),
			cFactor = this.colFactor;
		if(!this.onlyColScrollingEvent) {
			if(0 > offset) {
				offset = r.moveLeft(-offset);
			} else {
				offset = r.moveRight(offset);
			}
		}
		this.lastCol += offset;
		var sl = Math.round(this.lastCol / cFactor) * this.scrollOffset;
		this.scrollLeft = sl;
		this.lastScrollLeft = this.scrollLeft;
		if(this.cel) {
			this.syncColThumbPos();
			this.cel.addCls("ss-imcct-scrolling");
			this.fireEvent("colscrolling", offset, r, this);
			this.fireEvent("checkingcolscrolling", this);
		} else {
			this.fireEvent("colscrolling", offset, r, this);
		}
	},
	getScrollerLength: function(dir) {
		var len = 0;
		if("col" == dir) {
			if(this.rel) {
				len = this.rel.getWidth();
			}
		} else {
			if(this.cel) {
				len = this.cel.getHeight();
			}
		}
		return len;
	},
	destroy: function() {
		var region = this.region;
		region.un("afterrender", this.prepareScroller, this);
		region.un("resize", this.onResize, this);
		region.getEl().un("mousewheel", this.onMouseWheel, this);
		this.clearListeners();
	},
	onMouseDownRowUp: function(e) {
		this.bmdFlag = {
			dir: "row",
			step: -1
		};
		this.startPressTask();
	},
	onMouseDownRowDown: function(e) {
		this.bmdFlag = {
			dir: "row",
			step: 1
		};
		this.startPressTask();
	},
	onMouseDownRowTrack: function(e) {
		var y = e.getY();
		var target = Ext.get(e.getTarget());
		if(target === this.rel) {
			var top = this.rel.getTop(),
				bottom = this.rel.getBottom() - this.rel.getPadding("b");
			if(top <= y && y <= bottom) {
				var bTop = this.rbody.getTop(),
					bBottom = this.rbody.getBottom();
				var yoff;
				if(y > bBottom) {
					yoff = y - bBottom + bTop - top;
				} else {
					yoff = y - top;
				}
				var st = this.rbody.getMargin("t");
				var step = 0 === st || 0 === this.scrollTop ? 1 : this.scrollTop / st;
				this.scrollTop = Math.floor(yoff * step);
				this.onRowScroll();
				this.syncRowThumbPos();
			}
		}
	},
	onMouseDownColUp: function(e) {
		this.bmdFlag = {
			dir: "col",
			step: -1
		};
		this.startPressTask();
	},
	onMouseDownColDown: function(e) {
		this.bmdFlag = {
			dir: "col",
			step: 1
		};
		this.startPressTask();
	},
	onMouseDownColTrack: function(e) {
		var x = e.getX();
		var target = Ext.get(e.getTarget());
		if(target === this.cel) {
			var left = this.cel.getLeft(),
				right = this.cel.getRight() - this.cel.getPadding("r");
			if(left <= x && x <= right) {
				var bLeft = this.cbody.getLeft(),
					bRight = this.cbody.getRight();
				var xoff;
				if(x > bRight) {
					xoff = x - bRight + bLeft - left;
				} else {
					xoff = x - left;
				}
				var sl = this.cbody.getMargin("l");
				var step = 0 === sl || 0 === this.scrollLeft ? 1 : this.scrollLeft / sl;
				this.scrollLeft = Math.floor(xoff * step);
				this.onColScroll();
				this.syncColThumbPos();
			}
		}
	},
	startPressTask: function() {
		if(!this.pressTask) {
			this.pressTask = Ext.TaskManager.start({
				run: function() {
					if(this.bmdFlag) {
						var dir = this.bmdFlag.dir,
							step = this.bmdFlag.step;
						if("row" == dir) {
							this.scrollRow(step);
						} else {
							this.scrollCol(step);
						}
					} else {
						this.pressTask.stop();
					}
				},
				scope: this,
				interval: this.pressInterval
			});
		} else {
			Ext.TaskManager.start(this.pressTask);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.regions.Region", {
	extend: "Ext.Component",
	requires: ["EnterpriseSheet.sheet.data.Store", "EnterpriseSheet.sheet.resize.RowResizer", "EnterpriseSheet.sheet.resize.ColumnResizer", "EnterpriseSheet.sheet.editor.CellEditor", "EnterpriseSheet.sheet.regions.InfinateScroller", "EnterpriseSheet.sheet.regions.ImmerseScroller", "EnterpriseSheet.sheet.sm.CellSelectionModel", "EnterpriseSheet.sheet.sm.RowSelectionModel", "EnterpriseSheet.sheet.sm.ColumnSelectionModel", "EnterpriseSheet.sheet.sm.CellReferenceModel", "EnterpriseSheet.sheet.sm.ColumnReferenceModel", "EnterpriseSheet.sheet.sm.RowReferenceModel"],
	skipCanvas: true,
	resizeCheckBuffer: 0,
	sheetId: 0,
	currentWidth: 0,
	defaultReferenceModel: "CellReferenceModel",
	defaultSelectionModel: "CellSelectionModel",
	defaultResizerType: "CellResizer",
	enableCellMouseOver: false,
	enableCellMouseMove: true,
	allowRowResize: true,
	trackMouseOver: false,
	initSpan: function(noApply) {
		var defaultSpan = {
			rowStart: 1,
			rowEnd: 0,
			colStart: 1,
			colEnd: 0
		};
		if(!noApply) {
			Ext.applyIf(this, defaultSpan);
		}
		return defaultSpan;
	},
	initBound: function(noApply) {
		var defaultRowBound = {
			low: 1,
			min: 1,
			high: false
		};
		var defaultColBound = {
			low: 1,
			min: 1,
			high: false
		};
		if(!noApply) {
			this.rowBound = Ext.apply(this.rowBound || {}, defaultRowBound);
			this.colBound = Ext.apply(this.colBound || {}, defaultColBound);
		}
		return {
			rowBound: defaultRowBound,
			colBound: defaultColBound
		};
	},
	preparePlugins: function() {
		this.plugins = this.plugins || [];
		if(!this.infinateScroller && this.scrollConfig) {
			this.infinateScroller = new EnterpriseSheet.sheet.regions.ImmerseScroller(this.scrollConfig);
		}
		if(this.infinateScroller) {
			this.plugins.push(this.infinateScroller);
			this.relayEvents(this.infinateScroller, ["rowscrolling", "colscrolling"]);
		}
		if(!this.sm && !this.disableSelectionModel) {
			this.sm = new EnterpriseSheet.sheet.sm[this.defaultSelectionModel];
		}
		if(this.sm) {
			this.plugins.push(this.sm);
			this.relayEvents(this.sm, ["selectionchange", "pushcurrentselection", "focuschange", "dragscrollinglimited", "autofilldragend", "selectionmoving", "prepareautofillstyle", "resetautofillstyle"]);
		}
		this.prepareReferenceModel();
		if(!this.resizer && this.resizerConfig) {
			this.resizer = new EnterpriseSheet.sheet.resize[this.resizerConfig.rtype || this.defaultResizerType](this.resizerConfig);
		}
		if(this.resizer) {
			this.enableCellMouseOver = true;
			this.plugins.push(this.resizer);
			this.relayEvents(this.resizer, ["columnresized", "rowresized", "rowautoresized", "selectedcolumnresized", "selectedrowresized"]);
		}
		if(0 == this.plugins.length) {
			delete this.plugins;
		}
	},
	prepareReferenceModel: function() {
		if(!this.rm && !this.disableReferenceModel) {
			this.rm = new EnterpriseSheet.sheet.sm[this.defaultReferenceModel]({
				disabled: true
			});
		}
		if(this.rm) {
			this.plugins = this.plugins || [];
			this.plugins.push(this.rm);
			this.relayEvents(this.rm, ["showmodel", "hidemodel", "startmovereference", "beforemovingreference", "movingreference", "endmovereference", "referencemouseup"]);
			this.mon(this.rm, {
				scope: this,
				selectionchange: function(startPos, endPos, region, sm) {
					this.fireEvent("referencechange", region, sm);
				},
				show: function(rm) {
					this.fireEvent("showreference", this, rm);
				},
				hide: function(rm) {
					this.fireEvent("hidereference", this, rm);
				}
			});
		}
	},
	initComponent: function() {
		this.initSpan();
		this.initBound();
		this.cls = this.cls || "";
		this.cls += " ss-region-ct";
		this.regionTpl = this.regionTpl || SLAYOUT.region;
		this.rowTpl = this.rowTpl || SLAYOUT.row;
		this.cellTpl = this.cellTpl || SLAYOUT.cell;
		this.preparePlugins();
		this.callParent();
		var store = this.getStore();
		this.mon(store, {
			scope: this,
			cellchange: this.onCellChange,
			columnchange: this.onColumnChange,
			rowchange: this.onRowChange,
			removecell: this.onRemoveCell,
			cellremoved: this.onCellRemoved,
			removerow: this.onRemoveRow,
			rowremoved: this.onRowRemoved,
			removecolumn: this.onRemoveColumn,
			columnremoved: this.onColumnRemoved,
			insertcell: this.onInsertCell,
			cellinserted: this.onCellInserted,
			insertrow: this.onInsertRow,
			rowinserted: this.onRowInserted,
			insertcolumn: this.onInsertColumn,
			columninserted: this.onColumnInserted,
			hiderow: this.onHideRow,
			hidecolumn: this.onHideColumn,
			showrow: this.onShowRow,
			showcolumn: this.onShowColumn
		});
		this.on("resizing", this.processAfterResize, this, {
			buffer: this.resizeCheckBuffer
		});
		this.on("resize", function(comp, width, height) {
			this.getEl().setWidth(width);
			this.fireEvent("resizing", comp, width, height);
		}, this);
	},
	isInRange: function(row, col) {
		if(0 == row) {
			return this.colStart <= col && col <= this.colEnd;
		} else if(0 == col) {
			return this.rowStart <= row && row <= this.rowEnd;
		} else {
			return this.rowStart <= row && row <= this.rowEnd && this.colStart <= col && col <= this.colEnd;
		}
	},
	isRowOverlap: function(minrow, maxrow) {
		return this.rowStart <= minrow && minrow <= this.rowEnd || this.rowStart <= maxrow && maxrow <= this.rowEnd || this.rowStart > minrow && maxrow > this.rowEnd;
	},
	isColumnOverlap: function(mincol, maxcol) {
		return this.colStart <= mincol && mincol <= this.colEnd || this.colStart <= maxcol && maxcol <= this.colEnd || this.colStart > mincol && maxcol > this.colEnd;
	},
	isInColumnRange: function(col) {
		return this.colStart <= col && col <= this.colEnd;
	},
	isInRowRange: function(row) {
		return this.rowStart <= row && row <= this.rowEnd;
	},
	updateRegionElWidth: function(w) {
		var s = this.getStore();
		if(false == SCOM.typeOf(w)) {
			w = s.getRangeWidth(this.getSheetId(), this.colStart, this.colEnd, undefined, true);
		}
		this.regionEl.setWidth(w);
		this.currentWidth = w;
	},
	getCellEl: function(row, col) {
		try {
			var s = this.getStore();
			var sheetId = this.getSheetId();
			if(s.isVisibleRow(sheetId, row) && s.isVisibleColumn(sheetId, col)) {
				var cid = [row, col].join(s.separateChar);
				var found = Ext.DomQuery.jsSelect("div[data-cid=" + cid + "]", this.regionEl.dom);
				if(0 < found.length) {
					return Ext.get(found[0]);
				}
			}
			return null;
		} catch(e) {
			return null;
		}
	},
	setCellElSize: function(row, col, width, height) {
		var store = this.getStore();
		var cellEl = this.getCellEl(row, col);
		if(cellEl) {
			if(false != SCOM.typeOf(width)) {
				var w = width - cellEl.getBorderWidth("lr");
				if(0 > w) {
					w = 0;
					cellEl.setStyle("border-right-width", "0px");
				}
				cellEl.setWidth(w);
			}
			if(false != SCOM.typeOf(height)) {
				var h = height - cellEl.getBorderWidth("tb");
				if(0 > h) {
					h = 0;
					cellEl.setStyle("border-bottom-width", "0px");
				}
				cellEl.setHeight(h);
			}
			return true;
		}
		return false;
	},
	setRowElHeight: function(row, height, sysnCellHeight) {
		var store = this.getStore();
		var rowEl = this.getRowEl(row);
		if(rowEl) {
			if(false != SCOM.typeOf(height)) {
				var hoff = height - store.cellHeightOffset;
				var wpb = store.defaultProperty.wpb;
				if(0 > hoff) {
					wpb += hoff;
					hoff = 0;
				}
				rowEl.setStyle("padding-bottom", wpb + "px");
				rowEl.setStyle("height", hoff + "px");
				if(sysnCellHeight) {
					for(var i = this.colStart; i <= this.colEnd; i++) {
						this.setCellElSize(row, i, null, height);
					}
				}
			}
			return true;
		}
		return false;
	},
	updateRowHeight: function(row) {
		var rowEl = this.getRowEl(row);
		if(rowEl) {
			var s = this.getStore();
			cell = s.getCellData(this.getSheetId(), row, 0);
			var h = cell.height;
			var wpb = cell.wpb;
			rowEl.setStyle("height", h + "px");
			rowEl.setStyle("padding-bottom", wpb + "px");
		}
	},
	getRowEl: function(row) {
		try {
			var s = this.getStore();
			var sheetId = this.getSheetId();
			if(s.isVisibleRow(sheetId, row)) {
				var roffset = row - this.rowStart;
				for(var i = this.rowStart; i < row; i++) {
					if(!s.isVisibleRow(sheetId, i)) {
						roffset--;
					}
				}
				var row = this.regionEl.dom.childNodes[roffset];
				return Ext.get(row);
			}
			return null;
		} catch(e) {
			return null;
		}
	},
	updateOffsetWidth: function(offset) {
		if(0 < offset) {
			this.updateRegionElWidth(this.currentWidth + offset);
		} else if(0 > offset) {
			var less = offset + this.currentWidth - this.getEl().getWidth();
			if(0 <= less) {
				this.updateRegionElWidth(this.currentWidth + offset);
			} else if(!this.colBound.high) {
				this.currentWidth += offset;
				this.adjustCols(-less);
			}
		}
	},
	updateOffsetHeight: function(offset) {
		if(0 > offset) {
			var less = this.regionEl.getHeight() - this.getEl().getHeight();
			if(0 > less && !this.rowBound.high) {
				this.adjustRows(-less);
			}
		}
	},
	resizeColumn: function(col, w, suspendCellChange, suspendColChange) {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var cw = s.getColWidth(sheetId, col, true, true);
		var offset = w - cw;
		s.setColumnWidth(sheetId, col, w, suspendCellChange, suspendColChange);
		if((!suspendCellChange && this.isInRange(0, col)) && suspendColChange) {
			this.updateOffsetWidth(offset);
		}
	},
	resizeRow: function(row, h, suspendCellChange, suspendRowChange) {
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var rh = s.getRowHeight(sheetId, row, true, true);
		var offset = h - rh;
		if(0 != offset) {
			s.setRowHeight(sheetId, row, h, suspendCellChange, suspendRowChange);
			if(suspendRowChange) {
				this.updateRowHeight(row);
				this.updateOffsetHeight(offset);
			}
		}
	},
	resizeRowAutoHeight: function(row, h, suspendCellChange, suspendRowChange) {
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var rh = s.getRowHeight(sheetId, row, true, true);
		var offset = h - rh;
		if(0 != offset) {
			s.setRowAutoHeight(sheetId, row, h, suspendCellChange, suspendRowChange);
			if(suspendRowChange) {
				this.updateRowHeight(row);
				this.updateOffsetHeight(offset);
			}
		}
	},
	getData: function(row, col, suspendEvent, timestamp, withoutZoom, noPx) {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var ref = {},
			cell;
		if(!suspendEvent) {
			this.fireEvent("processdata", sheetId, row, col, ref, timestamp, this, withoutZoom);
			cell = ref.cell;
		}
		if(!cell) {
			cell = store.getCellData(sheetId, row, col, undefined, undefined, undefined, withoutZoom);
		}
		if(!noPx) {
			cell.width += "px";
			cell.height += "px";
		}
		cell.ri = row;
		cell.ci = col;
		if(0 !== row && 0 !== col) {
			if(cell.incell || SCONFIG.hideOverflowInCell) {
				cell.wrap = true;
			}
		}
		this.fixBorderGap(cell);
		return cell;
	},
	fixBorderGap: function(cell) {
		var zd = Ext.isDefined(cell.zd) ? "z-index:" + cell.zd + ";" : "";
		if(cell.fixedBorder) {
			if(!Ext.isDefined(cell.data)) {
				cell.data = "";
			}
			var fbs = cell.fixedBorder,
				html = "",
				dp = this.getStore().defaultProperty,
				pt = dp.pt,
				pl = dp.pl;
			for(var i in fbs) {
				if(fbs.hasOwnProperty(i)) {
					var it = fbs[i];
					var pos = i,
						color = it.color;
					if("rb" == pos) {
						var b = -cell.bbw,
							r = -cell.brw;
						if("double" == it.bs && "double" == it.rs) {
							if("double" == cell.bbt) {
								b--;
							}
							if("double" == cell.brt) {
								r--;
							}
							if(cell.wrap) {
								r = 0;
								b = 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:1px;height:1px;border-top:1px solid " + it.tc + ";border-left:1px solid " + it.lc + ";bottom:" + b + "px;right:" + r + "px;background:white;\"></div>";
						} else if("double" == it.bs) {
							if("double" == cell.bbt) {
								b--;
							}
							if(cell.wrap) {
								b = 0;
								r = "double" === cell.brt ? 1 : 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:" + it.w + "px;height:1px;border-top:1px solid " + it.tc + ";bottom:" + b + "px;right:" + r + "px;background:white;\"></div>";
						} else if("double" == it.rs) {
							if("double" == cell.brt) {
								r--;
							}
							if(cell.wrap) {
								r = 0;
								b = "double" === cell.bbt ? 1 : 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:1px;height:" + it.h + "px;border-left:1px solid " + it.lc + ";bottom:" + b + "px;right:" + r + "px;background:white;\"></div>";
						} else {
							if(cell.wrap) {
								r = "double" === cell.brt ? 1 : 0;
								b = "double" === cell.bbt ? 1 : 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:" + it.w + "px;height:" + it.h + "px;bottom:" + b + "px;right:" + r + "px;background:" + color + ";\"></div>";
						}
					} else if("lb" == pos) {
						var b = -cell.bbw,
							l = -cell.blw;
						if(it.tc) {
							if("double" == cell.bbt) {
								b--;
							}
							if(cell.wrap) {
								b = 0;
								l = 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:" + it.w + "px;height:" + (it.h - 1) + "px;bottom:" + b + "px;left:" + l + "px;background:" + it.rc + ";border-top:1px solid " + it.tc + ";\"></div>";
						} else {
							if(cell.wrap) {
								b = "double" === cell.bbt ? 1 : 0;
								l = 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:" + it.w + "px;height:" + it.h + "px;bottom:" + b + "px;left:" + l + "px;background:" + color + ";\"></div>";
						}
					} else if("rt" == pos) {
						var t = -cell.btw,
							r = -cell.brw;
						if(it.lc) {
							if("double" == cell.brt) {
								r--;
							}
							if(cell.wrap) {
								r = 0;
								t = 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:" + (it.w - 1) + "px;height:" + it.h + "px;top:" + t + "px;right:" + r + "px;background:" + it.bc + ";border-left:1px solid " + it.lc + ";\"></div>";
						} else {
							if(cell.wrap) {
								r = "double" === cell.brt ? 1 : 0;
								t = 0;
							}
							html += "<div class=\"ss-fb\" style=\"" + zd + "width:" + it.w + "px;height:" + it.h + "px;top:" + t + "px;right:" + r + "px;background:" + color + ";\"></div>";
						}
					} else if("lt" == pos) {
						var t = -cell.btw,
							l = -cell.blw;
						if(cell.wrap) {
							l = 0;
							t = 0;
						}
						html += "<div class=\"ss-fb\" style=\"" + zd + "width:" + it.w + "px;height:" + it.h + "px;top:" + t + "px;left:" + l + "px;background:" + color + ";\"></div>";
					}
				}
			}
			cell.fixborders = html;
		}
	},
	refreshCell: function(row, col, cell) {
		var cellEl = this.getCellEl(row, col);
		if(cellEl) {
			cell = cell || this.getData(row, col);
			var html = this.cellTpl.apply(cell);
			Ext.core.DomHelper.insertBefore(cellEl, html);
			Ext.removeNode(cellEl.dom);
			this.fireEvent("refreshcell", row, col, this);
		}
	},
	refreshMergedCell: function(row, col, cell) {
		var store = this.getStore();
		var sheetId = this.getSheetId();
		var c = store.getCell(sheetId, row, col);
		if(store.isMergedCell(c, sheetId, row, col)) {
			var minrow = row + c.minrow;
			var mincol = col + c.mincol;
			var maxrow = row + c.maxrow;
			var maxcol = col + c.maxcol;
			for(var i = minrow; i <= maxrow; i++) {
				for(var j = mincol; j <= maxcol; j++) {
					this.refreshCell(i, j);
				}
			}
		} else {
			this.refreshCell(row, col, cell);
		}
	},
	refreshRow: function(row) {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var rowEl = this.getRowEl(row);
		if(rowEl) {
			var cells = [];
			for(var i = this.colStart; i <= this.colEnd; i++) {
				if(store.isVisibleColumn(sheetId, i)) {
					var data = this.getData(row, i);
					cells.push(data);
				}
			}
			var o = this.getData(row, 0);
			o.cells = cells;
			var html = this.regionTpl.apply(o);
			Ext.core.DomHelper.insertBefore(rowEl, html);
			Ext.removeNode(rowEl.dom);
			this.fireEvent("refreshrow", row, this);
		}
	},
	refreshColumn: function(col) {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		if(store.isVisibleColumn(sheetId, col)) {
			for(var i = this.rowStart; i <= this.rowEnd; i++) {
				this.refreshCell(i, col);
			}
		}
	},
	onCellChange: function(sheetId, row, col, modified, deleted, odata, data, store) {
		if(sheetId == this.getSheetId()) {
			if(this.isVisible() && this.isInRange(row, col) && store.isVisibleRow(sheetId, row) && store.isVisibleColumn(sheetId, col)) {
				var cell = store.getCell(sheetId, row, col);
				if(store.isMergedCell(cell, sheetId, row, col)) {
					var minrow = row + cell.minrow;
					var mincol = col + cell.mincol;
					if(minrow == row && mincol == col) {
						this.refreshMergedCell(row, col);
						return;
					}
				}
				this.refreshCell(row, col);
			}
		}
	},
	onColumnChange: function(sheetId, col, modified, deleted, odata, data, store) {
		if(sheetId == this.getSheetId()) {
			if(this.isVisible() && this.isInColumnRange(col)) {
				var s = this.getStore();
				for(var i = this.rowStart; i <= this.rowEnd; i++) {
					if(s.isVisibleRow(sheetId, i)) {
						this.refreshCell(i, col);
					}
				}
				var cw = this.currentWidth;
				var w = s.getRangeWidth(sheetId, this.colStart, this.colEnd, undefined, true);
				var offset = w - cw;
				this.updateOffsetWidth(offset);
			} else {
				if(col < this.colStart) {
					this.sysn();
				}
			}
			this.fireEvent("columnchange", col, modified, deleted, odata, data, store, this);
		}
	},
	onRowChange: function(sheetId, row, modified, deleted, odata, data, store) {
		if(sheetId == this.getSheetId()) {
			if(this.isVisible() && this.isInRowRange(row)) {
				var s = this.getStore();
				var ch = this.regionEl.getHeight();
				this.refreshRow(row);
				var h = s.getRangeHeight(sheetId, this.rowStart, this.rowEnd, undefined, true);
				var offset = h - ch;
				if(0 != offset) {
					this.updateOffsetHeight(offset);
				}
			} else {
				if(row < this.rowStart) {
					this.sysn();
				}
			}
			this.fireEvent("rowchange", row, modified, deleted, odata, data, store, this);
		}
	},
	onRender: function() {
		this.callParent(arguments);
		var html;
		if(this.noInnerContainer) {
			html = ["<div class=\"ss-region\"></div>"].join("");
			this.el.update(html);
		} else {
			html = ["<div class=\"ss-region", this.backgroundImageUrl && "none" !== this.backgroundImageUrl ? " ss-region-bg" : "", "\"></div>", "<div class=\"ss-ifct\" style=\"", SCONST.dir.none, "\">", "<div class=\"ss-ifbody\" style=\"", SCONST.dirbody.none, this.backgroundImageUrl ? "background-image:" + this.backgroundImageUrl + ";" : "", "\">", "</div>", "</div>", this.skipCanvas ? "" : "<canvas class=\"ss-ifct\"></canvas>"].join("");
			this.el.update(html);
			this.ifctEl = Ext.get(this.el.dom.childNodes[1]);
			this.ifbodyEl = Ext.get(this.ifctEl.dom.firstChild);
			if(!this.skipCanvas) {
				this.canvasEl = Ext.get(this.el.dom.childNodes[2]);
				this.context2d = this.canvasEl.dom.getContext("2d");
			}
		}
		this.regionEl = Ext.get(this.el.dom.firstChild);
	},
	setRegionBackground: function(url) {
		url = Ext.String.trim(url || "");
		if(this.ifbodyEl) {
			if(url) {
				url = "url(" + url + ")";
			} else {
				url = "none";
			}
			this.ifbodyEl.setStyle("background-image", url);
			if(url && "none" !== url) {
				this.regionEl.addCls("ss-region-bg");
			} else {
				this.regionEl.removeCls("ss-region-bg");
			}
		} else {
			this.backgroundImageUrl = url;
		}
	},
	afterRender: function() {
		if(this.fixedRowForResize) {
			var s = this.getStore();
			var rows = [];
			for(var i = this.rowStart; i <= this.rowEnd; i++) {
				var cells = [];
				if(this.fixedColForResize) {
					for(var j = this.colStart; j <= this.colEnd; j++) {
						cells.push(this.getData(i, j));
					}
				}
				var o = this.getData(i, 0);
				o.cells = cells;
				rows.push(o);
			}
			var html = this.regionTpl.apply(rows);
			this.regionEl.update(html);
		}
		this.callParent();
		this.wrapElEvent();
	},
	wrapElEvent: function() {
		var sm = this.getSelectionModel();
		this.mon(this.el, "contextmenu", function(e) {
			e.preventDefault();
			var target = e.getTarget(null, null, true);
			try {
				if(target.hasCls("ss-ifct") || target.hasCls("ss-ifbody") || sm && sm.within(target) || target.hasCls("ss-cell") || target.hasCls("ss-incell") || target.hasCls("ss-vcell") || target.hasCls("ss-cell-inside")) {
					var rc = this.getRowColFromPos(e.getXY());
					if(rc) {
						this.fireEvent("cellcontextmenu", rc[0], rc[1], this, e);
					}
				}
			} catch(e) {}
		}, this);
		this.mon(this.el, "dblclick", function(e) {
			if(0 === e.button) {
				e.preventDefault();
				var target = e.getTarget(null, null, true);
				if(target.hasCls("ss-ifct") || target.hasCls("ss-ifbody") || sm && sm.within(target) || target.hasCls("ss-cell") || target.hasCls("ss-incell") || target.hasCls("ss-vcell") || target.hasCls("ss-cell-inside")) {
					var rc = this.getRowColFromPos(e.getXY());
					if(rc) {
						this.fireEvent("celldblclick", rc[0], rc[1], this, e);
					}
				}
			}
		}, this);
		this.mon(this.el, "click", function(e) {
			if(0 === e.button) {
				var target = e.getTarget();
				var tagName = target.tagName.toUpperCase();
				var rc = this.getRowColFromPos(e.getXY());
				if("A" !== tagName && "INPUT" !== tagName) {
					e.preventDefault();
				} else {
					this.fireEvent("clickcellitem", tagName, target, rc, this);
					return;
				}
				if(rc) {
					this.fireEvent("cellclick", rc[0], rc[1], this, e);
				}
			}
		}, this);
		this.mon(this.el, "mousedown", function(e) {
			this.fireEvent("regionmousedown", e, this);
			if(0 === e.button) {
				var target = e.getTarget(null, null, true),
					dot;
				var tagName = target.dom.tagName.toUpperCase();
				if("INPUT" !== tagName && "TEXTAREA" !== tagName) {
					e.preventDefault();
				} else {
					this.fireEvent("mousedowncellitem", tagName, this.getRowColFromPos(e.getXY()), this);
					return;
				}
				if(Ext.supports.ClassList && !target.dom.classList) {
					return;
				}
				if(sm && (dot = sm.atDot(target))) {
					this.autofillpressed = true;
					var xy = e.getXY();
					var rc = this.getRowColFromPos(xy);
					if(rc) {
						this.fireEvent("autofillmousedown", rc[0], rc[1], this, e, dot);
					}
				} else if(target.hasCls("ss-ifct") || target.hasCls("ss-ifbody") || sm && sm.within(target) || target.hasCls("ss-cell") || target.hasCls("ss-incell") || target.hasCls("ss-vcell") || target.hasCls("ss-cell-inside")) {
					var xy = e.getXY();
					var rc = this.getRowColFromPos(xy);
					if(rc) {
						if(false !== this.fireEvent("beforecellmousedown", rc[0], rc[1], this, e)) {
							this.mousepressed = true;
							this.fireEvent("preparecellmousedown", rc[0], rc[1], this, e);
							this.fireEvent("cellmousedown", rc[0], rc[1], this, e);
						}
					}
				} else if(target.parent(".ss-cell")) {
					var xy = e.getXY();
					var rc = this.getRowColFromPos(xy);
					if(rc) {
						if(false === this.fireEvent("incellmousedown", rc, target, this, e)) {
							this.mousepressed = true;
						}
					}
				}
			}
		}, this);
		if(this.enableCellMouseOver || this.enableCellMouseMove) {
			this.mon(this.el, "mousemove", function(e) {
				if(!this.mousepressed) {
					var target = e.getTarget(null, null, true);
					if(Ext.supports.ClassList && !target.dom.classList) {
						return;
					}
					if(target.hasCls("ss-ifct") || target.hasCls("ss-ifbody") || sm && sm.within(target) || target.hasCls("ss-cell") || target.hasCls("ss-incell") || target.hasCls("ss-vcell") || target.hasCls("ss-cell-inside")) {
						var rc = this.getRowColFromPos(e.getXY());
						if(rc) {
							if(this.trackMouseOver) {
								var lp = this.lastMouseOverPos;
								if(lp) {
									var lastCell = this.getCellEl(lp.row, lp.col);
									if(lastCell) {
										lastCell.removeCls("ss-cellover");
									}
								}
								var cell = this.getCellEl(rc[0], rc[1]);
								if(cell) {
									cell.addCls("ss-cellover");
								}
								this.lastMouseOverPos = {
									row: rc[0],
									col: rc[1]
								};
							}
							if(this.enableCellMouseOver) {
								if(this.mouseOverRow != rc[0] || this.mouseOverCol != rc[1]) {
									if(false == SCOM.typeOf(this.mouseOverRow)) {
										this.fireEvent("cellmouseenter", rc[0], rc[1], this, e);
									} else {
										this.fireEvent("cellmouseout", this.mouseOverRow, this.mouseOverCol, this, e);
									}
									this.mouseOverRow = rc[0];
									this.mouseOverCol = rc[1];
									this.fireEvent("cellmouseover", rc[0], rc[1], this, e);
								}
							}
							if(this.enableCellMouseMove) {
								this.fireEvent("cellmousemove", rc[0], rc[1], this, e);
							}
						}
					}
				}
			}, this);
		}
		this.mon(this.el, "mouseout", function(e) {
			if(this.trackMouseOver) {
				var lp = this.lastMouseOverPos;
				if(lp) {
					var lastCell = this.getCellEl(lp.row, lp.col);
					if(lastCell) {
						lastCell.removeCls("ss-cellover");
					}
				}
			}
			if(false != SCOM.typeOf(this.mouseOverRow)) {
				this.fireEvent("cellmouseout", this.mouseOverRow, this.mouseOverCol, this, e);
			}
		}, this);
		Ext.getDoc().on("mousemove", function(e) {
			if(this.mousepressed) {
				e.preventDefault();
				var rc = this.getRowColFromPos(e.getXY(), true);
				if(rc) {
					this.fireEvent("cellmousedrag", rc[0], rc[1], rc[2], this, e);
				}
			} else if(this.autofillpressed) {
				e.preventDefault();
				var rc = this.getRowColFromPos(e.getXY(), true);
				if(rc) {
					this.fireEvent("autofillmousedrag", rc[0], rc[1], rc[2], this, e);
				}
			}
		}, this);
		Ext.getDoc().on("mouseup", function(e) {
			if(this.mousepressed) {
				delete this.mousepressed;
				this.fireEvent("cellmouseup", this, e);
			}
			if(this.autofillpressed) {
				delete this.autofillpressed;
				this.fireEvent("autofillmouseup", this, e);
			}
		}, this);
	},
	getRowColFromPos: function(xy, checkout) {
		var rowBoundMax = SCONST.MAX_ROW_NUMBER,
			colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		var sheetId = this.getSheetId();
		var x = xy[0],
			y = xy[1],
			l = this.el.getLeft() + this.el.getBorderWidth("l"),
			t = this.el.getTop() + this.el.getBorderWidth("t");
		x -= l;
		y -= t;
		var s = this.getStore();
		var col = this.colStart;
		var woff = 0,
			hoff = 0;
		if(0 < x) {
			var rowDom = this.regionEl.dom.childNodes[0];
			var w = Ext.get(rowDom.firstChild).getWidth();
			col = Number(rowDom.firstChild.getAttribute("data-ci"));
			var i = 1,
				len = rowDom.childNodes.length;
			while(w <= x && (!colBoundMax || col < colBoundMax)) {
				if(i < len) {
					var child = Ext.get(rowDom.childNodes[i]);
					col = Number(child.getAttribute("data-ci"));
					w += child.getWidth();
					i++;
				} else {
					col++;
					w += s.getColWidth(sheetId, col, true, true);
				}
			}
			woff = x - w;
		} else if(0 > x) {
			var px = -x;
			var w = 0;
			while(w <= px && col > 1) {
				col--;
				w += s.getColWidth(sheetId, col, true, true);
			}
			woff = px - w;
		}
		var row = this.rowStart;
		if(0 < y) {
			var firstChild = Ext.get(this.regionEl.dom.childNodes[0]);
			var h = firstChild.getHeight();
			row = Number(firstChild.dom.firstChild.getAttribute("data-ri"));
			var i = 1,
				len = this.regionEl.dom.childNodes.length;
			while(h <= y && (!rowBoundMax || row < rowBoundMax)) {
				if(i < len) {
					var child = Ext.get(this.regionEl.dom.childNodes[i]);
					row = Number(child.dom.firstChild.getAttribute("data-ri"));
					h += child.getHeight();
					i++;
				} else {
					row++;
					h += s.getRowHeight(sheetId, row, true, true);
				}
			}
			hoff = y - h;
		} else if(0 > y) {
			var py = -y;
			var h = 0;
			while(h <= py && row > 1) {
				row--;
				h += s.getRowHeight(sheetId, row, true, true);
			}
			hoff = py - h;
		}
		if(0 < x) {
			s.cacheRangeWidth(xy[0] - this.ifbodyEl.getLeft() - woff, this.colBound.min, col, sheetId);
		}
		if(0 < y) {
			s.cacheRangeHeight(xy[1] - this.ifbodyEl.getTop() - hoff, this.rowBound.min, row, sheetId);
		}
		if(!checkout) {
			return [row, col];
		} else {
			var pos = {
				x: x,
				y: y,
				w: this.getEl().getWidth(),
				h: this.getEl().getHeight()
			};
			return [row, col, pos];
		}
	},
	processAfterResize: function(comp, width, height) {
		if(!this._skipProcessResize) {
			this.getEl().setWidth(width);
			if(!this.fixedRowForResize) {
				this.adjustRows(height - this.regionEl.getHeight());
			}
			if(!this.fixedColForResize) {
				this.adjustCols(width - this.currentWidth);
			}
			this.currentWidth = this.regionEl.getWidth();
			this.sysn(true);
			if(this.canvasEl) {
				this.canvasEl.dom.width = this.canvasEl.getWidth();
				this.canvasEl.dom.height = this.canvasEl.getHeight();
			}
		}
	},
	adjustCols: function(offsetWidth) {
		var w = 0;
		var s = this.getStore();
		var sheetId = this.getSheetId();
		if(0 < offsetWidth) {
			var colEnd = this.colEnd;
			var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
			while(true && (!colBoundMax || this.colEnd < colBoundMax)) {
				var width = s.getColWidth(sheetId, ++this.colEnd, true, true);
				w += width;
				if(w >= offsetWidth) {
					break;
				}
			}
			this.updateRegionElWidth(this.currentWidth + w);
			var columnVisible = [];
			colEnd++;
			for(var j = colEnd; j <= this.colEnd; j++) {
				columnVisible.push(s.isVisibleColumn(sheetId, j));
			}
			var k = 0;
			for(var i = this.rowStart; i <= this.rowEnd; i++) {
				if(s.isVisibleRow(sheetId, i)) {
					var cells = [];
					for(var j = colEnd; j <= this.colEnd; j++) {
						if(columnVisible[j - colEnd]) {
							var c = this.getData(i, j);
							cells.push(c);
						}
					}
					if(0 < cells.length) {
						var rowel = this.regionEl.dom.childNodes[k++];
						if(rowel) {
							var html = this.rowTpl.apply(cells);
							Ext.core.DomHelper.append(rowel, html);
						}
					}
				}
			}
		}
	},
	adjustRows: function(offsetHeight) {
		var sheetId = this.getSheetId();
		var h = 0;
		var s = this.getStore();
		if(0 < offsetHeight) {
			var rowEnd = this.rowEnd;
			var rowBoundMax = SCONST.MAX_ROW_NUMBER;
			while(true && (!rowBoundMax || this.rowEnd < rowBoundMax)) {
				var height = s.getRowHeight(sheetId, ++this.rowEnd, true, true);
				h += height;
				if(h >= offsetHeight) {
					break;
				}
			}
			var rows = [],
				columnVisible = [];
			for(var j = this.colStart; j <= this.colEnd; j++) {
				columnVisible.push(s.isVisibleColumn(sheetId, j));
			}
			rowEnd++;
			for(var i = rowEnd; i <= this.rowEnd; i++) {
				if(s.isVisibleRow(sheetId, i)) {
					var cells = [];
					for(var j = this.colStart; j <= this.colEnd; j++) {
						if(columnVisible[j - this.colStart]) {
							var c = this.getData(i, j);
							cells.push(c);
						}
					}
					var o = this.getData(i, 0);
					o.cells = cells;
					rows.push(o);
				}
			}
			this.appendRows(rows);
		}
	},
	appendRows: function(rows) {
		var html = this.regionTpl.apply(rows);
		Ext.core.DomHelper.append(this.regionEl.dom, html);
	},
	moveUp: function(offset) {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var low = this.rowBound.low;
		for(var i = low; i < this.rowStart; i++) {
			if(s.isVisibleRow(sheetId, low)) {
				break;
			} else {
				low = i + 1;
			}
		}
		if(low > this.rowStart - offset) {
			offset = this.rowStart - low;
		}
		if(0 >= offset) {
			return 0;
		}
		var el = this.regionEl.dom,
			rowDom = el.firstChild;
		var ah = 0,
			rows = [],
			visibleColumn = [];
		var eh = this.getEl().getHeight();
		for(var j = 0, len = rowDom.childNodes.length; j < len; j++) {
			var child = rowDom.childNodes[j],
				ci = Number(child.getAttribute("data-ci"));
			visibleColumn.push(ci);
		}
		var rowStart = this.rowStart,
			rowEnd;
		var oldRowStart = rowStart,
			tmpH = [];
		for(var i = 0; i < offset && low < rowStart;) {
			var h = s.getRowHeight(sheetId, --rowStart, true, true);
			if(0 !== h) {
				i++;
				tmpH.unshift({
					i: rowStart,
					h: h
				});
			}
		}
		for(var i = 0, size = tmpH.length; i < size; i++) {
			var it = tmpH[i];
			rowEnd = it.i;
			var h = it.h;
			var cells = [];
			for(var j = 0, len = visibleColumn.length; j < len; j++) {
				cells.push(this.getData(rowEnd, visibleColumn[j]));
			}
			var o = this.getData(rowEnd, 0);
			o.cells = cells;
			rows.push(o);
			ah += h;
			if(ah > eh) {
				break;
			}
		}
		if(ah > eh) {
			ah = s.getRangeHeight(sheetId, rowStart, this.rowStart - 1, undefined, true);
			var html = this.regionTpl.apply(rows);
			this.regionEl.update(html);
			this.rowStart = rowStart;
			this.rowEnd = rowEnd;
		} else {
			var ih = this.regionEl.getHeight();
			var html = this.regionTpl.apply(rows);
			Ext.core.DomHelper.insertBefore(el.firstChild, html);
			ih += ah;
			var offsetHeight = ih - eh;
			var rh = 0,
				rowEnd = this.rowEnd;
			while(true) {
				var h = s.getRowHeight(sheetId, rowEnd--, true, true);
				if(0 != h) {
					rh += h;
					if(rh > offsetHeight) {
						rowEnd++;
						break;
					} else {
						Ext.removeNode(el.lastChild);
					}
				}
			}
			this.rowStart = rowStart;
			this.rowEnd = rowEnd;
		}
		if(this.ifctEl) {
			this.ifctEl.dom.scrollTop -= ah;
		}
		this.fireEvent("moving", "up", offset, this);
		return -offset;
	},
	moveRow: function(rowStart, rowEnd, scrollTop) {
		if(rowEnd == this.rowEnd && rowStart == this.rowStart) {
			return;
		}
		var el = this.regionEl.dom,
			rowDom = el.firstChild;
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var renderWhole = false;
		var visibleColumn = [];
		for(var j = 0, len = rowDom.childNodes.length; j < len; j++) {
			var child = rowDom.childNodes[j],
				ci = Number(child.getAttribute("data-ci"));
			visibleColumn.push(ci);
		}
		if(rowStart < this.rowStart) {
			if(rowEnd < this.rowStart) {
				renderWhole = true;
			} else {
				var rows = [];
				for(var i = rowStart; i < this.rowStart; i++) {
					if(s.isVisibleRow(sheetId, i)) {
						var cells = [];
						for(var j = 0, len = visibleColumn.length; j < len; j++) {
							cells.push(this.getData(i, visibleColumn[j]));
						}
						var o = this.getData(i, 0);
						o.cells = cells;
						rows.push(o);
					}
				}
				var html = this.regionTpl.apply(rows);
				Ext.core.DomHelper.insertBefore(el.firstChild, html);
				for(var k = rowEnd + 1; k <= this.rowEnd; k++) {
					if(s.isVisibleRow(sheetId, k)) {
						Ext.removeNode(el.lastChild);
					}
				}
			}
		} else {
			if(rowStart > this.rowEnd) {
				renderWhole = true;
			} else {
				var rows = [];
				for(var i = this.rowEnd + 1; i <= rowEnd; i++) {
					if(s.isVisibleRow(sheetId, i)) {
						var cells = [];
						for(var j = 0, len = visibleColumn.length; j < len; j++) {
							cells.push(this.getData(i, visibleColumn[j]));
						}
						var o = this.getData(i, 0);
						o.cells = cells;
						rows.push(o);
					}
				}
				var html = this.regionTpl.apply(rows);
				Ext.core.DomHelper.append(el, html);
				for(var k = this.rowStart; k < rowStart; k++) {
					if(s.isVisibleRow(sheetId, k)) {
						Ext.removeNode(el.firstChild);
					}
				}
			}
		}
		if(renderWhole) {
			var rows = [];
			for(var i = rowStart; i <= rowEnd; i++) {
				if(s.isVisibleRow(sheetId, i)) {
					var cells = [];
					for(var j = 0, len = visibleColumn.length; j < len; j++) {
						cells.push(this.getData(i, visibleColumn[j]));
					}
					var o = this.getData(i, 0);
					o.cells = cells;
					rows.push(o);
				}
			}
			var html = this.regionTpl.apply(rows);
			this.regionEl.update(html);
		}
		this.rowStart = rowStart;
		this.rowEnd = rowEnd;
		if(this.ifctEl) {
			this.ifctEl.dom.scrollTop = scrollTop;
		}
	},
	moveDown: function(offset) {
		if(0 == offset || this.rowBound.high) {
			return 0;
		}
		var rowBoundMax = SCONST.MAX_ROW_NUMBER;
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var el = this.regionEl.dom;
		var eh = this.getEl().getHeight(),
			ih = this.regionEl.getHeight();
		var rowStart = this.rowStart,
			rowEnd, minh, rh;
		var rowSpan = el.childNodes.length;
		if(offset >= rowSpan) {
			rowStart = this.rowEnd;
			for(var i = 0, len = offset - rowSpan + 1; i < len;) {
				if(s.isVisibleRow(++rowStart)) {
					i++;
				}
			}
			if(rowBoundMax && rowStart > rowBoundMax) {
				rowStart = rowBoundMax;
			}
			rowEnd = rowStart - 1;
			minh = eh;
			rh = s.getRangeHeight(sheetId, this.rowStart, rowEnd, undefined, true);
		} else {
			rh = 0;
			for(var k = 0; k < offset; k++) {
				var child = Ext.get(el.childNodes[k]);
				var h = child.getHeight();
				rh += h;
				rowStart = child.dom.firstChild.getAttribute("data-ri");
				rowStart = Number(rowStart) + 1;
			}
			rowEnd = this.rowEnd;
			minh = rh - (ih - eh);
			if(eh < minh) {
				minh = eh;
			}
		}
		var ah = 0;
		var rows = [],
			visibleColumn = [];
		var rowDom = el.firstChild;
		for(var j = 0, len = rowDom.childNodes.length; j < len; j++) {
			var child = rowDom.childNodes[j],
				ci = Number(child.getAttribute("data-ci"));
			visibleColumn.push(ci);
		}
		while(ah < minh && (!rowBoundMax || rowEnd < rowBoundMax)) {
			var h = s.getRowHeight(sheetId, ++rowEnd, true, true);
			if(0 != h) {
				ah += h;
				var cells = [];
				for(var j = 0, len = visibleColumn.length; j < len; j++) {
					cells.push(this.getData(rowEnd, visibleColumn[j]));
				}
				var o = this.getData(rowEnd, 0);
				o.cells = cells;
				rows.push(o);
			}
		}
		var html;
		if(0 < rows.length) {
			html = this.regionTpl.apply(rows);
		}
		if(rowStart <= this.rowEnd) {
			for(var k = 1; k <= offset; k++) {
				Ext.removeNode(el.firstChild);
			}
			if(html) {
				Ext.core.DomHelper.append(el, html);
			}
			this.rowStart = rowStart;
			this.rowEnd = rowEnd;
		} else {
			this.rowStart = rowStart;
			this.rowEnd = rowEnd;
			this.regionEl.update(html);
		}
		if(this.ifctEl) {
			this.ifctEl.dom.scrollTop += rh;
		}
		this.fireEvent("moving", "down", offset, this);
		return offset;
	},
	moveRight: function(offset) {
		if(0 == offset || this.colBound.high) {
			return 0;
		}
		var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var el = this.regionEl.dom,
			rowDom = el.firstChild;
		var ew = this.getEl().getWidth(),
			iw = this.currentWidth;
		var rw, colEnd, colStart, minw;
		var colSpan = rowDom.childNodes.length;
		var beyondFlag = false;
		if(offset >= colSpan) {
			colStart = this.colEnd;
			for(var i = 0, len = offset - colSpan + 1; i < len;) {
				if(s.isVisibleColumn(++colStart)) {
					i++;
				}
			}
			if(colBoundMax && colStart > colBoundMax) {
				colStart = colBoundMax;
				beyondFlag = true;
			}
			colEnd = colStart - 1;
			minw = ew;
			rw = s.getRangeWidth(sheetId, this.colStart, colEnd, undefined, true);
		} else {
			rw = 0;
			colStart = this.colStart;
			for(var k = 0; k < offset; k++) {
				var child = Ext.get(rowDom.childNodes[k]);
				var w = child.getWidth();
				rw += w;
				colStart = child.getAttribute("data-ci");
				colStart = Number(colStart) + 1;
			}
			colEnd = this.colEnd;
			minw = rw - (iw - ew);
			if(ew < minw) {
				minw = ew;
			}
		}
		var rows = [],
			rowVisible = [];
		for(var i = 0, len = el.childNodes.length; i < len; i++) {
			var child = el.childNodes[i].firstChild,
				ri = Number(child.getAttribute("data-ri"));
			rowVisible.push(ri);
			var o = this.getData(ri, 0);
			o.cells = [];
			rows.push(o);
		}
		var aw = 0;
		while(aw < minw && (!colBoundMax || colEnd < colBoundMax)) {
			var w = s.getColWidth(sheetId, ++colEnd, true, true);
			if(0 != w) {
				aw += w;
				for(var k = 0, len = rowVisible.length; k < len; k++) {
					var cells = rows[k].cells;
					cells.push(this.getData(rowVisible[k], colEnd));
				}
			}
		}
		if(colStart <= this.colEnd) {
			var tmp = iw - rw;
			if(!beyondFlag) {
				tmp += aw;
			}
			this.updateRegionElWidth(tmp);
			for(var i = 0, len = el.childNodes.length; i < len; i++) {
				var row = el.childNodes[i];
				for(var k = 0; k < offset; k++) {
					Ext.removeNode(row.firstChild);
				}
				var cells = rows[i].cells;
				if(0 < cells.length) {
					var html = this.rowTpl.apply(cells);
					Ext.core.DomHelper.append(row, html);
				}
			}
			this.colStart = colStart;
			this.colEnd = colEnd;
		} else {
			this.updateRegionElWidth(aw);
			for(var k = 0, len = rowVisible.length; k < len; k++) {
				var o = this.getData(rowVisible[k], 0);
				Ext.applyIf(rows[k], o);
			}
			var html = this.regionTpl.apply(rows);
			this.colStart = colStart;
			this.colEnd = colEnd;
			this.regionEl.update(html);
		}
		if(this.ifctEl) {
			this.ifctEl.dom.scrollLeft += rw;
		}
		this.fireEvent("moving", "right", offset, this);
		return offset;
	},
	moveColumn: function(colStart, colEnd, scrollLeft) {
		if(colEnd == this.colEnd && colStart == this.colStart) {
			return;
		}
		var el = this.regionEl.dom,
			rowDom = el.firstChild;
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var renderWhole = false;
		if(colStart < this.colStart) {
			if(colEnd < this.colStart) {
				renderWhole = true;
			} else {
				var visibleColumn = [],
					removeVisibleColumn = [];
				for(var j = colStart; j < this.colStart; j++) {
					visibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
				for(var j = colEnd + 1; j <= this.colEnd; j++) {
					removeVisibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
				for(var k = 0, len = el.childNodes.length; k < len; k++) {
					var child = el.childNodes[k].firstChild,
						i = Number(child.getAttribute("data-ri"));
					var cells = [];
					for(var j = colStart; j < this.colStart; j++) {
						if(visibleColumn[j - colStart]) {
							cells.push(this.getData(i, j));
						}
					}
					var html = this.rowTpl.apply(cells);
					var row = el.childNodes[k];
					Ext.core.DomHelper.insertBefore(row.firstChild, html);
					for(var j = colEnd + 1; j <= this.colEnd; j++) {
						if(removeVisibleColumn[j - colEnd - 1]) {
							Ext.removeNode(row.lastChild);
						}
					}
				}
			}
		} else {
			if(colStart > this.colEnd) {
				renderWhole = true;
			} else {
				var visibleColumn = [],
					removeVisibleColumn = [];
				for(var j = this.colEnd + 1; j <= colEnd; j++) {
					visibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
				for(var j = this.colStart; j < colStart; j++) {
					removeVisibleColumn.push(s.isVisibleColumn(sheetId, j));
				}
				for(var k = 0, len = el.childNodes.length; k < len; k++) {
					var child = el.childNodes[k].firstChild,
						i = Number(child.getAttribute("data-ri"));
					var cells = [];
					for(var j = this.colEnd + 1; j <= colEnd; j++) {
						if(visibleColumn[j - this.colEnd - 1]) {
							cells.push(this.getData(i, j));
						}
					}
					var html = this.rowTpl.apply(cells);
					var row = el.childNodes[k];
					Ext.core.DomHelper.append(row, html);
					for(var j = this.colStart; j < colStart; j++) {
						if(removeVisibleColumn[j - this.colStart]) {
							Ext.removeNode(row.firstChild);
						}
					}
				}
			}
		}
		var visibleColumn = [],
			w = 0;
		for(var j = colStart; j <= colEnd; j++) {
			var visible = s.isVisibleColumn(sheetId, j);
			visibleColumn.push(visible);
			if(visible) {
				w += s.getColWidth(sheetId, j, true, true);
			}
		}
		if(renderWhole) {
			var rows = [];
			for(var k = 0, len = el.childNodes.length; k < len; k++) {
				var child = el.childNodes[k].firstChild,
					i = Number(child.getAttribute("data-ri"));
				var cells = [];
				for(var j = colStart; j <= colEnd; j++) {
					if(visibleColumn[j - colStart]) {
						cells.push(this.getData(i, j));
					}
				}
				var o = this.getData(i, 0);
				o.cells = cells;
				rows.push(o);
			}
			var html = this.regionTpl.apply(rows);
			this.regionEl.update(html);
		}
		this.colStart = colStart;
		this.colEnd = colEnd;
		if(this.ifctEl) {
			this.ifctEl.dom.scrollLeft = scrollLeft;
		}
		this.updateRegionElWidth(w);
	},
	moveLeft: function(offset) {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var low = this.colBound.low;
		for(var i = low; i < this.colStart; i++) {
			if(s.isVisibleColumn(sheetId, low)) {
				break;
			} else {
				low = i + 1;
			}
		}
		if(low > this.colStart - offset) {
			offset = this.colStart - low;
		}
		if(0 >= offset) {
			return 0;
		}
		var el = this.regionEl.dom;
		var ew = this.getEl().getWidth();
		var aw = 0,
			colStart = this.colStart,
			colEnd;
		var rowVisible = [],
			rows = [];
		for(var i = 0, len = el.childNodes.length; i < len; i++) {
			var child = el.childNodes[i].firstChild,
				ri = Number(child.getAttribute("data-ri"));
			rowVisible.push(ri);
			var o = this.getData(ri, 0);
			o.cells = [];
			rows.push(o);
		}
		var oldColStart = colStart,
			tmpW = [];
		for(var i = 0; i < offset && low < colStart;) {
			var w = s.getColWidth(sheetId, --colStart, true, true);
			if(0 !== w) {
				i++;
				tmpW.unshift({
					i: colStart,
					w: w
				});
			}
		}
		for(var i = 0, size = tmpW.length; i < size; i++) {
			var it = tmpW[i];
			colEnd = it.i;
			var w = it.w;
			for(var j = 0, len = rowVisible.length; j < len; j++) {
				var cells = rows[j].cells;
				cells.push(this.getData(rowVisible[j], colEnd));
			}
			aw += w;
			if(aw > ew) {
				break;
			}
		}
		if(aw > ew) {
			var xw = s.getRangeWidth(sheetId, colStart, this.colStart - 1, undefined, true);
			var html = this.regionTpl.apply(rows);
			this.regionEl.update(html);
			this.colStart = colStart;
			this.colEnd = colEnd;
			this.updateRegionElWidth(aw);
			aw = xw;
		} else {
			for(var i = 0, len = el.childNodes.length; i < len; i++) {
				var row = el.childNodes[i];
				var html = this.rowTpl.apply(rows[i].cells);
				Ext.core.DomHelper.insertBefore(row.firstChild, html);
			}
			var offsetWidth = this.currentWidth + aw - ew;
			var rw = 0,
				colEnd = this.colEnd;
			while(true) {
				var w = s.getColWidth(sheetId, colEnd--, true, true);
				if(0 != w) {
					rw += w;
					if(rw > offsetWidth) {
						rw -= w;
						colEnd++;
						break;
					} else {
						for(var i = 0, len = el.childNodes.length; i < len; i++) {
							var row = el.childNodes[i];
							Ext.removeNode(row.lastChild);
						}
					}
				}
			}
			this.colStart = colStart;
			this.colEnd = colEnd;
			this.updateRegionElWidth(this.currentWidth + aw - rw);
		}
		if(this.ifctEl) {
			this.ifctEl.dom.scrollLeft -= aw;
		}
		this.fireEvent("moving", "left", offset, this);
		return -offset;
	},
	renderRange: function() {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var rows = [],
			visibleColumn = [];
		for(var j = this.colStart; j <= this.colEnd; j++) {
			visibleColumn.push(s.isVisibleColumn(sheetId, j));
		}
		for(var i = this.rowStart; i <= this.rowEnd; i++) {
			if(s.isVisibleRow(sheetId, i)) {
				var cells = [];
				for(var j = this.colStart; j <= this.colEnd; j++) {
					if(visibleColumn[j - this.colStart]) {
						cells.push(this.getData(i, j));
					}
				}
				var o = this.getData(i, 0);
				o.cells = cells;
				rows.push(o);
			}
		}
		var html = this.regionTpl.apply(rows);
		this.regionEl.update(html);
	},
	changeRange: function(range, keepRegionWidth) {
		if(range) {
			this.setRange(range);
		}
		this.renderRange();
		if(!keepRegionWidth) {
			this.currentWidth = this.getStore().getRangeWidth(this.getSheetId(), this.colStart, this.colEnd, undefined, true);
			this.updateRegionElWidth(this.currentWidth);
		}
	},
	setRange: function(range) {
		Ext.apply(this, range);
	},
	switchScroller: function(visible) {
		if(this.infinateScroller) {
			this.infinateScroller.setVisible(visible);
		}
	},
	sysInfinateScroller: function(dir) {
		if(this.infinateScroller) {
			this.infinateScroller.sysn(dir);
		}
	},
	sysn: function(holdInfinateScroll) {
		var s = this.getStore();
		var sheetId = this.getSheetId();
		if(this.ifctEl) {
			var w = s.getRangeWidth(sheetId, 1, this.colStart - 1, undefined, true);
			var h = s.getRangeHeight(sheetId, 1, this.rowStart - 1, undefined, true);
			this.ifctEl.dom.scrollLeft = w;
			this.ifctEl.dom.scrollTop = h;
		}
		if(!holdInfinateScroll) {
			this.sysInfinateScroller();
		}
	},
	recalculateRange: function(rowObj, colObj) {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		this._skipProcessResize = true;
		if(rowObj) {
			this.rowStart = rowObj.rowStart;
			var rowBoundMax = SCONST.MAX_ROW_NUMBER;
			var rh = rowObj.height;
			var rowEnd = rowObj.rowEnd;
			if(false == SCOM.typeOf(rowEnd)) {
				rowEnd = this.rowStart - 1;
				var h = 0;
				while(true && (!rowBoundMax || rowEnd < rowBoundMax)) {
					var height = s.getRowHeight(sheetId, ++rowEnd, true, true);
					h += height;
					if(h >= rh) {
						break;
					}
				}
			}
			if(false == SCOM.typeOf(rh)) {
				rh = s.getRangeHeight(sheetId, this.rowStart, rowEnd, undefined, true);
			}
			this.rowEnd = rowEnd;
			this.setHeight(rh);
		}
		if(colObj) {
			this.colStart = colObj.colStart;
			var colBoundMax = SCONST.MAX_COLUMN_NUMBER;
			var cw = colObj.width;
			var colEnd = colObj.colEnd;
			if(false == SCOM.typeOf(colEnd)) {
				colEnd = this.colStart - 1;
				var w = 0;
				while(true && (!colBoundMax || colEnd < colBoundMax)) {
					var width = s.getColWidth(sheetId, ++colEnd, true, true);
					w += width;
					if(w >= cw) {
						break;
					}
				}
			}
			if(false == SCOM.typeOf(cw)) {
				cw = s.getRangeWidth(sheetId, this.colStart, colEnd, undefined, true);
			}
			this.colEnd = colEnd;
			this.setWidth(cw);
		}
		this.changeRange();
		delete this._skipProcessResize;
	},
	setBound: function(rb, cb) {
		Ext.apply(this.rowBound, rb);
		Ext.apply(this.colBound, cb);
	},
	getCellPosition: function(x, y) {
		var s = this.getStore();
		var sheetId = this.getSheetId();
		var w = s.getRangeWidth(sheetId, this.colStart, y, undefined, true);
		var h = s.getRangeHeight(sheetId, this.rowStart, x, undefined, true);
		return [w, h];
	},
	getStore: function() {
		return this.store;
	},
	getSelectionModel: function() {
		return this.sm;
	},
	getScroller: function() {
		return this.infinateScroller;
	},
	autoMoving: function(pos) {
		var scroller = this.getScroller();
		if(scroller) {
			var row = pos.row,
				col = pos.col,
				moved = false;
			if(row < this.rowBound.low) {
				row = this.rowBound.low;
			}
			if(row < this.rowStart) {
				scroller.scrollRow(row - this.rowStart);
				moved = true;
			} else if(!this.rowBound.high && row > this.rowEnd) {
				scroller.scrollRow(row - this.rowEnd);
				moved = true;
			}
			if(col < this.colBound.low) {
				col = this.colBound.low;
			}
			if(col < this.colStart) {
				scroller.scrollCol(col - this.colStart);
				moved = true;
			} else if(!this.colBound.high && col > this.colEnd) {
				scroller.scrollCol(col - this.colEnd);
				moved = true;
			}
			return moved;
		}
		return false;
	},
	removeAfterRow: function(minrow, maxrow, deleted) {
		var sheetId = this.getSheetId();
		if(this.isVisible() && minrow <= this.rowEnd) {
			if(this.rowStart < minrow) {
				minrow--;
			}
			var flag = minrow < this.rowStart,
				minr = minrow,
				maxr = maxrow;
			var span = maxrow - minrow + 1;
			if(minrow <= this.rowStart) {
				minrow = this.rowStart;
				maxrow = minrow + span - 1;
			} else {
				if(maxrow > this.rowEnd) {
					maxrow = this.rowEnd;
				}
			}
			if(minrow <= this.rowStart && maxrow >= this.rowEnd) {
				this.recalculateRange({
					rowStart: this.rowStart,
					height: this.getEl().getHeight()
				});
			} else {
				var s = this.getStore();
				var fn = function(rowIndex) {
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++) {
						if(minr <= i && i <= maxr) {
							if(!s.isVisibleRow(sheetId, i, deleted)) {
								k++;
							}
						} else if(!s.isVisibleRow(sheetId, i)) {
							k++;
						}
					}
					return rowIndex - this.rowStart - k;
				};
				var startIndex = fn.call(this, minrow),
					el = this.regionEl.dom;
				for(var i = startIndex, len = el.childNodes.length; i < len; i++) {
					Ext.removeNode(el.childNodes[startIndex]);
				}
				this.rowEnd = minrow - 1;
				var offset = this.regionEl.getHeight() - this.getEl().getHeight();
				if(0 > offset) {
					this.adjustRows(-offset);
				}
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	removeRow: function(minrow, maxrow, deleted) {
		var sheetId = this.getSheetId();
		if(this.isVisible() && minrow <= maxrow && minrow <= this.rowEnd) {
			var flag = minrow < this.rowStart,
				minr = minrow,
				maxr = maxrow;
			var span = maxrow - minrow + 1;
			if(minrow <= this.rowStart) {
				minrow = this.rowStart;
				maxrow = minrow + span - 1;
			} else {
				if(maxrow > this.rowEnd) {
					maxrow = this.rowEnd;
				}
			}
			if(minrow <= this.rowStart && maxrow >= this.rowEnd) {
				this.recalculateRange({
					rowStart: this.rowStart,
					height: this.getEl().getHeight()
				});
			} else {
				var s = this.getStore();
				var fn = function(rowIndex) {
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++) {
						if(minr <= i && i <= maxr) {
							if(!s.isVisibleRow(sheetId, i, deleted)) {
								k++;
							}
						} else if(!s.isVisibleRow(sheetId, i)) {
							k++;
						}
					}
					return rowIndex - this.rowStart - k;
				};
				var startIndex = fn.call(this, minrow),
					endIndex = fn.call(this, maxrow + 1),
					el = this.regionEl.dom;
				for(var i = startIndex; i < endIndex; i++) {
					Ext.removeNode(el.childNodes[startIndex]);
				}
				this.rowEnd -= (maxrow - minrow + 1);
				var offset = this.regionEl.getHeight() - this.getEl().getHeight();
				if(0 > offset) {
					this.adjustRows(-offset);
				}
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	onRemoveCell: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store) {
		if(sheetId == this.getSheetId()) {
			if("left" == moveDir) {
				this.removeAfterColumn(mincol, maxcol, deleted);
			} else {
				this.removeAfterRow(minrow, maxrow, deleted);
			}
		}
	},
	onCellRemoved: function(sheetId, minrow, maxrow, mincol, maxcol, moveDir, deleted, merged, store) {
		if(sheetId == this.getSheetId()) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift("cellremoved");
			args.push(this);
			this.fireEvent.apply(this, args);
		}
	},
	onRemoveRow: function(sheetId, minrow, maxrow, deleted, merged, store) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.removeAfterRow(minrow, maxrow, deleted);
		}
	},
	onRowRemoved: function(sheetId, minrow, maxrow, deleted, merged, store) {
		if(sheetId == this.getSheetId()) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift("rowremoved");
			args.push(this);
			this.fireEvent.apply(this, args);
		}
	},
	removeAfterColumn: function(mincol, maxcol, deleted) {
		var sheetId = this.getSheetId();
		if(this.isVisible() && mincol <= maxcol && mincol <= this.colEnd) {
			if(this.colStart < mincol) {
				mincol--;
			}
			var flag = mincol < this.colStart,
				minc = mincol,
				maxc = maxcol;
			var span = maxcol - mincol + 1;
			if(mincol <= this.colStart) {
				mincol = this.colStart;
				maxcol = mincol + span - 1;
			} else {
				if(maxcol > this.colEnd) {
					maxcol = this.colEnd;
				}
			}
			if(mincol <= this.colStart && maxcol >= this.colEnd) {
				this.recalculateRange(null, {
					colStart: this.colStart,
					width: this.getEl().getWidth()
				});
			} else {
				var s = this.getStore();
				var fn = function(colIndex) {
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++) {
						if(minc <= i && i <= maxc) {
							if(!s.isVisibleColumn(sheetId, i, deleted)) {
								k++;
							}
						} else if(!s.isVisibleColumn(sheetId, i)) {
							k++;
						}
					}
					return colIndex - this.colStart - k;
				};
				var startIndex = fn.call(this, mincol);
				var cw = 0,
					firstrow = this.regionEl.dom.firstChild;
				var len = firstrow.childNodes.length;
				for(var j = startIndex; j < len; j++) {
					var cellEl = Ext.get(firstrow.childNodes[j]);
					cw += cellEl.getWidth();
				}
				for(var i = this.rowStart; i <= this.rowEnd; i++) {
					if(s.isVisibleRow(sheetId, i)) {
						var rowel = this.getRowEl(i).dom;
						for(var j = startIndex; j < len; j++) {
							Ext.removeNode(rowel.childNodes[startIndex]);
						}
					}
				}
				this.colEnd = mincol - 1;
				var nw = this.currentWidth - cw;
				var less = nw - this.getEl().getWidth();
				if(0 <= less) {
					this.updateRegionElWidth(nw);
				} else {
					this.currentWidth = nw;
					this.adjustCols(-less);
				}
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	removeColumn: function(mincol, maxcol, deleted, merged) {
		var sheetId = this.getSheetId();
		if(this.isVisible() && mincol <= maxcol && mincol <= this.colEnd) {
			var flag = mincol < this.colStart,
				minc = mincol,
				maxc = maxcol;
			var span = maxcol - mincol + 1;
			if(mincol <= this.colStart) {
				mincol = this.colStart;
				maxcol = mincol + span - 1;
			} else {
				if(maxcol > this.colEnd) {
					maxcol = this.colEnd;
				}
			}
			if(mincol <= this.colStart && maxcol >= this.colEnd) {
				this.recalculateRange(null, {
					colStart: this.colStart,
					width: this.getEl().getWidth()
				});
			} else {
				var s = this.getStore();
				var fn = function(colIndex) {
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++) {
						if(minc <= i && i <= maxc) {
							if(!s.isVisibleColumn(sheetId, i, deleted)) {
								k++;
							}
						} else if(!s.isVisibleColumn(sheetId, i)) {
							k++;
						}
					}
					return colIndex - this.colStart - k;
				};
				var startIndex = fn.call(this, mincol),
					endIndex = fn.call(this, maxcol + 1);
				var cw = 0,
					firstrow = this.regionEl.dom.firstChild;
				var len = firstrow.childNodes.length;
				for(var j = startIndex; j < endIndex; j++) {
					var cellEl = Ext.get(firstrow.childNodes[j]);
					cw += cellEl.getWidth();
				}
				for(var i = this.rowStart; i <= this.rowEnd; i++) {
					if(s.isVisibleRow(sheetId, i)) {
						var rowel = this.getRowEl(i).dom;
						for(var j = startIndex; j < endIndex; j++) {
							Ext.removeNode(rowel.childNodes[startIndex]);
						}
					}
				}
				this.colEnd -= (maxcol - mincol + 1);
				var nw = this.currentWidth - cw;
				var less = nw - this.getEl().getWidth();
				if(0 <= less) {
					this.updateRegionElWidth(nw);
				} else {
					this.currentWidth = nw;
					this.adjustCols(-less);
				}
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	onRemoveColumn: function(sheetId, mincol, maxcol, deleted, merged, store) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.removeAfterColumn(mincol, maxcol, deleted);
		}
	},
	onColumnRemoved: function(sheetId, mincol, maxcol) {
		if(sheetId == this.getSheetId()) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift("columnremoved");
			args.push(this);
			this.fireEvent.apply(this, args);
		}
	},
	onInsertCell: function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store) {
		if(sheetId == this.getSheetId()) {
			if("right" == moveDir) {
				this.reinsertColumn(col, colSpan);
			} else {
				this.reinsertRow(row, rowSpan);
			}
		}
	},
	onCellInserted: function(sheetId, row, col, rowSpan, colSpan, moveDir, merged, store) {
		if(sheetId == this.getSheetId()) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift("cellinserted");
			args.push(this);
			this.fireEvent.apply(this, args);
		}
	},
	reinsertRow: function(row, span) {
		if(1 < row) {
			row--;
		}
		var sheetId = this.getSheetId();
		if(this.isVisible() && 0 < row && 0 < span && row <= this.rowEnd) {
			var flag = row < this.rowStart;
			if(row > this.rowStart) {
				var s = this.getStore();
				var fn = function(rowIndex) {
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++) {
						if(!s.isVisibleRow(sheetId, i)) {
							k++;
						}
					}
					return rowIndex - this.rowStart - k;
				};
				var startIndex = fn.call(this, row),
					el = this.regionEl.dom;
				for(var i = startIndex, len = el.childNodes.length; i < len; i++) {
					Ext.removeNode(el.childNodes[startIndex]);
				}
				this.rowEnd = row - 1;
				var offset = this.regionEl.getHeight() - this.getEl().getHeight();
				if(0 > offset) {
					this.adjustRows(-offset);
				}
			} else {
				this.recalculateRange({
					rowStart: this.rowStart,
					height: this.getEl().getHeight()
				});
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	insertRow: function(row, span) {
		var sheetId = this.getSheetId();
		if(this.isVisible() && 0 < row && 0 < span && row <= this.rowEnd) {
			var flag = row < this.rowStart,
				minrow = row,
				maxrow = row + span - 1;
			if(minrow <= this.rowStart && this.rowEnd <= maxrow) {
				this.recalculateRange({
					rowStart: this.rowStart,
					height: this.getEl().getHeight()
				});
			} else {
				var s = this.getStore();
				if(minrow < this.rowStart) {
					minrow = this.rowStart;
					maxrow = minrow + span - 1;
				}
				var height = s.getRangeHeight(sheetId, this.rowStart, minrow - 1, undefined, true);
				height = this.getEl().getHeight() - height;
				var h = 0,
					rows = [],
					i, columnVisible = [];
				for(var j = this.colStart; j <= this.colEnd; j++) {
					columnVisible.push(s.isVisibleColumn(sheetId, j));
				}
				for(i = minrow; i <= maxrow && h <= height; i++) {
					var rh = s.getRowHeight(sheetId, i, true, true);
					if(0 != rh) {
						h += rh;
						var cells = [];
						for(var j = this.colStart; j <= this.colEnd; j++) {
							if(columnVisible[j - this.colStart]) {
								cells.push(this.getData(i, j));
							}
						}
						var o = this.getData(i, 0);
						o.cells = cells;
						rows.push(o);
					}
				}
				var html = this.regionTpl.apply(rows);
				var fn = function(rowIndex) {
					var k = 0;
					for(var i = this.rowStart; i < rowIndex; i++) {
						if(!s.isVisibleRow(sheetId, i)) {
							k++;
						}
					}
					return rowIndex - this.rowStart - k;
				};
				var startIndex = fn.call(this, minrow),
					el = this.regionEl.dom;
				if(i <= maxrow) {
					var rowEnd = i - 1;
					for(i = startIndex, len = el.childNodes.length; i < len; i++) {
						Ext.removeNode(el.childNodes[startIndex]);
					}
					Ext.core.DomHelper.append(el, html);
					this.rowEnd = rowEnd;
				} else {
					el = el.childNodes[startIndex];
					Ext.core.DomHelper.insertBefore(el, html);
					this.rowEnd += span;
				}
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	onInsertRow: function(sheetId, row, span) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.reinsertRow(row, span);
		}
	},
	onRowInserted: function(sheetId, row, span) {
		if(sheetId == this.getSheetId()) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift("rowinserted");
			args.push(this);
			this.fireEvent.apply(this, args);
		}
	},
	reinsertColumn: function(col, span) {
		if(1 < col) {
			col--;
		}
		var sheetId = this.getSheetId();
		if(this.isVisible() && 0 < col && 0 < span && col <= this.colEnd) {
			var flag = col < this.colStart;
			if(col > this.colStart) {
				var s = this.getStore();
				var fn = function(colIndex) {
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++) {
						if(!s.isVisibleColumn(sheetId, i)) {
							k++;
						}
					}
					return colIndex - this.colStart - k;
				};
				var startIndex = fn.call(this, col),
					el = this.regionEl.dom,
					firstrow = el.firstChild;
				var cw = 0,
					len = firstrow.childNodes.length;
				for(var j = startIndex; j < len; j++) {
					cw += Ext.get(firstrow.childNodes[j]).getWidth();
				}
				for(var i = this.rowStart; i <= this.rowEnd; i++) {
					if(s.isVisibleRow(sheetId, i)) {
						var rowEl = this.getRowEl(i);
						for(var j = startIndex; j < len; j++) {
							Ext.removeNode(rowEl.dom.childNodes[startIndex]);
						}
					}
				}
				this.colEnd = col - 1;
				var nw = this.currentWidth - cw;
				var less = nw - this.getEl().getWidth();
				if(0 <= less) {
					this.updateRegionElWidth(nw);
				} else {
					this.currentWidth = nw;
					this.adjustCols(-less);
				}
			} else {
				this.recalculateRange(null, {
					colStart: this.colStart,
					width: this.getEl().getWidth()
				});
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	insertColumn: function(col, span) {
		var sheetId = this.getSheetId();
		if(this.isVisible() && 0 < col && 0 < span && col <= this.colEnd) {
			var flag = col < this.colStart,
				mincol = col,
				maxcol = col + span - 1;
			if(mincol <= this.colStart && this.colEnd <= maxcol) {
				this.recalculateRange(null, {
					colStart: this.colStart,
					width: this.getEl().getWidth()
				});
			} else {
				var s = this.getStore();
				if(mincol < this.colStart) {
					mincol = this.colStart;
					maxcol = mincol + span - 1;
				}
				var width = s.getRangeWidth(sheetId, this.colStart, mincol - 1, undefined, true);
				width = this.getEl().getWidth() - width;
				var w = 0,
					rows = [],
					j;
				for(j = mincol; j <= maxcol && w <= width; j++) {
					w += s.getColWidth(sheetId, j, true, true);
				}
				var notEnough = j <= maxcol;
				maxcol = j - 1;
				var columnVisible = [],
					rowVisible = [];
				for(var i = this.rowStart; i <= this.rowEnd; i++) {
					rowVisible.push(s.isVisibleRow(sheetId, i));
				}
				for(j = mincol; j <= maxcol; j++) {
					columnVisible.push(s.isVisibleColumn(sheetId, j));
				}
				for(var i = this.rowStart; i <= this.rowEnd; i++) {
					if(rowVisible[i - this.rowStart]) {
						var cells = [];
						for(j = mincol; j <= maxcol; j++) {
							if(columnVisible[j - mincol]) {
								cells.push(this.getData(i, j));
							}
						}
						rows.push(cells);
					}
				}
				var fn = function(colIndex) {
					var k = 0;
					for(var i = this.colStart; i < colIndex; i++) {
						if(!s.isVisibleColumn(sheetId, i)) {
							k++;
						}
					}
					return colIndex - this.colStart - k;
				};
				if(notEnough) {
					var startIndex = fn.call(this, mincol),
						el = this.regionEl.dom;
					for(var k = 0, i = this.rowStart; i <= this.rowEnd; i++) {
						var index = i - this.rowStart;
						if(rowVisible[index]) {
							var rowel = this.getRowEl(i).dom;
							for(j = startIndex, len = rowel.childNodes.length; j < len; j++) {
								Ext.removeNode(rowel.childNodes[startIndex]);
							}
							var html = this.rowTpl.apply(rows[k++]);
							Ext.core.DomHelper.append(rowel, html);
						}
					}
					this.colEnd = maxcol;
				} else {
					var startIndex = fn.call(this, mincol);
					for(var k = 0, i = this.rowStart; i <= this.rowEnd; i++) {
						var index = i - this.rowStart;
						if(rowVisible[index]) {
							var rowEl = this.getRowEl(i);
							var el = rowEl.dom.childNodes[startIndex];
							var html = this.rowTpl.apply(rows[k++]);
							Ext.core.DomHelper.insertBefore(el, html);
						}
					}
					this.colEnd += span;
				}
				width = s.getRangeWidth(sheetId, this.colStart, this.colEnd, undefined, true);
				this.updateRegionElWidth(width);
			}
			if(flag) {
				this.sysn();
			}
		}
	},
	onInsertColumn: function(sheetId, col, span, merged, store) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.reinsertColumn(col, span);
		}
	},
	onColumnInserted: function(sheetId, col, span, merged, store) {
		if(sheetId == this.getSheetId()) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift("columninserted");
			args.push(this);
			this.fireEvent.apply(this, args);
		}
	},
	onHideRow: function(sheetId, minrow, maxrow, store) {
		if(sheetId == this.getSheetId()) {
			if(this.isVisible()) {
				if(false !== this.fireEvent("beforehiderow", minrow, maxrow, this)) {
					if(this.isRowOverlap(minrow, maxrow)) {
						this.recalculateRange({
							rowStart: this.rowStart,
							height: this.getEl().getHeight()
						});
					}
					if(minrow < this.rowStart) {
						this.sysn();
					}
					this.fireEvent("hiderow", minrow, maxrow, this);
				}
			}
		}
	},
	onHideColumn: function(sheetId, mincol, maxcol, store) {
		if(sheetId == this.getSheetId()) {
			if(this.isVisible()) {
				if(false !== this.fireEvent("beforehidecolumn", mincol, maxcol, this)) {
					if(this.isColumnOverlap(mincol, maxcol)) {
						this.recalculateRange(null, {
							colStart: this.colStart,
							width: this.getEl().getWidth()
						});
					}
					if(mincol < this.colStart) {
						this.sysn();
					}
					this.fireEvent("hidecolumn", mincol, maxcol, this);
				}
			}
		}
	},
	onShowRow: function(sheetId, minrow, maxrow, store) {
		if(sheetId == this.getSheetId()) {
			if(this.isVisible()) {
				if(false !== this.fireEvent("beforeshowrow", minrow, maxrow, this)) {
					if(this.isRowOverlap(minrow, maxrow)) {
						this.recalculateRange({
							rowStart: this.rowStart,
							height: this.getEl().getHeight()
						});
					}
					if(minrow < this.rowStart) {
						this.sysn();
					}
					this.fireEvent("showrow", minrow, maxrow, this);
				}
			}
		}
	},
	onShowColumn: function(sheetId, mincol, maxcol, store) {
		if(sheetId == this.getSheetId()) {
			if(this.isVisible()) {
				if(false !== this.fireEvent("beforeshowcolumn", mincol, maxcol, this)) {
					if(this.isColumnOverlap(mincol, maxcol)) {
						this.recalculateRange(null, {
							colStart: this.colStart,
							width: this.getEl().getWidth()
						});
					}
					if(mincol < this.colStart) {
						this.sysn();
					}
					this.fireEvent("showcolumn", mincol, maxcol, this);
				}
			}
		}
	},
	go2LeftTop: function() {
		if(this.isVisible()) {
			var scroller = this.getScroller();
			if(scroller) {
				var offset = this.rowBound.low - this.rowStart;
				scroller.scrollRow(offset);
				offset = this.colBound.low - this.colStart;
				scroller.scrollCol(offset);
			}
		}
	},
	go2Left: function() {
		if(this.isVisible()) {
			var scroller = this.getScroller();
			if(scroller) {
				var offset = this.colBound.low - this.colStart;
				scroller.scrollCol(offset);
			}
		}
	},
	go2Top: function() {
		if(this.isVisible()) {
			var scroller = this.getScroller();
			if(scroller) {
				var offset = this.rowBound.low - this.rowStart;
				scroller.scrollRow(offset);
			}
		}
	},
	guessMaxWidthCells: function(sheetId, col) {
		var store = this.getStore();
		var row, dp = store.defaultProperty,
			set = {};
		store.each(function(rd) {
			var json = rd.data.json;
			if(sheetId == rd.data.sheet && col == rd.data.col && 0 != rd.data.row && !store.isMergedCell(json, sheetId, rd.data.row, col)) {
				var obj = this.getData(rd.data.row, col, true, undefined, true);
				delete obj.width;
				if(this instanceof EnterpriseSheet.sheet.regions.Header || this instanceof EnterpriseSheet.sheet.regions.Lefter) {
					obj = SFORMAT.transferFormat(obj, obj.fm, {
						sheet: sheetId,
						row: rd.data.row,
						col: col
					});
				}
				var data = SCOM.nullOrUndefined(obj.value) ? obj.data : obj.value;
				if(!SCOM.nullOrUndefined(data) && "" !== data) {
					var ff = obj.ff;
					var ws = obj.ws;
					var fz = obj.fz;
					var fw = obj.fw;
					var id = [ff, ws, fz, fw].join("$");
					set[id] = set[id] || {};
					if(set[id].cell) {
						set[id].cell.data += "<br>" + data;
					} else {
						obj.data = data;
						set[id].cell = obj;
					}
				}
			}
		}, this);
		var arr = [];
		for(var p in set) {
			arr.push(set[p].cell);
		}
		if(0 < arr.length) {
			return arr;
		}
	},
	guessMaxColumnWidth: function(sheetId, col) {
		var len = 0,
			text, row;
		var store = this.getStore();
		var rowTpl = this.rowTpl;
		var arr = this.guessMaxWidthCells(sheetId, col);
		if(arr) {
			var w = maxw = 0;
			var measureEl = Ext.core.DomHelper.append(document.body, "<div class=\"ss-guess-measure\"></div>", true);
			var htmls = [];
			for(var i = 0, len = arr.length; i < len; i++) {
				htmls.push(this.prepare2Measure(arr[i]));
			}
			var el = rowTpl.overwrite(measureEl, htmls, true);
			w = el.getWidth();
			if(maxw < w) {
				maxw = w;
			}
			measureEl.remove();
			return maxw;
		}
	},
	guessMaxHeightCells: function(sheetId, row) {
		var store = this.getStore();
		var col, dp = this.defaultProperty,
			set = {};
		store.each(function(rd) {
			var json = rd.data.json;
			if(sheetId == rd.data.sheet && row == rd.data.row && 0 != rd.data.col && !store.isMergedCell(json, sheetId, row, rd.data.col)) {
				var obj = this.getData(row, rd.data.col, true, undefined, true, true);
				if(Ext.isString(obj.data)) {
					obj.data = obj.data.replace(/\n/gi, "<br/>");
				}
				var data = obj.data;
				if(!SCOM.nullOrUndefined(data) && "" !== data) {
					var ff = obj.ff;
					var ws = obj.ws;
					var fz = obj.fz;
					var fw = obj.fw;
					var width = obj.width;
					var id = [ff, ws, fz, fw, width].join("$");
					var slong = data.toString().length;
					if(!set[id]) {
						set[id] = {
							len: slong,
							cell: obj
						};
					}
					if(set[id].len < slong) {
						set[id].len = slong;
						set[id].cell = obj;
					}
				}
			}
		}, this);
		var arr = [];
		for(var p in set) {
			if(set[p].cell) {
				arr.push(set[p].cell);
			}
		}
		if(0 < arr.length) {
			return arr;
		}
	},
	guessMaxRowHeight: function(sheetId, row) {
		var len = 0,
			text, col;
		var store = this.getStore();
		var guessHeightTpl = SLAYOUT.guessHeightTpl;
		var arr = this.guessMaxHeightCells(sheetId, row);
		if(arr) {
			var h = maxh = 0;
			var measureEl = Ext.core.DomHelper.append(document.body, "<div class=\"ss-guess-measure\"></div>", true);
			var htmls = [];
			for(var i = 0, len = arr.length; i < len; i++) {
				htmls.push(this.prepare2Measure(arr[i], "height"));
			}
			var el = guessHeightTpl.overwrite(measureEl, htmls, true);
			h = el.getHeight();
			if(maxh < h) {
				maxh = h;
			}
			measureEl.remove();
			var dh = store.defaultProperty.height;
			maxh--;
			if(maxh < dh) {
				maxh = dh;
			}
			return maxh;
		}
	},
	guessCellWidth: function(sheetId, row, col, cell, ignoreOld) {
		var store = this.getStore(),
			w = 0;
		if(!cell) {
			cell = store.getCellData(sheetId, row, col);
			cell.data = Ext.htmlEncode(cell.dta);
		}
		if(cell.data && 0 < cell.data.length) {
			var cTpl = this.cellTpl;
			var measureEl = Ext.core.DomHelper.append(document.body, "<div class=\"ss-guess-measure\"></div>", true);
			cell = this.prepare2Measure(cell);
			var el = cTpl.overwrite(measureEl, cell, true);
			w = el.getWidth();
			measureEl.remove();
		}
		if(!ignoreOld) {
			var cw = cell.w || store.getColWidth(sheetId, col, true, true);
			if(w < cw) {
				w = cw;
			}
		}
		return w;
	},
	guessCellHeight: function(sheetId, row, col, cell, ignoreOld) {
		var store = this.getStore(),
			h = 0;
		if(!cell) {
			cell = store.getCellData(sheetId, row, col);
			cell.data = Ext.htmlEncode(cell.dta);
		}
		if(cell.data && 0 < cell.data.length) {
			var cTpl = this.cellTpl;
			var measureEl = Ext.core.DomHelper.append(document.body, "<div class=\"ss-guess-measure\"></div>", true);
			cell = this.prepare2Measure(cell, "height");
			var el = cTpl.overwrite(measureEl, cell, true);
			h = el.getHeight();
			measureEl.remove();
		}
		if(!ignoreOld) {
			var ch = cell.h || store.getRowHeight(sheetId, row, true, true);
			if(h < ch) {
				h = ch;
			}
		}
		var dh = store.defaultProperty.height + store.cellHeightOffset;
		if(h < dh) {
			h = dh;
		}
		return h;
	},
	prepare2Measure: function(cell, flag) {
		if("height" != flag) {
			flag = "width";
		}
		if("width" == flag) {
			cell.width = "auto";
			cell.height = cell.h || cell.height || cell.autoHeight;
			cell.height += "px";
		} else {
			cell.height = "auto";
			cell.width = cell.w || cell.width;
			cell.width += "px";
		}
		cell.incell = false;
		cell.wrap = false;
		cell.va = "top";
		return cell;
	},
	scrollCell2View: function(row, col) {
		var store = this.getStore();
		var sheetId = this.getSheetId();
		var cellEl = null,
			el = this.getEl();
		var scroller = this.getScroller();
		if(scroller) {
			if(this.isInRange(row, col)) {
				cellEl = this.getCellEl(row, col);
				if(cellEl) {
					var xoff = cellEl.getRight() - el.getRight() + scroller.getScrollerLength("col");
					if(0 < xoff && this.colStart != col) {
						var w = 0,
							i, fc = false;
						for(i = this.colStart; i < col; i++) {
							if(store.isVisibleColumn(sheetId, i)) {
								if(false === fc) {
									fc = i;
								}
								w += store.getColWidth(sheetId, i, true, true);
								if(w >= xoff) {
									break;
								}
							}
						}
						fc = fc || this.colStart;
						var offset = i - fc + 1;
						scroller.scrollCol(offset);
					}
					var yoff = cellEl.getBottom() - el.getBottom() + scroller.getScrollerLength("row");
					if(0 < yoff && this.rowStart != row) {
						var h = 0,
							i, fr = false;
						for(i = this.rowStart; i < row; i++) {
							if(store.isVisibleRow(sheetId, i)) {
								if(false === fr) {
									fr = i;
								}
								h += store.getRowHeight(sheetId, i, true, true);
								if(h >= yoff) {
									break;
								}
							}
						}
						fr = fr || this.rowStart;
						var offset = i - fr + 1;
						scroller.scrollRow(offset);
					}
				}
			} else {
				var xoff, yoff;
				if(row < this.rowStart) {
					yoff = row - this.rowStart;
					scroller.scrollRow(yoff);
				} else if(row > this.rowEnd) {
					yoff = row - this.rowStart;
					scroller.scrollRow(yoff);
				}
				if(col < this.colStart) {
					xoff = col - this.colStart;
					scroller.scrollCol(xoff);
				} else if(col > this.colEnd) {
					xoff = col - this.colStart;
					scroller.scrollCol(xoff);
				}
			}
		}
		return cellEl;
	},
	lockIfctEl: function() {
		if(this.ifctEl) {
			this.ifScrollLeft = this.ifctEl.dom.scrollLeft;
			this.ifScrollTop = this.ifctEl.dom.scrollTop;
			if(!this.ifLocked) {
				this.ifLocked = true;
				this.ifctEl.on("scroll", this.blockIfScroll, this);
			}
		}
	},
	blockIfScroll: function(e) {
		e.stopEvent();
		this.ifctEl.dom.scrollLeft = this.ifScrollLeft;
		this.ifctEl.dom.scrollTop = this.ifScrollTop;
	},
	unlockIfctEl: function() {
		if(this.ifctEl) {
			delete this.ifScrollLeft;
			delete this.ifScrollTop;
			delete this.ifLocked;
			this.ifctEl.un("scroll", this.blockIfScroll, this);
		}
	},
	switchTrackMouseOver: function(flag) {
		if(false == SCOM.typeOf(this.lstTrackMouseOver)) {
			this.lstTrackMouseOver = this.trackMouseOver;
		}
		this.trackMouseOver = flag;
	},
	resumeTrackMouseOver: function() {
		this.trackMouseOver = this.lstTrackMouseOver;
		delete this.lstTrackMouseOver;
	},
	enableSelect: function() {
		var sm = this.getSelectionModel();
		sm.enableSelect();
	},
	disableSelect: function() {
		var sm = this.getSelectionModel();
		sm.disableSelect();
	},
	getReferenceModel: function() {
		return this.rm;
	},
	enableRefer: function(clear, single, simple) {
		var rm = this.getReferenceModel();
		rm.enableSelect.apply(rm, arguments);
	},
	disableRefer: function(clear, single, simple) {
		var rm = this.getReferenceModel();
		rm.disableSelect.apply(rm, arguments);
	},
	getRangeSpan: function() {
		if(this.isVisible()) {
			return {
				visible: true,
				range: {
					rowStart: this.rowStart,
					rowEnd: this.rowEnd,
					colStart: this.colStart,
					colEnd: this.colEnd
				},
				rowBound: Ext.apply({}, this.rowBound),
				colBound: Ext.apply({}, this.colBound)
			};
		} else {
			return {
				visible: false
			};
		}
	},
	getDefaultRangeSpan: function() {
		var span = {
			visible: true
		};
		span.range = this.initSpan(true);
		Ext.apply(span, this.initBound(true));
		return span;
	},
	setRangeSpan: function(span) {
		if(span) {
			var oldRowSpan = this.rowEnd - this.rowStart + 1;
			var oldColSpan = this.colEnd - this.colStart + 1;
			Ext.apply(this, span.range);
			if(SCOM.nullOrUndefined(this.rowEnd)) {
				this.rowEnd = this.rowStart + oldRowSpan - 1;
			}
			if(SCOM.nullOrUndefined(this.colEnd)) {
				this.colEnd = this.colStart + oldColSpan - 1;
			}
			if(true === span.visible) {
				this.show();
				this.rowBound = Ext.apply({}, span.rowBound);
				this.colBound = Ext.apply({}, span.colBound);
			} else if(false === span.visible) {
				this.hide();
			}
		}
	},
	show: function() {
		this._skipProcessResize = true;
		this.callParent(arguments);
		this._skipProcessResize = false;
	},
	hide: function() {
		this._skipProcessResize = true;
		this.callParent(arguments);
		this._skipProcessResize = false;
	},
	getSheetId: function() {
		return this.sheetId;
	},
	setSheetId: function(sheetId) {
		this.sheetId = sheetId;
	},
	render2RegionBody: function(comp) {
		comp.bindRegion = this;
		comp.render(this.ifbodyEl);
	},
	isAutofillPress: function() {
		return this.autofillpressed;
	},
	destroy: function() {
		if(Ext.isFunction(this.purgeListeners)) {
			this.purgeListeners();
		}
	},
	getIfPosOfCenter: function() {
		var scrollLeft = this.ifctEl.dom.scrollLeft,
			scrollTop = this.ifctEl.dom.scrollTop;
		var width = this.ifctEl.getWidth(),
			height = this.ifctEl.getHeight();
		return {
			x: scrollLeft + Math.floor(width / 2),
			y: scrollTop + Math.floor(height / 2)
		};
	},
	setReadOnly: function(readOnly) {
		this.readOnly = readOnly;
	},
	isReadOnly: function() {
		return this.readOnly;
	},
	getVisibleCoord: function() {
		var el = this.regionEl.dom,
			rowDom = el.firstChild,
			rowIndexs = [],
			sheetId = this.getSheetId();
		var start = false,
			end;
		for(var i = 0, len = el.childNodes.length; i < len; i++) {
			var child = el.childNodes[i].firstChild,
				ri = Number(child.getAttribute("data-ri"));
			if(false === start) {
				start = ri;
				end = start;
			} else if(end + 1 == ri) {
				end = ri;
			} else {
				rowIndexs.push([start, end]);
				start = end = ri;
			}
		}
		if(false !== start) {
			rowIndexs.push([start, end]);
		}
		var colIndexs = [];
		start = false;
		if(rowDom) {
			for(var i = 0, len = rowDom.childNodes.length; i < len; i++) {
				var child = rowDom.childNodes[i],
					ci = Number(child.getAttribute("data-ci"));
				if(false === start) {
					start = ci;
					end = start;
				} else if(end + 1 == ci) {
					end = ci;
				} else {
					colIndexs.push([start, end]);
					start = end = ci;
				}
			}
		}
		if(false !== start) {
			colIndexs.push([start, end]);
		}
		var coord = [];
		for(var i = 0, len = rowIndexs.length; i < len; i++) {
			var r = rowIndexs[i];
			for(var j = 0, size = colIndexs.length; j < size; j++) {
				var c = colIndexs[j];
				var span = [sheetId, r[0], c[0], r[1], c[1]];
				coord.push(span);
			}
		}
		return coord;
	},
	addPageBreakLine: function(row, col) {
		var ifbody = this.ifbodyEl;
		if(ifbody) {
			var store = this.getStore(),
				sheetId = this.getSheetId();
			if(this.rowBound.low <= row && (false === this.rowBound.high || row <= this.rowBound.high)) {
				var h = store.getRangeHeight(sheetId, 1, row, false, true);
				Ext.DomHelper.append(ifbody.dom, "<div class=\"ss-pb-line ss-pb-xline\" style=\"width:" + SCONST.MAX_LENGTH + "px;top:" + h + "px;z-index:" + SCONST.PB_Z_INDEX + ";\"></div>");
			}
			if(this.colBound.low <= col && (false === this.colBound.high || col <= this.colBound.high)) {
				var w = store.getRangeWidth(sheetId, 1, col, false, true);
				Ext.DomHelper.append(ifbody.dom, "<div class=\"ss-pb-line ss-pb-yline\" style=\"height:" + SCONST.MAX_LENGTH + "px;left:" + w + "px;z-index:" + SCONST.PB_Z_INDEX + ";\"></div>");
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.regions.Corner", {
	extend: "Ext.Component",
	cls: "ss-corner",
	referDisabled: true,
	initComponent: function() {
		this.callParent();
	},
	afterRender: function() {
		var store = this.store;
		var height = store.zoomSize(store.headerCellHeight, true) - store.cellHeightOffset;
		this.el.update("<div class=\"ss-cell\" style=\"height:" + height + "px;\"></div>");
		this.callParent();
		this.mon(this.el, "click", this.onClick, this);
	},
	refresh: function() {
		var store = this.store;
		var height = store.zoomSize(store.headerCellHeight, true);
		var width = store.zoomSize(store.getColWidth(store.getActivedSheetId(), 0), true);
		this.el.setWidth(width);
		this.el.setHeight(height);
		height -= store.cellHeightOffset;
		this.el.update("<div class=\"ss-cell\" style=\"height:" + height + "px;\"></div>");
	},
	onClick: function() {
		if(!this.selectDisabled) {
			this.fireEvent("selectionchange", {
				row: 0,
				col: 0
			}, {
				row: 0,
				col: 0
			}, this);
			this.fireEvent("cellmouseup", this, {});
		}
		if(!this.referDisabled) {
			this.fireEvent("referencechange", this, this);
		}
	},
	onSelectWholeSheet: function(flag) {
		if(flag) {
			this.addCls("ss-select-sheet");
		} else {
			this.removeCls("ss-select-sheet");
		}
	},
	enableSelect: function() {
		delete this.selectDisabled;
	},
	disableSelect: function() {
		this.selectDisabled = true;
	},
	enableRefer: function(clear, single, simple) {
		delete this.referDisabled;
	},
	disableRefer: function(clear, single, simple) {
		this.referDisabled = true;
	},
	getReference: function() {
		return [
			[this.getSheetId(), 0, 0, 0, 0]
		];
	},
	getSheetId: function() {
		return this.sheetId;
	},
	setSheetId: function(sheetId) {
		this.sheetId = sheetId;
	},
	setReadOnly: function(readOnly) {
		this.readOnly = readOnly;
	},
	isReadOnly: function() {
		return this.readOnly;
	}
});

Ext.define("EnterpriseSheet.sheet.regions.Header", {
	extend: "EnterpriseSheet.sheet.regions.Region",
	cls: "ss-header",
	skipCanvas: true,
	disableReferenceModel: true,
	defaultReferenceModel: "ColumnReferenceModel",
	defaultSelectionModel: "ColumnSelectionModel",
	trackMouseOver: true,
	skipZIndex: true,
	resizerConfig: {
		rtype: "ColumnResizer"
	},
	initSpan: function(noApply) {
		var defaultSpan = {
			rowStart: 0,
			rowEnd: 0,
			colStart: 1,
			colEnd: 0,
			fixedRowForResize: true
		};
		if(!noApply) {
			Ext.applyIf(this, defaultSpan);
		}
		return defaultSpan;
	},
	initBound: function(noApply) {
		var defaultRowBound = {
			low: 0,
			min: 0,
			high: true
		};
		var defaultColBound = {
			low: 1,
			min: 1,
			high: false
		};
		if(!noApply) {
			this.rowBound = Ext.apply(this.rowBound || {}, defaultRowBound);
			this.colBound = Ext.apply(this.colBound || {}, defaultColBound);
		}
		return {
			rowBound: defaultRowBound,
			colBound: defaultColBound
		};
	},
	onRemoveColumn: function(sheetId, mincol, maxcol, deleted, merged, store) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.removeAfterColumn(mincol, maxcol, deleted);
		}
	},
	onInsertColumn: function(sheetId, col, span, merged, store) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.reinsertColumn(col, span);
		}
	},
	getData: function(row, col, suspendEvent, timestamp) {
		var store = this.getStore();
		var cell = this.callParent(arguments);
		if(0 === row) {
			if(cell.hideTitle) {
				delete cell.data;
			} else if(Ext.isDefined(cell.ticon)) {
				var src = SCONFIG.TITLE_ICONS_PATH + "/" + cell.ticon + ".png";
				cell.data = "<span style=\"padding-left:20px;background-image:url(" + src + ");background-repeat:no-repeat;\">" + cell.data + "</span>";
			}
			cell.fz = store.zoomSize(store.defaultFontSize, true);
		}
		return cell;
	}
});

Ext.define("EnterpriseSheet.sheet.regions.Lefter", {
	extend: "EnterpriseSheet.sheet.regions.Region",
	cls: "ss-lefter",
	skipCanvas: true,
	disableReferenceModel: true,
	trackMouseOver: true,
	skipZIndex: true,
	resizerConfig: {
		rtype: "RowResizer"
	},
	defaultReferenceModel: "RowReferenceModel",
	defaultSelectionModel: "RowSelectionModel",
	initSpan: function(noApply) {
		var defaultSpan = {
			rowStart: 1,
			rowEnd: 0,
			colStart: 0,
			colEnd: 0,
			fixedColForResize: true
		};
		if(!noApply) {
			Ext.applyIf(this, defaultSpan);
		}
		return defaultSpan;
	},
	initBound: function(noApply) {
		var defaultRowBound = {
			low: 1,
			min: 1,
			high: false
		};
		var defaultColBound = {
			low: 0,
			min: 0,
			high: true
		};
		if(!noApply) {
			this.rowBound = Ext.apply(this.rowBound || {}, defaultRowBound);
			this.colBound = Ext.apply(this.colBound || {}, defaultColBound);
		}
		return {
			rowBound: defaultRowBound,
			colBound: defaultColBound
		};
	},
	onRemoveRow: function(sheetId, minrow, maxrow, deleted, merged, store) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.removeAfterRow(minrow, maxrow, deleted);
		}
	},
	onInsertRow: function(sheetId, row, span, merged, store) {
		if(sheetId == this.getSheetId() && this.isVisible()) {
			this.reinsertRow(row, span);
		}
	},
	getData: function(row, col, suspendEvent, timestamp) {
		var store = this.getStore();
		var cell = this.callParent(arguments);
		if(0 === col) {
			cell.fz = store.zoomSize(store.defaultFontSize, true);
		}
		return cell;
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.options.CellTemplateOption", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.sheet.menu.CellStyleMenu"],
	optionPaneWidth: 500,
	scrollOffset: 18,
	layout: "fit",
	initComponent: function() {
		var preferStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var modelStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var titleStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var subjectStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var numberStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.CellTplModel"
		});
		var tpl = new Ext.XTemplate("<tpl for=\".\">", "<div class=\"thumb-wrap\">", "<div class=\"thumb cell-style\" style=\"{style}\">{text}</div>", "</div>", "</tpl>", "<div class=\"x-clear\"></div>");
		for(var i = 0, len = CELLTPL_DATA.length; i < len; i++) {
			var it = CELLTPL_DATA[i];
			if("prefer" == it.type) {
				var r = preferStore.createModel(it);
				preferStore.add(r);
			} else if("model" == it.type) {
				var r = modelStore.createModel(it);
				modelStore.add(r);
			} else if("title" == it.type) {
				var r = titleStore.createModel(it);
				titleStore.add(r);
			} else if("subject" == it.type) {
				var r = subjectStore.createModel(it);
				subjectStore.add(r);
			} else if("number" == it.type) {
				var r = numberStore.createModel(it);
				numberStore.add(r);
			}
		}
		this.preferView = new Ext.view.View({
			cls: "images-view",
			store: preferStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.modelView = new Ext.view.View({
			cls: "images-view",
			store: modelStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.titleView = new Ext.view.View({
			cls: "images-view",
			store: titleStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.subjectView = new Ext.view.View({
			cls: "images-view",
			store: subjectStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.numberView = new Ext.view.View({
			cls: "images-view",
			store: numberStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.items = [{
			xtype: "container",
			style: "background:rgb(250,250,250);",
			autoScroll: true,
			items: [{
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.bad_good_ok
			}, this.preferView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.data_modal
			}, this.modelView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.title
			}, this.titleView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.subject_text
			}, this.subjectView, {
				xtype: "box",
				cls: "tpl-title",
				html: SLANG.number_format
			}, this.numberView],
			listeners: {
				afterrender: function(ct) {
					var el = ct.getEl();
					var me = this;
					me.mon(el, "mousewheel", function(e) {
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta * me.scrollOffset;
					});
				},
				scope: this
			}
		}];
		this.callParent();
		this.mon(this.preferView, "itemclick", this._onClickItem, this);
		this.mon(this.modelView, "itemclick", this._onClickItem, this);
		this.mon(this.titleView, "itemclick", this._onClickItem, this);
		this.mon(this.subjectView, "itemclick", this._onClickItem, this);
		this.mon(this.numberView, "itemclick", this._onClickItem, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	_onClickItem: function(dv, rec) {
		var property = rec.data.property,
			fn = rec.data.fn;
		if(property || fn) {
			this.setPropertyForSelection(property, fn);
		}
		this.fireEvent("done", this);
	},
	setPropertyForSelection: function(property, fn) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var sm = sheet.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		if(false !== sheet.fireEvent("beforeborderchange", range, sheet)) {
			sheet.fireEvent("prepareborderchange", range, sheet);
			var dp = {
				bgc: "",
				fz: "",
				fw: "",
				fs: "",
				color: ""
			};
			property = Ext.apply(dp, property);
			sheet.setPropertyForSelection(property, null, true, true);
			if(fn) {
				fn(sheet);
			}
			range.refresh();
			sheet.fireEvent("borderchange", range, sheet);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.options.ChartOption", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.sheet.action.ActionBox"],
	style: "padding:10px 25px;",
	initComponent: function() {
		this.defaults = {
			xtype: "button"
		};
		this.items = [{
			xtype: "component",
			html: "<div class=\"sc-set-title\">" + SLANG.charts + "</div>"
		}, SABOX.get("insertColumnChart", {
			minWidth: 60,
			iconCls: "icon-column-chart32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: SLANG.column,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertAreaChart", {
			minWidth: 60,
			iconCls: "icon-area-chart32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: Ext.isIE ? "&nbsp;" + SLANG.area + "&nbsp;" : SLANG.area,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertPieChart", {
			minWidth: 60,
			iconCls: "icon-pie-chart32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: Ext.isIE ? "&nbsp;&nbsp;&nbsp;" + SLANG.pie + "&nbsp;&nbsp;&nbsp;" : SLANG.pie,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertLineChart", {
			minWidth: 60,
			iconCls: "icon-line-chart32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: Ext.isIE ? "&nbsp;" + SLANG.line + "&nbsp;" : SLANG.line,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertBarChart", {
			minWidth: 60,
			iconCls: "icon-bar-chart32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: Ext.isIE ? "&nbsp;&nbsp;&nbsp;" + SLANG.bar + "&nbsp;&nbsp;&nbsp;" : SLANG.bar,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertScatterChart", {
			minWidth: 60,
			iconCls: "icon-scatter-chart32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: SLANG.scatter,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertRadarChart", {
			minWidth: 60,
			iconCls: "icon-radar-chart32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: SLANG.radar,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), {
			xtype: "component",
			style: "margin-top:20px;",
			html: "<div class=\"sc-set-title\">" + SLANG.mini_charts + "</div>"
		}, SABOX.get("insertColumnMiniChart", {
			minWidth: 60,
			iconCls: "icon-mini-column32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: SLANG.column,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertGainLossMiniChart", {
			minWidth: 60,
			iconCls: "icon-mini-gainloss32",
			ui: "default-toolbar",
			scale: "large",
			iconAlign: "top",
			text: SLANG.gain_loss,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		}), SABOX.get("insertLineMiniChart", {
			minWidth: 60,
			iconCls: "icon-mini-line32",
			ui: "default-toolbar",
			hidden: !Ext.supports.Svg,
			scale: "large",
			iconAlign: "top",
			text: SLANG.line,
			style: "margin-left:10px;margin-top:10px;",
			sender: this
		})];
		this.callParent();
		this.items.each(function(it) {
			this.mon(it, {
				scope: this,
				click: function() {
					this.fireEvent("done", this);
				}
			});
		}, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.options.ConditionOption", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.sheet.action.ActionBox", "Ext.layout.container.Card", "EnterpriseSheet.sheet.pop.condition.IconSetRuleWin"],
	style: "padding:10px;",
	layout: "card",
	activeItem: 0,
	optionPaneWidth: 250,
	initComponent: function() {
		this.colors = {
			red: [255, 0, 0],
			green: [0, 255, 0],
			blue: [0, 0, 255],
			orange: [255, 128, 0],
			'native': [0, 128, 255],
			pink: [255, 0, 128],
			white: [255, 255, 255],
			yellow: [255, 255, 0]
		};
		this.gradColors = {
			red: [248, 105, 107],
			green: [90, 190, 123],
			blue: [90, 138, 198],
			white: [255, 255, 255],
			yellow: [255, 235, 132]
		};
		this.colorTpl = (new Ext.XTemplate("rgb({0},{1},{2})")).compile();
		this.iconSetTpl = SCOM.iconSetTpl;
		this.iconSetStore = SCOM.iconSetStore;
		this.iconSetView = Ext.create("Ext.view.View", {
			store: this.iconSetStore,
			tpl: this.iconSetTpl,
			itemSelector: "div.ss-condition-iconset",
			overItemCls: "ss-iconset-over"
		});
		this.iconSetView.on("itemclick", this.onIconSetClick, this);
		this.items = [{
			xtype: "container",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			defaults: {
				xtype: "button",
				ui: "default-toolbar",
				scale: "large",
				style: "margin-top:10px;",
				textAlign: "left"
			},
			items: [{
				iconCls: "icon-compare-highlight32",
				text: SLANG.condition_highlight_cell,
				handler: function() {
					this.getLayout().setActiveItem(1);
				},
				scope: this
			}, {
				iconCls: "icon-calculate-highlight32",
				text: SLANG.calculate_highlight_cell,
				handler: function() {
					this.getLayout().setActiveItem(2);
				},
				scope: this
			}, {
				iconCls: "icon-red-bar32",
				text: SLANG.colorbar,
				handler: function() {
					this.getLayout().setActiveItem(3);
				},
				scope: this
			}, {
				iconCls: "icon-colorchange32",
				text: SLANG.color_scales,
				handler: function() {
					this.getLayout().setActiveItem(4);
				},
				scope: this
			}, {
				iconCls: "icon-iconset32",
				text: SLANG.icon_set,
				handler: function() {
					this.getLayout().setActiveItem(5);
				},
				scope: this
			}, {
				xtype: "component",
				flex: 1
			}, {
				iconCls: "icon-clear-condition32",
				text: SLANG.clear_selecttion_condition,
				handler: this.onClearSelectionCondition,
				scope: this
			}, {
				iconCls: "icon-clear-condition32",
				text: SLANG.clear_sheet_condition,
				handler: this.onClearSheetCondition,
				scope: this
			}, {
				iconCls: "icon-manage-condition32",
				text: SLANG.condition_management + "...",
				handler: this.onManageCondition,
				scope: this
			}]
		}, {
			xtype: "container",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			defaults: {
				xtype: "button",
				ui: "default-toolbar",
				scale: "large",
				style: "margin-top:10px;",
				textAlign: "left"
			},
			items: [{
				iconCls: "icon-condition-greater32",
				text: SLANG.greater_than + "...",
				handler: this.onConditionGreater,
				scope: this
			}, {
				iconCls: "icon-condition-less32",
				text: SLANG.less_than + "...",
				handler: this.onConditionLess,
				scope: this
			}, {
				iconCls: "icon-condition-equal32",
				text: SLANG.equal + "...",
				handler: this.onConditionEqual,
				scope: this
			}, {
				iconCls: "icon-condition-between32",
				text: SLANG.between + "...",
				handler: this.onConditionBetween,
				scope: this
			}, {
				iconCls: "icon-condition-include32",
				text: SLANG.include + "...",
				handler: this.onConditionInclude,
				scope: this
			}, {
				iconCls: "icon-condition-date32",
				text: SLANG.date_ocurring_at + "...",
				handler: this.onConditionDate,
				scope: this
			}, {
				iconCls: "icon-condition-repeat32",
				text: SLANG.repeat_value + "...",
				handler: this.onConditionRepeat,
				scope: this
			}, {
				text: SLANG.other_condition + "...",
				handler: this.onConditionMore,
				scope: this
			}, {
				xtype: "component",
				flex: 1
			}, {
				text: SLANG.back,
				iconCls: "icon-back32",
				handler: this.back2Home,
				scope: this
			}]
		}, {
			xtype: "container",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			defaults: {
				xtype: "button",
				ui: "default-toolbar",
				scale: "large",
				style: "margin-top:10px;",
				textAlign: "left"
			},
			items: [{
				iconCls: "icon-condition-max32",
				text: SLANG.top_10_value + "...",
				handler: this.onConditionMax,
				scope: this
			}, {
				iconCls: "icon-condition-top32",
				text: SLANG['top_10%'] + "...",
				handler: this.onConditionTop,
				scope: this
			}, {
				iconCls: "icon-condition-min32",
				text: SLANG.bottom_10_value + "...",
				handler: this.onConditionMin,
				scope: this
			}, {
				iconCls: "icon-condition-bottom32",
				text: SLANG['bottom_10%'] + "...",
				handler: this.onConditionBottom,
				scope: this
			}, {
				iconCls: "icon-condition-above32",
				text: SLANG.above_average + "...",
				handler: this.onConditionAbove,
				scope: this
			}, {
				iconCls: "icon-condition-below32",
				text: SLANG.below_average + "...",
				handler: this.onConditionBelow,
				scope: this
			}, {
				xtype: "component",
				flex: 1
			}, {
				text: SLANG.back,
				iconCls: "icon-back32",
				handler: this.back2Home,
				scope: this
			}]
		}, {
			xtype: "container",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "container",
				layout: {
					type: "table",
					columns: 3,
					tableAttrs: {
						style: {
							width: "100%"
						}
					}
				},
				style: "padding:10px 25px;",
				defaults: {
					xtype: "button",
					scale: "large",
					ui: "default-toolbar",
					style: "margin:5px;",
					textAlign: "left",
					handler: this.onColorBar,
					scope: this
				},
				items: [{
					iconCls: "icon-blue-bar32",
					color: "blue"
				}, {
					iconCls: "icon-green-bar32",
					color: "green"
				}, {
					iconCls: "icon-red-bar32",
					color: "red"
				}, {
					iconCls: "icon-native-bar32",
					color: "native"
				}, {
					iconCls: "icon-orange-bar32",
					color: "orange"
				}, {
					iconCls: "icon-pink-bar32",
					color: "pink"
				}]
			}, {
				xtype: "component",
				flex: 1
			}, {
				xtype: "button",
				scale: "large",
				ui: "default-toolbar",
				text: SLANG.back,
				iconCls: "icon-back32",
				handler: this.back2Home,
				scope: this
			}]
		}, {
			xtype: "container",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				xtype: "container",
				layout: {
					type: "table",
					columns: 4,
					tableAttrs: {
						style: {
							width: "100%"
						}
					}
				},
				style: "padding:10px 25px;",
				defaults: {
					xtype: "button",
					scale: "large",
					ui: "default-toolbar",
					style: "margin:2px;",
					textAlign: "left",
					handler: this.onColorChange,
					scope: this
				},
				items: [{
					iconCls: "icon-grad-green2orange2red32",
					start: "green",
					stop: "yellow",
					end: "red"
				}, {
					iconCls: "icon-grad-red2orange2green32",
					start: "red",
					stop: "yellow",
					end: "green"
				}, {
					iconCls: "icon-grad-blue2orange2red32",
					start: "blue",
					stop: "yellow",
					end: "red"
				}, {
					iconCls: "icon-grad-red2orange2blue32",
					start: "red",
					stop: "yellow",
					end: "blue"
				}, {
					iconCls: "icon-grad-green2yellow32",
					start: "green",
					end: "yellow"
				}, {
					iconCls: "icon-grad-yellow2green32",
					start: "yellow",
					end: "green"
				}, {
					iconCls: "icon-grad-orange2red32",
					start: "yellow",
					end: "red"
				}, {
					iconCls: "icon-grad-red2orange32",
					start: "red",
					end: "yellow"
				}, {
					iconCls: "icon-grad-white2pink32",
					start: "white",
					end: "red"
				}, {
					iconCls: "icon-grad-pink2white32",
					start: "red",
					end: "white"
				}, {
					iconCls: "icon-grad-white2green32",
					start: "white",
					end: "green"
				}, {
					iconCls: "icon-grad-green2white32",
					start: "green",
					end: "white"
				}]
			}, {
				xtype: "component",
				flex: 1
			}, {
				xtype: "button",
				ui: "default-toolbar",
				scale: "large",
				text: SLANG.back,
				iconCls: "icon-back32",
				handler: this.back2Home,
				scope: this
			}]
		}, {
			xtype: "container",
			layout: {
				type: "vbox",
				align: "stretch"
			},
			items: [{
				height: 400,
				autoScroll: true,
				xtype: "container",
				items: [this.iconSetView]
			}, {
				xtype: "button",
				ui: "default-toolbar",
				text: SLANG.other_rule + "...",
				handler: this.onIconSetOtherRule,
				scope: this
			}, {
				xtype: "component",
				flex: 1
			}, {
				xtype: "button",
				scale: "large",
				ui: "default-toolbar",
				text: SLANG.back,
				iconCls: "icon-back32",
				handler: this.back2Home,
				scope: this
			}]
		}];
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onConditionGreater: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		avg = Math.round(avg * 100) / 100;
		var sheetId = this.sheet.getSheetId();
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.greater_than,
			label: SLANG.set_style_for_greater,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "greater",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt, sheetId);
				},
				scope: this
			}
		});
	},
	onConditionLess: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.less_than,
			label: SLANG.set_style_for_less,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "less",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionEqual: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.equal,
			label: SLANG.set_style_for_equal,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "equal",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionBetween: function() {
		SPOP.showConditionBetween({
			sheet: this.sheet,
			title: SLANG.between,
			label: SLANG.set_style_for_between,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "between",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionMore: function() {
		SPOP.showConditionMore({
			sheet: this.sheet,
			title: SLANG.other_condition,
			label: SLANG.chooseMoreCdt,
			applyCallback: {
				fn: function(o) {
					if(o.type == "inXY") {
						var opt1 = {
							type: "equal",
							base: o.base.min,
							style: o.style
						};
						var opt2 = {
							type: "equal",
							base: o.base.max,
							style: o.style
						};
						this.sheet.setConditionForSelection("boolstyle", opt1);
						this.sheet.setConditionForSelection("boolstyle", opt2);
					} else {
						var opt = {
							type: o.type,
							base: o.base,
							style: o.style
						};
						this.sheet.setConditionForSelection("boolstyle", opt);
					}
				},
				scope: this
			}
		});
	},
	onConditionInclude: function() {
		var avg = this.sheet.getAverageOfSelection(3);
		SPOP.showConditionBool({
			sheet: this.sheet,
			title: SLANG.include,
			label: SLANG.set_style_for_include,
			value: avg,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "include",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionRepeat: function() {
		SPOP.showConditionRepeat({
			sheet: this.sheet,
			title: SLANG.repeat_value,
			label: SLANG.set_style_for_cell,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "repeat",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionDate: function() {
		SPOP.showConditionDate({
			sheet: this.sheet,
			title: SLANG.date_ocurring_at,
			label: SLANG.set_style_date_ocurring_at,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "date",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionAbove: function() {
		SPOP.showConditionAverage({
			sheet: this.sheet,
			title: SLANG.above_average,
			label: SLANG.set_style_above_average,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "average",
						base: SCONST.ABOVE_AVERAGE,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionBelow: function() {
		SPOP.showConditionAverage({
			sheet: this.sheet,
			title: SLANG.below_average,
			label: SLANG.set_style_below_average,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "average",
						base: SCONST.BELOW_AVERAGE,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionMax: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG.top_10_value,
			label: SLANG.set_style_max_value,
			setAsTxt: SLANG.set_as,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "max",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionTop: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG['top_10%'],
			label: SLANG.set_style_top_value,
			setAsTxt: SLANG.percent_set_as,
			maxValue: 100,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "top",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionMin: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG.bottom_10_value,
			label: SLANG.set_style_min_value,
			setAsTxt: SLANG.set_as,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "min",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onConditionBottom: function() {
		SPOP.showConditionPosition({
			sheet: this.sheet,
			title: SLANG['bottom_10%'],
			label: SLANG.set_style_bottom_value,
			setAsTxt: SLANG.percent_set_as,
			maxValue: 100,
			applyCallback: {
				fn: function(o) {
					var opt = {
						type: "bottom",
						base: o.base,
						style: o.style
					};
					this.sheet.setConditionForSelection("boolstyle", opt);
				},
				scope: this
			}
		});
	},
	onIconSetClick: function(view, rec) {
		var data = rec.data;
		var opt = {
			set: data.set,
			level: data.level
		};
		this.sheet.setConditionForSelection("iconset", opt);
		this.fireEvent("done", this);
	},
	onColorBar: function(btn) {
		var opt = {
			pos: "red",
			neg: "green"
		};
		if(btn) {
			var color = this.colors[btn.color];
			if(color) {
				opt = {
					pos: this.colorTpl.apply(color),
					neg: this.colorTpl.apply([255 - color[0], 255 - color[1], 255 - color[2]])
				};
			}
		}
		this.sheet.setConditionForSelection("colorbar", opt);
		this.fireEvent("done", this);
	},
	onColorChange: function(btn) {
		var opt = {
			start: this.gradColors.green,
			end: this.gradColors.red
		};
		if(btn) {
			var start = this.gradColors[btn.start];
			var stop = this.gradColors[btn.stop];
			var end = this.gradColors[btn.end];
			if(start) {
				opt = opt || {};
				opt.start = start;
			}
			if(stop) {
				opt = opt || {};
				opt.stop = stop;
			}
			if(end) {
				opt = opt || {};
				opt.end = end;
			}
		}
		this.sheet.setConditionForSelection("colorgrad", opt);
		this.fireEvent("done", this);
	},
	onClearSelectionCondition: function() {
		this.sheet.clearConditionForSelection();
	},
	onClearSheetCondition: function() {
		this.sheet.clearConditonForSheet();
	},
	onManageCondition: function() {
		SPOP.showConditionManage({
			sheet: this.sheet
		});
	},
	back2Home: function() {
		this.getLayout().setActiveItem(0);
	},
	onIconSetOtherRule: function() {
		if(!this.iconSetRuleWin) {
			this.iconSetRuleWin = Ext.create("EnterpriseSheet.sheet.pop.condition.IconSetRuleWin", {
				sheet: this.sheet,
				applyCallback: {
					fn: function(params) {
						this.sheet.setConditionForSelection("iconset", params);
						this.fireEvent("done", this);
					},
					scope: this
				}
			});
		}
		this.iconSetRuleWin.popup();
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.options.PictureOption", {
	extend: "Ext.container.Container",
	layout: "anchor",
	style: "padding:10px;",
	optionPaneWidth: 240,
	cls: "ss-side-pop",
	initComponent: function() {
		this.previewBox = new Ext.Component({
			cls: "sc-preview-box",
			style: "margin-top:10px;",
			height: 160,
			html: "<img src=\"\">"
		});
		this.urlField = new Ext.form.field.TextArea({
			labelAlign: "top",
			fieldLabel: SLANG.picture_link,
			anchor: "100%",
			height: 100,
			allowBlank: false
		});
		this.inCellCheckbox = new Ext.form.field.Checkbox({
			boxLabel: SLANG.image_in_cell
		});
		this.items = [this.urlField, this.inCellCheckbox, {
			xtype: "button",
			minWidth: 50,
			text: SLANG.preview,
			handler: this.previewPicture,
			scope: this
		}, {
			xtype: "button",
			minWidth: 50,
			style: "margin-left:10px;",
			text: SLANG.insert,
			handler: this.insertPicture,
			scope: this
		}, {
			xtype: "component",
			style: "padding-top:40px;color:gray;",
			html: SLANG.preview_img_below
		}, this.previewBox];
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	previewPicture: function() {
		if(this.urlField.isValid()) {
			var url = this.urlField.getValue();
			var img = this.previewBox.getEl().down("img");
			img.dom.src = url;
		}
	},
	insertPicture: function() {
		if(this.urlField.isValid()) {
			var url = this.urlField.getValue();
			var incell = this.inCellCheckbox.getValue();
			if(incell) {
				this.sheet.createInCellPicture(url);
			} else {
				this.sheet.createPicture(url);
			}
			this.fireEvent("done", this);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.options.WedgitOption", {
	extend: "Ext.container.Container",
	layout: "anchor",
	style: "padding:10px;",
	optionPaneWidth: 340,
	initComponent: function() {
		this.previewBox = new Ext.Component({
			cls: "sc-preview-box",
			style: "margin-top:10px;",
			height: 160,
			html: "<iframe src=\"\"></iframe>"
		});
		this.urlField = new Ext.form.field.TextArea({
			labelAlign: "top",
			fieldLabel: SLANG.wedgit_link,
			anchor: "100%",
			height: 100,
			allowBlank: false
		});
		this.items = [this.urlField, {
			xtype: "button",
			minWidth: 50,
			text: SLANG.preview,
			handler: this.previewWedgit,
			scope: this
		}, {
			xtype: "button",
			minWidth: 50,
			style: "margin-left:10px;",
			text: SLANG.insert,
			handler: this.insertWedgit,
			scope: this
		}, {
			xtype: "component",
			style: "padding-top:40px;color:gray;",
			html: SLANG.preview_widget_below
		}, this.previewBox];
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	previewWedgit: function() {
		if(this.urlField.isValid()) {
			var url = this.urlField.getValue();
			if(0 !== url.indexOf("http://")) {
				url = "http://" + url;
			}
			var iframe = this.previewBox.getEl().down("iframe");
			iframe.dom.src = url;
		}
	},
	insertWedgit: function() {
		if(this.urlField.isValid()) {
			var url = this.urlField.getValue();
			if(0 !== url.indexOf("http://")) {
				url = "http://" + url;
			}
			this.sheet.createWedgit(url);
			this.fireEvent("done", this);
		}
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.options.SearchOption", {
	extend: "Ext.grid.Panel",
	requires: ["EnterpriseSheet.sheet.model.TargetModel", "Ext.grid.feature.Grouping"],
	bodyStyle: "border-left:none;border-right:none;",
	optionPaneWidth: 240,
	hideHeaders: true,
	initComponent: function() {
		this.searchField = new Ext.form.field.Text({
			fieldLabel: SLANG.search,
			labelAlign: "top",
			anchor: "100%",
			allowBlank: false,
			enableKeyEvents: true,
			listeners: {
				keypress: {
					fn: this.onFindKeyPress,
					scope: this
				}
			}
		});
		this.replaceField = new Ext.form.field.Text({
			fieldLabel: SLANG.replace_with,
			labelAlign: "top",
			anchor: "100%",
			enableKeyEvents: true
		});
		this.searchBtn = new Ext.button.Button({
			flex: 1,
			text: SLANG.find,
			handler: this.findMatch,
			scope: this
		});
		this.prevBtn = new Ext.button.Button({
			disabled: true,
			text: SLANG.prev,
			handler: this.prevMatch,
			scope: this
		});
		this.nextBtn = new Ext.button.Button({
			disabled: true,
			text: SLANG.next,
			handler: this.nextMatch,
			scope: this
		});
		this.replaceBtn = new Ext.button.Button({
			disabled: true,
			flex: 1,
			text: SLANG.replace,
			handler: this.replaceSelect,
			scope: this
		});
		this.replaceAllBtn = new Ext.button.Button({
			disabled: true,
			flex: 1,
			text: SLANG.replace_all,
			handler: this.replaceAll,
			scope: this
		});
		this.nextPageBtn = Ext.create("Ext.button.Button", {
			text: SLANG.more,
			handler: this.loadMore,
			scope: this
		});
		this.moreBar = Ext.create("Ext.toolbar.Toolbar", {
			hidden: true,
			layout: {
				type: "hbox",
				pack: "center"
			},
			dock: "bottom",
			style: "border-left:none;border-right:none;",
			items: [this.nextPageBtn]
		});
		this.dockedItems = [{
			xtype: "container",
			dock: "top",
			layout: "anchor",
			cls: "ss-search-fields-ct",
			items: [this.searchField, this.replaceField]
		}, {
			xtype: "container",
			style: "padding:0px 10px 10px 10px;",
			cls: "ss-search-button-ct",
			dock: "bottom",
			layout: "hbox",
			items: [this.replaceBtn, {
				xtype: "component",
				width: 10
			}, this.replaceAllBtn]
		}, {
			xtype: "container",
			cls: "ss-search-button-ct",
			dock: "bottom",
			layout: "hbox",
			items: [this.searchBtn, {
				xtype: "component",
				width: 10
			}, this.prevBtn, {
				xtype: "component",
				width: 10
			}, this.nextBtn]
		}, this.moreBar];
		var me = this;
		this.columns = [{
			width: 50,
			dataIndex: "cell"
		}, {
			flex: 1,
			dataIndex: "data"
		}];
		this.store = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TargetModel",
			groupField: "sheetName"
		});
		var groupingFeature = Ext.create("Ext.grid.feature.Grouping", {
			groupHeaderTpl: "{name} ({rows.length})",
			hideGroupedHeader: true
		});
		this.features = [groupingFeature];
		this.callParent();
		this.loadMask = new Ext.LoadMask({
			target: this,
			msg: SLANG.processing
		});
		this.on("itemclick", this.onItemClick, this);
		var sm = this.getSelectionModel();
		this.mon(sm, {
			scope: this,
			selectionchange: this.onSelectionChange
		});
		this.on("show", this.searchFieldFocus, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	searchFieldFocus: function() {
		this.searchField.focus(true, 100);
	},
	findMatch: function() {
		if(this.searchField.isValid()) {
			var txt = "*" + this.searchField.getValue() + "*";
			this.findText = txt;
			var sheet = this.sheet;
			var store = sheet.getStore(),
				sm = sheet.getSelectionModel();
			var focusCell = sm.getFocusCell();
			var startRow = focusCell.row,
				startCol = focusCell.col;
			this.loadMask.show();
			Ext.Function.defer(function() {
				store.findMatchCells(txt, function(matchs, nextCellId) {
					this.store.removeAll();
					if(matchs && 0 < matchs.length) {
						var match = matchs[0];
						var sheetId = match.sheet,
							row = match.row,
							col = match.col;
						this.store.add(matchs);
						this.replaceBtn.enable();
						this.replaceAllBtn.enable();
					} else {
						this.prevBtn.disable();
						this.nextBtn.disable();
					}
					this.loadMask.hide();
					if(nextCellId) {
						this.moreBar.show();
						this.nextCellId = nextCellId;
					} else {
						this.moreBar.hide();
						delete this.nextCellId;
					}
				}, this);
			}, 100, this);
		}
	},
	loadMore: function() {
		this.loadMask.show();
		Ext.Function.defer(function() {
			store.findMatchCells(this.findText, function(matchs, nextCellId) {
				if(matchs && 0 < matchs.length) {
					var match = matchs[0];
					var sheetId = match.sheet,
						row = match.row,
						col = match.col;
					this.store.add(matchs);
				}
				this.loadMask.hide();
				if(nextCellId) {
					this.moreBar.show();
					this.nextCellId = nextCellId;
				} else {
					this.moreBar.hide();
					delete this.nextCellId;
				}
			}, this, this.nextCellId);
		}, 100, this);
	},
	onFindKeyPress: function(field, e) {
		if(e.ENTER == e.getKey()) {
			this.findMatch();
		}
	},
	onItemClick: function(grid, rec) {
		this.go2Pos(rec.data.sheet, rec.data.row, rec.data.col);
	},
	go2Pos: function(sheetId, row, col) {
		var sheet = this.sheet,
			curSheetId = sheet.getSheetId();
		var store = sheet.getStore(),
			sm = sheet.getSelectionModel();
		var fn = function() {
			var orow = row,
				ocol = col;
			var cregion = sheet.cregion;
			if(!cregion.isInRange(row, col)) {
				row = row - Math.floor((cregion.rowEnd - cregion.rowStart) / 2);
				col = col - Math.floor((cregion.colEnd - cregion.colStart) / 2);
				if(row < 1) {
					row = 1;
				}
				if(col < 1) {
					col = 1;
				}
				sheet.go2Pos(row, col);
			}
			sm.selectRange({
				row: orow,
				col: ocol
			});
			sm.setFocusCell(orow, ocol);
		};
		if(curSheetId == sheetId) {
			fn();
		} else {
			sheet.go2Sheet(sheetId, fn, this);
		}
	},
	onSelectionChange: function(sm, sels) {
		if(0 < sels.length) {
			var sel = sels[0];
			var index = this.store.indexOf(sel);
			if(0 < index) {
				this.prevBtn.enable();
			} else {
				this.prevBtn.disable();
			}
			if(index < this.store.getCount() - 1) {
				this.nextBtn.enable();
			} else {
				this.nextBtn.disable();
			}
		} else {
			this.prevBtn.disable();
			this.nextBtn.disable();
		}
	},
	prevMatch: function() {
		var sm = this.getSelectionModel();
		var sel = sm.getSelection()[0];
		var index = this.store.indexOf(sel);
		index--;
		sm.select(index);
		var rec = this.store.getAt(index);
		this.go2Pos(rec.data.sheet, rec.data.row, rec.data.col);
	},
	nextMatch: function() {
		var sm = this.getSelectionModel();
		var sel = sm.getSelection()[0];
		var index = this.store.indexOf(sel);
		index++;
		sm.select(index);
		var rec = this.store.getAt(index);
		this.go2Pos(rec.data.sheet, rec.data.row, rec.data.col);
	},
	replaceSelect: function() {
		var txt = this.replaceField.getValue();
		var findTxt = this.searchField.getValue();
		var sm = this.getSelectionModel();
		var sels = sm.getSelection();
		if(0 < sels.length) {
			var sel = sels[0];
			var modified, deleted;
			var originalData = sel.data.data;
			var reg = new RegExp(findTxt, "gi");
			if(SCOM.nullOrUndefined(txt)) {
				txt = "";
			}
			txt = originalData.replace(reg, txt);
			if(!SCOM.nullOrUndefined(txt) && "" != txt) {
				modified = {
					data: txt
				};
			} else {
				deleted = ["data"];
			}
			var cellDatail = this.sheet.getStore().getCellProperty(sel.data.sheet, sel.data.row, sel.data.col);
			if(cellDatail.dsd && cellDatail.dsd === "ed") {} else {
				this.sheet.setCellData(sel.data.sheet, sel.data.row, sel.data.col, modified, deleted);
			}
		} else {
			Ext.Msg.alert(SLANG.hint, SLANG.no_selection_replace);
		}
	},
	replaceAll: function() {
		var txt = this.replaceField.getValue();
		var findTxt = this.searchField.getValue();
		var modified, deleted;
		Ext.Msg.show({
			title: SLANG.hint,
			msg: SLANG.really_replace_all,
			icon: Ext.Msg.QUESTION,
			buttons: Ext.Msg.YESNO,
			fn: function(bid) {
				if("yes" == bid) {
					this.loadMask.show();
					Ext.Function.defer(function() {
						this.loadMask.hide();
						this.store.each(function(rec) {
							var originalData = rec.data.data;
							if(SCOM.isEmptyValue(originalData)) {
								originalData = "";
							}
							var reg = new RegExp(findTxt, "gi");
							if(SCOM.nullOrUndefined(txt)) {
								txt = "";
							}
							var replacedTxt = originalData.replace(reg, txt);
							if(!SCOM.nullOrUndefined(replacedTxt) && "" != replacedTxt) {
								modified = {
									data: replacedTxt
								};
							} else {
								deleted = ["data"];
							}
							var cellDatail = this.sheet.getStore().getCellProperty(rec.data.sheet, rec.data.row, rec.data.col);
							if(cellDatail.dsd && cellDatail.dsd === "ed") {} else {
								this.sheet.setCellData(rec.data.sheet, rec.data.row, rec.data.col, modified, deleted, true);
							}
						}, this);
						this.sheet.getStore().pullingAction();
						this.sheet.refreshRange(null, true);
					}, 100, this);
				}
			},
			scope: this
		});
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.options.TableTemplateOption", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.sheet.menu.TableStyleMenu"],
	optionPaneWidth: 515,
	scrollOffset: 18,
	layout: "fit",
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	initComponent: function() {
		var lightStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TableTplModel"
		});
		var mediumStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TableTplModel"
		});
		var darkStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TableTplModel"
		});
		var tpls = EnterpriseSheet.sheet.tpl.TableTemplate.prototype.tableTplData;
		for(var i = 0, len = tpls.length; i < len; i++) {
			var it = tpls[i];
			if("light" == it.type) {
				var r = lightStore.createModel(it);
				lightStore.add(r);
			} else if("medium" == it.type) {
				var r = mediumStore.createModel(it);
				mediumStore.add(r);
			} else {
				var r = darkStore.createModel(it);
				darkStore.add(r);
			}
		}
		var tpl = new Ext.XTemplate("<tpl for=\".\">", "<div class=\"thumb-wrap\">", "<div class=\"thumb\"><img src=\"{url}\"></div>", "</div>", "</tpl>", "<div class=\"x-clear\"></div>");
		this.lightView = new Ext.view.View({
			cls: "images-view",
			store: lightStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.mediumView = new Ext.view.View({
			cls: "images-view",
			store: mediumStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.darkView = new Ext.view.View({
			cls: "images-view",
			store: darkStore,
			tpl: tpl,
			autoHeight: true,
			singleSelect: true,
			trackOver: true,
			overItemCls: "x-view-over",
			itemSelector: "div.thumb-wrap"
		});
		this.items = [{
			xtype: "container",
			style: "background:white;",
			autoScroll: true,
			items: [{
				xtype: "button",
				style: "margin:5px;",
				text: SLANG.clear_table_tpl,
				handler: this.clearTableTpl,
				scope: this
			}, {
				xtype: "component",
				cls: "tpl-title",
				html: SLANG.light_color
			}, this.lightView, {
				xtype: "component",
				cls: "tpl-title",
				html: SLANG.dark_color
			}, this.mediumView, {
				xtype: "component",
				cls: "tpl-title",
				html: SLANG.deep_dark_color
			}, this.darkView],
			listeners: {
				afterrender: function(ct) {
					var el = ct.getEl();
					var me = this;
					me.mon(el, "mousewheel", function(e) {
						var delta = e.getWheelDelta();
						el.dom.scrollTop += -delta * me.scrollOffset;
					});
				},
				scope: this
			}
		}];
		this.callParent();
		this.mon(this.lightView, "itemclick", this._onClickItem, this);
		this.mon(this.mediumView, "itemclick", this._onClickItem, this);
		this.mon(this.darkView, "itemclick", this._onClickItem, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	setTplForSelection: function(tpl) {
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl) {
			tableTpl.setTplForSpan(span, tpl);
		}
	},
	clearTableTpl: function() {
		var sm = this.sheet.getSelectionModel();
		var span = sm.selection2Span();
		var tableTpl = this.sheet.getTableTpl();
		if(tableTpl) {
			tableTpl.clearTplForSpan(span);
		}
	},
	_onClickItem: function(dv, rec) {
		var tpl = rec.data.tpl;
		if(tpl) {
			this.setTplForSelection({
				id: rec.data.id
			});
		}
		this.fireEvent("done", this);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.BackgroundColorButton", {
	extend: "EnterpriseSheet.common.ColorButton",
	initialColor: "#C0504D",
	iconCls: "icon-paintcan",
	themeColorStr: SLANG.theme_colors,
	standardColorStr: SLANG.standard_colors,
	initComponent: function() {
		this.currentFillColor = this.initialColor;
		this.menu = [{
			text: SLANG.no_fill_color,
			cls: "no-fill-color-item",
			handler: this.onNoFillColor,
			scope: this
		}];
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	selectHandler: function(cp, color) {
		this.currentFillColor = color;
		this.fillColor(this.currentFillColor);
	},
	handler: function() {
		this.fillColor(this.currentFillColor);
	},
	onNoFillColor: function() {
		this.currentFillColor = null;
		this.fillColor();
		this.setColor();
		this.menu.hide();
	},
	fillColor: function(color) {
		this.sheet.setPropertyForSelection({
			bgc: color || ""
		});
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.BorderButton", {
	extend: "Ext.button.Split",
	requires: ["EnterpriseSheet.common.Common", "Ext.picker.Color"],
	iconCls: "icon-border-bottom",
	initComponent: function() {
		this.menu = new Ext.menu.Menu({
			items: ["<b class=\"menu-title\">" + SLANG.border_style + "</b>", {
				iconCls: "icon-border-bottom",
				text: SLANG.border_bottom,
				handler: this.onBorderBottom,
				scope: this
			}, {
				iconCls: "icon-border-top",
				text: SLANG.border_top,
				handler: this.onBorderTop,
				scope: this
			}, {
				iconCls: "icon-border-left",
				text: SLANG.border_left,
				handler: this.onBorderLeft,
				scope: this
			}, {
				iconCls: "icon-border-right",
				text: SLANG.border_right,
				handler: this.onBorderRight,
				scope: this
			}, "-", {
				iconCls: "icon-border-none",
				text: SLANG.border_none,
				handler: this.onBorderNone,
				scope: this
			}, {
				iconCls: "icon-border-all",
				text: SLANG.border_all,
				handler: this.onBorderAll,
				scope: this
			}, {
				iconCls: "icon-border-outside",
				text: SLANG.border_outside,
				handler: this.onBorderOutside,
				scope: this
			}, {
				iconCls: "icon-bold-border-outside",
				text: SLANG.bold_border_outside,
				handler: this.onBoldBorderOutside,
				scope: this
			}, "-", {
				iconCls: "icon-double-border-bottom",
				text: SLANG.double_border_bottom,
				handler: this.onDoubleBorderBottom,
				scope: this
			}, {
				iconCls: "icon-bold-border-bottom",
				text: SLANG.bold_border_bottom,
				handler: this.onBoldBorderBottom,
				scope: this
			}, {
				iconCls: "icon-border-top-bottom",
				text: SLANG.border_top_bottom,
				handler: this.onBorderTopBottom,
				scope: this
			}, {
				iconCls: "icon-border-top-bottombold",
				text: SLANG.border_top_bottom_bold,
				handler: this.onBorderTopBottomBold,
				scope: this
			}, {
				iconCls: "icon-border-top-bottomdouble",
				text: SLANG.double_border_bottom_top_border,
				handler: this.onBorderTopBottomDouble,
				scope: this
			}, {
				iconCls: "icon-clean-border",
				text: SLANG.clean_border,
				handler: this.onBorderNone,
				scope: this
			}, {
				iconCls: "icon-border-color",
				text: SLANG.border_color,
				menu: new Ext.menu.Menu({
					cls: "color-menu",
					plain: true,
					style: "padding-left:5px;background-position:-30px 0;",
					items: ["<b class=\"menu-title\">" + SLANG.theme_colors + "</b>", new Ext.picker.Color({
						allowReselect: true,
						style: "height:120px;width:185px;",
						colors: SCOM.themeColors,
						listeners: {
							select: {
								fn: this.onSelectBorderColor,
								scope: this
							}
						}
					}), "<b class=\"menu-title\">" + SLANG.standard_colors + "</b>", new Ext.picker.Color({
						allowReselect: true,
						style: "width:185px;height:80px;",
						listeners: {
							select: {
								fn: this.onSelectBorderColor,
								scope: this
							}
						}
					})]
				})
			}, {
				text: SLANG.line_style,
				menu: new Ext.menu.Menu({
					items: [{
						checked: true,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-solid",
						handler: this.onSolidLine,
						scope: this
					}, {
						checked: false,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-dotted",
						handler: this.onDottedLine,
						scope: this
					}, {
						checked: false,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-dashed",
						handler: this.onDashedLine,
						scope: this
					}, {
						checked: false,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-dotted2",
						handler: this.onBoldDottedLine,
						scope: this
					}, {
						checked: false,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-dashed2",
						handler: this.onBoldDashedLine,
						scope: this
					}, {
						checked: false,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-solid2",
						handler: this.onBoldSolidLine,
						scope: this
					}, {
						checked: false,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-double",
						handler: this.onDoubleLine,
						scope: this
					}, {
						checked: false,
						group: "line-style",
						text: "&nbsp;",
						cls: "ls-solid3",
						handler: this.onTriSolidLine,
						scope: this
					}]
				})
			}]
		});
		this.handler = this.onBorder = this.onBorderBottom;
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onBorderAll: function(btn) {
		this.setRangeBorder("all");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderAll;
	},
	onBorderNone: function(btn) {
		var s = this.sheet.getStore();
		this.setRangeBorder("all", "", 1, "solid");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderNone;
	},
	onBorderTop: function(btn) {
		this.setRangeBorder("top");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderTop;
	},
	onBorderBottom: function(btn) {
		this.setRangeBorder("bottom");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderBottom;
	},
	onBorderLeft: function(btn) {
		this.setRangeBorder("left");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderLeft;
	},
	onBorderRight: function(btn) {
		this.setRangeBorder("right");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderRight;
	},
	onBorderTopBottom: function(btn) {
		this.setRangeBorder("topbottom", null, 1, "solid");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderTopBottom;
	},
	onBorderOutside: function(btn) {
		this.setRangeBorder("outside");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderOutside;
	},
	onBoldBorderOutside: function(btn) {
		this.setRangeBorder("outside", null, 2);
		this.setIconCls(btn.iconCls);
		this.handler = this.onBoldBorderOutside;
	},
	onDoubleBorderBottom: function(btn) {
		this.setRangeBorder("bottom", null, 3, "double");
		this.setIconCls(btn.iconCls);
		this.handler = this.onDoubleBorderBottom;
	},
	onBoldBorderBottom: function(btn) {
		this.setRangeBorder("bottom", null, 2);
		this.setIconCls(btn.iconCls);
		this.handler = this.onBoldBorderBottom;
	},
	onBorderTopBottomBold: function(btn) {
		this.setRangeBorder("top", null, 1, "solid", true);
		this.setRangeBorder("bottom", null, 2, "bold");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderTopBottomBold;
	},
	onBorderTopBottomDouble: function(btn) {
		this.setRangeBorder("top", null, 1, "solid", true);
		this.setRangeBorder("bottom", null, 3, "double");
		this.setIconCls(btn.iconCls);
		this.handler = this.onBorderTopBottomDouble;
	},
	onSelectBorderColor: function(cp, color) {
		this.menu.hide();
		this.borderColor = "#" + color;
	},
	onPaintBorder: function(btn) {},
	onSolidLine: function() {
		this.borderWidth = 1;
		this.borderStyle = "solid";
	},
	onDottedLine: function() {
		this.borderWidth = 1;
		this.borderStyle = "dotted";
	},
	onDashedLine: function() {
		this.borderWidth = 1;
		this.borderStyle = "dashed";
	},
	onBoldDottedLine: function() {
		this.borderWidth = 2;
		this.borderStyle = "dotted";
	},
	onBoldDashedLine: function() {
		this.borderWidth = 2;
		this.borderStyle = "dashed";
	},
	onBoldSolidLine: function() {
		this.borderWidth = 2;
		this.borderStyle = "solid";
	},
	onDoubleLine: function() {
		this.borderWidth = 3;
		this.borderStyle = "double";
	},
	onTriSolidLine: function() {
		this.borderWidth = 3;
		this.borderStyle = "solid";
	},
	setRangeBorder: function(dir, color, width, style, suspendRefresh) {
		dir = dir || "all";
		if(false == SCOM.typeOf(color)) {
			color = this.borderColor || "black";
		}
		if(false == SCOM.typeOf(width)) {
			width = this.borderWidth || 1;
		}
		if(false == SCOM.typeOf(style)) {
			style = this.borderStyle;
		}
		this.sheet.setRangeBorder(dir, color, width, style, suspendRefresh);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.BrushButton", {
	extend: "Ext.button.Button",
	initComponent: function() {
		this.enableToggle = true;
		if(this.sheet) {
			this.handler = this.onBrush;
		}
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
		this.handler = this.onBrush;
	},
	onBrush: function() {
		var sheet = this.sheet;
		if(this.pressed) {
			this.brush = Ext.core.DomHelper.append(document.body, "<div class=\"ss-brush icon-brush\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>", true);
			this.brush.hide();
			Ext.getDoc().on("mousemove", this.moveBrush, this);
			this.mon(sheet, "cellmouseup", this.cancelBrush, this, {
				single: true
			});
			var sm = sheet.getSelectionModel(),
				rm = sheet.getReferenceModel();
			this.brushFromCoord = sm.selection2Coord();
		} else {
			sheet.un("cellmouseup", this.cancelBrush, this, {
				single: true
			});
			this.cancelBrush();
		}
	},
	moveBrush: function(e) {
		if(this.brush) {
			var xy = e.getXY();
			var sel = this.sheet.getEl();
			var left = sel.getLeft(),
				top = sel.getTop(),
				right = sel.getRight(),
				bottom = sel.getBottom();
			if(left <= xy[0] && xy[0] <= right && top <= xy[1] && xy[1] <= bottom) {
				var x = xy[0] + 16,
					y = xy[1] - 5;
				this.brush.setLeft(x);
				this.brush.setTop(y);
				this.brush.show();
			} else {
				this.brush.hide();
			}
		}
	},
	cancelBrush: function(region, e) {
		var sheet = this.sheet;
		if(region && e) {
			var sm = sheet.getSelectionModel();
			var fromSpan = this.brushFromCoord[0];
			var toSpan = sm.selection2Span();
			var res = sm.calculateRowColSpan(fromSpan);
			if(!res.hasMerged) {
				res.hasMerged = true;
				res.rowSpan = fromSpan[3] - fromSpan[1] + 1;
				res.colSpan = fromSpan[4] - fromSpan[2] + 1;
			}
			toSpan = sm.adjustToSpanForMerged(fromSpan, toSpan, res);
			if(toSpan) {
				sheet.applyBrush(this.brushFromCoord, [toSpan]);
			} else {
				Ext.Msg.alert(SLANG.hint, SLANG.target_range_shouldbe_same_size);
			}
		}
		Ext.removeNode(this.brush.dom);
		delete this.brush;
		Ext.getDoc().on("mousemove", this.moveBrush, this);
		this.toggle(false, true);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.FontColorButton", {
	extend: "EnterpriseSheet.common.ColorButton",
	iconCls: "icon-font",
	themeColorStr: SLANG.theme_colors,
	standardColorStr: SLANG.standard_colors,
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	selectHandler: function(cp, color) {
		Ext.Function.defer(function() {
			var editor = this.sheet.editor;
			if(editor && editor.isVisible()) {
				editor.focus();
			}
			var ss = this.sheet;
			var fc = this.fontColor = color;
			if(false !== ss.fireEvent("cmd", "forecolor", fc, ss)) {
				ss.setPropertyForSelection({
					color: fc
				});
			}
		}, 10, this);
	},
	handler: function() {
		var fc = this.fontColor;
		var ss = this.sheet;
		if(false !== ss.fireEvent("cmd", "forecolor", fc, ss)) {
			ss.setPropertyForSelection({
				color: fc
			});
		}
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.FontFamilyButton", {
	extend: "Ext.button.Button",
	requires: ["EnterpriseSheet.common.Common"],
	defaultValue: "Arial",
	minWidth: 125,
	textAlign: "right",
	initComponent: function() {
		this.store = SCOM.fontFamilyStore;
		var items = [],
			text;
		this.store.each(function(rec) {
			if(this.defaultValue == rec.data.id) {
				text = rec.data.text;
			}
			items.push({
				ff: rec.data.id,
				text: rec.data.text,
				handler: this.onFontFamilySelect,
				scope: this
			});
		}, this);
		this.text = text;
		this.menu = items;
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onFontFamilySelect: function(item) {
		var editor = this.sheet.editor;
		if(editor && editor.isVisible()) {
			editor.focus();
		}
		var ff = item.ff;
		var ss = this.sheet;
		if(false !== ss.fireEvent("cmd", "fontName", ff, ss)) {
			ss.setPropertyForSelection({
				ff: ff
			});
		}
		this.setText(item.text);
	},
	setFontFamily: function(ff) {
		var text = ff || this.defaultValue;
		this.store.each(function(rec) {
			if(text == rec.data.id) {
				text = rec.data.text;
				return false;
			}
		}, this);
		this.setText(text);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.FontFamilyCombo", {
	extend: "Ext.form.field.ComboBox",
	requires: ["EnterpriseSheet.common.Common"],
	displayField: "text",
	valueField: "id",
	value: "Arial",
	typeAhead: true,
	queryMode: "local",
	triggerAction: "all",
	forceSelection: true,
	initComponent: function() {
		this.store = SCOM.fontFamilyStore;
		this.callParent();
		this.on("select", this.onFontFamilySelect, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onFontFamilySelect: function(cb, sels) {
		Ext.Function.defer(function() {
			var editor = this.sheet.editor;
			if(editor && editor.isVisible()) {
				editor.focus();
			}
			var rec = sels[0];
			var ff = rec.data.id;
			var ss = this.sheet;
			if(false !== ss.fireEvent("cmd", "fontName", ff, ss)) {
				ss.setPropertyForSelection({
					ff: ff
				});
			}
		}, 10, this);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.FontSizeButton", {
	extend: "Ext.button.Button",
	requires: ["EnterpriseSheet.common.Common"],
	defaultValue: "10",
	minWidth: 50,
	initComponent: function() {
		this.store = SCOM.fontSizeStore;
		var items = [],
			text;
		this.store.each(function(rec) {
			if(this.defaultValue == rec.data.id) {
				text = rec.data.text;
			}
			items.push({
				fontsize: rec.data.id,
				text: rec.data.text,
				handler: this.onFontSizeSelect,
				scope: this
			});
		}, this);
		this.text = text;
		this.menu = items;
		this.callParent();
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onFontSizeSelect: function(item) {
		var editor = this.sheet.editor;
		if(editor && editor.isVisible()) {
			editor.focus();
		}
		var ss = this.sheet,
			store = ss.getStore();
		if(false !== ss.fireEvent("cmd", "fontSize", item.fontsize, ss)) {
			ss.setPropertyForSelection({
				fz: item.fontsize
			});
		}
		this.setText(item.text);
	},
	setFontSize: function(fz) {
		var text = fz || this.defaultValue;
		this.store.each(function(rec) {
			if(fz == rec.data.id) {
				text = rec.data.text;
				return false;
			}
		}, this);
		this.setText(text);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.FontSizeCombo", {
	extend: "Ext.form.field.ComboBox",
	requires: ["EnterpriseSheet.common.Common"],
	displayField: "text",
	valueField: "id",
	value: "14",
	typeAhead: true,
	queryMode: "local",
	triggerAction: "all",
	forceSelection: true,
	initComponent: function() {
		this.store = SCOM.fontSizeStore;
		this.callParent();
		this.on("select", this.onFontSizeSelect, this);
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onFontSizeSelect: function(cb, sels) {
		Ext.Function.defer(function() {
			var editor = this.sheet.editor;
			if(editor && editor.isVisible()) {
				editor.focus();
			}
			var ss = this.sheet;
			var rec = sels[0];
			if(false !== ss.fireEvent("cmd", "fontSize", rec.data.id, ss)) {
				ss.setPropertyForSelection({
					fz: rec.data.id
				});
			}
		}, 10, this);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.MoneyButton", {
	extend: "Ext.button.Split",
	requires: ["EnterpriseSheet.sheet.menu.TextFormatMenu", "EnterpriseSheet.sheet.pop.money.MoneySelectWin", "EnterpriseSheet.sheet.menu.CustomFormatMenu", "EnterpriseSheet.sheet.pop.NumberSpecialWin"],
	iconCls: "icon-money",
	overflowText: SLANG.currency,
	initComponent: function() {
		this.formatMenu = new EnterpriseSheet.sheet.menu.TextFormatMenu({
			minWidth: 160
		});
		this.customMenu = new EnterpriseSheet.sheet.menu.CustomFormatMenu({
			minWidth: 170
		});
		this.menu = [{
			iconCls: "fa fa-usd fa-lg",
			name: "usd",
			text: SLANG.money_us_dollar,
			handler: this.onPopMoney,
			scope: this
		}, {
			iconCls: "fa fa-cny fa-lg",
			text: SLANG.money_china_rmb,
			name: "rmb",
			handler: this.onPopMoney,
			scope: this
		}, {
			iconCls: "fa fa-eur fa-lg",
			name: "eur",
			text: SLANG.money_european_euro,
			handler: this.onPopMoney,
			scope: this
		}, {
			iconCls: "fa fa-jpy fa-lg",
			name: "jpy",
			text: SLANG.money_japanese_yen,
			handler: this.onPopMoney,
			scope: this
		}, {
			iconCls: "fa fa-inr fa-lg",
			name: "inr",
			text: SLANG.money_indian_rupee,
			handler: this.onPopMoney,
			scope: this
		}, {
			iconCls: "fa fa-gbp fa-lg",
			name: "gbp",
			text: SLANG.money_english_pound,
			handler: this.onPopMoney,
			scope: this
		}, {
			text: SLANG.more + "...",
			handler: this.onPopMoney,
			scope: this
		}, "-", {
			text: SLANG.number_format,
			menu: this.formatMenu
		}, {
			iconCls: "icon-custom",
			text: SLANG.customNum,
			menu: this.customMenu
		}, {
			text: SLANG.number_special,
			handler: this.onNumberSpecial,
			scope: this
		}, {
			text: SLANG.locale,
			iconCls: "fa fa-globe fa-lg",
			handler: this.onLocale,
			scope: this
		}];
		this.handler = this.onPopMoney;
		this.callParent();
		this.mon(this.formatMenu, {
			scope: this,
			show: this.onFormatMenuShow
		});
	},
	onPopMoney: function(item) {
		if(!this.openMoneyWin) {
			this.openMoneyWin = Ext.create("EnterpriseSheet.sheet.pop.money.MoneySelectWin", {});
			this.openMoneyWin.bindSheet(this.sheet);
		}
		if(item && item.name) {
			this.openMoneyWin.popup(item.name);
		} else {
			this.openMoneyWin.popup();
		}
	},
	onNumberSpecial: function(item) {
		if(!this.numberSpecialWin) {
			this.numberSpecialWin = Ext.create("EnterpriseSheet.sheet.pop.NumberSpecialWin", {});
			this.numberSpecialWin.bindSheet(this.sheet);
		}
		this.numberSpecialWin.popup();
	},
	onLocale: function(item) {
		if(!this.openLocaleWin) {
			this.openLocaleWin = Ext.create("EnterpriseSheet.sheet.pop.money.LocaleSelectWin", {});
			this.openLocaleWin.bindSheet(this.sheet);
		}
		if(item && item.name) {
			this.openLocaleWin.popup(item.name);
		} else {
			this.openLocaleWin.popup();
		}
	},
	onFormatMenuShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			var sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var focus = sm.getFocusCell();
			var cell = sheet.getCellValue(sheet.getSheetId(), focus.row, focus.col);
			this.formatMenu.previewTextFormat(cell.data);
		}
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
		this.formatMenu.bindSheet(sheet);
		this.customMenu.bindSheet(sheet);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.pieces.TextFormatCombo", {
	extend: "Ext.form.field.ComboBox",
	requires: ["EnterpriseSheet.common.Common", "Ext.toolbar.Toolbar"],
	displayField: "text",
	valueField: "id",
	typeAhead: true,
	queryMode: "local",
	triggerAction: "all",
	selectOnFocus: true,
	forceSelection: true,
	value: "regular",
	initComponent: function() {
		this.listConfig = {
			minWidth: 250,
			getInnerTpl: function(display) {
				return ["<div class=\"ss-textformat icon-{id}32\">", "<b>{text}</b><br>", "{preview}", "</div>"].join("");
			},
			pagingToolbar: new Ext.toolbar.Toolbar({
				style: "border-left:none;border-right:none;border-bottom:none;",
				items: [{
					text: SLANG.number_format + "...",
					handler: this.onOtherFormat,
					scope: this
				}],
				bindStore: Ext.emptyFn
			})
		};
		this.store = SCOM.textFormatStore;
		this.callParent();
		this.on({
			scope: this,
			select: this.selectTextFormat,
			expand: this.onDropListExpand
		});
	},
	bindSheet: function(sheet) {
		this.sheet = sheet;
	},
	onOtherFormat: function() {},
	selectTextFormat: function(pick, sels) {
		var sheet = this.sheet;
		if(sheet) {
			var value = sels[0].data.id;
			sheet.setTextFormatForSelection(value);
		}
	},
	previewTextFormat: function(data) {
		if(data) {
			var rds = this.store.getRange();
			for(var i = 0, len = rds.length; i < len; i++) {
				var rd = rds[i];
				var preview = SFORMAT.transferFormat({
					data: data
				}, rd.data.id).data;
				rd.set("preview", preview);
			}
		} else {
			var rds = this.store.getRange();
			for(var i = 0, len = rds.length; i < len; i++) {
				rds[i].set("preview", null);
			}
		}
	},
	onDropListExpand: function() {
		var sheet = this.sheet;
		if(sheet) {
			var sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var focus = sm.getFocusCell();
			var cell = store.getCell(sheet.getSheetId(), focus.row, focus.col, true);
			this.previewTextFormat(cell.data);
		}
	},
	setValue: function(v) {
		v = v || "regular";
		var moneySet = {
			rmb: "money",
			pound: "money",
			dollar: "money",
			euro: "money"
		};
		v = moneySet[v] || v;
		this.callParent([v]);
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.Contentbar", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.common.Common", "EnterpriseSheet.common.SimpleButton", "EnterpriseSheet.sheet.editor.ContentEditor", "EnterpriseSheet.sheet.pop.ReferenceNameList"],
	cls: "ss-content-bar",
	height: 25,
	collapsedHeight: 25,
	epxandHeight: 65,
	layout: {
		type: "hbox",
		align: "stretch"
	},
	initComponent: function() {
		this.anchorBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: "icon-anchor",
			width: 25,
			style: "background-position:center center;",
			color: "silver",
			handler: this.doAnchor,
			scope: this
		});
		this.posBox = new Ext.Component({
			style: "padding:3px;text-align:center;",
			width: 107
		});
		this.splitBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: "icon-hbar",
			width: 30,
			color: "silver",
			handler: this.showNameList,
			scope: this
		});
		this.enterBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: "icon-check",
			style: "background-position:center center;",
			disabled: true,
			width: 24,
			color: "silver",
			handler: function() {
				this.contentBox.completeEdit();
				this.contentBox.blurOff();
				this.sheet.fireEvent("loseeditingfocus", this.sheet);
				this.onSheetChange();
			},
			scope: this
		});
		this.escBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: "icon-cross",
			style: "background-position:center center;",
			disabled: true,
			width: 24,
			color: "silver",
			handler: function() {
				this.contentBox.cancelEdit();
				this.contentBox.blurOff();
				this.sheet.fireEvent("loseeditingfocus", this.sheet);
				this.onSheetChange();
			},
			scope: this
		});
		this.contentBox = new EnterpriseSheet.sheet.editor.ContentEditor({
			flex: 1,
			disableCalEditorStyle: this.disableCalEditorStyle,
			showValueInCalEditor: this.showValueInCalEditor
		});
		this.expandBtn = new EnterpriseSheet.common.SimpleButton({
			iconCls: "icon-list-drop",
			width: 20,
			color: "silver",
			handler: this.toggleContentbar,
			scope: this
		});
		this.items = [this.anchorBtn, this.posBox, this.splitBtn, this.enterBtn, this.escBtn, this.contentBox, this.expandBtn];
		this.callParent(arguments);
		this.contentBox.on({
			scope: this,
			afterstartedit: function() {
				this.enterBtn.enable();
				this.escBtn.enable();
			},
			quit: function() {
				this.enterBtn.disable();
				this.escBtn.disable();
			}
		});
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.contentBox.init(sheet);
		this.mon(sheet, "focuschange", this.checkFocusChange, this);
		this.mon(sheet, "refreshfocus", this.checkFocusChange, this);
		this.mon(sheet, "changereadonly", this.onChangeReadOnly, this);
		this.mon(sheet, "refreshfocus", this.onFocusChange, this, {
			buffer: 100
		});
		this.mon(sheet, "focuschange", this.onFocusChange, this, {
			buffer: 100
		});
		this.mon(sheet, "selectionchange", this.onSelectionChange, this, {
			buffer: 50
		});
		var store = sheet.getStore();
		this.mon(store, "renamesheet", this.refreshContentBox, this);
		this.mon(store, "deletesheet", this.refreshContentBox, this);
		this.contentBox.on({
			scope: this,
			editorfocus: this.onEditorFocus
		});
	},
	doAnchor: function() {
		this.sheet.go2LeftTop();
		this.sheet.focus(this.sheet.focusDelayTime);
	},
	checkFocusChange: function(row, col, sm, cd) {
		var ss = this.sheet,
			editor = ss.getEditor();
		var sheetId = ss.getSheetId();
		var store = ss.getStore();
		var contentBox = this.contentBox;
		if(ss.isReadOnly() || store.isDisabledCell(sheetId, row, col)) {
			if(!contentBox.inputing) {
				contentBox.disable();
			}
		} else {
			contentBox.enable();
		}
	},
	onEditorFocus: function() {
		var store = this.sheet.getStore();
		if(this.focusCell) {
			var row = this.focusCell.row,
				col = this.focusCell.col;
			var boxEl = this.posBox.getEl();
			if(boxEl) {
				boxEl.removeCls("ss-cross-pos");
			}
			this.posBox.update(store.getColName(col) + row);
		}
	},
	onChangeReadOnly: function(readOnly, sheet) {
		var contentBox = this.contentBox;
		if(readOnly) {
			if(!contentBox.inputing) {
				contentBox.disable();
			}
		} else {
			contentBox.enable();
		}
	},
	onSheetChange: function() {
		var sm = this.sheet.getSelectionModel(),
			store = this.sheet.getStore();
		var focusCell = sm.getFocusCell();
		this.onFocusChange(focusCell.row, focusCell.col, sm, store.getCell(store.getActivedSheetId(), focusCell.row, focusCell.col));
	},
	onFocusChange: function(row, col, sm, cd) {
		var ss = this.sheet,
			editor = ss.getEditor();
		var sheetId = ss.getSheetId();
		var store = ss.getStore();
		if(this.showValueInCalEditor) {
			cd = ss.getCellValue(sheetId, row, col);
		}
		var contentEditing = this.contentBox.isEditing(),
			editing = editor.isEditing();
		if(!contentEditing && !editing) {
			if(0 == row) {
				row = 1;
			}
			if(0 == col) {
				col = 1;
			}
			this.focusCell = {
				row: row,
				col: col
			};
			var boxEl = this.posBox.getEl();
			if(boxEl) {
				boxEl.removeCls("ss-cross-pos");
			}
			this.posBox.update(store.getColName(col) + row);
			var data = cd.data;
			if(SCOM.nullOrUndefined(data)) {
				data = "";
			}
			if(Ext.isNumber(cd.afrow)) {
				var afrow = cd.afrow + row,
					afcol = cd.afcol + col;
				if(afrow === row && afcol === col) {
					this.contentBox.setValue("{" + Ext.htmlEncode(data) + "}");
				} else {
					var afCell = store.getCell(sheetId, afrow, afcol);
					this.contentBox.setValue("{" + Ext.htmlEncode(afCell.data) + "}");
				}
			} else {
				this.contentBox.setValue(Ext.htmlEncode(data));
			}
		} else {
			var curEditor = contentEditing ? this.contentBox : editor;
			if(curEditor.sheetId != sheetId) {
				var sheetName = store.getSheetNameById(curEditor.sheetId);
				var boxEl = this.posBox.getEl();
				if(boxEl) {
					boxEl.addCls("ss-cross-pos");
				}
				this.posBox.update(sheetName + "!" + store.getColName(curEditor.col) + curEditor.row);
			} else {
				var boxEl = this.posBox.getEl();
				if(boxEl) {
					boxEl.removeCls("ss-cross-pos");
				}
				this.posBox.update(store.getColName(curEditor.col) + curEditor.row);
			}
		}
	},
	refreshContentBox: function() {
		if(this.focusCell) {
			var store = this.sheet.getStore();
			var cd = store.getCellData(store.getActivedSheetId(), this.focusCell.row, this.focusCell.col);
			var data = cd.data || "";
			this.contentBox.setValue(Ext.htmlEncode(data));
		}
	},
	onSelectionChange: function(startPos, endPos, region, sm) {
		if(startPos) {
			var rowSpan = Math.abs(startPos.row - endPos.row) + 1,
				colSpan = Math.abs(startPos.col - endPos.col) + 1;
			if(1 == rowSpan && 1 == colSpan) {} else if(1 == rowSpan) {
				this.posBox.update(colSpan + "C");
			} else if(1 == colSpan) {
				this.posBox.update(rowSpan + "R");
			} else {
				this.posBox.update(rowSpan + "R x " + colSpan + "C");
			}
		}
	},
	toggleContentbar: function(btn) {
		if("icon-list-drop" == btn.iconCls) {
			btn.setIconCls("icon-list-collapse");
			this.setHeight(this.epxandHeight);
		} else {
			btn.setIconCls("icon-list-drop");
			this.setHeight(this.collapsedHeight);
		}
		var editor = this.sheet.getEditor();
		if(editor) {
			editor.syncPosition();
		}
	},
	showNameList: function(btn) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var refs = store.getNamedFuncConfig();
		if(!this.nameList) {
			this.nameList = new EnterpriseSheet.sheet.pop.ReferenceNameList({
				sheet: sheet,
				refList: refs
			});
		} else {
			this.nameList.loadRefList(refs);
		}
		this.nameList.showBy(btn.getEl());
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.SheetTabbar", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.common.Common", "EnterpriseSheet.sheet.action.ActionBox", "Ext.button.Split", "EnterpriseSheet.common.SimpleButton", "Ext.ux.BoxReorderer", "Ext.window.MessageBox", "Ext.form.field.Text", "Ext.toolbar.Spacer", "EnterpriseSheet.sheet.pop.TextWin", "EnterpriseSheet.common.ColorMenu"],
	cls: "ss-sheet-tabbar",
	height: 30,
	layout: {
		type: "hbox",
		align: "stretch"
	},
	maxTitleLen: 100,
	tabThemeColor: "rgb(15,110,76)",
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.mon(this.sheet, {
			scope: this,
			switchsheet: this.onSwitchSheet,
			afterloadsheet: this.afterLoad,
			changereadonly: this.onChangeReadOnly
		});
		var store = sheet.getStore();
		if(store) {
			this.mon(store, {
				scope: this,
				updatesheettab: this.onUpdateSheetTab,
				deletesheet: this.onDeleteSheet,
				copysheet: this.onSheetCreated,
				addsheet: this.onSheetCreated,
				filecolorchanged: this.onFileColorChanged
			});
			this.initSheetButtons();
		}
	},
	initComponent: function() {
		this.sheetMenu = this.initSheetMenu();
		this.sheetBar = this.initSheetBar();
		this.displayItem = new Ext.toolbar.TextItem({
			style: "padding-left:26px;",
			text: "&nbsp;"
		});
		this.sheetListBtn = new EnterpriseSheet.common.SimpleButton({
			cls: "ss-sheet-list-btn fa fa-lg " + ("top" === SCONFIG.sheet_tab_bar_position ? "fa-angle-double-down" : "fa-angle-double-up"),
			color: "silver",
			width: 20,
			notSplited: true,
			menu: new Ext.menu.Menu({
				items: [],
				plain: true,
				minWidth: 160,
				bbar: {
					xtype: "toolbar",
					cls: "ss-sheetlist-bar",
					height: 25,
					border: false,
					items: [this.displayItem]
				},
				listeners: {
					beforeshow: {
						fn: this.beforeSheetListShow,
						scope: this
					}
				}
			})
		});
		this.addSheetBtn = Ext.create("EnterpriseSheet.common.SimpleButton", {
			color: this.tabThemeColor,
			width: 30,
			cls: "ss-simple-button-add",
			text: "+",
			handler: function() {
				this.addSheet();
			},
			scope: this
		});
		this.items = [this.addSheetBtn, this.sheetListBtn, this.sheetBar];
		this.callParent(arguments);
	},
	removeSheetBtns: function() {
		this.sheetBar.items.each(function(it) {
			if(!SCOM.nullOrUndefined(it.sheetId)) {
				this.sheetBar.remove(it);
			}
		}, this);
	},
	initSheetButtons: function() {
		this.removeSheetBtns();
		var ss = this.sheet,
			store = ss.getStore(),
			activeSheetId = ss.getSheetId();
		var sheets = store.getSheets(),
			loadedFile = store.getLoadedFile();
		var sheetListMenu = this.sheetListBtn.menu;
		sheetListMenu.removeAll();
		for(var i = 0, len = sheets.length; i < len; i++) {
			var s = sheets[i];
			var pressed = s.id == activeSheetId;
			var color = s.color || this.tabThemeColor;
			var btnObj = {
				xtype: "simplebtn",
				color: color,
				sheetId: s.id,
				hidden: s.hidden,
				pressed: pressed,
				toggleGroup: "sheetbar-overflow",
				enableToggle: true,
				text: s.name,
				menu: this.sheetMenu,
				handler: this.switchSheet,
				scope: this
			};
			if(s.width && s.width > 70) {
				Ext.apply(btnObj, {
					width: s.width
				});
				var maxLength = Math.round(s.width * 15 / 100 - 9);
				Ext.apply(btnObj, {
					maxTextLength: maxLength
				});
			}
			this.sheetBar.add(btnObj);
			sheetListMenu.add({
				group: "sheetbar-sheetlist",
				cls: s.hidden ? "ss-hidden-tab-item" : "",
				checked: pressed,
				sheetId: s.id,
				text: s.name,
				handler: this.switchSheetByMenu,
				scope: this
			});
		}
	},
	initSheetMenu: function(posItems) {
		this.nameField = new Ext.form.field.Text({
			width: 200,
			enableKeyEvents: true
		});
		this.deleteTabItem = Ext.create("Ext.menu.Item", {
			iconCls: "icon-delete",
			text: SLANG['delete'],
			handler: this.deleteSheet,
			scope: this
		});
		this.rowHeightItem = Ext.create("Ext.menu.Item", {
			iconCls: "icon-row-height",
			text: SLANG.row_height,
			handler: this.changeAllRowHeight,
			scope: this
		});
		this.columnWidthItem = new Ext.menu.Item({
			iconCls: "icon-column-width",
			text: SLANG.column_width,
			handler: this.changeAllColumnWidth,
			scope: this
		});
		this.tabWidthNumberField = new Ext.form.field.Number({
			width: 200,
			minValue: 50,
			maxValue: 600,
			enableKeyEvents: true
		});
		this.hideItem = new Ext.menu.Item({
			text: SLANG.hide,
			handler: this.hideSheet,
			scope: this
		});
		var items = [{
			text: SLANG.rename,
			menu: {
				plain: true,
				items: [{
					xtype: "label",
					cls: "sc-menu-label",
					text: SLANG.input_sheet_name
				}, this.nameField],
				listeners: {
					show: {
						fn: this.onNameFieldShow,
						scope: this
					}
				}
			}
		}, {
			text: SLANG.copy,
			handler: this.copySheet,
			scope: this
		}, this.deleteTabItem,
		//2018 6.28 去除颜色选择
/*		{
			text: SLANG.color,
			menu: new EnterpriseSheet.common.ColorMenu({
				selectHandler: this.changeTabColor,
				scope: this
			})
		}, */
		{
			text: SLANG.tab_width,
			menu: {
				plain: true,
				items: [{
					xtype: "label",
					cls: "sc-menu-label",
					text: SLANG.tab_width
				}, this.tabWidthNumberField],
				listeners: {
					show: {
						fn: this.onTabWidthFieldShow,
						scope: this
					}
				}
			}
		}, this.rowHeightItem, this.columnWidthItem, this.hideItem];
		if(Ext.isArray(posItems)) {
			items = items.concat(posItems);
		}
		this.sheetMenu = new Ext.menu.Menu({
			items: items
		});
		this.mon(this.sheetMenu, {
			scope: this,
			beforeshow: function() {
				if(this.sheet.isReadOnly()) {
					return false;
				}
				var store = this.sheet.getStore();
				var sheets = store.getSheets();
				if(1 >= sheets.length) {
					this.deleteTabItem.hide();
				} else {
					this.deleteTabItem.show();
				}
				var count = 0;
				for(var i = 0, len = sheets.length; i < len; i++) {
					var it = sheets[i];
					if(!it.hidden) {
						count++;
						if(2 <= count) {
							break;
						}
					}
				}
				if(1 >= count) {
					this.hideItem.hide();
				} else {
					this.hideItem.show();
				}
			}
		});
		this.mon(this.nameField, {
			scope: this,
			keydown: this.onNameFieldKeyDown
		});
		this.mon(this.tabWidthNumberField, {
			scope: this,
			keydown: this.onWidthFieldKeyDown
		});
		return this.sheetMenu;
	},
	onNameFieldKeyDown: function(field, e) {
		if(e.ENTER == e.getKey()) {
			e.stopEvent();
			this.renameSheet();
			this.sheetMenu.hide();
		}
	},
	onNameFieldShow: function() {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn) {
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var name = store.getSheetNameById(sheetId);
			this.nameField.setValue(name);
		}
	},
	onWidthFieldKeyDown: function(field, e) {
		if(e.ENTER == e.getKey()) {
			e.stopEvent();
			var width = this.tabWidthNumberField.getValue();
			this.resetTabWidth(width);
			this.sheetMenu.hide();
		}
	},
	onTabWidthFieldShow: function() {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn) {
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var width = store.getSheetWidthById(sheetId);
			if(width && width > 10) {
				this.tabWidthNumberField.setValue(width);
			} else {
				this.tabWidthNumberField.setValue();
			}
		}
	},
	changeAllRowHeight: function() {
		SPOP.showRowHeightBox({
			applyCallback: {
				fn: function(h) {
					this.sheet.setRowHeight(h, {
						minrow: 0,
						maxrow: 0
					});
				},
				scope: this
			}
		});
	},
	changeAllColumnWidth: function() {
		SPOP.showColumnWidthBox({
			applyCallback: {
				fn: function(w) {
					this.sheet.setColumnWidth(w, {
						mincol: 0,
						maxcol: 0
					});
				},
				scope: this
			}
		});
	},
	initSheetBar: function() {
		this.barReorder = Ext.create("Ext.ux.BoxReorderer", {
			listeners: {
				drop: {
					fn: this.afterReorder,
					scope: this
				}
			}
		});
		this.sheetBar = new Ext.toolbar.Toolbar({
			cls: "ss-transparent-toolbar ss-sheetbar",
			flex: 1,
			plugins: [this.barReorder],
			layout: {
				type: "hbox",
				align: "stretch",
				overflowHandler: "Scroller"
			},
			items: []
		});
		this.mon(this.sheetBar, {
			scope: this,
			afterlayout: function() {
				var layout = this.sheetBar.getLayout();
				var overflow = layout.overflowHandler;
				if(overflow) {
					var item;
					this.sheetBar.items.each(function(it) {
						if(it.pressed) {
							item = it;
							return false;
						}
					});
					if(item) {
						overflow.scrollToItem(item, true);
					}
				}
			}
		});
		return this.sheetBar;
	},
	getActivedSheetButton: function() {
		var actived;
		this.sheetBar.items.each(function(btn) {
			if(!SCOM.nullOrUndefined(btn.sheetId) && btn.isPressed()) {
				actived = btn;
				return false;
			}
		}, this);
		return actived;
	},
	afterLoad: function() {
		var loadedFile = this.sheet.getStore().getLoadedFile();
		var fileColor = null;
		if(loadedFile) {
			fileColor = loadedFile.color;
		}
		this.updateBackgroundColor(fileColor);
		this.initSheetButtons();
	},
	onFileColorChanged: function() {
		var loadedFile = this.sheet.getStore().getLoadedFile();
		var fileColor = null;
		if(loadedFile) {
			fileColor = loadedFile.color;
		}
		this.updateBackgroundColor(fileColor);
	},
	switchSheet: function(btn) {
		this.switchSheetByBtn(btn);
	},
	switchSheetByBtn: function(btn, callback, scope) {
		var sheet = this.sheet,
			store = sheet.getStore();
		var loadMask = sheet.loadMask;
		var sheetId = btn.sheetId;
		if(loadMask) {
			loadMask.show();
			Ext.Function.defer(function() {
				store.loadSheet(sheetId, function(success) {
					if(success) {
						sheet.switchSheet(sheetId, function() {
							loadMask.hide();
							if(callback) {
								callback.call(scope, sheetId, this);
							}
						}, this);
					} else {
						loadMask.hide();
					}
				}, this);
			}, 50);
		} else {
			store.loadSheet(sheetId, function(success) {
				if(success) {
					sheet.switchSheet(sheetId, function() {
						if(callback) {
							callback.call(scope, sheetId, this);
						}
					}, this);
				} else {
					loadMask.hide();
				}
			}, this);
		}
		var layout = this.sheetBar.getLayout();
		var overflow = layout.overflowHandler;
		if(overflow) {
			overflow.scrollToItem(btn, true);
		}
	},
	switchSheetByMenu: function(item) {
		var sheetId = item.sheetId;
		var store = this.sheet.getStore(),
			activeSheetId = store.getActivedSheetId();
		var sheetObj = store.getSheetById(sheetId);
		if(sheetObj.hidden) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.wanna_show_this_tab,
				buttons: Ext.Msg.YESNO,
				fn: function(bid) {
					var menu = this.sheetListBtn.menu;
					var item;
					menu.items.each(function(it) {
						if(it.sheetId == activeSheetId) {
							item = it;
							return false;
						}
					});
					if(item) {
						item.setChecked(true, true);
					}
					if("yes" === bid) {
						this.showSheetBySheetId(sheetId);
					}
				},
				scope: this
			});
		} else {
			var btn;
			this.sheetBar.items.each(function(it) {
				if(it.sheetId == sheetId) {
					btn = it;
					return false;
				}
			});
			if(btn) {
				this.switchSheetByBtn(btn);
			}
		}
	},
	onSwitchSheet: function(oldSheetId, sheetId, sheet) {
		var btn;
		this.sheetBar.items.each(function(it) {
			if(it.isPressed() && !SCOM.nullOrUndefined(it.sheetId)) {
				it.toggle(false, true);
			}
			if(it.sheetId == sheetId) {
				btn = it;
			}
		}, this);
		if(btn) {
			btn.toggle(true, true);
		}
		var menu = this.sheetListBtn.menu;
		var item;
		menu.items.each(function(it) {
			if(it.sheetId == sheetId) {
				item = it;
				return false;
			}
		});
		if(item) {
			item.setChecked(true, true);
		}
	},
	isExistedSheetName: function(name) {
		return this.sheet.getStore().isExistedSheetName(name);
	},
	addSheet: function(tabConfig, notSwitchToNewSheet, callback, scope) {
		var ss = this.sheet,
			store = ss.getStore(),
			activeSheetId = ss.getSheetId();
		if(ss.isReadOnly()) {
			Ext.Msg.alert(SLANG.error, SLANG.action_on_read_only);
			return false;
		}
		tabConfig = tabConfig || {};
		var sheets = store.getSheets();
		var len = sheets.length,
			name = tabConfig.name,
			color = tabConfig.color;
		if(name) {
			if(this.isExistedSheetName(name)) {
				Ext.Msg.alert(SLANG.error, SLANG.tab_name_existed);
				return false;
			}
		} else {
			name = SLANG.sheet + len;
			while(this.isExistedSheetName(name)) {
				len++;
				name = SLANG.sheet + len;
			}
			tabConfig.name = name;
		}
		var position = tabConfig.position;
		color = color || this.tabThemeColor;
		store.addSheet(tabConfig, function(data) {
			var btnObj = {
				xtype: "simplebtn",
				color: color,
				sheetId: data.id,
				text: name,
				menu: this.sheetMenu,
				handler: this.switchSheet,
				scope: this
			};
			var btn, menu = this.sheetListBtn.menu;
			var itemObj = {
				xtype: "menucheckitem",
				sheetId: data.id,
				text: name,
				group: "sheetbar-sheetlist",
				handler: this.switchSheetByMenu,
				scope: this
			};
			if(Ext.isNumber(position)) {
				btn = this.sheetBar.insert(position, btnObj);
				menu.insert(position, itemObj);
			} else {
				btn = this.sheetBar.add(btnObj);
				menu.add(itemObj);
			}
			if(!notSwitchToNewSheet) {
				this.switchSheetByBtn(btn, callback, scope);
			} else if(callback) {
				callback.call(scope, data.id, this);
			}
		}, this);
	},
	doDeleteSheet: function(btn) {
		var store = this.sheet.getStore();
		var sheetId = btn.sheetId;
		var isActived = btn.isPressed();
		var loadMask = this.sheet.loadMask;
		if(loadMask) {
			loadMask.show();
		}
		this.sheet.deleteSheet(sheetId, function(deleted, success) {
			if(success) {
				this.sheetBar.remove(btn);
				var item = this.getMenuItemBySheetId(sheetId);
				if(item) {
					this.sheetListBtn.menu.remove(item);
				}
				if(isActived) {
					var found;
					this.sheetBar.items.each(function(it) {
						if(it.isVisible()) {
							found = it;
							return false;
						}
					}, this);
					if(found) {
						this.switchSheetByBtn(found);
					}
				} else if(loadMask) {
					loadMask.hide();
				}
			} else if(loadMask) {
				loadMask.hide();
			}
		}, this);
	},
	hideSheet: function() {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn) {
			var isActived = btn.isPressed();
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var loadMask = this.sheet.loadMask;
			if(loadMask) {
				loadMask.show();
			}
			store.hideSheet(sheetId, function(sheetObj, store, success) {
				if(success) {
					btn.hide();
					this.sheetBar.doLayout();
					var item = this.getMenuItemBySheetId(sheetId);
					if(item) {
						item.addCls("ss-hidden-tab-item");
					}
					if(isActived) {
						var found;
						this.sheetBar.items.each(function(it) {
							if(it.isVisible()) {
								found = it;
								return false;
							}
						}, this);
						if(found) {
							this.switchSheetByBtn(found);
						}
					} else if(loadMask) {
						loadMask.hide();
					}
				} else if(loadMask) {
					loadMask.hide();
				}
			}, this);
		}
	},
	showSheetBySheetId: function(sheetId) {
		var btn;
		this.sheetBar.items.each(function(b) {
			if(b.sheetId === sheetId) {
				btn = b;
				return false;
			}
		});
		if(btn) {
			var store = this.sheet.getStore();
			var loadMask = this.sheet.loadMask;
			if(loadMask) {
				loadMask.show();
			}
			store.showSheet(sheetId, function(sheetObj, store, success) {
				if(success) {
					btn.show();
					this.sheetBar.doLayout();
					var item = this.getMenuItemBySheetId(sheetId);
					if(item) {
						item.removeCls("ss-hidden-tab-item");
					}
					if(loadMask) {
						loadMask.hide();
					}
				} else if(loadMask) {
					loadMask.hide();
				}
			}, this);
		}
	},
	deleteSheet: function() {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn) {
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var name = store.getSheetNameById(sheetId);
			Ext.Msg.show({
				title: SLANG.confirm,
				msg: SLANG.do_u_really_wanna_delete + " [" + name + "]?",
				buttons: Ext.Msg.YESNO,
				icon: Ext.Msg.QUESTION,
				fn: function(bid) {
					if("yes" == bid) {
						this.doDeleteSheet(btn);
					}
				},
				scope: this
			});
		}
	},
	getMenuItemBySheetId: function(sheetId) {
		var item;
		this.sheetListBtn.menu.items.each(function(it) {
			if(it.sheetId == sheetId) {
				item = it;
				return false;
			}
		});
		return item;
	},
	getBtnBySheetId: function(sheetId) {
		var item;
		this.sheetBar.items.each(function(it) {
			if(it.sheetId == sheetId) {
				item = it;
				return false;
			}
		});
		return item;
	},
	renameSheet: function() {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		var newName = this.nameField.getValue();
		if(btn && newName) {
			var valid = EnterpriseSheet.sheet.calculate.Coordinate.prototype.sheetNameReg.test(newName);
			if(valid) {
				var sheetId = btn.sheetId;
				var store = this.sheet.getStore();
				var name = store.getSheetNameById(sheetId);
				if(name != newName) {
					store.renameSheet(sheetId, newName, function() {
						btn.setText(newName);
						var item = this.getMenuItemBySheetId(sheetId);
						if(item) {
							item.setText(newName);
						}
						if(Ext.isFunction(this.sheetBar.doLayout)) {
							this.sheetBar.doLayout();
						} else if(Ext.isFunction(this.sheetBar.updateLayout)) {
							this.sheetBar.updateLayout();
						}
					}, this);
				}
			} else {
				Ext.Msg.alert(SLANG.hint, SLANG.sheet_name_invalid);
			}
		}
	},
	afterReorder: function(reorder, bar, box, startIndex, currentIndex) {
		if(this.sheet) {
			this.reorderBox = box;
			this.sheet.changeSheetOrder(startIndex, currentIndex, function(success) {
				if(success) {
					this.sheetBar.insert(currentIndex, this.reorderBox);
				} else {
					this.sheetBar.insert(startIndex, this.reorderBox);
				}
			}, this);
		}
	},
	copySheet: function() {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn) {
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var sheetName = store.getCopyName(sheetId);
			SPOP.showTextBox({
				title: SLANG.copy_sheet_to,
				fieldLabel: SLANG.input_sheet_name,
				value: sheetName,
				applyCallback: {
					fn: function(name) {
						store.copySheet(sheetId, name, function(data) {
							this.sheetBar.add({
								xtype: "simplebtn",
								color: data.color || this.tabThemeColor,
								sheetId: data.id,
								text: data.name,
								menu: this.sheetMenu,
								handler: this.switchSheet,
								scope: this
							});
							this.sheetListBtn.menu.add({
								group: "sheetbar-sheetlist",
								checked: false,
								sheetId: data.id,
								text: data.name,
								handler: this.switchSheetByMenu,
								scope: this
							});
						}, this);
					},
					scope: this
				}
			});
		}
	},
	beforeSheetListShow: function(menu) {
		var len = menu.items.getCount();
		this.displayItem.setText(SLANG.total_sheet_number + ": " + len);
	},
	changeTabColor: function(cp, color) {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn) {
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var sheet = store.getSheetById(sheetId);
			if(sheet.color !== color) {
				store.changeSheetColor(sheetId, color, function() {
					btn.setBtnColor(color);
				}, this);
			}
		}
	},
	resetTabWidth: function(width) {
		var menu = this.sheetMenu;
		var btn = menu.bindBtn;
		if(btn) {
			var sheetId = btn.sheetId;
			var store = this.sheet.getStore();
			var sheet = store.getSheetById(sheetId);
			if(width < 50) {
				width = 50;
			}
			store.changeSheetWidth(sheetId, width, function() {
				btn.setBtnWidth(width);
				var maxLength = Math.round(width * 15 / 100 - 9);
				btn.setMaxTextLength(maxLength);
				btn.setText(btn.getText());
				if(Ext.isFunction(this.sheetBar.doLayout)) {
					this.sheetBar.doLayout();
				} else if(Ext.isFunction(this.sheetBar.updateLayout)) {
					this.sheetBar.updateLayout();
				}
			}, this);
		}
	},
	onChangeReadOnly: function(readOnly, sheet) {
		if(readOnly) {
			this.addSheetBtn.hide();
			for(var i = 0, len = this.sheetBar.items.getCount(); i < len; i++) {
				var it = this.sheetBar.items.get(i);
				it.reorderable = false;
			}
			this.addCls("ss-disabled-sheetbar");
		} else {
			this.addSheetBtn.show();
			for(var i = 0, len = this.sheetBar.items.getCount(); i < len; i++) {
				var it = this.sheetBar.items.get(i);
				it.reorderable = true;
			}
			this.removeCls("ss-disabled-sheetbar");
		}
	},
	onUpdateSheetTab: function(sheetId) {
		var store = this.sheet.getStore();
		var sheetTab = store.getSheetById(sheetId);
		var btn = this.getBtnBySheetId(sheetId);
		if(sheetTab.name) {
			btn.setText(sheetTab.name);
		}
		if(sheetTab.color) {
			btn.setBtnColor(sheetTab.color);
		}
		if(sheetId === store.getActivedSheetId()) {
			btn.toggle(true, true);
		} else {
			btn.toggle(false, true);
		}
		var item = this.getMenuItemBySheetId(sheetId);
		if(item) {
			item.setText(sheetTab.name);
		}
		var index = this.sheetBar.items.indexOf(btn);
		if(Ext.isNumber(sheetTab.position) && index !== sheetTab.position) {
			this.sheetBar.insert(sheetTab.position, btn);
			this.sheetListBtn.menu.insert(sheetTab.position, item);
		}
		if(Ext.isFunction(this.sheetBar.doLayout)) {
			this.sheetBar.doLayout();
		} else if(Ext.isFunction(this.sheetBar.updateLayout)) {
			this.sheetBar.updateLayout();
		}
	},
	onDeleteSheet: function(sheetId) {
		var btn = this.getBtnBySheetId(sheetId);
		var item = this.getMenuItemBySheetId(sheetId);
		if(btn) {
			this.sheetBar.remove(btn);
		}
		if(item) {
			this.sheetListBtn.menu.remove(item);
		}
	},
	onSheetCreated: function(sheetId) {
		var btn = this.getBtnBySheetId(sheetId);
		var store = this.sheet.getStore();
		if(!btn) {
			var sheetTab = store.getSheetById(sheetId);
			var index = store.indexOfSheetId(sheetId);
			var btnObj = {
				xtype: "simplebtn",
				color: sheetTab.color || this.tabThemeColor,
				sheetId: sheetId,
				text: sheetTab.name,
				menu: this.sheetMenu,
				handler: this.switchSheet,
				scope: this
			};
			var itemObj = {
				group: "sheetbar-sheetlist",
				checked: false,
				sheetId: sheetId,
				text: sheetTab.name,
				handler: this.switchSheetByMenu,
				scope: this
			};
			if(Ext.isNumber(index)) {
				btn = this.sheetBar.insert(index, btnObj);
				this.sheetListBtn.menu.insert(index, itemObj);
			} else {
				btn = this.sheetBar.add(btnObj);
				this.sheetListBtn.menu.add(itemObj);
			}
			if(sheetId === store.getActivedSheetId()) {
				btn.toggle(true, true);
			}
			var layout = this.sheetBar.getLayout();
			var overflow = layout.overflowHandler;
			if(overflow) {
				overflow.scrollToItem(btn, true);
			}
		}
	},
	updateBackgroundColor: function(color) {
		var el = this.sheetBar.getEl();
		el.setStyle("background-color", color ? "#" + color : "");
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.Toolbar", {
	extend: "Ext.container.Container",
	requires: ["EnterpriseSheet.sheet.action.ActionBox", "EnterpriseSheet.sheet.history.History", "EnterpriseSheet.sheet.history.HistoryButton", "EnterpriseSheet.sheet.toolbar.pieces.BrushButton", "EnterpriseSheet.sheet.toolbar.pieces.FontFamilyButton", "EnterpriseSheet.sheet.toolbar.pieces.FontSizeButton", "EnterpriseSheet.sheet.toolbar.pieces.BorderButton", "EnterpriseSheet.sheet.toolbar.pieces.FontColorButton", "EnterpriseSheet.sheet.toolbar.pieces.BackgroundColorButton", "EnterpriseSheet.sheet.toolbar.pieces.MoneyButton", "EnterpriseSheet.common.toolbar.BorderToolbar", "EnterpriseSheet.sheet.pop.DateSelectWin"],
	cls: "ss-toolbar",
	height: 33,
	constructor: function() {
		this.pieces = [];
		this.defaultText = SLANG ? SLANG.ready : "Ready";
		this.callParent(arguments);
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.history.init(sheet);
		this.initPieces(sheet);
		this.store = this.sheet.getStore();
		this.mon(sheet, "refreshfocus", this.onFocusChange, this, {
			buffer: 100
		});
		this.mon(sheet, "focuschange", this.onFocusChange, this, {
			buffer: 100
		});
		this.mon(sheet, {
			scope: this,
			changereadonly: this.onChangeReadOnly
		});
	},
	initPieces: function(sheet) {
		if("array" == SCOM.typeOf(this.pieces)) {
			for(var i = 0, len = this.pieces.length; i < len; i++) {
				this.pieces[i].bindSheet(sheet);
			}
		}
	},
	layout: {
		type: "hbox",
		align: "middle",
		overflowHandler: "Menu",
		padding: "0 45 0 30"
	},
	initComponent: function() {
		this.items = this.prepareIcons();
		this.callParent(arguments);
	},
	prepareIcons: function() {
		this.cutBtn = new Ext.Button(SABOX.get("cut", {
			iconCls: "fa fa-cut",
			text: "",
			tooltip: SLANG.cut_tip,
			overflowText: SLANG.cut,
			sender: this
		}));
		this.copyBtn = new Ext.Button(SABOX.get("copy", {
			iconCls: "fa fa-copy",
			text: "",
			tooltip: SLANG.copy_tip,
			overflowText: SLANG.copy,
			sender: this
		}));
		this.pasteBtn = new Ext.button.Button(SABOX.get("paste", {
			iconCls: "fa fa-paste",
			text: "",
			tooltip: SLANG.paste_tip,
			overflowText: SLANG.paste,
			sender: this
		}));
		var historyClassName = this.historyClassName || "EnterpriseSheet.sheet.history.History";
		this.history = Ext.create(historyClassName, {});
		this.undoBtn = new EnterpriseSheet.sheet.history.HistoryButton({
			iconCls: "fa fa-undo",
			history: this.history,
			tooltip: SLANG.undo,
			overflowText: SLANG.undo
		});
		this.redoBtn = new EnterpriseSheet.sheet.history.HistoryButton({
			iconCls: "fa fa-repeat",
			mode: "redo",
			history: this.history,
			tooltip: SLANG.redo,
			overflowText: SLANG.redo
		});
		this.brushBtn = new EnterpriseSheet.sheet.toolbar.pieces.BrushButton({
			iconCls: "fa fa-paint-brush",
			tooltip: SLANG.format_brush,
			overflowText: SLANG.format_brush
		});
		this.pieces.push(this.brushBtn);
		this.fontFamilyBtn = new EnterpriseSheet.sheet.toolbar.pieces.FontFamilyButton({
			tooltip: SLANG.font_family,
			overflowText: SLANG.font_family
		});
		this.pieces.push(this.fontFamilyBtn);
		this.fontSizeBtn = new EnterpriseSheet.sheet.toolbar.pieces.FontSizeButton({
			tooltip: SLANG.font_size,
			overflowText: SLANG.font_size
		});
		this.pieces.push(this.fontSizeBtn);
		this.sizeIncBtn = new Ext.Button(SABOX.get("incFontSize", {
			tooltip: SLANG.increase_font_size,
			overflowText: SLANG.increase_font_size,
			sender: this
		}));
		this.sizeDesBtn = new Ext.Button(SABOX.get("descFontSize", {
			tooltip: SLANG.decrease_font_size,
			overflowText: SLANG.decrease_font_size,
			sender: this
		}));
		this.boldBtn = new Ext.Button(SABOX.get("bold", {
			enableToggle: true,
			tooltip: SLANG.bold_tip,
			iconCls: "fa fa-bold",
			text: "",
			overflowText: SLANG.bold,
			sender: this
		}));
		this.italicBtn = new Ext.Button(SABOX.get("italic", {
			enableToggle: true,
			tooltip: SLANG.italic_tip,
			iconCls: "fa fa-italic",
			text: "",
			overflowText: SLANG.italic,
			sender: this
		}));
		this.underlineBtn = new Ext.Button(SABOX.get("underline", {
			enableToggle: true,
			tooltip: SLANG.underline_tip,
			iconCls: "fa fa-underline",
			text: "",
			overflowText: SLANG.underline,
			sender: this
		}));
		this.strikeBtn = new Ext.Button(SABOX.get("strike", {
			enableToggle: true,
			tooltip: SLANG.strike,
			iconCls: "fa fa-strikethrough",
			text: "",
			overflowText: SLANG.strike,
			sender: this
		}));
		this.borderBtn = new EnterpriseSheet.sheet.toolbar.pieces.BorderButton({
			tooltip: SLANG.border,
			overflowText: SLANG.border
		});
		this.pieces.push(this.borderBtn);
		this.fontBtn = new EnterpriseSheet.sheet.toolbar.pieces.FontColorButton({
			iconCls: "",
			iconCls: "fa fa-pencil",
			tooltip: SLANG.font_color,
			overflowText: SLANG.font_color
		});
		this.pieces.push(this.fontBtn);
		this.paintcanBtn = new EnterpriseSheet.sheet.toolbar.pieces.BackgroundColorButton({
			iconCls: "fa fi-fill",
			tooltip: SLANG.background_color,
			overflowText: SLANG.background_color
		});
		this.pieces.push(this.paintcanBtn);
		var listeners = {
			click: {
				fn: function() {
					this.alignBtn.menu.hide();
					this.sheet.focus();
				},
				scope: this
			}
		};
		this.alignLeftBtn = Ext.create("Ext.Button", SABOX.get("alignLeft", {
			tooltip: SLANG.align_left,
			text: "",
			listeners: listeners,
			sender: this
		}));
		this.alignCenterBtn = Ext.create("Ext.Button", SABOX.get("alignCenter", {
			tooltip: SLANG.align_center,
			style: "margin-left:3px;",
			text: "",
			listeners: listeners,
			sender: this
		}));
		this.alignRightBtn = Ext.create("Ext.Button", SABOX.get("alignRight", {
			tooltip: SLANG.align_right,
			style: "margin-left:3px;",
			text: "",
			listeners: listeners,
			sender: this
		}));
		this.alignTopBtn = Ext.create("Ext.Button", SABOX.get("alignTop", {
			tooltip: SLANG.align_top,
			style: "margin-left:3px;",
			text: "",
			listeners: listeners,
			sender: this
		}));
		this.alignMiddleBtn = Ext.create("Ext.Button", SABOX.get("alignMiddle", {
			tooltip: SLANG.align_middle,
			style: "margin-left:3px;",
			text: "",
			listeners: listeners,
			sender: this
		}));
		this.alignBottomBtn = Ext.create("Ext.Button", SABOX.get("alignBottom", {
			tooltip: SLANG.align_bottom,
			style: "margin-left:3px;",
			text: "",
			listeners: listeners,
			sender: this
		}));
		this.alignBtn = new Ext.Button({
			iconCls: "icon-align-left",
			tooltip: SLANG.align,
			overflowText: SLANG.align,
			menu: {
				plain: true,
				items: [{
					xtype: "toolbar",
					border: false,
					style: "background:white;",
					defaults: {
						xtype: "button"
					},
					items: [this.alignLeftBtn, this.alignCenterBtn, this.alignRightBtn, this.alignTopBtn, this.alignMiddleBtn, this.alignBottomBtn]
				}]
			}
		});
		this.wordWrapBtn = new Ext.Button(SABOX.get("wordWrap", {
			iconCls: "fa fi-wordwrap",
			tooltip: SLANG.word_wrap,
			text: "",
			overflowText: SLANG.word_wrap,
			sender: this
		}));
		this.combineBtn = new Ext.button.Split(SABOX.get("mergeCell", {
			iconCls: "fa fi-merge-center",
			text: "",
			tooltip: SLANG.merge_cell,
			overflowText: SLANG.merge_cell,
			menu: new Ext.menu.Menu({
				items: [SABOX.get("mergeCell", {
					iconCls: "fa fi-merge-center",
					text: SLANG.merge_cell,
					sender: this
				}), SABOX.get("mergeColumn", {
					iconCls: "fa fi-merge-row",
					text: SLANG.merge_cell_in_column,
					sender: this
				}), SABOX.get("mergeRow", {
					iconCls: "fa fi-merge-row",
					text: SLANG.merge_cell_in_row,
					sender: this
				}), SABOX.get("cancelMerge", {
					iconCls: "fa fi-cancel-merge",
					text: SLANG.cancel_merge_cell,
					sender: this
				})]
			}),
			sender: this
		}));
		this.formulaMenu = new Ext.menu.Menu({
			items: [SABOX.get("sum", {
				text: SLANG.sum,
				sender: this
			}), SABOX.get("average", {
				text: SLANG.average,
				sender: this
			}), SABOX.get("count", {
				text: SLANG.count,
				sender: this
			}), SABOX.get("maxValue", {
				text: SLANG.max,
				sender: this
			}), SABOX.get("minValue", {
				text: SLANG.min,
				sender: this
			}), "-", SABOX.get("insertFormula", {
				iconCls: "icon-fx",
				text: SLANG.more_functions + "...",
				sender: this
			})]
		});
		this.formulaBtn = new Ext.Button({
			iconCls: "fa fa-calculator",
			tooltip: SLANG['function'],
			overflowText: SLANG['function'],
			menu: this.formulaMenu
		});
		this.filterMenu = new Ext.menu.Menu({
			items: [SABOX.get("sortAsc", {
				iconCls: "icon-sort-asc",
				text: SLANG.sort_asc,
				disabled: SCONFIG.SORT_DISABLE,
				sender: this
			}), SABOX.get("sortDesc", {
				iconCls: "icon-sort-desc",
				text: SLANG.sort_desc,
				disabled: SCONFIG.SORT_DISABLE,
				sender: this
			}), {
				text: SLANG.filtering,
				handler: this.toggleFiltering,
				scope: this
			}],
			listeners: {
				show: {
					fn: this.onFilterMenuShow,
					scope: this
				}
			}
		});
		this.filterBtn = new Ext.Button({
			iconCls: "fa fa-filter",
			tooltip: SLANG.filter_sort,
			overflowText: SLANG.filter_sort,
			menu: this.filterMenu
		});
		this.cleanRangeBtn = new Ext.button.Button({
			iconCls: "fa fa-eraser",
			tooltip: SLANG.clear,
			overflowText: SLANG.clear,
			menu: new Ext.menu.Menu({
				items: [SABOX.get("clean", {
					text: SLANG.clean_all,
					sender: this
				}), SABOX.get("cleanContent", {
					text: SLANG.clean_content,
					sender: this
				}), SABOX.get("cleanStyle", {
					text: SLANG.clean_style,
					sender: this
				})]
			})
		});
		this.editableBtn = this.getEditableBtn();
		this.moneyBtn = new EnterpriseSheet.sheet.toolbar.pieces.MoneyButton({
			tooltip: SLANG.money,
			overflowText: SLANG.money,
			iconCls: "fa fa-money"
		});
		this.pieces.push(this.moneyBtn);
		this.dotMoveLeftBtn = new Ext.Button(SABOX.get("leftDot", {
			iconCls: "fa fi-dot-left",
			tooltip: SLANG.decimalIncrease,
			overflowText: SLANG.dot_move_left,
			sender: this
		}));
		this.dotMoveRightBtn = new Ext.Button(SABOX.get("rightDot", {
			iconCls: "fa fi-dot-right",
			tooltip: SLANG.decimalDecrease,
			overflowText: SLANG.dot_move_right,
			sender: this
		}));
		this.percentBtn = new Ext.Button(SABOX.get("percentFormat", {
			tooltip: SLANG.percent,
			overflowText: SLANG.percent,
			sender: this
		}));
		this.commaBtn = new Ext.Button(SABOX.get("commaFormat", {
			tooltip: SLANG.comma,
			overflowText: SLANG.comma,
			sender: this
		}));
		this.dateTimeWin = Ext.create("EnterpriseSheet.sheet.pop.DateSelectWin", {});
		this.pieces.push(this.dateTimeWin);
		this.initDateFormatMenu();
		this.dateBtn = new Ext.Button({
			iconCls: "fa fa-calendar",
			tooltip: SLANG.date,
			menu: this.dateFormatMenu
		});
		var icons = [this.undoBtn, this.redoBtn, {
			xtype: "tbspacer",
			width: 10
		}, this.cutBtn, this.copyBtn, this.pasteBtn, {
			xtype: "tbspacer",
			width: 10
		}, this.brushBtn, {
			xtype: "tbspacer",
			flex: 1
		}, this.boldBtn, this.underlineBtn, this.italicBtn, this.strikeBtn, {
			xtype: "tbspacer",
			flex: 1
		}, this.fontFamilyBtn, this.fontSizeBtn, this.sizeIncBtn, this.sizeDesBtn, this.fontBtn, this.wordWrapBtn, {
			xtype: "tbspacer",
			flex: 1
		}, this.alignBtn, this.paintcanBtn, this.borderBtn, this.combineBtn, {
			xtype: "tbspacer",
			flex: 1
		}, this.dotMoveLeftBtn, this.dotMoveRightBtn, {
			xtype: "tbspacer",
			width: 10
		}, this.moneyBtn, this.percentBtn, this.commaBtn, this.dateBtn, {
			xtype: "tbspacer",
			flex: 1
		}, this.filterBtn, this.formulaBtn, this.cleanRangeBtn, this.editableBtn];
		return icons;
	},
	getEditableBtn: function() {
		return new Ext.Button({
			iconCls: "fa fa-lock",
			menu: {
				plain: true,
				defaults: {
					xtype: "menucheckitem"
				},
				items: [SABOX.get("editable", {
					group: "editable",
					text: SLANG.lock_edit_for_all,
					sender: this
				}), SABOX.get("lockOtherEdit", {
					group: "editable",
					text: SLANG.lock_edit_for_other,
					sender: this
				})]
			}
		});
	},
	onFilterMenuShow: function() {
		var filterItem = this.filterMenu.items.last();
		var sheet = this.sheet,
			sheetId = sheet.getSheetId();
		var store = sheet.getStore();
		if(store.withFilterInSheet(sheetId)) {
			filterItem.setText(SLANG.cancel_filtering);
			filterItem.setIconCls("icon-cross");
			filterItem.filtered = true;
		} else {
			filterItem.setText(SLANG.filtering);
			filterItem.setIconCls();
			filterItem.filtered = false;
		}
	},
	initDateFormatMenu: function() {
		var formats = SCONST.jsDateFm;
		var formatDetails = SCONST.javaDateFm;
		var items = [];
		var today = new Date;
		for(var i = 0, len = formats.length; i < len; i++) {
			var fm = formats[i];
			var fmDetail = formatDetails[i];
			items.push({
				iconCls: "icon-date-go",
				text: Ext.Date.format(today, fm),
				fm: fm,
				handler: this.selectDateFormat,
				scope: this
			});
		}
		var timeFts = SCONST.jsTimeFm;
		for(var i = 0, len = timeFts.length; i < len; i++) {
			var fm = timeFts[i];
			items.push({
				iconCls: "icon-time",
				text: Ext.Date.format(today, fm),
				fm: fm,
				handler: this.selectTimeFormat,
				scope: this
			});
		}
		var dateTimeFts = SCONST.jsDateTimeFm;
		var dateTimeFormatDetails = SCONST.javaDateTimeFm;
		for(var i = 0, len = dateTimeFts.length; i < len; i++) {
			var fm = dateTimeFts[i];
			var fmDetail = dateTimeFormatDetails[i];
			items.push({
				text: Ext.Date.format(today, fm),
				fm: fm,
				handler: this.selectDateTimeFormat,
				scope: this
			});
		}
		items.push({
			text: SLANG.more + "...",
			handler: this.moreDateTimeFormat,
			scope: this
		});
		this.dateFormatMenu = Ext.create("Ext.menu.Menu", {
			defaults: {
				group: Ext.id() + "-date",
				checked: false
			},
			width: 180,
			items: items
		});
	},
	moreDateTimeFormat: function() {
		this.dateTimeWin.popup();
	},
	selectDateFormat: function(btn) {
		var fm = btn.fm;
		this.sheet.setDateFormatForSelection(fm);
	},
	selectTimeFormat: function(btn) {
		var fm = btn.fm;
		this.sheet.setTimeFormatForSelection(fm);
	},
	selectDateTimeFormat: function(btn) {
		var fm = btn.fm;
		this.sheet.setDateTimeFormatForSelection(fm);
	},
	toggleFiltering: function(item) {
		var sheet = this.sheet,
			filter = sheet.getFilter();
		if(filter) {
			if(item.filtered) {
				filter.cleanFilterForSheet(sheet.getSheetId(), false, false);
			} else {
				filter.createFilterForSelecton();
			}
			sheet.focus();
		}
	},
	updateStatus: function(row, col) {
		var ss = this.sheet;
		var sheetId = ss.getSheetId();
		var store = ss.getStore();
		var cell = store.getCellData(sheetId, row, col, undefined, undefined, undefined, true);
		this.fontFamilyBtn.setFontFamily(cell.ff);
		this.fontSizeBtn.setFontSize(cell.fz);
		if("bold" == cell.fw) {
			this.boldBtn.toggle(true, true);
		} else {
			this.boldBtn.toggle(false, true);
		}
		if("italic" == cell.fs) {
			this.italicBtn.toggle(true, true);
		} else {
			this.italicBtn.toggle(false, true);
		}
		if("underline" == cell.u) {
			this.underlineBtn.toggle(true, true);
		} else {
			this.underlineBtn.toggle(false, true);
		}
		if("line-through" == cell.s) {
			this.strikeBtn.toggle(true, true);
		} else {
			this.strikeBtn.toggle(false, true);
		}
		if("normal" == cell.ws) {
			this.wordWrapBtn.toggle(true, true);
		} else {
			this.wordWrapBtn.toggle(false, true);
		}
		if("center" == cell.ta) {
			this.alignLeftBtn.toggle(false, true);
			this.alignCenterBtn.toggle(true, true);
			this.alignRightBtn.toggle(false, true);
		} else if("right" == cell.ta) {
			this.alignLeftBtn.toggle(false, true);
			this.alignCenterBtn.toggle(false, true);
			this.alignRightBtn.toggle(true, true);
		} else if("left" == cell.ta) {
			this.alignLeftBtn.toggle(true, true);
			this.alignCenterBtn.toggle(false, true);
			this.alignRightBtn.toggle(false, true);
		} else if(Ext.isNumber(Number(cell.data)) || Ext.isNumber(Number(cell.value))) {
			this.alignLeftBtn.toggle(false, true);
			this.alignCenterBtn.toggle(false, true);
			this.alignRightBtn.toggle(true, true);
		} else {
			this.alignLeftBtn.toggle(true, true);
			this.alignCenterBtn.toggle(false, true);
			this.alignRightBtn.toggle(false, true);
		}
		if("middle" == cell.va) {
			this.alignTopBtn.toggle(false, true);
			this.alignMiddleBtn.toggle(true, true);
			this.alignBottomBtn.toggle(false, true);
		} else if("bottom" == cell.va) {
			this.alignTopBtn.toggle(false, true);
			this.alignMiddleBtn.toggle(false, true);
			this.alignBottomBtn.toggle(true, true);
		} else {
			this.alignTopBtn.toggle(true, true);
			this.alignMiddleBtn.toggle(false, true);
			this.alignBottomBtn.toggle(false, true);
		}
		this.updateEditableBtnState(cell);
	},
	updateEditableBtnState: function(cell) {
		if(cell.dsd) {
			this.editableBtn.toggle(true, true);
			var menu = this.editableBtn.menu;
			if("ed" == cell.dsd) {
				menu.items.get(0).setChecked(true, true);
				menu.items.get(1).setChecked(false, true);
			} else {
				menu.items.get(0).setChecked(false, true);
				menu.items.get(1).setChecked(true, true);
			}
		} else {
			this.editableBtn.toggle(false, true);
			var menu = this.editableBtn.menu;
			menu.items.get(0).setChecked(false, true);
			menu.items.get(1).setChecked(false, true);
		}
	},
	onFocusChange: function(row, col, sm, cd) {
		this.updateStatus(row, col);
	},
	onFindReplace: function() {
		this.fireEvent("findreplace", this);
	},
	onShowCharts: function() {
		this.fireEvent("showCharts", this);
	},
	onShowTables: function() {
		this.fireEvent("showTables", this);
	},
	onShowCellStyles: function() {
		this.fireEvent("showcellstyles", this);
	},
	onConditionMgr: function() {
		this.fireEvent("showconditionmgr", this);
	},
	onLinkFunctionList: function() {
		window.open("http://www.enterprisesheet.com/enterpriseSheetFormulas.jsp");
	},
	onChangeReadOnly: function(readOnly, sheet) {
		if(readOnly) {
			this.disable();
		} else {
			this.enable();
		}
	},
	getHistory: function() {
		return this.history;
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.Sidebar", {
	extend: "Ext.panel.Panel",
	requires: ["Ext.layout.container.Card", "Ext.toolbar.Spacer", "EnterpriseSheet.sheet.model.InfoModel", "EnterpriseSheet.sheet.toolbar.options.PictureOption", "EnterpriseSheet.sheet.toolbar.options.WedgitOption", "EnterpriseSheet.sheet.toolbar.options.SearchOption", "EnterpriseSheet.sheet.toolbar.options.ChartOption", "EnterpriseSheet.sheet.toolbar.options.TableTemplateOption", "EnterpriseSheet.sheet.toolbar.options.CellTemplateOption", "EnterpriseSheet.sheet.toolbar.options.ConditionOption"],
	border: false,
	autoWidth: true,
	width: 45,
	optionPaneWidth: 200,
	layout: "fit",
	constructor: function() {
		this.pieces = [];
		this.callParent(arguments);
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.initPieces(sheet);
		var sm = sheet.getSelectionModel();
		if(sm) {
			this.mon(sm, "selectionchange", this.onSelectionChange, this, {
				buffer: 500
			});
		}
		this.mon(sheet, {
			scope: this,
			changereadonly: this.onChangeReadOnly
		});
	},
	initPieces: function(sheet) {
		if("array" == SCOM.typeOf(this.pieces)) {
			for(var i = 0, len = this.pieces.length; i < len; i++) {
				this.pieces[i].bindSheet(sheet);
			}
		}
	},
	initComponent: function() {
		this.cls = this.cls || "";
		this.cls = "ss-sidebar " + this.cls;
		this.initOptionPane();
		this.searchBtn = new Ext.Button({
			iconCls: "fa fa-binoculars",
			cls: "option-button",
			scale: "large",
			iconAlign: "top",
			tooltip: SLANG.search,
			arrowAlign: "bottom",
			toggleGroup: "ss-side",
			name: "search",
			handler: this.toggleOption,
			scope: this
		});
		this.pictureBtn = new Ext.Button({
			iconCls: "fa fa-photo",
			cls: "option-button",
			scale: "large",
			iconAlign: "top",
			tooltip: SLANG.picture,
			arrowAlign: "bottom",
			toggleGroup: "ss-side",
			name: "picture",
			handler: this.toggleOption,
			scope: this
		});
		this.wedgitBtn = new Ext.Button({
			iconCls: "fa fa-puzzle-piece",
			cls: "option-button",
			scale: "large",
			iconAlign: "top",
			tooltip: SLANG.wedgit,
			arrowAlign: "bottom",
			toggleGroup: "ss-side",
			name: "wedgit",
			handler: this.toggleOption,
			scope: this
		});
		this.conditionStyleBtn = new Ext.Button({
			iconCls: "fa fa-tasks",
			cls: "option-button",
			scale: "large",
			iconAlign: "top",
			arrowAlign: "bottom",
			tooltip: SLANG.condition,
			toggleGroup: "ss-side",
			name: "condition",
			handler: this.toggleOption,
			scope: this
		});
		this.tableStyleBtn = new Ext.Button({
			iconCls: "fa fa-table",
			cls: "option-button",
			scale: "large",
			iconAlign: "top",
			tooltip: "&nbsp;&nbsp;" + SLANG.table + "&nbsp;&nbsp;",
			arrowAlign: "bottom",
			toggleGroup: "ss-side",
			name: "table",
			handler: this.toggleOption,
			scope: this
		});
		this.cellStyleBtn = new Ext.Button({
			iconCls: "fa fa-font",
			cls: "option-button",
			scale: "large",
			iconAlign: "top",
			arrowAlign: "bottom",
			tooltip: SLANG.cell,
			toggleGroup: "ss-side",
			name: "cell",
			handler: this.toggleOption,
			scope: this
		});
		this.chartBtn = new Ext.Button({
			scale: "large",
			iconCls: "fa fa-bar-chart",
			cls: "option-button",
			iconAlign: "top",
			arrowAlign: "bottom",
			tooltip: SLANG.chart,
			toggleGroup: "ss-side",
			name: "chart",
			handler: this.toggleOption,
			scope: this
		});
		this.initInfoStore();
		this.infoView = new Ext.view.View({
			store: this.infoStore,
			tpl: new Ext.XTemplate(["<tpl for=\".\">", "<div class=\"ss-cal-info-item {[0===xindex%2?\"ss-cal-info-item-strip\":\"\"]}\">", "<div class=\"ss-cal-info-item-inner\" data-qtip=\"{value}\">", "<div class=\"ss-cal-info-title\">{display}</div>", "<div class=\"ss-cal-info-value\">{value}</div>", "</div>", "</div>", "</tpl>"].join(""), {
				compile: true
			}),
			itemSelector: "div.ss-cal-info-item",
			cls: "ss-info-bar",
			autoHeight: true,
			width: 40
		});
		this.sidebar = new Ext.toolbar.Toolbar({
			dock: "right",
			cls: "ss-side-bar",
			vertical: true,
			items: [this.searchBtn, this.pictureBtn, this.wedgitBtn, this.chartBtn, this.tableStyleBtn, this.cellStyleBtn, this.conditionStyleBtn, "->", this.infoView]
		});
		this.dockedItems = [this.sidebar];
		this.callParent(arguments);
		this.on({
			scope: this,
			done: function() {
				if(!this.suspendMintorMouseDown) {
					this.closeOptionPane();
				}
			}
		});
	},
	initInfoStore: function() {
		this.infoStore = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.InfoModel",
			data: [{
				name: "sum",
				display: "Sum",
				value: 100
			}, {
				name: "average",
				display: "Avg.",
				value: 10
			}, {
				name: "max",
				display: "Max",
				value: 50,
				hidden: true
			}, {
				name: "min",
				display: "Min",
				value: -15,
				hidden: true
			}, {
				name: "count",
				display: "Count",
				value: 5
			}]
		});
		this.sumRec = this.infoStore.getAt(0);
		this.avgRec = this.infoStore.getAt(1);
		this.maxRec = this.infoStore.getAt(2);
		this.minRec = this.infoStore.getAt(3);
		this.countRec = this.infoStore.getAt(4);
	},
	initOptionPane: function() {
		this.pinTool = new Ext.panel.Tool({
			type: "pin",
			handler: this.pinOptionPane,
			scope: this
		});
		this.unpinTool = new Ext.panel.Tool({
			type: "unpin",
			hidden: true,
			handler: this.unPinOptionPane,
			scope: this
		});
		this.searchOption = new EnterpriseSheet.sheet.toolbar.options.SearchOption;
		this.pieces.push(this.searchOption);
		this.pictureOption = new EnterpriseSheet.sheet.toolbar.options.PictureOption;
		this.pieces.push(this.pictureOption);
		this.wedgitOption = new EnterpriseSheet.sheet.toolbar.options.WedgitOption;
		this.pieces.push(this.wedgitOption);
		this.chartOption = new EnterpriseSheet.sheet.toolbar.options.ChartOption;
		this.pieces.push(this.chartOption);
		this.tableOption = new EnterpriseSheet.sheet.toolbar.options.TableTemplateOption;
		this.pieces.push(this.tableOption);
		this.cellOption = new EnterpriseSheet.sheet.toolbar.options.CellTemplateOption;
		this.pieces.push(this.cellOption);
		this.conditionOption = new EnterpriseSheet.sheet.toolbar.options.ConditionOption;
		this.pieces.push(this.conditionOption);
		this.optionPane = new Ext.panel.Panel({
			cls: "ss-option-pane",
			tools: [this.pinTool, this.unpinTool, {
				type: "close",
				handler: this.closeOptionPane,
				scope: this
			}],
			width: this.optionPaneWidth,
			floating: {
				shadow: false
			},
			layout: "card",
			activeItem: 0,
			items: [this.searchOption, this.pictureOption, this.wedgitOption, this.chartOption, this.tableOption, this.cellOption, this.conditionOption]
		});
		this.mon(Ext.getBody(), {
			mousedown: function(e) {
				if(!this.suspendMintorMouseDown) {
					var target = e.getTarget(".option-button");
					if(this.optionPane && !e.within(this.optionPane.getEl()) && !target) {
						this.optionPane.hide();
						if(this.currentActiveBtn) {
							this.currentActiveBtn.toggle(false, true);
						}
					}
				}
			},
			scope: this
		});
		this.optionPane.items.each(function(it) {
			this.relayEvents(it, ["done"]);
		}, this);
	},
	showOptionPane: function(name, callback, scope) {
		var activeOption;
		if("picture" == name) {
			activeOption = this.pictureOption;
		} else if("wedgit" == name) {
			activeOption = this.wedgitOption;
		} else if("search" == name) {
			activeOption = this.searchOption;
		} else if("chart" == name) {
			activeOption = this.chartOption;
		} else if("table" == name) {
			activeOption = this.tableOption;
		} else if("cell" == name) {
			activeOption = this.cellOption;
		} else if("condition" == name) {
			activeOption = this.conditionOption;
		}
		var optionPaneWidth = activeOption.optionPaneWidth || this.optionPaneWidth;
		this.optionPane.setWidth(optionPaneWidth);
		var el = this.sidebar.getEl();
		var x = el.getX() - optionPaneWidth,
			y = el.getY();
		var title = SLANG[name] || name;
		this.optionPane.setTitle(title);
		this.optionPane.getLayout().setActiveItem(activeOption);
		if(!this.optionPane.isVisible()) {
			var h = this.getHeight();
			this.optionPane.setHeight(h);
			this.optionPane.showAt(-1000, -1000);
			if(this.suspendMintorMouseDown) {
				this.setWidth(this.sidebar.getWidth() + optionPaneWidth - 1);
			}
			this.optionPane.animate({
				duration: 500,
				from: {
					x: el.getLeft(),
					y: el.getTop()
				},
				to: {
					x: x,
					y: y
				},
				callback: function() {
					if(callback) {
						callback.call(scope, this);
					}
				},
				scope: this
			});
		} else {
			if(this.suspendMintorMouseDown) {
				this.setWidth(this.sidebar.getWidth() + optionPaneWidth - 1);
			}
			this.optionPane.showAt(x, y);
		}
		if("search" == name) {
			this.searchOption.searchFieldFocus();
		}
	},
	toggleOption: function(btn, e, callback, scope) {
		btn.toggle(true, true);
		this.currentActiveBtn = btn;
		this.showOptionPane(btn.name, callback, scope);
	},
	pinOptionPane: function() {
		this.suspendMintorMouseDown = true;
		var width = this.sidebar.getWidth();
		var activeOption = this.optionPane.getLayout().activeItem;
		var optionPaneWidth = activeOption.optionPaneWidth || this.optionPaneWidth;
		this.setWidth(width + optionPaneWidth - 1);
		this.pinTool.hide();
		this.unpinTool.show();
	},
	unPinOptionPane: function() {
		this.suspendMintorMouseDown = false;
		var width = this.sidebar.getWidth();
		this.setWidth(width);
		this.pinTool.show();
		this.unpinTool.hide();
	},
	closeOptionPane: function() {
		this.suspendMintorMouseDown = false;
		if(this.currentActiveBtn) {
			this.currentActiveBtn.toggle(false, true);
		}
		this.optionPane.hide();
		var width = this.sidebar.getWidth();
		this.setWidth(width);
	},
	onSelectionChange: function(startPos, endPos, region, sm) {
		var me = this;
		if(startPos) {
			var infoStore = me.infoStore;
			var coord = sm.selection2Coord();
			var sheet = this.sheet,
				store = sheet.getStore(),
				sheetLookup = store.getSheetIdLookup();
			var sum = 0,
				count = 0,
				min = false,
				max = false,
				avg = 0;
			var rowVisibles = {},
				colVisibles = {},
				arr = [];
			for(var i = 0, len = coord.length; i < len; i++) {
				var span = coord[i];
				var sheetObj = sheetLookup[span[0]];
				if(sheetObj) {
					var maxRow = sheetObj.maxRow,
						maxCol = sheetObj.maxCol;
					if(span[3] > maxRow) {
						span[3] = maxRow;
					}
					for(var r = span[1]; r <= span[3]; r++) {
						if(store.isVisibleRow(span[0], r)) {
							rowVisibles[r] = true;
						}
					}
					if(span[4] > maxCol) {
						span[4] = maxCol;
					}
					for(var c = span[2]; c <= span[4]; c++) {
						if(store.isVisibleColumn(span[0], c)) {
							colVisibles[c] = true;
						}
					}
					arr.push(span);
				}
			}
			store.walkRange(arr, function(rd) {
				var sheetId = rd.data.sheet,
					row = rd.data.row,
					col = rd.data.col;
				var json = rd.data.json;
				if(rowVisibles[row] && colVisibles[col]) {
					if(!store.isMergedCell(json, sheetId, row, col) || 0 === json.minrow && 0 === json.mincol) {
						var val = json.value;
						if(!Ext.isDefined(val)) {
							val = json.data;
						}
						if(Ext.isString(val)) {
							val = Ext.String.trim(val);
						}
						if(!SCOM.isEmptyValue(val)) {
							var num = Number(val);
							if(Ext.isNumber(num)) {
								count++;
								if(false === min || min > num) {
									min = num;
								}
								if(false === max || max < num) {
									max = num;
								}
								sum += num;
							}
						}
					}
				}
			}, this, undefined, undefined, true);
			if(0 < count) {
				avg = Math.round(sum / count * 1000) / 1000;
			}
			if(false === min) {
				min = 0;
			}
			if(false === max) {
				max = 0;
			}
			me.sumRec.set("value", sum);
			me.minRec.set("value", min);
			me.maxRec.set("value", max);
			me.avgRec.set("value", avg);
			me.countRec.set("value", count);
		}
	},
	onChangeReadOnly: function(readOnly, sheet) {
		if(readOnly) {
			this.disable();
		} else {
			this.enable();
		}
	}
});

Ext.define("EnterpriseSheet.sheet.toolbar.MenuTitlebar", {
	extend: "Ext.toolbar.Toolbar",
	alias: "widget.menutitlebar",
	requires: ["EnterpriseSheet.common.Common", "EnterpriseSheet.sheet.action.ActionBox", "Ext.button.Split", "EnterpriseSheet.common.SimpleButton", "Ext.ux.BoxReorderer", "Ext.window.MessageBox", "Ext.form.field.Text", "Ext.toolbar.Spacer", "EnterpriseSheet.sheet.pop.TextWin", "EnterpriseSheet.sheet.pop.money.MoneySelectWin", "EnterpriseSheet.sheet.menu.CustomFormatMenu", "EnterpriseSheet.sheet.pop.NumberSpecialWin", "EnterpriseSheet.sheet.pop.PrintSettingWin", "EnterpriseSheet.sheet.pop.FileDetailWin"],
	cls: "ss-title-bar ss-title-menubar",
	height: 35,
	layout: {
		type: "hbox",
		align: "middle"
	},
	maxTitleLen: 30,
	constructor: function() {
		this.pieces = [];
		this.callParent(arguments);
	},
	init: function(sheet) {
		if(this.sheet) {
			return;
		}
		this.sheet = sheet;
		this.initPieces(sheet);
		this.store = this.sheet.getStore();
		if(this.store) {
			this.mon(this.store, {
				scope: this,
				beforeload: this.beforeLoad,
				preparepull: this.beforePulling,
				pull: this.onPull,
				load: this.onLoad,
				afterload: this.afterLoad,
				exception: this.onLoadError,
				disconnectserver: this.onLostConnection,
				connectserver: this.onConnectServer,
				prepareloadingrange: this.beforeLoadingRange,
				loadingrange: this.onLoad
			});
		}
		this.mon(this.otherFormatMenu, {
			scope: this,
			show: this.onOtherFormatMenuShow
		});
		this.mon(this.sheet, {
			scope: this,
			afterloadsheet: this.afterLoad,
			changereadonly: this.onChangeReadOnly
		});
	},
	initPieces: function(sheet) {
		if("array" == SCOM.typeOf(this.pieces)) {
			for(var i = 0, len = this.pieces.length; i < len; i++) {
				this.pieces[i].bindSheet(sheet);
			}
		}
	},
	defaults: {
		arrowVisible: false,
		padding: "0 5"
	},
	initComponent: function() {
		this.items = this.prepareMenuItems();
		this.callParent(arguments);
		this.mon(this.titleBox, {
			scope: this,
			afterrender: function() {
				var el = this.titleBox.getEl();
				if(el) {
					this.mon(el, {
						scope: this,
						click: this.onTitleBoxClick
					});
				}
			}
		});
		this.on({
			scope: this,
			afterlayout: function() {
				var titleEl = this.titleBox.getEl(),
					el = this.getEl(),
					fillEl = this.fillBtn.getEl();
				if(titleEl) {
					var bw = el.getWidth(),
						tw = titleEl.getWidth() - titleEl.getPadding("lr");
					var pad = (bw - tw) / 2;
					var left = el.getX();
					var loff = titleEl.getX() - left;
					var nw = tw + (pad - loff) * 2;
					if(100 > nw) {
						nw = 100;
					}
					titleEl.setWidth(nw);
					fillEl.setWidth(fillEl.getRight() - titleEl.getRight());
					fillEl.setLeft(titleEl.getRight());
				}
			}
		});
	},
	prepareMenuItems: function() {
		this.titleBox = new Ext.Component({
			cls: "ss-file-title",
			html: "<span class=\"ss-file-title-span\" >" + SLANG.untitle_spreadsheet + "</span>",
			flex: 1
		});
		this.refreshBtn = new Ext.button.Button({
			iconCls: "fa fa-refresh fa-lg",
			disabled: true,
			reorderable: false,
			handler: this.doRefresh,
			scope: this
		});
		this.reconnectBtn = new Ext.button.Button({
			iconCls: "fa fa-flash fa-lg",
			hidden: true,
			reorderable: false,
			handler: this.doReconnect,
			scope: this
		});
		this.statusItem = new Ext.toolbar.TextItem({
			text: this.text || this.defaultText || "",
			reorderable: false
		});
		this.shareFileItem = Ext.create("Ext.menu.Item", SABOX.get("shareFile", {
			text: SLANG.share + "...",
			sender: this
		}));
		this.exportFileItem = Ext.create("Ext.menu.Item", SABOX.get("exportFile", {
			iconCls: "fa fa-download fa-lg",
			text: SLANG.exportExcel,
			disabled: !SCONFIG.enableExport,
			sender: this
		}));
		this.printSettingItem = Ext.create("Ext.menu.Item", {
			text: SLANG.print_setting,
			handler: this.onPrintSetting,
			iconCls: "fa fa-print fa-lg",
			scope: this
		});
		this.fileMenu = Ext.create("Ext.menu.Menu", {
			items: [{
				text: SLANG['new'],
				iconCls: "fa fa-file-o fa-lg",
				menu: [SABOX.get("newSheet", {
					text: SLANG.sheet,
					sender: this
				}), SABOX.get("newSheetFromTpl", {
					text: SLANG.sheetFromTpl,
					sender: this
				}), SABOX.get("newSheetTpl", {
					text: SLANG.sheetTpl,
					sender: this
				})]
			}, SABOX.get("openFile", {
				iconCls: "fa fa-folder-open-o fa-lg",
				text: SLANG.open + " (Ctrl+O)",
				sender: this
			}), SABOX.get("saveFile", {
				iconCls: "fa fa-floppy-o fa-lg",
				text: SLANG.save_as + " (Ctrl+S)",
				sender: this
			}), "-", SABOX.get("importFile", {
				iconCls: "fa fa-upload fa-lg",
				text: SLANG['import'],
				disabled: !SCONFIG.enableImport,
				sender: this
			}), this.exportFileItem, "-", this.printSettingItem]
		});
		this.editMenu = Ext.create("Ext.menu.Menu", {
			items: [SABOX.get("cut", {
				iconCls: "fa fa-cut fa-lg",
				tooltip: SLANG.cut_tip,
				text: SLANG.cut + " (Ctrl+X)",
				sender: this
			}), SABOX.get("copy", {
				iconCls: "fa fa-copy fa-lg",
				tooltip: SLANG.copy_tip,
				text: SLANG.copy + " (Ctrl+C)",
				sender: this
			}), SABOX.get("paste", {
				iconCls: "fa fa-paste fa-lg",
				tooltip: SLANG.paste_tip,
				text: SLANG.paste + " (Ctrl+V)",
				sender: this
			}), "-", {
				text: SLANG.find_replace + "... (Ctrl+F)",
				handler: this.onFindReplace,
				scope: this
			}, {
				text: SLANG.charts + "...",
				handler: this.onShowCharts,
				scope: this
			}, {
				text: SLANG.table_styles + "...",
				handler: this.onShowTables,
				scope: this
			}, {
				text: SLANG.cell_styles + "...",
				handler: this.onShowCellStyles,
				scope: this
			}, {
				text: SLANG.condition_management + "...",
				handler: this.onConditionMgr,
				scope: this
			}]
		});
		this.freezeItem = new Ext.menu.Item(SABOX.get("doFreeze", {
			text: SLANG.freeze_sheet,
			toggle: function(pressed, suspendEvent) {
				if(!pressed) {
					this.setText(SLANG.freeze_sheet);
				} else {
					this.setText(SLANG.cancel_freeze);
				}
			},
			sender: this
		}));
		this.splitItem = new Ext.menu.Item(SABOX.get("doSplit", {
			text: SLANG.split_sheet,
			toggle: function(pressed, suspendEvent) {
				if(!pressed) {
					this.setText(SLANG.split_sheet);
				} else {
					this.setText(SLANG.cancel_split);
				}
			},
			sender: this
		}));
		this.gridLineItem = new Ext.menu.Item(SABOX.get("toggleGridLine", {
			text: SLANG.hide_grid_line,
			toggle: function(pressed, suspendEvent) {
				if(!pressed) {
					this.setText(SLANG.hide_grid_line);
				} else {
					this.setText(SLANG.show_grid_line);
				}
			},
			sender: this
		}));
		this.rowNameItem = new Ext.menu.Item(SABOX.get("toggleRowName", {
			text: SLANG.hide_row_name,
			toggle: function(pressed, suspendEvent) {
				if(!pressed) {
					this.setText(SLANG.hide_row_name);
				} else {
					this.setText(SLANG.show_row_name);
				}
			},
			sender: this
		}));
		this.colNameItem = new Ext.menu.Item(SABOX.get("toggleColName", {
			text: SLANG.hide_col_name,
			toggle: function(pressed, suspendEvent) {
				if(!pressed) {
					this.setText(SLANG.hide_col_name);
				} else {
					this.setText(SLANG.show_col_name);
				}
			},
			sender: this
		}));
		this.customNumField = new Ext.form.field.Number({
			width: 100,
			minValue: 20,
			enableKeyEvents: true
		});
		this.zoomMenu = Ext.create("Ext.menu.Menu", {
			defaults: {
				group: "ss-zoom-view",
				xtype: "menucheckitem",
				handler: this.changeZoom,
				scope: this
			},
			items: [{
				text: "200%",
				zoom: 2
			}, {
				checked: true,
				text: "100%",
				zoom: 1
			}, {
				text: "75%",
				zoom: 0.75
			}, {
				text: "50%",
				zoom: 0.5
			}, {
				text: "25%",
				zoom: 0.25
			}, {
				text: SLANG.custom,
				zoom: 0,
				menu: {
					plain: true,
					items: [{
						xtype: "container",
						layout: {
							type: "hbox"
						},
						items: [this.customNumField, {
							xtype: "label",
							style: "padding: 4px 0 0 5px;",
							text: "%"
						}]
					}]
				}
			}]
		});
		this.mon(this.customNumField, {
			scope: this,
			keydown: function(field, e) {
				if(e.ENTER == e.getKey()) {
					e.stopEvent();
					var val = field.getValue();
					var item = {
						zoom: val / 100
					};
					this.changeZoom(item);
					this.viewMenu.hide();
				}
			}
		});
		this.zoomMenu.on({
			scope: this,
			beforeshow: this.beforeShowZoomMenu
		});
		this.viewMenu = Ext.create("Ext.menu.Menu", {
			items: [this.freezeItem, this.splitItem, this.gridLineItem, this.rowNameItem, this.colNameItem, {
				text: SLANG.zoom,
				iconCls: "fa fa-search",
				hidden: this.zoomHidden,
				menu: this.zoomMenu
			}]
		});
		this.viewMenu.on({
			scope: this,
			show: this.onViewMenuShow
		});
		this.backgroundWin = Ext.create("EnterpriseSheet.sheet.pop.BackgroundWin", {});
		this.pieces.push(this.backgroundWin);
		this.insertMenu = Ext.create("Ext.menu.Menu", {
			items: [SABOX.get("insertDropList", {
				text: SLANG.insert_drop_list,
				hidden: SCONFIG.js_standalone,
				sender: this
			}), SABOX.get("insertCheckbox", {
				text: SLANG.checkbox,
				sender: this
			}), SABOX.get("insertRadio", {
				text: SLANG.radio,
				sender: this
			}), SABOX.get("insertDatePicker", {
				text: SLANG.insert_date_picker,
				sender: this
			}), SABOX.get("clearItem", {
				text: SLANG.clearCheckboxRadio,
				sender: this
			}), "-", {
				text: SLANG['function'],
				iconCls: "icon-sum",
				menu: [SABOX.get("sum", {
					text: SLANG.sum,
					sender: this
				}), SABOX.get("average", {
					text: SLANG.average,
					sender: this
				}), SABOX.get("count", {
					text: SLANG.count,
					sender: this
				}), SABOX.get("maxValue", {
					text: SLANG.max,
					sender: this
				}), SABOX.get("minValue", {
					text: SLANG.min,
					sender: this
				}), "-", SABOX.get("insertFormula", {
					iconCls: "icon-fx",
					text: SLANG.more_functions + "...",
					sender: this
				})]
			}, SABOX.get("markRange", {
				text: SLANG.mark_range + "..",
				sender: this
			}), SABOX.get("insertComment", {
				iconCls: "fa fa-comment-o fa-lg",
				text: SLANG.insert_comment,
				sender: this
			}), "-", SABOX.get("insertHyperlink", {
				iconCls: "fa fa-link fa-lg",
				text: SLANG.hyperlink + "... (Ctrl+K)",
				sender: this
			}), {
				text: SLANG.image + "...",
				handler: this.onInsertImage,
				scope: this
			}, {
				text: SLANG.background + "...",
				handler: this.onInsertBackgroundImage,
				scope: this
			}, {
				text: SLANG.page_break,
				menu: [{
					text: SLANG.insert_page_break,
					handler: this.onInsertPageBreak,
					scope: this
				}, {
					text: SLANG.delete_page_break,
					handler: this.onDeletePageBreak,
					scope: this
				}]
			}]
		});
		this.otherFormatMenu = Ext.create("EnterpriseSheet.sheet.menu.TextFormatMenu", {
			minWidth: 160
		});
		this.pieces.push(this.otherFormatMenu);
		this.localeWin = Ext.create("EnterpriseSheet.sheet.pop.money.LocaleSelectWin", {});
		this.pieces.push(this.localeWin);
		this.currencyWin = Ext.create("EnterpriseSheet.sheet.pop.money.MoneySelectWin", {});
		this.pieces.push(this.currencyWin);
		this.customMenu = Ext.create("EnterpriseSheet.sheet.menu.CustomFormatMenu", {});
		this.pieces.push(this.customMenu);
		this.numberSpecialWin = Ext.create("EnterpriseSheet.sheet.pop.NumberSpecialWin", {});
		this.pieces.push(this.numberSpecialWin);
		this.formatMenu = Ext.create("Ext.menu.Menu", {
			items: [{
				text: SLANG.currency,
				iconCls: "fa fa-usd fa-lg",
				handler: function() {
					this.currencyWin.popup();
				},
				scope: this
			}, {
				text: SLANG.locale,
				iconCls: "fa fa-globe fa-lg",
				handler: function() {
					this.localeWin.popup();
				},
				scope: this
			}, {
				text: SLANG.number_format,
				menu: this.otherFormatMenu,
				sender: this
			}, {
				text: SLANG.custom,
				iconCls: "fa fa-tag fa-lg",
				menu: this.customMenu,
				sender: this
			}, {
				text: SLANG.number_special,
				handler: function() {
					this.numberSpecialWin.popup();
				},
				scope: this
			}, "-", SABOX.get("bold", {
				iconCls: "icon-bold",
				tooltip: SLANG.bold_tip,
				text: SLANG.bold + " (Ctrl+B)",
				sender: this
			}), SABOX.get("underline", {
				iconCls: "icon-underline",
				tooltip: SLANG.underline_tip,
				text: SLANG.underline + " (Ctrl+U)",
				sender: this
			}), SABOX.get("italic", {
				iconCls: "icon-italic",
				tooltip: SLANG.italic_tip,
				text: SLANG.italic + " (Ctrl+I)",
				sender: this
			}), SABOX.get("strike", {
				iconCls: "icon-strike",
				tooltip: SLANG.strike,
				text: SLANG.strike,
				sender: this
			}), {
				text: SLANG.orientation,
				iconCls: "icon-arrow-cc",
				menu: [SABOX.get("rotateText45", {
					text: SLANG.rotate_angle_cc,
					sender: this
				}), SABOX.get("rotateTextDown45", {
					text: SLANG.rotate_angle_c,
					sender: this
				}), SABOX.get("rotateTextUp", {
					text: SLANG.rotate_text_up,
					sender: this
				}), SABOX.get("rotateTextDown", {
					text: SLANG.rotate_text_down,
					sender: this
				})]
			}, {
				text: SLANG.indent,
				menu: [SABOX.get("increaseIndent", {
					text: SLANG.inc_indent,
					sender: this
				}), SABOX.get("removeIndent", {
					text: SLANG.remove_indent,
					sender: this
				})]
			}, "-", {
				text: SLANG.align,
				iconCls: "icon-align-left",
				menu: [SABOX.get("alignLeft", {
					text: SLANG.align_left,
					sender: this
				}), SABOX.get("alignCenter", {
					text: SLANG.align_center,
					sender: this
				}), SABOX.get("alignRight", {
					text: SLANG.align_right,
					sender: this
				}), SABOX.get("alignTop", {
					text: SLANG.align_top,
					sender: this
				}), SABOX.get("alignMiddle", {
					text: SLANG.align_middle,
					sender: this
				}), SABOX.get("alignBottom", {
					text: SLANG.align_bottom,
					sender: this
				})]
			}, {
				text: SLANG.fill,
				iconCls: "icon-fill-625gray",
				menu: [{
					text: SLANG.fill_pattern,
					menu: [SABOX.get("fill625Gray", {
						text: SLANG.fill_625_gray,
						sender: this
					}), SABOX.get("fill125Gray", {
						text: SLANG.fill_125_gray,
						sender: this
					}), SABOX.get("fill25Gray", {
						text: SLANG.fill_25_gray,
						sender: this
					}), SABOX.get("fill50Gray", {
						text: SLANG.fill_50_gray,
						sender: this
					}), SABOX.get("fill75Gray", {
						text: SLANG.fill_75_gray,
						sender: this
					}), SABOX.get("horizontalStripe", {
						text: SLANG.fill_horizontal_stripe,
						sender: this
					}), SABOX.get("thinHorizontalStripe", {
						text: SLANG.fill_thin_horizontal_stripe,
						sender: this
					}), SABOX.get("verticalStripe", {
						text: SLANG.fill_vertical_stripe,
						sender: this
					}), SABOX.get("thinVerticalStripe", {
						text: SLANG.fill_thin_vertical_stripe,
						sender: this
					}), SABOX.get("thinDiagonalStripe", {
						text: SLANG.fill_thin_diagonal_stripe,
						sender: this
					}), SABOX.get("thinReverseDiagonalStripe", {
						text: SLANG.fill_thin_reverse_diagonal_stripe,
						sender: this
					}), SABOX.get("thinDiagonalCH", {
						text: SLANG.fill_thin_diagonal_CH,
						sender: this
					}), SABOX.get("diagonalCH", {
						text: SLANG.fill_diagonal_CH,
						sender: this
					}), SABOX.get("thickDiagonalCH", {
						text: SLANG.fill_thick_diagonal_CH,
						sender: this
					}), SABOX.get("thickHorizontalCH", {
						text: SLANG.fill_thick_horizontal_CH,
						sender: this
					})]
				}]
			}, {
				text: SLANG.merge_cell,
				iconCls: "fa fi-merge-center",
				menu: [SABOX.get("mergeCell", {
					text: SLANG.merge_cell,
					sender: this
				}), SABOX.get("mergeColumn", {
					text: SLANG.merge_cell_in_column,
					sender: this
				}), SABOX.get("mergeRow", {
					text: SLANG.merge_cell_in_row,
					sender: this
				}), SABOX.get("cancelMerge", {
					text: SLANG.cancel_merge_cell,
					sender: this
				})]
			}, SABOX.get("wordWrap", {
				tooltip: SLANG.word_wrap,
				text: SLANG.word_wrap,
				sender: this
			}), "-", {
				text: SLANG.clear,
				iconCls: "fa fa-eraser",
				menu: [SABOX.get("clean", {
					text: SLANG.clean_all,
					sender: this
				}), SABOX.get("cleanContent", {
					text: SLANG.clean_content,
					sender: this
				}), SABOX.get("cleanStyle", {
					text: SLANG.clean_style,
					sender: this
				})]
			}]
		});
		this.dataMenu = Ext.create("Ext.menu.Menu", {
			items: [SABOX.get("validation", {
				text: SLANG.validation + "..",
				sender: this
			}), "-", SABOX.get("sortAsc", {
				iconCls: "icon-sort-asc",
				text: SLANG.sort_asc,
				sender: this
			}), SABOX.get("sortDesc", {
				iconCls: "icon-sort-desc",
				text: SLANG.sort_desc,
				sender: this
			}), "-", SABOX.get("deleteRepeat", {
				text: SLANG.delete_repeat_item,
				sender: this
			})]
		});
		this.langMenu = Ext.create("Ext.menu.Menu", {
			items: [SABOX.get("langen", {
				text: SLANG.lang_en,
				sender: this
			}), SABOX.get("langzh", {
				text: SLANG.lang_zh,
				sender: this
			})]
		});
		var hidden = SCONFIG.help_menu_hide && "commercial" === SCONST.limitType;
		this.helpMenu = Ext.create("Ext.menu.Menu", {
			hidden: hidden,
			items: [{
				text: SLANG.documentation,
				handler: this.onSupport,
				scope: this
			}, SABOX.get("keyboardShortcuts", {
				text: SLANG.keyboard_shortcuts,
				sender: this
			}), SABOX.get("aboutSheet", {
				iconCls: "icon-sheet",
				text: SLANG.aboutSheet,
				sender: this
			})]
		});
		this.fillBtn = Ext.create("Ext.toolbar.Fill", {});
		
		this.operateMenu = Ext.create("Ext.menu.Menu", {
			items: [SABOX.get("filedelete", {
				text: SLANG.filedelete,
				sender: this
			})]
		});
		var items = [
/*		{
			text: SLANG.file,
			hidden: SCONFIG.file_menu_hide,
			menu: this.fileMenu
		},*/ 
		
		{
			text: SLANG.operate,
			menu: this.operateMenu
		},	{
			text: SLANG.edit,
			menu: this.editMenu
		}, {
			text: SLANG.view,
			menu: this.viewMenu
		}, {
			text: SLANG.insert,
			menu: this.insertMenu
		}, {
			text: SLANG.format,
			menu: this.formatMenu
		}, {
			text: SLANG.data,
			menu: this.dataMenu
		}, 
		/*{
			text: SLANG.help,
			menu: this.helpMenu
		},*/ 
		
		this.titleBox, this.fillBtn, this.statusItem, this.refreshBtn, this.reconnectBtn, {
			text: SLANG.language,
			hidden: true,
			menu: this.langMenu
		}];
		return items;
	},
	beforePulling: function() {
		if(this.rendered && this.refreshBtn) {
			this.refreshBtn.disable();
			var sEl = this.statusItem.getEl();
			if(sEl) {
				sEl.addCls("ss-loading-span");
			}
			if(this.countDownTask) {
				Ext.TaskManager.stop(this.countDownTask);
			}
			this.reconnectBtn.hide();
			this.statusItem.setText(SLANG.saving + "...");
		}
	},
	onPull: function() {
		this.onLoad();
	},
	beforeLoad: function() {
		if(this.rendered && this.refreshBtn) {
			this.refreshBtn.disable();
			this.refreshBtn.setIconCls("fa fa-refresh fa-lg fa-spin");
			var sEl = this.statusItem.getEl();
			if(sEl) {
				sEl.addCls("ss-loading-span");
			}
			this.statusItem.setText(SLANG.loading + "...");
		}
	},
	beforeLoadingRange: function() {
		if(this.rendered && this.refreshBtn) {
			this.refreshBtn.disable();
			this.refreshBtn.setIconCls("fa fa-refresh fa-lg fa-spin");
			var sEl = this.statusItem.getEl();
			if(sEl) {
				sEl.addCls("ss-loading-span");
			}
			this.statusItem.setText(SLANG.loading_calculating + "...");
		}
	},
	onLoad: function() {
		this.refreshBtn.enable();
		var sEl = this.statusItem.getEl();
		if(sEl) {
			sEl.removeCls("ss-loading-span");
		}
		this.refreshBtn.setIconCls("fa fa-refresh fa-lg");
		var date = new Date;
		var dateStr = Ext.Date.format(date, "H:i:s");
		this.statusItem.setText(SLANG.all_changes_are_saved + " " + SLANG.at + " " + dateStr);
	},
	onLoadError: function() {
		if(!this.rendered) {
			return;
		}
		var sEl = this.statusItem.getEl();
		if(sEl) {
			sEl.removeCls("ss-loading-span");
		}
		this.refreshBtn.setIconCls("fa fa-refresh fa-lg");
		this.refreshBtn.enable();
	},
	doRefresh: function() {
		if(this.store) {
			this.store.loadFile();
		}
	},
	onFindReplace: function() {
		this.fireEvent("findreplace", this);
	},
	onShowCharts: function() {
		this.fireEvent("showCharts", this);
	},
	onShowTables: function() {
		this.fireEvent("showTables", this);
	},
	onShowCellStyles: function() {
		this.fireEvent("showcellstyles", this);
	},
	onConditionMgr: function() {
		this.fireEvent("showconditionmgr", this);
	},
	onInsertImage: function() {
		this.fireEvent("showinsertimage", this);
	},
	onInsertBackgroundImage: function() {
		this.backgroundWin.popup();
	},
	onLinkFunctionList: function() {
		window.open("http://www.enterprisesheet.com/resource/document/EnterpriseSheetFunctions.pdf");
	},
	onSupport: function() {
		window.open("http://www.enterprisesheet.com/api");
	},
	onViewMenuShow: function() {
		this.splitItem.toggle(this.sheet.isSplited(), true);
		this.freezeItem.toggle(this.sheet.isFreezed(), true);
		this.gridLineItem.toggle(!this.sheet.withGridLine(), true);
		this.rowNameItem.toggle(this.sheet.getStore().rowNameHidden, true);
		this.colNameItem.toggle(this.sheet.getStore().colNameHidden, true);
	},
	updateTitleBox: function(fileName, fileStared, exname, isPublic) {
		var fullName = fileName;
		fileName = Ext.String.ellipsis(fileName, this.maxTitleLen, true);
		var tip = "";
		if(fullName !== fileName) {
			tip = "data-qtip=\"" + fullName + "\"";
		}
		var tpl = "";
		if(exname == "xlt") {
			tpl = "<span class=\"ss-file-tpl icon-sheet-tpl\" data-qtip=\"" + SLANG.sheetTplUpdateTip + "\">&nbsp;</span>";
		}
		var cls = fileStared ? "ss-file-stared" : "";
		//this.titleBox.update([tpl, "<span class=\"ss-file-title-span\" " + tip + ">", fileName, "</span>", "<span class=\"fa fa-star fa-lg ss-file-title-star ", cls, "\">&nbsp;</span>", "&nbsp;<span class=\"fa fa-chevron-down ss-file-title-drop\">&nbsp;</span>"].join(""));
		this.titleBox.update([tpl, "<span class=\"ss-file-title-span\" " + tip + ">", fileName, "</span>","&nbsp;<span class=\"fa fa-chevron-down ss-file-title-drop\">&nbsp;</span>"].join(""));
	},
	updateBackgroundColor: function(color) {
		var el = this.getEl();
		el.setStyle("background-color", "#" + color);
	},
	afterLoad: function() {
		var ss = this.sheet,
			store = ss.getStore(),
			activeSheetId = ss.getSheetId();
		var sheets = store.getSheets(),
			loadedFile = store.getLoadedFile();
		var fileName, fileColor = null;
		if(loadedFile) {
			fileName = loadedFile.name;
			fileColor = loadedFile.color;
		}
		fileName = fileName || SLANG.untitle_spreadsheet;
		if(fileColor) {
			this.updateBackgroundColor(fileColor);
		}
		this.updateTitleBox(fileName, loadedFile.stared, loadedFile.exname);
		this.onLoad();
	},
	onTitleBoxClick: function(e) {
		if(this.sheet.isReadOnly()) {
			return;
		}
		var store = this.sheet.getStore();
		var starSpan = e.getTarget(".ss-file-title-star");
		var dropSpan = e.getTarget(".ss-file-title-drop");
		if(starSpan) {
			var file = store.getLoadedFile();
			starSpan = Ext.get(starSpan);
			if(starSpan.hasCls("ss-file-stared")) {
				if(Ext.isDefined(file.id)) {
					store.changeFileStared(false, function(success) {
						if(success) {
							starSpan.removeCls("ss-file-stared");
						}
					}, this);
				} else {
					starSpan.removeCls("ss-file-stared");
				}
			} else {
				if(Ext.isDefined(file.id)) {
					store.changeFileStared(true, function(success) {
						if(success) {
							starSpan.addCls("ss-file-stared");
						}
					}, this);
				} else {
					starSpan.addCls("ss-file-stared");
				}
			}
		} else if(dropSpan) {
			var fileName = store.getLoadedFileName() || SLANG.untitle_spreadsheet;
			if(store.getFileId() != null) {
				this.showFileDetailWin(store.getLoadedFile(), this.titleBox.getEl());
			} else {
				TOPMINDER.showMsg("", SLANG.file_not_saved);
			}
		} else {
			var titleSpan = e.getTarget(".ss-file-title-span");
			if(titleSpan) {
				var fileName = store.getLoadedFileName() || SLANG.untitle_spreadsheet;
				this.showRenameFileWin(fileName);
			}
		}
	},
	showRenameFileWin: function(fileName) {
		SPOP.showTextBox({
			title: SLANG.change_file_title,
			fieldLabel: SLANG.input_file_name,
			value: fileName,
			applyCallback: {
				fn: function(name) {
					this.changeFileName(name);
				},
				scope: this
			}
		});
	},
	showFileDetailWin: function(file, dropSpan) {
		if(!this.fileDetailWin) {
			this.fileDetailWin = Ext.create("EnterpriseSheet.sheet.pop.FileDetailWin", {});
		}
		var stared = file.stared;
		this.fileDetailWin.popup({
			sender: dropSpan,
			file: file,
			applyCallback: {
				fn: function(fileObj) {
					store.changeFileName({
						fileName: fileObj.fileName,
						description: fileObj.description
					}, function(success) {
						if(success) {
							this.updateTitleBox(fileObj.fileName, stared);
						}
					}, this);
				},
				scope: this
			},
			updateCssColorCallback: {
				fn: function(fileObj) {
					store.changeFileColor({
						color: fileObj.color
					}, function(success) {
						if(success) {
							this.updateBackgroundColor(fileObj.color);
						}
					}, this);
				},
				scope: this
			},
			scope: this
		});
	},
	changeFileName: function(fileName) {
		var stared;
		if(this.sheet) {
			var store = this.sheet.getStore();
			var file = store.getLoadedFile();
			if(Ext.isDefined(file.id)) {
				stared = file.stared;
				store.changeFileName({
					fileName: fileName
				}, function(success) {
					if(success) {
						this.updateTitleBox(fileName, stared);
					}
				}, this);
			} else {
				this.updateTitleBox(fileName, stared);
			}
		}
	},
	onOtherFormatMenuShow: function() {
		var sheet = this.sheet;
		if(sheet) {
			var sm = sheet.getSelectionModel(),
				store = sheet.getStore();
			var focus = sm.getFocusCell();
			var cell = sheet.getCellValue(sheet.getSheetId(), focus.row, focus.col);
			this.otherFormatMenu.previewTextFormat(cell.data);
		}
	},
	onChangeReadOnly: function(readOnly, sheet) {
		this.items.each(function(it) {
			if(!Ext.isDefined(it.initHidden)) {
				it.initHidden = !it.isVisible();
			}
		}, this);
		if(readOnly) {
			this.items.each(function(it, index) {
				if(it !== this.titleBox && Ext.isFunction(it.hide)) {
					it.hide();
				}
			}, this);
			this.addCls("ss-disabled-title-menubar");
		} else {
			this.items.each(function(it) {
				if(Ext.isFunction(it.show)) {
					if(true !== it.initHidden) {
						it.show();
					}
				}
			}, this);
			this.removeCls("ss-disabled-title-menubar");
		}
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
	},
	beforeFileMenuShow: function() {
		if(this.sheet) {
			var store = this.sheet.getStore();
			if(store.isShareableFile()) {
				this.shareFileItem.enable();
				this.publicFileItem.enable();
			} else {
				this.shareFileItem.disable();
				this.publicFileItem.disable();
			}
			var isShowExport = store.isExportableFile();
			if(SCONFIG.enableExport && isShowExport) {
				this.exportFileItem.enable();
			} else {
				this.exportFileItem.disable();
			}
		}
	},
	onLostConnection: function() {
		this.statusItem.show();
		this.reconnectBtn.show();
		var sEl = this.statusItem.getEl();
		if(sEl) {
			sEl.removeCls("ss-loading-span");
		}
		var count = Math.round(SCONST.RECONNECT_SERVER_INTERVAL / 1000),
			me = this;
		this.statusItem.setText(SLANG.disconnect_with_server + ", " + SLANG.reconnect_in + " " + count + " " + (1 < count ? SLANG.seconds : SLANG.second));
		if(this.countDownTask) {
			Ext.TaskManager.stop(this.countDownTask);
		}
		this.countDownTask = Ext.TaskManager.start({
			run: function() {
				count--;
				me.statusItem.setText(SLANG.disconnect_with_server + ", " + SLANG.reconnect_in + " " + count + " " + (1 < count ? SLANG.seconds : SLANG.second));
			},
			interval: 1000,
			repeat: count - 1
		});
	},
	onConnectServer: function() {
		this.reconnectBtn.hide();
		this.refreshBtn.show();
		this.onLoad();
	},
	doReconnect: function() {
		if(this.countDownTask) {
			Ext.TaskManager.stop(this.countDownTask);
		}
		this.statusItem.setText(SLANG.connectiong_sever + "...");
		this.sheet.getStore().reconnectServer();
	},
	onPrintSetting: function() {
		if(!this.printSettingWin) {
			this.printSettingWin = Ext.create("EnterpriseSheet.sheet.pop.PrintSettingWin", {
				sheet: this.sheet,
				applyCallback: {
					fn: function(params) {
						this.sheet.savePrintSettingForSheet(this.sheet.getSheetId(), params);
					},
					scope: this
				}
			});
		}
		this.printSettingWin.popup();
	},
	changeZoom: function(item) {
		var zoom = item.zoom;
		this.sheet.changeZoom(zoom);
	},
	beforeShowZoomMenu: function() {
		var store = this.sheet.getStore(),
			sheetId = store.getActivedSheetId();
		var config = store.getSheetConfig(sheetId);
		var zoom = config.zoom || 1;
		this.zoomMenu.items.each(function(it) {
			if(it.zoom === zoom || it.zoom === 0) {
				if(it.zoom === 0) {
					this.customNumField.setValue(Math.ceil(zoom * 100));
				}
				it.setChecked(true, true);
				return false;
			}
		}, this);
	},
	onInsertPageBreak: function() {
		this.sheet.insertPageBreakAtFocus();
	},
	onDeletePageBreak: function() {
		this.sheet.deletePageBreakAtFocus();
	}
});

Ext.define("EnterpriseSheet.sheet.plugin.SequenceNumber", {
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent(arguments);
		this.initMenu();
	},
	initMenu: function() {
		this.menu = Ext.create("Ext.menu.Menu", {
			items: [{
				text: "Insert sequence No after"
			}, {
				text: "Insert sub-sequence No after"
			}]
		});
	},
	init: function(sheet) {
		this.sheet = sheet;
		Ext.getDoc().on("mousedown", this.onMouseDownViewEl, this);
	},
	onMouseDownViewEl: function(e) {
		var target = Ext.get(e.getTarget());
		if(target.hasCls("ss-cell-seq")) {
			if(this.pressedTarget && this.pressedTarget !== target) {
				this.pressedTarget.removeCls("ss-cell-seq-pressed");
				delete this.pressedTarget;
				return;
			}
			this.pressedTarget = target;
			target.addCls("ss-cell-seq-pressed");
			this.menu.showBy(target);
		} else {
			if(this.pressedTarget) {
				this.pressedTarget.removeCls("ss-cell-seq-pressed");
				delete this.pressedTarget;
			}
		}
	}
});

Ext.define("EnterpriseSheet.sheet.Basic", {
	extend: "EnterpriseSheet.pure.sheet.Basic"
});

Ext.define("EnterpriseSheet.sheet.Sheet", {
	extend: "Ext.container.Container",
	alias: "widget.enterprisesheet",
	mixins: {
		basic: "EnterpriseSheet.sheet.Basic"
	},
	requires: ["EnterpriseSheet.common.CONST", "EnterpriseSheet.common.Common", "EnterpriseSheet.sheet.data.RollingStore", "EnterpriseSheet.sheet.plugin.CellRender", "EnterpriseSheet.sheet.plugin.DataTypeProcessor", "EnterpriseSheet.sheet.layout.LayoutTemplates", "EnterpriseSheet.sheet.layout.Table", "EnterpriseSheet.sheet.data.Format", "EnterpriseSheet.common.Tip", "EnterpriseSheet.sheet.autofill.Autofill", "EnterpriseSheet.sheet.action.ActionBox", "EnterpriseSheet.sheet.menu.ContextMenu", "EnterpriseSheet.sheet.regions.Region", "EnterpriseSheet.sheet.regions.Lefter", "EnterpriseSheet.sheet.regions.Header", "EnterpriseSheet.sheet.regions.Corner", "EnterpriseSheet.sheet.calculate.Condition", "EnterpriseSheet.sheet.filter.Filter", "EnterpriseSheet.sheet.tpl.TableTemplate", "EnterpriseSheet.sheet.range.Range", "EnterpriseSheet.sheet.data.RangeStore", "EnterpriseSheet.sheet.floating.picture.PictureFloor", "EnterpriseSheet.sheet.floating.chart.ChartFloor", "EnterpriseSheet.sheet.pop.FloatingContainer", "EnterpriseSheet.common.LoadMask", "EnterpriseSheet.sheet.floating.DeleteRepeatOption"],
	sheetUIFlag: true,
	resizeCheckBuffer: 0,
	calMaskDelayTime: 1000,
	keyDownThrottled: 15,
	maxDigital: 18,
	kitOffset: [0, 5],
	focusDelayTime: Ext.isIE ? 500 : 100,
	disableCondition: false,
	useDefaultEditor: true,
	highlightCellsAfterCalculate: true,
	useDefaultTableTpl: true,
	useDefaultFilter: true,
	disableCalculate: false,
	sheetId: 0,
	scrollStep: Ext.isChrome ? 3 : 1,
	defaultRowIndexDigital: 2,
	maxRowIndexDigital: 2,
	digitalWidth: 8,
	spaceWidth: 10,
	enableRowColGroup: true,
	groupPadding: 10,
	groupOffset: 15,
	checkLeftDelay: 100,
	enableCommentTip: true,
	enableVariableTip: true,
	enableCustomBindingDataTip: true,
	initDataTypeProcessor: function() {
		this.dtProcessor = Ext.create("EnterpriseSheet.sheet.plugin.DataTypeProcessor", {});
		this.dtProcessor.init(this);
	},
	getDataTypeProcessor: function() {
		return this.dtProcessor;
	},
	initCommentTip: function() {
		var me = this,
			store = me.getStore();
		this.commentTip = new EnterpriseSheet.sheet.pop.FloatingContainer({
			cls: "ss-comment-ct",
			defaultAlign: "tl-tr?",
			width: 200,
			autoHeight: true,
			items: [{
				xtype: "component",
				cls: "ss-comment-inner"
			}, {
				xtype: "container",
				cls: "ss-comment-bbar",
				items: [{
					xtype: "button",
					text: SLANG.edit,
					margin: "0 5 0 0",
					handler: function() {
						SPOP.showCommentBox({
							title: SLANG.insert_comment,
							comment: me.commentTip.comment,
							applyCallback: {
								fn: function(comment) {
									me.insertComment(comment, me.commentTip.currentPos);
								},
								scope: this
							}
						});
						me.commentTip.hide();
					}
				}, {
					xtype: "button",
					text: SLANG['delete'],
					handler: function() {
						var pos = me.commentTip.currentPos,
							sheetId = pos.sheet,
							minrow = pos.row,
							mincol = pos.col,
							maxrow = minrow,
							maxcol = mincol;
						var cell = store.getCell(sheetId, minrow, mincol);
						if(Ext.isDefined(cell.minrow)) {
							minrow += cell.minrow;
							mincol += cell.mincol;
							maxrow += cell.maxrow;
							maxcol += cell.maxcol;
						}
						me.deleteComment([
							[sheetId, minrow, mincol, maxrow, maxcol]
						]);
						me.commentTip.hide();
					}
				}]
			}],
			updateComment: function(msg) {
				this.items.get(0).update(msg);
			},
			hideBtn: function() {
				this.items.get(1).setVisible(false);
			},
			showBtn: function() {
				this.items.get(1).setVisible(true);
			}
		});
	},
	initVariableTip: function() {
		var me = this,
			store = me.getStore();
		this.variableTip = new EnterpriseSheet.sheet.pop.FloatingContainer({
			cls: "ss-var-ct",
			defaultAlign: "tl-tr?",
			width: 200,
			autoHeight: true,
			items: [{
				xtype: "component",
				cls: "ss-var-inner"
			}, {
				xtype: "container",
				cls: "ss-var-bbar",
				items: [{
					xtype: "button",
					text: SLANG.edit,
					margin: "0 5 0 0",
					handler: function() {
						var pos = me.variableTip.currentPos;
						var str = me.coord2StringWithSheetName([
							[pos.sheet, pos.row, pos.col, pos.row, pos.col]
						], "");
						SPOP.showVarTextBox({
							title: SLANG.add_variable_for + str,
							fieldLabel: SLANG.input_variable_name,
							value: me.variableTip.vname,
							applyCallback: {
								fn: function(name) {
									me.insertVariable(pos.sheet, pos.row, pos.col, name);
								},
								scope: this
							}
						});
						me.variableTip.hide();
					}
				}, {
					xtype: "button",
					text: SLANG['delete'],
					handler: function() {
						var pos = me.variableTip.currentPos;
						me.deleteVariable([
							[pos.sheet, pos.row, pos.col, pos.row, pos.col]
						]);
						me.variableTip.hide();
					}
				}]
			}],
			updateContent: function(msg) {
				msg = SLANG.define_variable_for_cell + "<br><b>" + msg + "</b>";
				this.items.get(0).update(msg);
			},
			hideBtn: function() {
				this.items.get(1).setVisible(false);
			},
			showBtn: function() {
				this.items.get(1).setVisible(true);
			}
		});
	},
	initCustomBindingDataTip: function() {
		var me = this,
			store = me.getStore();
		this.customBindingDataTip = new EnterpriseSheet.sheet.pop.FloatingContainer({
			cls: "ss-var-ct",
			defaultAlign: "tl-tr?",
			width: 300,
			autoHeight: true,
			items: [{
				xtype: "component",
				cls: "ss-var-inner"
			}],
			updateContent: function(msg) {
				this.items.get(0).update(msg);
			}
		});
	},
	initExceptionTip: function() {
		this.exceptionTip = new EnterpriseSheet.sheet.pop.FloatingContainer({
			cls: "ss-exception-ct",
			defaultAlign: "tr-tl?",
			width: 200,
			autoHeight: true
		});
	},
	constructor: function(config) {
		Ext.apply(this, config);
		this.mixins.basic.beforeConstructor.apply(this);
		this.callParent(arguments);
		this.mixins.basic.afterConstructor.apply(this);
		this.bindListeners();
	},
	initComponent: function() {
		SABOX.addHotKey(this);
		this.clipboard = new EnterpriseSheet.sheet.action.ClipBoard;
		this.clipboard.init(this);
		this.autofill = new EnterpriseSheet.sheet.autofill.Autofill;
		this.autofill.init(this);
		this.layout = "fit";
		var sheetId = this.getSheetId();
		this.cls = this.cls || "";
		this.cls = "ss-ct " + this.cls;
		var lw = this.maxRowIndexDigital * this.digitalWidth + this.spaceWidth;
		this.store.setLeftWidth(sheetId, lw);
		this.ltcorner = new EnterpriseSheet.sheet.regions.Corner({
			store: this.store,
			sheet: this
		});
		this.lheader = new EnterpriseSheet.sheet.regions.Header({
			hidden: true,
			fixedRowForResize: true,
			store: this.store,
			scrollConfig: {
				dir: "none",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},
			resizerConfig: {
				rtype: "ColumnResizer",
				proxy: "ss-cproxy"
			}
		});
		this.sheader = new EnterpriseSheet.sheet.regions.Header({
			fixedRowForResize: true,
			store: this.store,
			scrollConfig: {
				dir: "none",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},
			resizerConfig: {
				rtype: "ColumnResizer",
				proxy: "ss-cproxy"
			}
		});
		this.ulefter = new EnterpriseSheet.sheet.regions.Lefter({
			hidden: true,
			fixedColForResize: true,
			store: this.store,
			scrollConfig: {
				dir: "none",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},
			resizerConfig: {
				rtype: "RowResizer",
				proxy: "ss-rproxy"
			}
		});
		this.slefter = new EnterpriseSheet.sheet.regions.Lefter({
			fixedColForResize: true,
			store: this.store,
			scrollConfig: {
				dir: "none",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			},
			resizerConfig: {
				rtype: "RowResizer",
				proxy: "ss-rproxy"
			}
		});
		this.ltregion = new EnterpriseSheet.sheet.regions.Region({
			hidden: true,
			cls: "ss-ltregion",
			fixedRowForResize: true,
			fixedColForResize: true,
			store: this.store,
			scrollConfig: {
				dir: "none",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});
		this.tregion = new EnterpriseSheet.sheet.regions.Region({
			hidden: true,
			cls: "ss-tregion",
			fixedRowForResize: true,
			store: this.store,
			scrollConfig: {
				dir: "y",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});
		this.lregion = new EnterpriseSheet.sheet.regions.Region({
			hidden: true,
			cls: "ss-lregion",
			fixedColForResize: true,
			store: this.store,
			scrollConfig: {
				dir: "x",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});
		this.cregion = new EnterpriseSheet.sheet.regions.Region({
			cls: "ss-cregion",
			store: this.store,
			scrollConfig: {
				dir: "xy",
				scrollStep: this.scrollStep,
				alwaysVisible: this.scrollerAlwaysVisible
			}
		});
		this.defaults = this.defaults || {};
		Ext.applyIf(this.defaults, {
			sheetId: this.getSheetId()
		});
		this.innerCt = new Ext.container.Container({
			cls: "ss-inner-ct",
			layout: {
				type: "sheettable",
				columns: 3
			},
			items: [this.ltcorner, this.lheader, this.sheader, this.ulefter, this.ltregion, this.tregion, this.slefter, this.lregion, this.cregion]
		});
		this.items = [this.innerCt];
		this.regionLookup = ["ulefter", "slefter", "lheader", "sheader", "ltregion", "tregion", "lregion", "cregion"];
		this.bodyRegionLookup = ["ltregion", "lregion", "tregion", "cregion"];
		this.floorRegionLookup = ["ltregion", "lregion", "tregion", "cregion"];
		this.lefterHeaderRegionLookup = ["ulefter", "slefter", "lheader", "sheader"];
		this.initReferenceModel();
		this.initEditor();
		this.initTableTpl();
		this.initFilter();
		this.initDataTypeProcessor();
		this.callParent();
		if(this.enableCommentTip) {
			this.initCommentTip();
		}
		if(this.enableVariableTip) {
			this.initVariableTip();
		}
		if(this.enableCustomBindingDataTip) {
			this.initCustomBindingDataTip();
		}
		this.initExceptionTip();
		this.relayEvents(this.ltcorner, ["selectionchange", "referencechange", "cellmouseup"]);
		var evts = ["columnchange", "rowchange", "cellcontextmenu", "incellmousedown", "beforecellmousedown", "preparecellmousedown", "cellmousedown", "cellmouseenter", "cellmouseout", "cellmouseover", "cellmousemove", "cellmousedrag", "celldblclick", "cellclick", "cellmouseup", "focuschange", "selectionchange", "pushcurrentselection", "referencechange", "selectionmoving", "showreference", "hidereference", "dragscrollinglimited", "prepareautofillstyle", "resetautofillstyle", "autofilldragend", "startmovereference", "beforemovingreference", "movingreference", "endmovereference", "referencemouseup", "rowscrolling", "colscrolling", "clickcellitem"];
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			this.relayEvents(this[this.regionLookup[i]], evts);
		}
		evts = ["beforehiderow", "beforehidecolumn", "beforeshowrow", "beforeshowcolumn"];
		this.relayEvents(this.lheader, evts);
		this.relayEvents(this.ulefter, evts);
		this.relayEvents(this.ltregion, evts);
		this.relayEvents(this.tregion, evts);
		this.relayEvents(this.lregion, evts);
		evts = ["columnresized", "selectedcolumnresized"];
		this.relayEvents(this.lheader, evts);
		this.relayEvents(this.sheader, evts);
		evts = ["rowresized", "rowautoresized", "selectedrowresized"];
		this.relayEvents(this.ulefter, evts);
		this.relayEvents(this.slefter, evts);
		evts = ["processdata"];
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++) {
			this.relayEvents(this[this.bodyRegionLookup[i]], evts);
		}
	},
	initEditor: function() {
		if(!this.editor && this.useDefaultEditor) {
			this.editor = new EnterpriseSheet.sheet.editor.CellEditor({
				disableCalEditorStyle: this.disableCalEditorStyle,
				showValueInCalEditor: this.showValueInCalEditor
			});
		}
		this.editor.init(this);
	},
	initTableTpl: function() {
		if(!this.tableTpl && this.useDefaultTableTpl) {
			this.tableTpl = new EnterpriseSheet.sheet.tpl.TableTemplate;
		}
		this.tableTpl.init(this);
	},
	initFilter: function() {
		if(!this.filter && this.useDefaultFilter) {
			this.filter = new EnterpriseSheet.sheet.filter.Filter;
		}
		this.filter.init(this);
	},
	initReferenceModel: function() {
		var rm = this.getReferenceModel();
		for(var i = 0, len = this.lefterHeaderRegionLookup.length; i < len; i++) {
			var region = this[this.lefterHeaderRegionLookup[i]];
			rm.bindListener2Region(region);
		}
	},
	bindListeners: function() {
		this.mixins.basic.bindListeners.apply(this, arguments);
		this.mon(this.store, {
			scope: this,
			clear: this.refresh,
			loadingmore: this.onLoadingMore
		});
		if(this.enableRowColGroup) {
			this.mon(this.innerCt, {
				scope: this,
				afterrender: this.afterInnerCtRender
			});
		}
		this.mon(this.lheader, {
			colscrolling: this.onLHeaderColScrolling,
			columnresized: this.onLeftColumnResize,
			selectedcolumnresized: this.onLeftColumnResize,
			scope: this
		});
		this.mon(this.sheader, {
			colscrolling: this.onSHeaderColScrolling,
			scope: this
		});
		this.mon(this.ulefter, {
			rowscrolling: this.onULefterRowScrolling,
			rowresized: this.onUpperRowResize,
			selectedrowresized: this.onUpperRowResize,
			scope: this
		});
		this.mon(this.slefter, {
			rowscrolling: this.onSLefterRowScrolling,
			scope: this
		});
		this.mon(this.ltregion, {
			rowscrolling: this.onLTRegionRowScrolling,
			colscrolling: this.onLTRegionColScrolling,
			scope: this
		});
		this.mon(this.tregion, {
			rowscrolling: this.onTRegionRowScrolling,
			colscrolling: this.onTRegionColScrolling,
			scope: this
		});
		this.mon(this.lregion, {
			rowscrolling: this.onLRegionRowScrolling,
			colscrolling: this.onLRegionColScrolling,
			scope: this
		});
		this.mon(this.cregion, {
			rowscrolling: this.onCRegionRowScrolling,
			colscrolling: this.onCRegionColScrolling,
			scope: this
		});
		this.on({
			scope: this,
			render: this._onRender,
			afterrender: this._afterRender,
			focuschange: this.onFocusChange,
			selectionchange: this.onSelectionChange,
			pushcurrentselection: this.onPushSelection,
			cellmousedown: this.onCellMouseDown,
			beforecellmousedown: this.beforeCellMouseDown,
			referencechange: this.onReferenceChange,
			prepareautofillstyle: this.onPrepareAutofill,
			resetautofillstyle: this.onResetAutofill,
			showreference: this.onShowReferenceModel,
			hidereference: this.onHideReferenceModel,
			dragscrollinglimited: this.onDragScrollingLimited,
			beforehiderow: this.beforeHideRow,
			beforehidecolumn: this.beforeHideColumn,
			beforeshowrow: this.beforeShowRow,
			beforeshowcolumn: this.beforeShowColumn,
			processdata: function(sheetId, row, col, cell, timestamp, region, withoutZoom) {
				this.processData(sheetId, row, col, cell, timestamp, undefined, region, withoutZoom);
			},
			selectionmoving: this.moveSelection,
			chartfocus: this.onChartFocus,
			floormove: this.onFloorMoveResize,
			floorresize: this.onFloorMoveResize,
			rangestorecoordchagne: this.onRangeStoreCoordChange,
			chartchange: this.onChartChange,
			clickcellitem: this.onClickCellItem,
			cellmousemove: this.onCellMouseMove,
			selectedcolumnresized: this.onSelectedColumnResized,
			columnresized: this.onColumnResized,
			rowresized: this.onRowResized,
			selectedrowresized: this.onSelectedRowResized,
			changing: this.onChanging,
			keydown: this.onKeyDown,
			try2changepartofarrayformula: this.onTry2ChangePartOfArrayFormula,
			beforecompleteedit: this.beforeCompleteEdit,
			loseeditingfocus: this.onLoseEditingFocus,
			highlightcells: this.onHighlightCells
		});
		this.mon(this.editor, {
			scope: this,
			keydown: this.onEditorKeyDown
		});
		this.innerCt.on("resize", this.processAfterResize, this, {
			buffer: this.resizeCheckBuffer
		});
	},
	afterInnerCtRender: function(ct) {
		var ctEl = ct.getEl();
		this.mon(ctEl, {
			scope: this,
			click: this.onClickInnerCt
		});
		if(SCOM.needShowLogo()) {
			SCOM.showPoweredByLogo(ctEl);
		}
		this.fzXLineEl = Ext.core.DomHelper.append(ctEl.dom, "<div class=\"ss-fz-xline\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>", true);
		this.fzYLineEl = Ext.core.DomHelper.append(ctEl.dom, "<div class=\"ss-fz-yline\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>", true);
	},
	onLoseEditingFocus: function() {
		this.editor.focus(100);
	},
	isInShowRange: function(sheetId, row, col) {
		if(this.getSheetId() == sheetId) {
			for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++) {
				var region = this[this.bodyRegionLookup[i]];
				if(region.isVisible() && region.isInRange(row, col)) {
					return true;
				}
			}
		}
		return false;
	},
	getCellEls: function(row, col) {
		var arr = [];
		var r = this.cregion;
		if(r.isInRange(row, col)) {
			var el = r.getCellEl(row, col);
			if(el) {
				arr.push(el);
			}
		}
		var r = this.tregion;
		if(r.isVisible()) {
			if(r.isInRange(row, col)) {
				var el = r.getCellEl(row, col);
				if(el) {
					arr.push(el);
				}
			}
		}
		var r = this.lregion;
		if(r.isVisible()) {
			if(r.isInRange(row, col)) {
				var el = r.getCellEl(row, col);
				if(el) {
					arr.push(el);
				}
			}
		}
		var r = this.ltregion;
		if(r.isVisible()) {
			if(r.isInRange(row, col)) {
				var el = r.getCellEl(row, col);
				if(el) {
					arr.push(el);
				}
			}
		}
		return arr;
	},
	getSelectionModel: function() {
		return this.cregion.getSelectionModel();
	},
	getReferenceModel: function() {
		return this.cregion.getReferenceModel();
	},
	getClipboard: function() {
		return this.clipboard;
	},
	getAutofill: function() {
		return this.autofill;
	},
	enableSelect: function() {
		this.ltcorner.enableSelect();
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			region.enableSelect();
		}
	},
	disableSelect: function() {
		this.ltcorner.disableSelect();
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			region.disableSelect();
		}
	},
	enableRefer: function(clear, single, simple) {
		this.ltcorner.enableRefer();
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			if(region.getReferenceModel()) {
				region.enableRefer.apply(region, arguments);
			}
		}
	},
	disableRefer: function(clear, single) {
		this.ltcorner.disableRefer();
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			if(region.getReferenceModel()) {
				region.disableRefer.apply(region, arguments);
			}
		}
	},
	enableEdit: function() {
		if(this.editor) {
			this.editor.enable();
		}
	},
	disableEdit: function() {
		if(this.editor) {
			this.editor.disable();
		}
	},
	getEditor: function() {
		return this.editor;
	},
	setSecondTRVisible: function(visible) {
		var layout = this.getLayout();
		if(visible) {
			layout.getRow(1).style.display = "";
		} else {
			layout.getRow(1).style.display = "none";
		}
	},
	onSelectionChange: function(startPos, endPos, region, sm) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var r = this[this.regionLookup[i]];
			if(r.isVisible()) {
				var selModel = r.getSelectionModel();
				if(selModel && sm != selModel) {
					selModel.selectRange(startPos, endPos, true);
				}
			}
		}
		this.currentRegion = region;
		this.focus(this.focusDelayTime);
		this.ltcorner.onSelectWholeSheet((1 >= startPos.row || 1 >= endPos.row) && (1 >= startPos.col || 1 >= endPos.col));
	},
	onPushSelection: function(sm) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var r = this[this.regionLookup[i]];
			if(r.isVisible()) {
				var selModel = r.getSelectionModel();
				if(selModel && selModel instanceof EnterpriseSheet.sheet.sm.CellSelectionModel) {
					selModel.pushSelection();
				}
			}
		}
	},
	getCurrentRegion: function() {
		if(this.isFreezed()) {
			var rowStart = this.cregion.rowStart,
				colStart = this.cregion.colStart;
			var sm = this.cregion.getSelectionModel();
			var focusCell = sm.getFocusCell();
			var row = focusCell.row,
				col = focusCell.col;
			if(row < rowStart && col < colStart) {
				return this.ltregion;
			} else if(row < rowStart) {
				return this.tregion;
			} else if(col < colStart) {
				return this.lregion;
			} else {
				return this.cregion;
			}
		} else {
			if(this.isSplited()) {
				if(this.lheader == this.currentRegion || this.ulefter == this.currentRegion) {
					return this.ltregion;
				} else if(this.sheader == this.currentRegion) {
					return this.tregion;
				} else if(this.slefter == this.currentRegion) {
					return this.lregion;
				} else if(this.ltcorner == this.currentRegion) {
					return this.cregion;
				}
				return this.currentRegion || this.cregion;
			} else {
				return this.cregion;
			}
		}
	},
	simulateFocusChange: function() {
		var sm = this.getSelectionModel(),
			focusCell = sm.focusCell;
		var cd = this.store.getCell(this.getSheetId(), focusCell.row, focusCell.col);
		this.fireEvent("refreshfocus", focusCell.row, focusCell.col, sm, cd);
		this.onFocusChange(focusCell.row, focusCell.col, sm);
	},
	refreshFocus: function(row, col, suspendEvent) {
		var sm = this.getSelectionModel(),
			store = this.getStore();
		var focusCell = sm.getFocusCell();
		if(!SCOM.nullOrUndefined(row) && row !== focusCell.row || !SCOM.nullOrUndefined(col) && col !== focusCell.col) {
			sm.setFocusCell(row, col, suspendEvent);
		} else {
			if(!suspendEvent) {
				var sheetId = this.getSheetId();
				var cd = store.getCell(sheetId, focusCell.row, focusCell.col);
				this.fireEvent("refreshfocus", focusCell.row, focusCell.col, sm, cd);
			} else {
				this.onFocusChange(focusCell.row, focusCell.col, sm);
			}
		}
		this.focus(500);
	},
	onFocusChange: function(row, col, sm) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			var selModel = region.getSelectionModel();
			if(selModel && sm != selModel) {
				selModel.setFocusCell(row, col, true, true);
			}
		}
		var store = this.getStore(),
			editor = this.getEditor();
		var sheetId = this.getSheetId();
		var cd = store.getCellData(sheetId, row, col);
		var data = cd.data || "",
			flag = false;
		if(store.isDisabledCell(store.getActivedSheetId(), row, col)) {
			if(!editor.inputing) {
				editor.completeEdit();
			}
			editor.disable();
		} else {
			editor.enable();
		}
		if(cd.link) {
			this.showLinkKit({
				row: row,
				col: col
			}, cd);
		} else {
			this.hideLinkKit();
		}
		if(EnterpriseSheet.sheet.calculate.Calculate.prototype.isCalculate(data)) {
			if(Ext.isNumber(cd.afrow)) {
				var afrow = cd.afrow + row,
					afcol = cd.afcol + col;
				if(afrow !== row || afcol !== col) {
					cd = store.getCell(sheetId, afrow, afcol);
					data = cd.data;
				}
			}
			flag = this.syncReferenceForCalculate(data, true);
		} else if(this.isFitlerCell(cd)) {
			flag = this.filter.showFilterReference(cd, sheetId, row, col);
		}
		if(!flag) {
			var rm = this.getReferenceModel();
			if(rm.hasCls("ss-cal-ref")) {
				rm.hide();
			}
		}
	},
	onReferenceChange: function(region, rm, forceRefresh) {
		var refs = rm.getReference(true);
		var curCls = rm.curCls;
		var currentColorIndex = rm.colorIndex;
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var r = this[this.regionLookup[i]];
			if(r.isVisible()) {
				var refModel = r.getReferenceModel();
				if(refModel && r != region) {
					refModel.clearSelection(true);
					refModel.setReference(refs, forceRefresh, true, curCls, currentColorIndex);
				}
			}
		}
	},
	onShowReferenceModel: function(region, rm) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var r = this[this.regionLookup[i]];
			if(r.isVisible()) {
				var refModel = r.getReferenceModel();
				if(refModel && refModel != rm) {
					refModel.show(true);
				}
			}
		}
	},
	onHideReferenceModel: function(region, rm) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var r = this[this.regionLookup[i]];
			if(r.isVisible()) {
				var refModel = r.getReferenceModel();
				if(refModel && refModel != rm) {
					refModel.hide(true);
				}
			}
		}
	},
	_onRender: function() {
		if(this.el) {
			Ext.core.DomHelper.append(this.el.dom, "<div id=\"ss-cproxy\" class=\"ss-crz-xproxy\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div><div id=\"ss-rproxy\"  class=\"ss-crz-yproxy\" style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>");
		}
	},
	_afterRender: function() {
		this.getEl().setStyle("z-index", 0);
		if(this.loadMask) {
			var store = this.getStore();
			this.loadMask = new EnterpriseSheet.common.LoadMask(Ext.apply({
				target: this
			}, this.loadMask));
			store.on({
				scope: this,
				beforeload: function() {
					this.loadMask.show();
				}
			});
		}
	},
	initSelection: function() {
		var fn = function(region) {
			region.fireEvent("cellmousedown", region.rowStart, region.colStart, region);
		};
		if(this.ltregion.isVisible()) {
			fn(this.ltregion);
		} else if(this.tregion.isVisible()) {
			fn(this.tregion);
		} else if(this.lregion.isVisible()) {
			fn(this.lregion);
		} else {
			fn(this.cregion);
		}
	},
	onLHeaderColScrolling: function(offset, region) {
		var colStart = region.colStart,
			colEnd = region.colEnd,
			scrollLeft = region.ifctEl.dom.scrollLeft;
		if(this.ltregion.isVisible()) {
			this.ltregion.moveColumn(colStart, colEnd, scrollLeft);
		}
		this.lregion.moveColumn(colStart, colEnd, scrollLeft);
		this.lregion.sysInfinateScroller("x");
	},
	onSHeaderColScrolling: function(offset, region) {
		if(0 < offset) {
			if(this.tregion.isVisible()) {
				this.tregion.moveRight(offset);
			}
			this.cregion.moveRight(offset);
		} else {
			if(this.tregion.isVisible()) {
				this.tregion.moveLeft(-offset);
			}
			this.cregion.moveLeft(-offset);
		}
		this.cregion.sysInfinateScroller("x");
	},
	onULefterRowScrolling: function(offset, region) {
		var rowStart = region.rowStart,
			rowEnd = region.rowEnd,
			scrollTop = region.ifctEl.dom.scrollTop;
		if(this.ltregion.isVisible()) {
			this.ltregion.moveRow(rowStart, rowEnd, scrollTop);
		}
		this.tregion.moveRow(rowStart, rowEnd, scrollTop);
		this.tregion.sysInfinateScroller("y");
		this.checkLefterWidth();
	},
	onSLefterRowScrolling: function(offset, region) {
		var rowStart = region.rowStart,
			rowEnd = region.rowEnd,
			scrollTop = region.ifctEl.dom.scrollTop;
		if(this.lregion.isVisible()) {
			this.lregion.moveRow(rowStart, rowEnd, scrollTop);
		}
		this.cregion.moveRow(rowStart, rowEnd, scrollTop);
		this.cregion.sysInfinateScroller("y");
		this.checkLefterWidth();
	},
	onTRegionRowScrolling: function(offset, region) {
		var rowStart = region.rowStart,
			rowEnd = region.rowEnd,
			scrollTop = region.ifctEl.dom.scrollTop;
		this.ulefter.moveRow(rowStart, rowEnd, scrollTop);
		if(this.ltregion.isVisible()) {
			this.ltregion.moveRow(rowStart, rowEnd, scrollTop);
		}
		this.checkLefterWidth();
	},
	onLRegionColScrolling: function(offset, region) {
		var colStart = region.colStart,
			colEnd = region.colEnd,
			scrollLeft = region.ifctEl.dom.scrollLeft;
		this.lheader.moveColumn(colStart, colEnd, scrollLeft);
		if(this.ltregion.isVisible()) {
			this.ltregion.moveColumn(colStart, colEnd, scrollLeft);
		}
	},
	onLRegionRowScrolling: function(offset, region) {
		var rowStart = region.rowStart,
			rowEnd = region.rowEnd,
			scrollTop = region.ifctEl.dom.scrollTop;
		this.slefter.moveRow(rowStart, rowEnd, scrollTop);
		this.cregion.moveRow(rowStart, rowEnd, scrollTop);
		this.cregion.sysInfinateScroller("y");
		this.checkLefterWidth();
	},
	onLTRegionRowScrolling: function(offset, region) {
		var rowStart = region.rowStart,
			rowEnd = region.rowEnd,
			scrollTop = region.ifctEl.dom.scrollTop;
		this.ulefter.moveRow(rowStart, rowEnd, scrollTop);
		this.tregion.moveRow(rowStart, rowEnd, scrollTop);
		this.tregion.sysInfinateScroller("y");
		this.checkLefterWidth();
	},
	onCRegionRowScrolling: function(offset, region) {
		var rowStart = region.rowStart,
			rowEnd = region.rowEnd,
			scrollTop = region.ifctEl.dom.scrollTop;
		this.slefter.moveRow(rowStart, rowEnd, scrollTop);
		if(this.lregion.isVisible()) {
			this.lregion.moveRow(rowStart, rowEnd, scrollTop);
		}
		this.checkLefterWidth();
	},
	onLTRegionColScrolling: function(offset, region) {
		var colStart = region.colStart,
			colEnd = region.colEnd,
			scrollLeft = region.ifctEl.dom.scrollLeft;
		this.lheader.moveColumn(colStart, colEnd, scrollLeft);
		this.lregion.moveColumn(colStart, colEnd, scrollLeft);
		this.lregion.sysInfinateScroller("x");
	},
	onTRegionColScrolling: function(offset, region) {
		var colStart = region.colStart,
			colEnd = region.colEnd,
			scrollLeft = region.ifctEl.dom.scrollLeft;
		this.sheader.moveColumn(colStart, colEnd, scrollLeft);
		this.cregion.moveColumn(colStart, colEnd, scrollLeft);
		this.cregion.sysInfinateScroller("x");
	},
	onCRegionColScrolling: function(offset, region) {
		var colStart = region.colStart,
			colEnd = region.colEnd,
			scrollLeft = region.ifctEl.dom.scrollLeft;
		this.sheader.moveColumn(colStart, colEnd, scrollLeft);
		if(this.tregion.isVisible()) {
			this.tregion.moveColumn(colStart, colEnd, scrollLeft);
		}
	},
	getPaddingOffset: function() {
		var p = 0;
		if(this.isSplited()) {
			p = this.getStore().splitOffset;
		}
		return p;
	},
	processAfterResize: function(comp, width, height) {
		var innerEl = this.getInnerEl();
		width = innerEl.getWidth();
		height = innerEl.getHeight();
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var p = this.getPaddingOffset();
		var lw = s.getColWidth(sheetId, 0, true, true),
			hh = s.getRowHeight(sheetId, 0, true, true);
		var sw = width - innerEl.getBorderWidth("lr") - lw - p,
			sh = height - innerEl.getBorderWidth("tb") - hh - p;
		this.ltcorner.setSize(lw, hh);
		if(this.isFreezed() || this.isSplited()) {
			var fw = 0;
			if(this.lheader.isVisible()) {
				fw = this.lheader.getWidth();
			}
			var fh = 0;
			if(this.ulefter.isVisible()) {
				fh = this.ulefter.getHeight();
			}
			if(sw > fw) {
				sw -= fw;
			}
			if(sh > fh) {
				sh -= fh;
			}
			if(this.tregion.isVisible()) {
				this.tregion.setSize(sw, fh);
			}
			if(this.lregion.isVisible()) {
				this.lregion.setSize(fw, sh);
			}
			this.sheader.setSize(sw, hh);
			this.slefter.setSize(lw, sh);
			this.cregion.setSize(sw, sh);
		} else {
			this.sheader.setSize(sw, hh);
			this.slefter.setSize(lw, sh);
			this.cregion.setSize(sw, sh);
		}
		if(!this._firstInitSelection) {
			this._firstInitSelection = true;
			this.initSelection();
			this.fireEvent("afterlayoutresized", this);
		}
	},
	getRowStart: function() {
		return this.ulefter.isVisible() || this.tregion.isVisible() ? this.ulefter.rowStart : this.slefter.rowStart;
	},
	getColStart: function() {
		return this.lheader.isVisible() || this.lregion.isVisible() ? this.lheader.colStart : this.sheader.colStart;
	},
	getMaxRow: function() {
		if(this.ulefter.isVisible()) {
			var u = this.ulefter.rowEnd,
				s = this.slefter.rowEnd;
			return u > s ? u : s;
		} else {
			return this.slefter.rowEnd;
		}
	},
	countCell: function() {
		var sum = 0;
		var r = this.cregion;
		sum += (r.rowEnd - r.rowStart + 1) * (r.colEnd - r.colStart + 1);
		if(this.tregion.isVisible()) {
			r = this.tregion;
			sum += (r.rowEnd - r.rowStart + 1) * (r.colEnd - r.colStart + 1);
		}
		if(this.lregion.isVisible()) {
			r = this.lregion;
			sum += (r.rowEnd - r.rowStart + 1) * (r.colEnd - r.colStart + 1);
		}
		if(this.ltregion.isVisible()) {
			r = this.ltregion;
			sum += (r.rowEnd - r.rowStart + 1) * (r.colEnd - r.colStart + 1);
		}
		return sum;
	},
	getInnerEl: function() {
		return this.innerCt.getEl();
	},
	switchLeftRangeForFreeze: function(row, col) {
		var colStart = this.getColStart();
		var rowStart = this.getRowStart();
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth() - El.getBorderWidth("lr"),
			height = El.getHeight() - El.getBorderWidth("tb");
		var lw = s.getColWidth(sheetId, 0, true, true),
			hh = s.getRowHeight(sheetId, 0, true, true);
		var w = s.getRangeWidth(sheetId, colStart, col - 1, undefined, true);
		var h = s.getRangeHeight(sheetId, rowStart, row - 1, undefined, true);
		var fw = lw + w,
			fh = hh + h;
		this.fzXLineEl.setStyle("top", fh + "px");
		this.fzYLineEl.setStyle("left", fw + "px");
		var sw = width - fw;
		var sh = height - fh;
		var lowcol = col;
		if(colStart < col) {
			this.lheader.show();
			this.lregion.show();
			this.sheader.recalculateRange(null, {
				colStart: col,
				width: sw
			});
			this.sheader.setBound(null, {
				low: col,
				high: false
			});
			this.sheader.sysn();
			this.lheader.recalculateRange({
				rowStart: 0,
				rowEnd: 0,
				height: hh
			}, {
				colStart: colStart,
				colEnd: col - 1,
				width: w
			});
			this.lheader.setBound(null, {
				low: colStart,
				high: col - 1
			});
			this.lheader.sysn();
			this.lregion.recalculateRange({
				rowStart: row,
				height: sh
			}, {
				colStart: colStart,
				colEnd: col - 1,
				width: w
			});
			this.lregion.setBound({
				low: rowStart < row ? row : 1,
				high: false
			}, {
				low: colStart,
				high: col - 1
			});
			this.lregion.sysn();
		} else {
			var lowcol = 1;
			if(this.lheader.isVisible()) {
				this.lheader.hide();
				this.lregion.hide();
				this.sheader.recalculateRange(null, {
					colStart: col,
					width: sw
				});
				this.sheader.setBound(null, {
					low: lowcol,
					high: false
				});
				this.sheader.sysn();
			}
		}
		return lowcol;
	},
	switchTopRangeForFreeze: function(row, col) {
		var colStart = this.getColStart();
		var rowStart = this.getRowStart();
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth() - El.getBorderWidth("lr"),
			height = El.getHeight() - El.getBorderWidth("tb");
		var lw = s.getColWidth(sheetId, 0, true, true),
			hh = s.getRowHeight(sheetId, 0, true, true);
		var w = s.getRangeWidth(sheetId, colStart, col - 1, undefined, true);
		var h = s.getRangeHeight(sheetId, rowStart, row - 1, undefined, true);
		var sw = width - lw - w;
		var sh = height - hh - h;
		var lowrow = row;
		if(rowStart < row) {
			this.ulefter.show();
			this.tregion.show();
			this.slefter.recalculateRange({
				rowStart: row,
				rowEnd: this.lregion.isVisible() ? this.lregion.rowEnd : null,
				height: sh
			});
			this.slefter.setBound({
				low: row,
				high: false
			});
			this.slefter.sysn();
			this.ulefter.recalculateRange({
				rowStart: rowStart,
				rowEnd: row - 1,
				height: h
			}, {
				colStart: 0,
				colEnd: 0,
				width: lw
			});
			this.ulefter.setBound({
				low: rowStart,
				high: row - 1
			});
			this.ulefter.sysn();
			this.tregion.recalculateRange({
				rowStart: rowStart,
				rowEnd: row - 1,
				height: h
			}, {
				colStart: col,
				colEnd: this.sheader.colEnd,
				width: sw
			});
			this.tregion.setBound({
				low: rowStart,
				high: row - 1
			}, {
				low: colStart < col ? col : 1,
				high: false
			});
			this.tregion.sysn();
		} else {
			lowrow = 1;
			if(this.ulefter.isVisible()) {
				this.ulefter.hide();
				this.tregion.hide();
				this.slefter.recalculateRange({
					rowStart: row,
					height: sh
				});
				this.slefter.setBound({
					low: lowrow,
					high: false
				});
				this.slefter.sysn();
			}
		}
		return lowrow;
	},
	switchLeftTopRangeForFreeze: function(row, col) {
		var colStart = this.getColStart();
		var rowStart = this.getRowStart();
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var w = s.getRangeWidth(sheetId, colStart, col - 1, undefined, true);
		var h = s.getRangeHeight(sheetId, rowStart, row - 1, undefined, true);
		if(colStart < col && rowStart < row) {
			this.ltregion.show();
			this.ltregion.recalculateRange({
				rowStart: rowStart,
				rowEnd: row - 1,
				height: h
			}, {
				colStart: colStart,
				colEnd: col - 1,
				width: w
			});
			this.ltregion.setBound({
				low: rowStart,
				high: row - 1
			}, {
				low: colStart,
				high: col - 1
			});
			this.ltregion.sysn();
		} else {
			this.ltregion.hide();
		}
	},
	switchFreezeCls: function(on) {
		if(on) {
			this.removeSplitCss();
			this.addCls("ss-freeze");
		} else {
			this.removeCls("ss-freeze");
		}
	},
	freeze: function(row, col, suspendEvent) {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		if(row < 1) {
			row = 1;
		}
		if(col < 1) {
			col = 1;
		}
		var oldFreezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null;
		var oldSplitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
		var oldRangeInfo = this.getRangeInfo();
		this.freezePos = this.freezePos || {};
		var fp = this.freezePos;
		if(fp.row != row || fp.col != col) {
			fp.row = row;
			fp.col = col;
			delete this.splitPos;
			this.switchFreezeCls(true);
			var colStart = this.getColStart();
			var rowStart = this.getRowStart();
			var El = this.getInnerEl();
			var width = El.getWidth() - El.getBorderWidth("lr"),
				height = El.getHeight() - El.getBorderWidth("tb");
			var lw = s.getColWidth(sheetId, 0, true, true),
				hh = s.getRowHeight(sheetId, 0, true, true);
			var w = s.getRangeWidth(sheetId, colStart, col - 1, undefined, true);
			var h = s.getRangeHeight(sheetId, rowStart, row - 1, undefined, true);
			var sw = width - lw - w;
			var sh = height - hh - h;
			var lowcol = this.switchLeftRangeForFreeze(row, col);
			var lowrow = this.switchTopRangeForFreeze(row, col);
			this.switchLeftTopRangeForFreeze(row, col);
			this.cregion.recalculateRange({
				rowStart: row,
				rowEnd: this.slefter.rowEnd,
				height: sh
			}, {
				colStart: col,
				colEnd: this.sheader.colEnd,
				width: sw
			});
			this.cregion.setBound({
				low: lowrow,
				high: false
			}, {
				low: lowcol,
				high: false
			});
			this.cregion.sysn();
			this.refreshSelection();
			if(row <= rowStart && col <= colStart) {
				delete this.freezePos;
			}
			this.updateSheetConfig(true);
			if(!suspendEvent) {
				var freezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null;
				var splitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
				var rangeInfo = this.getRangeInfo();
				this.fireEvent("freezechange", freezePos, oldFreezePos, splitPos, oldSplitPos, rangeInfo, oldRangeInfo, this);
			}
		}
	},
	unfreeze: function(suspendEvent) {
		if(this.isFreezed()) {
			var oldFreezePos = Ext.apply({}, this.freezePos);
			var oldSplitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
			var oldRangeInfo = this.getRangeInfo();
			var s = this.getStore();
			var sheetId = this.getSheetId();
			var El = this.getInnerEl();
			var width = El.getWidth() - El.getBorderWidth("lr"),
				height = El.getHeight() - El.getBorderWidth("tb");
			this.switchFreezeCls(false);
			var col = this.lheader.isVisible() ? this.lheader.colStart : this.sheader.colStart;
			var row = this.ulefter.isVisible() ? this.ulefter.rowStart : this.slefter.rowStart;
			this.lheader.hide();
			this.ulefter.hide();
			this.ltregion.hide();
			this.lregion.hide();
			this.tregion.hide();
			var lw = s.getColWidth(sheetId, 0, true, true),
				hh = s.getRowHeight(sheetId, 0, true, true);
			var sw = width - lw;
			var sh = height - hh;
			if(1 < this.freezePos.col) {
				this.sheader.recalculateRange(null, {
					colStart: col,
					width: sw
				});
				this.sheader.setBound(null, {
					low: 1,
					high: false
				});
				this.sheader.sysn();
			}
			if(1 < this.freezePos.row) {
				this.slefter.recalculateRange({
					rowStart: row,
					height: sh
				});
				this.slefter.setBound({
					low: 1,
					high: false
				});
				this.slefter.sysn();
			}
			this.cregion.recalculateRange({
				rowStart: row,
				rowEnd: this.slefter.rowEnd,
				height: sh
			}, {
				colStart: col,
				colEnd: this.sheader.colEnd,
				width: sw
			});
			this.cregion.setBound({
				low: 1,
				high: false
			}, {
				low: 1,
				high: false
			});
			this.cregion.sysn();
			delete this.freezePos;
			this.refreshSelection();
			this.updateSheetConfig(true);
			if(!suspendEvent) {
				var rangeInfo = this.getRangeInfo();
				var splitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
				this.fireEvent("freezechange", null, oldFreezePos, splitPos, oldSplitPos, rangeInfo, oldRangeInfo, this);
			}
		}
	},
	setCtTdOffset: function(region, dir, offset) {
		var td = region.getEl().parent("td");
		if(0 < offset) {
			offset -= 1;
		}
		td.setStyle("padding-" + dir, offset + "px");
	},
	switchSplitCls: function(on) {
		if(on) {
			var p = this.getStore().splitOffset;
			this.removeCls("ss-freeze");
			this.addCls("ss-split");
			if(0 < this.splitPos.width) {
				this.setCtTdOffset(this.lregion, "right", p);
				this.setCtTdOffset(this.ltregion, "right", p);
				this.cregion.addCls("ss-leftborder");
				this.sheader.addCls("ss-leftborder");
				this.tregion.addCls("ss-leftborder");
				this.lregion.switchScroller(true);
			} else {
				this.setCtTdOffset(this.lregion, "right", 0);
				this.setCtTdOffset(this.ltregion, "right", 0);
				this.cregion.removeCls("ss-leftborder");
				this.sheader.removeCls("ss-leftborder");
				this.tregion.removeCls("ss-leftborder");
				this.lregion.switchScroller(false);
			}
			if(0 < this.splitPos.height) {
				this.setCtTdOffset(this.tregion, "bottom", p);
				this.setCtTdOffset(this.ltregion, "bottom", p);
				this.cregion.addCls("ss-topborder");
				this.slefter.addCls("ss-topborder");
				this.lregion.addCls("ss-topborder");
				this.tregion.switchScroller(true);
			} else {
				this.setCtTdOffset(this.tregion, "bottom", 0);
				this.setCtTdOffset(this.ltregion, "bottom", 0);
				this.cregion.removeCls("ss-topborder");
				this.slefter.removeCls("ss-topborder");
				this.lregion.removeCls("ss-topborder");
				this.tregion.switchScroller(false);
			}
		} else {
			this.removeSplitCss();
		}
	},
	split: function(splitWidth, splitHeight, suspendEvent) {
		var sheetId = this.getSheetId();
		var oldFreezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null;
		var oldSplitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
		var oldRangeInfo = this.getRangeInfo();
		this.splitPos = this.splitPos || {};
		var sp = this.splitPos;
		if(sp.height != splitHeight || sp.width != splitWidth) {
			var s = this.getStore();
			sp.width = splitWidth;
			sp.height = splitHeight;
			delete this.freezePos;
			this.switchSplitCls(true);
			var colStart = this.getColStart();
			var rowStart = this.getRowStart();
			var El = this.getInnerEl();
			var width = El.getWidth() - El.getBorderWidth("lr"),
				height = El.getHeight() - El.getBorderWidth("tb");
			var lw = s.getColWidth(sheetId, 0, true, true),
				hh = s.getRowHeight(sheetId, 0, true, true),
				p = s.splitOffset;
			var sw = width - lw - splitWidth;
			if(0 < splitWidth) {
				sw -= p;
			}
			var sh = height - hh - splitHeight;
			if(0 < splitHeight) {
				sh -= p;
			}
			if(0 < splitWidth) {
				this.lheader.show();
				this.lregion.show();
				this.lheader.recalculateRange({
					rowStart: 0,
					rowEnd: 0,
					height: hh
				}, {
					colStart: colStart,
					width: splitWidth
				});
				this.lheader.setBound(null, {
					low: 1,
					high: false
				});
				this.lheader.sysn();
				this.sheader.recalculateRange(null, {
					colStart: this.lheader.colEnd + 1,
					width: sw
				});
				this.sheader.setBound(null, {
					low: 1,
					high: false
				});
				this.sheader.sysn();
			}
			if(0 < splitHeight) {
				this.ulefter.show();
				this.tregion.show();
				this.ulefter.recalculateRange({
					rowStart: rowStart,
					height: splitHeight
				}, {
					colStart: 0,
					colEnd: 0,
					width: lw
				});
				this.ulefter.setBound({
					low: 1,
					high: false
				});
				this.ulefter.sysn();
				this.slefter.recalculateRange({
					rowStart: this.ulefter.rowEnd + 1,
					height: sh
				});
				this.slefter.setBound({
					low: 1,
					high: false
				});
				this.slefter.sysn();
			}
			if(0 < splitWidth) {
				this.lregion.recalculateRange({
					rowStart: this.slefter.rowStart,
					rowEnd: this.slefter.rowEnd,
					height: sh
				}, {
					colStart: colStart,
					colEnd: this.lheader.colEnd,
					width: splitWidth
				});
				this.lregion.setBound({
					low: 1,
					high: false
				}, {
					low: 1,
					high: false
				});
				this.lregion.sysn();
			}
			if(0 < splitHeight) {
				this.tregion.recalculateRange({
					rowStart: rowStart,
					rowEnd: this.ulefter.rowEnd,
					height: splitHeight
				}, {
					colStart: this.sheader.colStart,
					colEnd: this.sheader.colEnd,
					width: sw
				});
				this.tregion.setBound({
					low: 1,
					high: false
				}, {
					low: 1,
					high: false
				});
				this.tregion.sysn();
			}
			if(0 < splitWidth && 0 < splitHeight) {
				this.ltregion.show();
				this.ltregion.recalculateRange({
					rowStart: rowStart,
					rowEnd: this.ulefter.rowEnd,
					height: splitHeight
				}, {
					colStart: colStart,
					colEnd: this.lheader.colEnd,
					width: splitWidth
				});
				this.ltregion.setBound({
					low: 1,
					high: false
				}, {
					low: 1,
					high: false
				});
				this.ltregion.sysn();
			}
			sh++;
			sw++;
			this.cregion.recalculateRange({
				rowStart: this.slefter.rowStart,
				rowEnd: this.slefter.rowEnd,
				height: sh
			}, {
				colStart: this.sheader.colStart,
				colEnd: this.sheader.colEnd,
				width: sw
			});
			this.cregion.setBound({
				low: 1,
				high: false
			}, {
				low: 1,
				high: false
			});
			this.cregion.sysn();
			this.refreshSelection();
			this.updateSheetConfig(true);
			if(!suspendEvent) {
				var freezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null;
				var splitPos = this.splitPos ? Ext.apply({}, this.splitPos) : null;
				var rangeInfo = this.getRangeInfo();
				this.fireEvent("splitchange", splitPos, oldSplitPos, freezePos, oldFreezePos, rangeInfo, oldRangeInfo, this);
			}
		}
	},
	removeSplitCss: function() {
		this.removeCls("ss-split");
		this.setCtTdOffset(this.lregion, "right", 0);
		this.setCtTdOffset(this.tregion, "bottom", 0);
		this.setCtTdOffset(this.ltregion, "right", 0);
		this.setCtTdOffset(this.ltregion, "bottom", 0);
		this.cregion.removeCls("ss-leftborder");
		this.sheader.removeCls("ss-leftborder");
		this.lregion.removeCls("ss-topborder");
		this.tregion.removeCls("ss-leftborder");
		this.cregion.removeCls("ss-topborder");
		this.slefter.removeCls("ss-topborder");
		this.lregion.switchScroller(false);
		this.tregion.switchScroller(false);
	},
	unsplit: function(suspendEvent) {
		if(this.isSplited()) {
			var oldSplitPos = Ext.apply({}, this.splitPos);
			var oldFreezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null;
			var oldRangeInfo = this.getRangeInfo();
			var s = this.getStore();
			var sheetId = this.getSheetId();
			var El = this.getInnerEl();
			var width = El.getWidth() - El.getBorderWidth("lr"),
				height = El.getHeight() - El.getBorderWidth("tb");
			delete this.splitPos;
			this.lheader.hide();
			this.ulefter.hide();
			this.ltregion.hide();
			this.lregion.hide();
			this.tregion.hide();
			this.switchSplitCls(false);
			var lw = s.getColWidth(sheetId, 0, true, true),
				hh = s.getRowHeight(sheetId, 0, true, true);
			var sw = width - lw;
			var sh = height - hh;
			var col = this.lheader.colStart;
			var row = this.ulefter.rowStart;
			this.sheader.recalculateRange(null, {
				colStart: col,
				width: sw
			});
			this.sheader.setBound(null, {
				low: 1,
				high: false
			});
			this.sheader.sysn();
			this.slefter.recalculateRange({
				rowStart: row,
				height: sh
			});
			this.slefter.setBound({
				low: 1,
				high: false
			});
			this.slefter.sysn();
			this.cregion.recalculateRange({
				rowStart: row,
				rowEnd: this.slefter.rowEnd,
				height: sh
			}, {
				colStart: col,
				colEnd: this.sheader.colEnd,
				width: sw
			});
			this.cregion.setBound({
				low: 1,
				high: false
			}, {
				low: 1,
				high: false
			});
			this.cregion.sysn();
			this.refreshSelection();
			this.updateSheetConfig(true);
			if(!suspendEvent) {
				var freezePos = this.freezePos ? Ext.apply({}, this.freezePos) : null;
				var rangeInfo = this.getRangeInfo();
				this.fireEvent("splitchange", null, oldSplitPos, freezePos, oldFreezePos, rangeInfo, oldRangeInfo, this);
			}
		}
	},
	refreshForFreeze: function() {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth() - El.getBorderWidth("lr"),
			height = El.getHeight() - El.getBorderWidth("tb");
		var lw = s.getColWidth(sheetId, 0, true, true),
			hh = s.getRowHeight(sheetId, 0, true, true),
			w = 0,
			h = 0;
		if(this.lheader.isVisible()) {
			this.lheader.recalculateRange({
				rowStart: this.lheader.rowStart,
				rowEnd: this.lheader.rowEnd,
				height: hh
			}, {
				colStart: this.lheader.colStart,
				colEnd: this.lheader.colEnd
			});
			w = this.lheader.getWidth();
			this.lheader.sysn();
		}
		if(this.ulefter.isVisible()) {
			this.ulefter.recalculateRange({
				rowStart: this.ulefter.rowStart,
				rowEnd: this.ulefter.rowEnd
			}, {
				colStart: this.ulefter.colStart,
				colEnd: this.ulefter.colEnd,
				width: lw
			});
			h = this.ulefter.getHeight();
			this.ulefter.sysn();
		}
		if(this.ltregion.isVisible()) {
			this.ltregion.recalculateRange({
				rowStart: this.ltregion.rowStart,
				rowEnd: this.ltregion.rowEnd,
				height: h
			}, {
				colStart: this.ltregion.colStart,
				colEnd: this.ltregion.colEnd,
				width: w
			});
			this.ltregion.sysn();
		}
		var fw = lw + w,
			fh = hh + h;
		var sw = width - fw;
		var sh = height - fh;
		this.fzXLineEl.setStyle("top", fh + "px");
		this.fzYLineEl.setStyle("left", fw + "px");
		this.sheader.recalculateRange({
			rowStart: this.sheader.rowStart,
			rowEnd: this.sheader.rowEnd,
			height: hh
		}, {
			colStart: this.sheader.colStart,
			width: sw
		});
		this.sheader.sysn();
		this.slefter.recalculateRange({
			rowStart: this.slefter.rowStart,
			height: sh
		}, {
			colStart: this.slefter.colStart,
			colEnd: this.slefter.colEnd,
			width: lw
		});
		this.slefter.sysn();
		if(this.lregion.isVisible()) {
			this.lregion.recalculateRange({
				rowStart: this.lregion.rowStart,
				rowEnd: this.slefter.rowEnd,
				height: sh
			}, {
				colStart: this.lheader.colStart,
				colEnd: this.lheader.colEnd,
				width: w
			});
			this.lregion.sysn();
		}
		if(this.tregion.isVisible()) {
			this.tregion.recalculateRange({
				rowStart: this.ulefter.rowStart,
				rowEnd: this.ulefter.rowEnd,
				height: h
			}, {
				colStart: this.tregion.colStart,
				colEnd: this.sheader.colEnd,
				width: sw
			});
			this.tregion.sysn();
		}
		this.cregion.recalculateRange({
			rowStart: this.cregion.rowStart,
			rowEnd: this.slefter.rowEnd,
			height: sh
		}, {
			colStart: this.cregion.colStart,
			colEnd: this.sheader.colEnd,
			width: sw
		});
		this.cregion.sysn();
	},
	refreshForSplit: function() {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth() - El.getBorderWidth("lr"),
			height = El.getHeight() - El.getBorderWidth("tb");
		var lw = s.getColWidth(sheetId, 0, true, true),
			hh = s.getRowHeight(sheetId, 0, true, true),
			w = this.splitPos.width,
			h = this.splitPos.height;
		if(this.lheader.isVisible()) {
			this.lheader.recalculateRange({
				rowStart: this.lheader.rowStart,
				rowEnd: this.lheader.rowEnd,
				height: hh
			}, {
				colStart: this.lheader.colStart,
				width: w
			});
			this.lheader.sysn();
		}
		if(this.ulefter.isVisible()) {
			this.ulefter.recalculateRange({
				rowStart: this.ulefter.rowStart,
				height: h
			}, {
				colStart: this.ulefter.colStart,
				colEnd: this.ulefter.colEnd,
				width: lw
			});
			this.ulefter.sysn();
		}
		if(this.ltregion.isVisible()) {
			this.ltregion.recalculateRange({
				rowStart: this.ltregion.rowStart,
				rowEnd: this.ulefter.rowEnd,
				height: h
			}, {
				colStart: this.ltregion.colStart,
				colEnd: this.lheader.colEnd,
				width: w
			});
			this.ltregion.sysn();
		}
		var sw = width - lw - w - s.splitOffset;
		var sh = height - hh - h - s.splitOffset;
		sh++;
		sw++;
		this.sheader.recalculateRange({
			rowStart: this.sheader.rowStart,
			rowEnd: this.sheader.rowEnd,
			height: hh
		}, {
			colStart: this.sheader.colStart,
			width: sw
		});
		this.sheader.sysn();
		this.slefter.recalculateRange({
			rowStart: this.slefter.rowStart,
			height: sh
		}, {
			colStart: this.slefter.colStart,
			colEnd: this.slefter.colEnd,
			width: lw
		});
		this.slefter.sysn();
		if(this.lregion.isVisible()) {
			this.lregion.recalculateRange({
				rowStart: this.lregion.rowStart,
				rowEnd: this.slefter.rowEnd,
				height: sh
			}, {
				colStart: this.lregion.colStart,
				colEnd: this.lheader.colEnd,
				width: w
			});
			this.lregion.sysn();
		}
		if(this.tregion.isVisible()) {
			this.tregion.recalculateRange({
				rowStart: this.tregion.rowStart,
				rowEnd: this.ulefter.rowEnd,
				height: h
			}, {
				colStart: this.tregion.colStart,
				colEnd: this.sheader.colEnd,
				width: sw
			});
			this.tregion.sysn();
		}
		this.cregion.recalculateRange({
			rowStart: this.cregion.rowStart,
			rowEnd: this.slefter.rowEnd,
			height: sh
		}, {
			colStart: this.cregion.colStart,
			colEnd: this.sheader.colEnd,
			width: sw
		});
		this.cregion.sysn();
	},
	refreshForNormal: function() {
		var sheetId = this.getSheetId();
		var s = this.getStore();
		var El = this.getInnerEl();
		var width = El.getWidth() - El.getBorderWidth("lr"),
			height = El.getHeight() - El.getBorderWidth("tb");
		var lw = s.getColWidth(sheetId, 0, true, true),
			hh = s.getRowHeight(sheetId, 0, true, true);
		var sw = width - lw;
		var sh = height - hh;
		this.sheader.recalculateRange({
			rowStart: this.sheader.rowStart,
			rowEnd: this.sheader.rowEnd,
			height: hh
		}, {
			colStart: this.sheader.colStart,
			width: sw
		});
		this.sheader.sysn();
		this.slefter.recalculateRange({
			rowStart: this.slefter.rowStart,
			height: sh
		}, {
			colStart: this.slefter.colStart,
			colEnd: this.slefter.colEnd,
			width: lw
		});
		this.slefter.sysn();
		this.cregion.recalculateRange({
			rowStart: this.cregion.rowStart,
			rowEnd: this.slefter.rowEnd,
			height: sh
		}, {
			colStart: this.cregion.colStart,
			colEnd: this.sheader.colEnd,
			width: sw
		});
		this.cregion.sysn();
	},
	refresh: function() {
		this.ltcorner.refresh();
		if(this.isFreezed()) {
			this.switchFreezeCls(true);
			this.refreshForFreeze();
		} else if(this.isSplited()) {
			this.switchSplitCls(true);
			this.refreshForSplit();
		} else {
			this.switchFreezeCls(false);
			this.switchSplitCls(false);
			this.refreshForNormal();
		}
		this.checkLefterWidth();
		this.refreshSelection();
		this.refreshFocus();
	},
	refreshSelection: function() {
		var sm = this.cregion.getSelectionModel();
		var selection = sm.getSelection();
		this.cregion.fireEvent("selectionchange", selection.startPos, selection.endPos);
	},
	refreshReference: function() {
		var rm = this.cregion.getReferenceModel();
		if(rm.isVisible()) {
			this.cregion.fireEvent("referencechange", null, rm, true);
		}
	},
	getCellPosition: function(row, col, region) {
		if(region) {
			return region.getCellPosition(row, col);
		} else {
			return this.cregion.getCellPosition(row, col);
		}
	},
	checkLefterWidth: function(stopRecursion, forceCheckFlag) {
		if(!this.checkingLefter && !this.store.rowNameHidden) {
			this.checkingLefter = true;
			var max = this.slefter.rowEnd;
			var sheetId = this.getSheetId();
			var low = Math.pow(10, this.maxRowIndexDigital - 1);
			var high = Math.pow(10, this.maxRowIndexDigital);
			if(this.ulefter.isVisible() && this.ulefter.rowEnd > this.slefter.rowEnd) {
				max = this.ulefter.rowEnd;
			}
			var s = this.getStore();
			if(max >= high || max <= low || forceCheckFlag) {
				var old = this.maxRowIndexDigital;
				this.maxRowIndexDigital = Math.floor(Math.log(max) / Math.LN10) + 1;
				if(this.maxRowIndexDigital < this.defaultRowIndexDigital) {
					this.maxRowIndexDigital = this.defaultRowIndexDigital;
				}
				var offsetWidth = (this.maxRowIndexDigital - old) * this.digitalWidth;
				if(0 != offsetWidth || forceCheckFlag) {
					s.setLeftWidth(sheetId, this.maxRowIndexDigital * this.digitalWidth + this.spaceWidth + s.cellWidthOffset);
					var lw = s.getColWidth(sheetId, 0, true, true);
					this.ltcorner.setWidth(lw);
					this.slefter.recalculateRange(null, {
						colStart: this.slefter.colStart,
						colEnd: this.slefter.colEnd,
						width: lw
					});
					if(this.ulefter.isVisible()) {
						this.ulefter.recalculateRange(null, {
							colStart: this.ulefter.colStart,
							colEnd: this.ulefter.colEnd,
							width: lw
						});
					}
					var sw = this.cregion.getWidth() - offsetWidth;
					if(this.tregion.isVisible()) {
						this.tregion.setWidth(sw);
					}
					this.sheader.setWidth(sw);
					this.cregion.setWidth(sw);
					var lsm = this.slefter.getSelectionModel();
					if(lsm.startPos && 0 == lsm.startPos.col && 0 != lsm.startPos.row) {
						lsm.selectRange(lsm.startPos, lsm.endPos, true);
						if(this.ulefter.isVisible()) {
							lsm = this.ulefter.getSelectionModel();
							lsm.selectRange(lsm.startPos, lsm.endPos, true);
						}
					}
				}
			}
			if(!stopRecursion) {
				Ext.Function.defer(function() {
					this.checkingLefter = false;
					Ext.Function.defer(this.checkLefterWidth, this.checkLeftDelay, this, [true]);
				}, this.checkLeftDelay, this);
			} else {
				this.checkingLefter = false;
			}
		}
	},
	onLeftColumnResize: function() {
		if(this.isFreezed()) {
			var s = this.getStore(),
				sheetId = this.getSheetId();
			var fw = s.getRangeWidth(sheetId, this.lheader.colStart, this.freezePos.col - 1, undefined, true);
			var lw = s.getColWidth(sheetId, 0, true, true);
			this.fzYLineEl.setStyle("left", fw + lw + "px");
			var offset = fw - this.lheader.getWidth();
			if(this.ltregion.isVisible()) {
				this.ltregion.setWidth(fw);
			}
			this.lregion.setWidth(fw);
			this.lheader.setWidth(fw);
			var sw = this.sheader.getWidth() - offset;
			this.sheader.setWidth(sw);
			this.cregion.setWidth(sw);
			if(this.tregion.isVisible()) {
				this.tregion.setWidth(sw);
			}
		}
	},
	onUpperRowResize: function() {
		if(this.isFreezed()) {
			var s = this.getStore(),
				sheetId = this.getSheetId();
			var fh = s.getRangeHeight(sheetId, this.ulefter.rowStart, this.freezePos.row - 1, undefined, true);
			var hh = s.getRowHeight(sheetId, 0, true, true);
			this.fzXLineEl.setStyle("top", fh + hh + "px");
			var offset = fh - this.tregion.getHeight();
			if(this.ltregion.isVisible()) {
				this.ltregion.setHeight(fh);
			}
			this.tregion.setHeight(fh);
			this.ulefter.setHeight(fh);
			var sh = this.slefter.getHeight() - offset;
			this.slefter.setHeight(sh);
			this.cregion.setHeight(sh);
			if(this.lregion.isVisible()) {
				this.lregion.setHeight(sh);
			}
		}
	},
	onRemoveRow: function(sheetId, minrow, maxrow) {
		var needRefresh;
		if(sheetId == this.getSheetId()) {
			if(this.isFreezed()) {
				if(minrow < this.freezePos.row) {
					maxrow = this.freezePos.row < maxrow ? this.freezePos.row : maxrow;
					var span = maxrow - minrow + 1;
					var row = this.freezePos.row - span;
					if(1 > row) {
						row = 1;
					}
					this.freeze(row, this.freezePos.col, true);
					needRefresh = false;
				}
			}
		}
		if(this.rowGroups) {
			var oldMaxLevel = this.rowGroupMaxLevel;
			var groups = this.rowGroups,
				maps = this.rowGroupNameMap;
			var newGroups = [],
				rowSpan = maxrow - minrow + 1;
			var levels = {};
			for(var name in maps) {
				var group = maps[name],
					span = group.span;
				if(!(minrow <= span[0] && span[1] <= maxrow)) {
					if(minrow >= span[0] && maxrow <= span[1]) {
						span[1] -= rowSpan;
					} else if(minrow >= span[0] && span[1] >= minrow) {
						span[1] = minrow - 1;
					} else if(maxrow >= span[0] && span[1] >= maxrow) {
						span[0] = minrow;
						span[1] -= rowSpan;
					} else if(maxrow < span[0]) {
						span[0] -= rowSpan;
						span[1] -= rowSpan;
					}
					if(0 < span[1] - span[0]) {
						var level = group.level;
						levels[level] = levels[level] || {};
						levels[level][span[1]] = group;
						newGroups.push(group);
					}
				}
			}
			var index = 0;
			for(var i = 1; i <= oldMaxLevel; i++) {
				var line = levels[i];
				if(i < oldMaxLevel) {
					var upper = levels[i + 1],
						removes = {};
					for(var p in line) {
						if(upper[p]) {
							removes[p] = true;
						}
					}
					for(var p in removes) {
						delete line[p];
					}
				}
				if(line && !SCOM.isEmptyObj(line)) {
					index++;
					for(var p in line) {
						line[p].level = index;
					}
				}
			}
			this.layoutRowGroups(newGroups);
			needRefresh = true;
		}
		return needRefresh;
	},
	onRemoveColumn: function(sheetId, mincol, maxcol) {
		var needRefresh;
		if(sheetId == this.getSheetId()) {
			if(this.isFreezed()) {
				if(mincol < this.freezePos.col) {
					maxcol = this.freezePos.col < maxcol ? this.freezePos.col : maxcol;
					var span = maxcol - mincol + 1;
					var col = this.freezePos.col - span;
					if(1 > col) {
						col = 1;
					}
					this.freeze(this.freezePos.row, col, true);
					needRefresh = false;
				}
			}
		}
		if(this.colGroups) {
			var oldMaxLevel = this.colGroupMaxLevel;
			var groups = this.colGroups,
				maps = this.colGroupNameMap;
			var newGroups = [],
				colSpan = maxcol - mincol + 1;
			var levels = {};
			for(var name in maps) {
				var group = maps[name],
					span = group.span;
				if(!(mincol <= span[0] && span[1] <= maxcol)) {
					if(mincol >= span[0] && maxcol <= span[1]) {
						span[1] -= colSpan;
					} else if(mincol >= span[0] && span[1] >= mincol) {
						span[1] = mincol - 1;
					} else if(maxcol >= span[0] && span[1] >= maxcol) {
						span[0] = mincol;
						span[1] -= colSpan;
					} else if(maxcol < span[0]) {
						span[0] -= colSpan;
						span[1] -= colSpan;
					}
					if(0 < span[1] - span[0]) {
						var level = group.level;
						levels[level] = levels[level] || {};
						levels[level][span[1]] = group;
						newGroups.push(group);
					}
				}
			}
			var index = 0;
			for(var i = 1; i <= oldMaxLevel; i++) {
				var line = levels[i];
				if(i < oldMaxLevel) {
					var upper = levels[i + 1],
						removes = {};
					for(var p in line) {
						if(upper[p]) {
							removes[p] = true;
						}
					}
					for(var p in removes) {
						delete line[p];
					}
				}
				if(line && !SCOM.isEmptyObj(line)) {
					index++;
					for(var p in line) {
						line[p].level = index;
					}
				}
			}
			this.layoutColumnGroups(newGroups);
			needRefresh = true;
		}
		return needRefresh;
	},
	onInsertRow: function(sheetId, row, rowSpan) {
		var needRefresh;
		if(sheetId == this.getSheetId()) {
			if(this.isFreezed()) {
				var maxrow = row + rowSpan - 1;
				if(maxrow <= this.freezePos.row) {
					var row = this.freezePos.row + rowSpan;
					this.freeze(row, this.freezePos.col, true);
					needRefresh = false;
				}
			}
		}
		if(this.rowGroups) {
			var oldMaxLevel = this.rowGroupMaxLevel;
			var groups = this.rowGroups,
				maps = this.rowGroupNameMap;
			var newGroups = [];
			var levels = {};
			for(var name in maps) {
				var group = maps[name],
					span = group.span;
				if(row <= span[1]) {
					if(row < span[0]) {
						span[0] += rowSpan;
						span[1] += rowSpan;
					} else {
						span[1] += rowSpan;
					}
				}
				var level = group.level;
				levels[level] = levels[level] || {};
				levels[level][span[1]] = group;
				newGroups.push(group);
			}
			var index = 0;
			for(var i = 1; i <= oldMaxLevel; i++) {
				var line = levels[i];
				if(i < oldMaxLevel) {
					var upper = levels[i + 1],
						removes = {};
					for(var p in line) {
						if(upper[p]) {
							removes[p] = true;
						}
					}
					for(var p in removes) {
						delete line[p];
					}
				}
				if(line && !SCOM.isEmptyObj(line)) {
					index++;
					for(var p in line) {
						line[p].level = index;
					}
				}
			}
			this.layoutRowGroups(newGroups);
			needRefresh = true;
		}
		return needRefresh;
	},
	onInsertColumn: function(sheetId, col, colSpan) {
		var needRefresh;
		if(sheetId == this.getSheetId()) {
			if(this.isFreezed()) {
				var maxcol = col + colSpan - 1;
				if(maxcol <= this.freezePos.col) {
					var col = this.freezePos.col + colSpan;
					this.freeze(this.freezePos.row, col, true);
					needRefresh = false;
				}
			}
		}
		if(this.colGroups) {
			var oldMaxLevel = this.colGroupMaxLevel;
			var groups = this.colGroups,
				maps = this.colGroupNameMap;
			var newGroups = [];
			var levels = {};
			for(var name in maps) {
				var group = maps[name],
					span = group.span;
				if(col <= span[1]) {
					if(col < span[0]) {
						span[0] += colSpan;
						span[1] += colSpan;
					} else {
						span[1] += colSpan;
					}
				}
				var level = group.level;
				levels[level] = levels[level] || {};
				levels[level][span[1]] = group;
				newGroups.push(group);
			}
			var index = 0;
			for(var i = 1; i <= oldMaxLevel; i++) {
				var line = levels[i];
				if(i < oldMaxLevel) {
					var upper = levels[i + 1],
						removes = {};
					for(var p in line) {
						if(upper[p]) {
							removes[p] = true;
						}
					}
					for(var p in removes) {
						delete line[p];
					}
				}
				if(line && !SCOM.isEmptyObj(line)) {
					index++;
					for(var p in line) {
						line[p].level = index;
					}
				}
			}
			this.layoutColumnGroups(newGroups);
			needRefresh = true;
		}
		return needRefresh;
	},
	go2Pos: function(row, col) {
		row = row || 1;
		col = col || 1;
		var splited = this.isSplited();
		var lvisible = this.lheader.isVisible(),
			uvisible = this.ulefter.isVisible();
		if(splited) {
			if(lvisible && !this.lheader.isInRange(0, col)) {
				this.lheader.recalculateRange(null, {
					colStart: col < this.lheader.colBound.low ? this.lheader.colBound.low : col,
					width: this.lheader.getWidth()
				});
				this.lheader.sysn();
			}
			if(uvisible && !this.ulefter.isInRange(row, 0)) {
				this.ulefter.recalculateRange({
					rowStart: row < this.ulefter.rowBound.low ? this.ulefter.rowBound.low : row,
					height: this.ulefter.getHeight()
				});
				this.ulefter.sysn();
			}
			if(this.ltregion.isVisible() && !this.ltregion.isInRange(row, col)) {
				this.ltregion.recalculateRange({
					rowStart: this.ulefter.rowStart,
					rowEnd: this.ulefter.rowEnd
				}, {
					colStart: this.lheader.colStart,
					colEnd: this.lheader.colEnd
				});
				this.ltregion.sysn();
			}
		}
		if(!this.cregion.isInRange(row, col)) {
			var height = this.cregion.getHeight();
			this.cregion.recalculateRange({
				rowStart: row < this.cregion.rowBound.low ? this.cregion.rowBound.low : row,
				height: height
			}, {
				colStart: col < this.cregion.colBound.low ? this.cregion.colBound.low : col,
				width: this.cregion.getWidth()
			});
			this.cregion.sysn();
			this.slefter.recalculateRange({
				rowStart: this.cregion.rowStart,
				rowEnd: this.cregion.rowEnd,
				height: height
			});
			this.slefter.sysn();
			this.sheader.recalculateRange(null, {
				colStart: this.cregion.colStart,
				colEnd: this.cregion.colEnd
			});
			this.sheader.sysn();
			if(this.lregion.isVisible()) {
				this.lregion.recalculateRange({
					rowStart: this.cregion.rowStart,
					rowEnd: this.cregion.rowEnd,
					height: this.lregion.getHeight()
				}, splited && lvisible ? {
					colStart: this.lheader.colStart,
					colEnd: this.lheader.colEnd
				} : null);
				this.lregion.sysn();
			}
			if(this.tregion.isVisible()) {
				this.tregion.recalculateRange(splited && uvisible ? {
					rowStart: this.ulefter.rowStart,
					rowEnd: this.ulefter.rowEnd
				} : null, {
					colStart: this.cregion.colStart,
					colEnd: this.cregion.colEnd,
					width: this.tregion.getWidth()
				});
				this.tregion.sysn();
			}
		}
		var sm = this.getSelectionModel();
		sm.selectRange({
			row: row,
			col: col
		}, {
			row: row,
			col: col
		});
		sm.setFocusCell(row, col);
		this.checkLefterWidth();
	},
	go2LeftTop: function() {
		this.go2Pos();
	},
	navigateSelection: function(e, region) {
		var key = e.getKey(),
			shift = e.shiftKey,
			ctrl = e.ctrlKey;
		var sm = region.getSelectionModel(),
			pos;
		if(e.TAB == key || e.RIGHT == key) {
			pos = sm.selectNext("col", shift);
		} else if(e.ENTER == key && shift) {
			pos = sm.selectPrevious("row", false);
		} else if(e.ENTER == key || e.DOWN == key) {
			pos = sm.selectNext("row", shift);
		} else if(e.UP == key) {
			pos = sm.selectPrevious("row", shift);
		} else if(e.LEFT == key) {
			pos = sm.selectPrevious("col", shift);
		}
		if(ctrl) {
			if(65 == key) {
				e.preventDefault();
				var sm = this.getSelectionModel();
				sm.selectRange({
					row: 0,
					col: 0
				}, {
					row: 0,
					col: 0
				});
			}
		}
		return pos;
	},
	onEditorKeyDown: function(e, row, col, region, editor) {
		if(!region) {
			region = this.cregion;
			var sm = this.getSelectionModel();
			var focusCell = sm.getFocusCell();
			if(focusCell) {
				row = focusCell.row;
				col = focusCell.col;
			} else {
				return false;
			}
		}
		if(false === this.fireEvent("preparekeydown", e, row, col, region, editor, this)) {
			return false;
		}
		if(editor && !editor.isAvailable()) {
			if(false === this.fireEvent("keydown", e, row, col, region, editor, this)) {
				return false;
			}
			var key = e.getKey();
			region = region || this.getCurrentRegion();
			if(e.TAB == key || e.RIGHT == key || e.ENTER == key || e.DOWN == key || e.LEFT == key || e.UP == key || e.ctrlKey && 65 == key || key == 36 || key == 34 || key == 33) {
				e.preventDefault();
				if(!this._navigating) {
					this._navigating = true;
					var pos = this.navigateSelection(e, region);
					if(pos) {
						region.scrollCell2View(pos.row, pos.col);
						this.focus(this.focusDelayTime);
					}
					Ext.Function.defer(function() {
						delete this._navigating;
					}, this.keyDownThrottled, this);
				}
				return false;
			} else if(e.ESC == key) {
				this.hideCurrentOptionFloors();
				return false;
			} else if(255 === key) {
				return false;
			}
		}
	},
	onDragScrollingLimited: function(dir, flag, pos, sm, region) {
		if("high" == flag) {
			if(region == this.ltregion) {
				this.cregion.go2LeftTop();
			} else if(region == this.tregion) {
				this.cregion.go2Top();
			} else if(region == this.lregion) {
				this.cregion.go2Left();
			}
		}
	},
	beforeHideRow: function(minrow, maxrow, region) {
		if(this.ulefter == region || this.ltregion == region) {
			return false;
		} else if(this.tregion == region) {
			this.refreshRange();
			return false;
		}
	},
	beforeHideColumn: function(mincol, maxcol, region) {
		if(this.lheader == region || this.ltregion == region) {
			return false;
		} else if(this.lregion == region) {
			this.refreshRange();
			return false;
		}
	},
	beforeShowRow: function(minrow, maxrow, region) {
		if(this.ulefter == region || this.ltregion == region) {
			return false;
		} else if(this.tregion == region) {
			this.refreshRange();
			return false;
		}
	},
	beforeShowColumn: function(mincol, maxcol, region) {
		if(this.lheader == region || this.ltregion == region) {
			return false;
		} else if(this.lregion == region) {
			this.refreshRange();
			return false;
		}
	},
	getFocusCellData: function() {
		var sheetId = this.getSheetId();
		var sm = this.getSelectionModel();
		var store = this.getStore();
		var focusCell = sm.getFocusCell();
		if(focusCell) {
			var row = focusCell.row,
				col = focusCell.col;
			var data = store.getCellData(sheetId, row, col, undefined, undefined, undefined, true);
			return data;
		}
		return Ext.apply({}, store.defaultProperty);
	},
	isFitlerCell: function(cell, sheetId, row, col) {
		if(this.condition) {
			if(!cell) {
				cell = this.getStore().getCell(sheetId, row, col);
			}
			return cell.filter ? true : false;
		}
		return false;
	},
	isMiniChartCell: function(sheetId, row, col) {
		if(this.condition) {
			var store = this.getStore();
			var cdt = this.getConditionOfCell(sheetId, row, col);
			if(0 < cdt.length) {
				for(var i = 0, len = cdt.length; i < len; i++) {
					var it = cdt[i];
					if("minichart" == it.name) {
						return true;
					}
				}
			}
		}
		return false;
	},
	getMiniChartRange: function(sheetId, row, col) {
		if(this.condition) {
			return this.condition.getMiniChartRangeByCell(sheetId, row, col);
		}
	},
	isTableTplCell: function(cell, sheetId, row, col) {
		if(this.tableTpl) {
			if(!cell) {
				cell = this.getStore().getCellData(sheetId, row, col);
			}
			return cell.tpl ? true : false;
		}
		return false;
	},
	isTableTplHeader: function(cell, sheetId, row, col) {
		if(this.tableTpl) {
			if(!cell) {
				cell = this.getStore().getCellData(sheetId, row, col);
			}
			return this.tableTpl.isTableHeader(cell, sheetId, row, col);
		}
		return false;
	},
	getTableTpl: function() {
		return this.tableTpl;
	},
	applyCondition: function(cell) {
		var cdtVal = cell.cdtVal,
			o = {};
		if(cdtVal) {
			for(var p in cdtVal) {
				if(cdtVal.hasOwnProperty(p)) {
					var it = cdtVal[p];
					Ext.applyIf(o, it);
				}
			}
			return Ext.apply(cell, o);
		} else {
			return cell;
		}
	},
	processTableTpl: function(cell, scope) {
		try {
			if(this.isTableTplCell(cell)) {
				cell = this.tableTpl.processTpl(cell, scope);
			}
			return cell;
		} catch(e) {
			cell.data = e;
			return cell;
		}
	},
	getCellData: function(sheetId, row, col) {
		return this.processData(sheetId, row, col);
	},
	processData: function(sheetId, row, col, ref, timestamp, skipUpdateValue, region, withoutZoom) {
		var activedSheetId = this.getSheetId();
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = activedSheetId;
		}
		var store = this.getStore();
		var cell = store.getCellData(sheetId, row, col, undefined, undefined, {
			fn: function(o, s, r, c) {
				var sp = {
					store: store,
					sheet: s,
					row: r,
					col: c,
					timestamp: o.timestamp
				};
				o = this.processCellDataConfig(o, sp);
				o = this.processCalculate(o, sp, skipUpdateValue);
				o = this.processCondition(o, sp, skipUpdateValue);
				this.processTableTpl(o, sp);
			},
			scope: this
		}, withoutZoom);
		if(ref) {
			ref.cell = cell;
		}
		var scope = {
			store: store,
			sheet: sheetId,
			row: row,
			col: col,
			timestamp: cell.timestamp
		};
		cell = this.processCellDataRender(cell, scope);
		if(region && 0 !== row && 0 !== col) {
			cell.zd = col;
			if("normal" !== cell.ws && this.isContentCell(cell)) {
				var next = this.findNextNonEmptyColIndex(sheetId, row, col, region) || SCONST.MAX_COL_Z_INDEX;
				cell.zd = next;
			}
		}
		cell = this.calculate.processArrayFormulaResult(cell, row, col);
		if(0 !== row && 0 !== col) {
			cell = SFORMAT.transferFormat(cell, cell.fm);
		}
		var pos = [sheetId, row, col];
		cell = this.processComment(cell, pos);
		cell = this.processVariable(cell, pos);
		cell = this.processItemTrigger(cell);
		if(cell.showIconOnly) {
			cell.data = "";
		} else if(cell.rotation) {
			cell = this.processVerticalText(cell);
		}
		return cell;
	},
	getCellProperty: function(sheetId, row, col) {
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var cell = store.getCellProperty(sheetId, row, col);
		var scope = {
			store: store,
			sheet: sheetId,
			row: row,
			col: col,
			timestamp: cell.timestamp
		};
		cell = this.processCellDataConfig(cell, scope);
		return cell;
	},
	findPrevNonEmptyColIndex: function(sheetId, row, col, region) {
		var store = this.getStore();
		var startCol = region.colStart - region.colEnd + col;
		if(1 > startCol) {
			startCol = 1;
		}
		for(var i = col - 1; i >= startCol; i--) {
			var cell = store.getCell(sheetId, row, i);
			if(this.isContentCell(cell)) {
				return i;
			}
		}
	},
	findNextNonEmptyColIndex: function(sheetId, row, col, region) {
		var store = this.getStore();
		var endCol = col - region.colStart + region.colEnd;
		for(var i = col + 1; i <= endCol; i++) {
			var cell = store.getCell(sheetId, row, i);
			if(this.isContentCell(cell)) {
				return i;
			}
		}
	},
	processVerticalText: function(cell) {
		var cellData = cell.data;
		if(cell.rotation == 45) {
			cell.data = "<div class=\"ss-cell-vertical_45\">" + cellData + "</div>";
			if(cell.va == "top") {
				cell.va = "bottom";
			}
		} else if(cell.rotation == 90) {
			cell.data = "<div class=\"ss-cell-vertical_90\">" + cellData + "</div>";
		} else if(cell.rotation == 315) {
			cell.data = "<div class=\"ss-cell-vertical_315\">" + cellData + "</div>";
			if(cell.va == "bottom") {
				cell.va = "top";
			}
		} else {
			cell.data = "<div class=\"ss-cell-vertical_270\">" + cellData + "</div>";
			if(cell.va == "top" || cell.va == "middle") {
				cell.va = "bottom";
			}
		}
		return cell;
	},
	processPlainForTplCell: function(sheetId, row, col) {
		if(0 !== row && 0 !== col) {
			var store = this.getStore();
			var cell = this.getCellValue(sheetId, row, col);
			store.setCell(sheetId, row, col, {
				plain: cell.data
			}, undefined, true);
		}
	},
	isContentCell: function(cell) {
		if(cell.it || cell.trigger || !SCOM.nullOrUndefined(cell.data) && "" !== cell.data || cell.itms) {
			return true;
		}
		return false;
	},
	processComment: function(cell, cellPos) {
		if(cell.comment) {
			var info = "";
			if(cellPos) {
				info = "sheet=\"" + cellPos[0] + "\" row=\"" + cellPos[1] + "\" col=\"" + cellPos[2] + "\"";
			}
			var comment = "<div class=\"ss-comment-sign ss-cell-inside\" " + info + " style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>";
			cell.rtcorner = comment;
		}
		return cell;
	},
	processVariable: function(cell, cellPos) {
		if(cell.vname && "hide" !== cell.vnameEdit) {
			var info = "";
			if(cellPos) {
				info = "sheet=\"" + cellPos[0] + "\" row=\"" + cellPos[1] + "\" col=\"" + cellPos[2] + "\"";
			}
			var varSign = "<div class=\"ss-var-sign ss-cell-inside\" " + info + " style=\"z-index:" + SCONST.TOP_Z_INDEX + ";\"></div>";
			cell.rbcorner = varSign;
		}
		return cell;
	},
	processItemTrigger: function(cell) {
		var topZIndex = SCONST.INCELL_ITEM_Z_INDEX;
		var data = cell.data;
		if(SCOM.nullOrUndefined(data)) {
			data = "";
			cell.data = data;
		}
		var z = -1;
		if(cell.body && (cell.it || cell.trigger || cell.seq || cell.drop || cell.ltcorner || cell.rtcorner || cell.lbcorner || cell.rbcorner || cell.icon)) {
			if(cell.seq) {
				cell.preItem = cell.preItem || "";
				cell.preItem += "<div style=\"z-index:" + topZIndex + ";\" class=\"ss-cell-seq\">" + cell.seq + "</div>";
			}
			if(cell.icon) {
				cell.preItem = cell.preItem || "";
				cell.preItem += "<div style=\"z-index:" + topZIndex + ";background-image:" + cell.icon + ";\" class=\"ss-cell-icon\"></div>";
			}
			if(cell.it) {
				if(cell.it == "button") {
					cell.data = "<button style=\"" + cell.btnStyle + "\" type=\"button\">" + cell.data + "</button>";
				} else {
					cell.data = "<input style=\"margin:0 2px 0 " + (cell.preItem ? 20 : 2) + "px;z-index:" + topZIndex + ";\" type=\"" + cell.it + "\" " + (cell.itchk ? "checked" : "") + " />" + cell.data;
				}
				data = cell.data;
			}
			var va = cell.va;
			if(cell.trigger) {
				var style = "top:0;margin-top:0px;";
				if("middle" === va) {
					style = "top:50%;margin-top:-8px;";
				} else if("bottom" === va) {
					style = "top:100%;margin-top:-18px;";
				}
				cell.posTrigger = "<div style=\"z-index:" + topZIndex + ";" + style + "\" class=\"ss-trigger " + cell.trigger + "\"></div>";
				cell.data = data + "<span style=\"padding-left:20px;font-size:0px;\">&nbsp;</span>";
			} else if(cell.drop) {
				var style = "top:1px;margin-top:0px;";
				if("middle" === va) {
					style = "top:50%;margin-top:-8px;";
				} else if("bottom" === va) {
					style = "top:100%;margin-top:-18px;";
				}
				var cls = "date" === cell.drop ? "ss-date-picker" : "ss-drop-list";
				cell.posTrigger = "<div style=\"z-index:" + topZIndex + ";" + style + "\" class=\"ss-trigger " + cls + "\"></div>";
				cell.data = data + "<span style=\"padding-left:20px;font-size:0px;\">&nbsp;</span>";
			}
			z = 0;
		}
		if(cell.icp) {
			if(cell.imgStyle) {
				cell.icp = "<img style=\"" + cell.imgStyle + "z-index:" + z + ";\" src=\"" + cell.icp + "\">";
			} else {
				cell.icp = "<img style=\"position:absolute;left:0px;top:0px;width:100%;height:100%;z-index:" + z + ";\" src=\"" + cell.icp + "\">";
			}
		}
		if(cell.fm == "sign") {
			var icp = cell.data;
			if(icp) {
				cell.icp = "<img style=\"position:absolute;left:0px;top:0px;width:100%;height:100%;z-index:" + z + ";\" src=\"" + icp + "\">";
				delete cell.data;
			}
		}
		return cell;
	},
	setCellData: function(sheetId, row, col, modified, deleted, suspendRefresh) {
		if(suspendRefresh) {
			this.setCell(sheetId, row, col, modified, deleted, suspendRefresh);
		} else {
			if(false !== this.fireEvent("beforesetcell", sheetId, row, col, modified, deleted, suspendRefresh, this)) {
				this.setCell(sheetId, row, col, modified, deleted, suspendRefresh);
			}
		}
	},
	checkRowHeight: function(sheetId, row) {
		var store = this.store;
		var rowPro = store.getCellProperty(sheetId, row, 0);
		if(!SCOM.canbeNumber(rowPro.height)) {
			var h = this.cregion.guessMaxRowHeight(sheetId, row);
			var isNum = Ext.isNumber(h);
			var ah = rowPro.autoHeight;
			if(!SCOM.canbeNumber(ah)) {
				ah = store.defaultProperty.height;
			}
			if(h != ah) {
				if(isNum) {
					store.setRow(sheetId, row, {
						autoHeight: h
					}, null, true, false, null, true);
				} else {
					store.setRow(sheetId, row, null, ["autoHeight"], true, false, null, true);
				}
			}
		}
	},
	onHighlightCells: function(ret) {
		var sheetId = this.getSheetId();
		Ext.Function.defer(function() {
			for(var i = 0, len = ret.length; i < len; i++) {
				var it = ret[i];
				if(sheetId === it[0]) {
					var startRow = it[1],
						endRow = it[3],
						startCol = it[2],
						endCol = it[4];
					for(var x = startRow; x <= endRow; x++) {
						for(var y = startCol; y <= endCol; y++) {
							var cellEls = this.getCellEls(x, y);
							for(var k = 0, count = cellEls.length; k < count; k++) {
								cellEls[k].highlight("00aa00", {
									attr: "color",
									duration: 2000
								});
							}
						}
					}
				}
			}
		}, 100, this);
	},
	isSplited: function() {
		return this.splitPos ? true : false;
	},
	isFreezed: function() {
		return this.freezePos ? true : false;
	},
	getRangeInfo: function() {
		var info = {};
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var name = this.regionLookup[i];
			info[name] = this[name].getRangeSpan();
		}
		return info;
	},
	setRangeInfo: function(info) {
		for(var p in info) {
			var o = info[p];
			this[p].setRangeSpan(o);
		}
	},
	getRowGroupPin: function() {
		var el = this.getInnerEl();
		var pinEl = el.down(".ss-row-group-pin");
		if(!pinEl) {
			pinEl = Ext.DomHelper.append(el.dom, "<div class=\"ss-row-group-pin\"></div>", true);
		}
		return pinEl;
	},
	removeRowGroupPin: function() {
		var el = this.getInnerEl();
		var pinEl = el.down(".ss-row-group-pin");
		if(pinEl) {
			Ext.removeNode(pinEl.dom);
		}
	},
	getColumnGroupPin: function() {
		var el = this.getInnerEl();
		var pinEl = el.down(".ss-col-group-pin");
		if(!pinEl) {
			pinEl = Ext.DomHelper.append(el.dom, "<div class=\"ss-col-group-pin\"></div>", true);
		}
		return pinEl;
	},
	removeColumnGroupPin: function() {
		var el = this.getInnerEl();
		var pinEl = el.down(".ss-col-group-pin");
		if(pinEl) {
			Ext.removeNode(pinEl.dom);
		}
	},
	layoutColumnGroups: function(colGroups) {
		if(colGroups && 0 === colGroups.length) {
			colGroups = null;
		}
		var needLayout = this.setColumnGroups(colGroups);
		this.updateColumnGroups();
		if(needLayout) {
			if(Ext.isFunction(this.doLayout)) {
				this.doLayout();
			} else if(Ext.isFunction(this.updateLayout)) {
				this.updateLayout();
			}
		}
	},
	layoutRowGroups: function(rowGroups) {
		if(rowGroups && 0 === rowGroups.length) {
			rowGroups = null;
		}
		var needLayout = this.setRowGroups(rowGroups);
		this.updateRowGroups();
		if(needLayout) {
			if(Ext.isFunction(this.doLayout)) {
				this.doLayout();
			} else if(Ext.isFunction(this.updateLayout)) {
				this.updateLayout();
			}
		}
	},
	setRowGroups: function(rowGroups, refreshPin) {
		var colorLen = SCOM.colors.length;
		var el = this.getEl(),
			needLayout = false;
		if(rowGroups) {
			this.rowGroupNameMap = {};
			this.rowGroupLookup = {};
			this.rowGroups = SCOM.copy(rowGroups);
			el.addCls("ss-row-group-ct");
			var maxLevel = 0;
			for(var i = 0, len = this.rowGroups.length; i < len; i++) {
				var group = this.rowGroups[i],
					span = group.span,
					level = group.level;
				if(level > maxLevel) {
					maxLevel = level;
				}
				var name = span.join("$");
				this.rowGroupNameMap[name] = group;
				var minRow = span[0],
					maxRow = span[1];
				for(var j = minRow; j <= maxRow; j++) {
					this.rowGroupLookup[j] = this.rowGroupLookup[j] || {};
					this.rowGroupLookup[j][name] = group;
				}
			}
			needLayout = maxLevel != this.rowGroupMaxLevel;
			if(needLayout || refreshPin) {
				this.rowGroupMaxLevel = maxLevel;
				var padding = this.groupOffset * maxLevel + this.groupPadding;
				el.setStyle("padding-left", padding + "px");
				var pinEl = this.getRowGroupPin();
				pinEl.setStyle("left", -padding - 1 + "px");
				pinEl.setWidth(padding);
				var arr = [];
				for(var i = maxLevel; i > 0; i--) {
					var color = SCOM.colors[(i - 1) % colorLen];
					arr.push("<div class=\"ss-row-group-no\" style=\"background-color:" + color + ";\" data-level=\"" + i + "\">" + i + "</div>");
				}
				pinEl.update(arr.join(""));
			}
		} else {
			needLayout = this.rowGroupMaxLevel ? true : false;
			if(needLayout || refreshPin) {
				this.removeRowGroupPin();
				delete this.rowGroups;
				delete this.rowGroupNameMap;
				delete this.rowGroupLookup;
				delete this.rowGroupMaxLevel;
				el.removeCls("ss-row-group-ct");
				el.setStyle("padding-left", "0px");
			}
		}
		return needLayout;
	},
	setColumnGroups: function(colGroups, refreshPin) {
		var colorLen = SCOM.colors.length;
		var el = this.getEl(),
			needLayout = false;
		if(colGroups) {
			this.colGroupNameMap = {};
			this.colGroupLookup = {};
			this.colGroups = SCOM.copy(colGroups);
			el.addCls("ss-col-group-ct");
			var maxLevel = 0;
			for(var i = 0, len = this.colGroups.length; i < len; i++) {
				var group = this.colGroups[i],
					span = group.span,
					level = group.level;
				if(level > maxLevel) {
					maxLevel = level;
				}
				var name = span.join("$");
				this.colGroupNameMap[name] = group;
				var minRow = span[0],
					maxRow = span[1];
				for(var j = minRow; j <= maxRow; j++) {
					this.colGroupLookup[j] = this.colGroupLookup[j] || {};
					this.colGroupLookup[j][name] = group;
				}
			}
			needLayout = maxLevel != this.colGroupMaxLevel;
			if(needLayout || refreshPin) {
				this.colGroupMaxLevel = maxLevel;
				var padding = maxLevel * this.groupOffset + this.groupPadding;
				el.setStyle("padding-top", padding + "px");
				var pinEl = this.getColumnGroupPin();
				pinEl.setStyle("top", -padding - 1 + "px");
				pinEl.setHeight(padding);
				var arr = [];
				for(var i = maxLevel; i > 0; i--) {
					var color = SCOM.colors[(i - 1) % colorLen];
					arr.push("<div class=\"ss-col-group-no\" style=\"background-color:" + color + ";\" data-level=\"" + i + "\">" + i + "</div>");
				}
				pinEl.update(arr.join(""));
			}
		} else {
			needLayout = this.colGroupMaxLevel ? true : false;
			if(needLayout || refreshPin) {
				this.removeColumnGroupPin();
				delete this.colGroups;
				delete this.colGroupNameMap;
				delete this.colGroupLookup;
				delete this.colGroupMaxLevel;
				el.removeCls("ss-col-group-ct");
				el.setStyle("padding-top", "0px");
			}
		}
		return needLayout;
	},
	setGroups: function(data) {
		var rowGroups, needLayout = false;
		if(data.rowGroups) {
			rowGroups = Ext.decode(data.rowGroups);
		}
		if(this.setRowGroups(rowGroups)) {
			needLayout = true;
		}
		var colGroups;
		if(data.colGroups) {
			colGroups = Ext.decode(data.colGroups);
		}
		if(this.setColumnGroups(colGroups)) {
			needLayout = true;
		}
		return needLayout;
	},
	getGroupLevel: function(dir) {
		var maps = this[dir + "GroupNameMap"];
		var mapStates = {};
		for(var p in maps) {
			mapStates[p] = maps[p].collapsed || false;
		}
		var levelPins = "",
			pinEl;
		if("row" == dir) {
			pinEl = this.getRowGroupPin();
		} else {
			pinEl = this.getColumnGroupPin();
		}
		if(pinEl) {
			levelPins = pinEl.dom.innerHTML;
		}
		return {
			mapStates: mapStates,
			levelPins: levelPins
		};
	},
	setGroupLevel: function(dir, info) {
		var maps = this[dir + "GroupNameMap"];
		var mapStates = info.mapStates,
			levelPins = info.levelPins;
		if("row" == dir) {
			pinEl = this.getRowGroupPin();
		} else {
			pinEl = this.getColumnGroupPin();
		}
		if(pinEl) {
			pinEl.update(levelPins);
		}
		for(var name in mapStates) {
			maps[name].collapsed = mapStates[name];
		}
	},
	setSheetId: function(sheetId) {
		this.sheetId = sheetId;
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			this[this.regionLookup[i]].setSheetId(sheetId);
		}
		this.ltcorner.setSheetId(sheetId);
	},
	updateSheetConfig: function(suspendEvent) {
		var config = this.getSheetConfig();
		var store = this.getStore(),
			sheetId = this.getSheetId();
		store.updateSheetConfig(sheetId, config, suspendEvent);
		return config;
	},
	getSheetConfig: function() {
		var sm = this.getSelectionModel();
		var rm = this.getReferenceModel();
		var config = {
			rangeInfo: this.getRangeInfo(),
			selection: sm.getSelection(),
			focusCell: sm.getFocusCell(),
			noGridLine: !this.withGridLine(),
			zoom: this.store.getZoom(),
			background: this.sheetTabBackground,
			rowNameHidden: this.store.rowNameHidden,
			colNameHidden: this.store.colNameHidden
		};
		if(this.freezePos) {
			config.freezePos = Ext.apply({}, this.freezePos);
		}
		if(this.splitPos) {
			config.splitPos = Ext.apply({}, this.splitPos);
		}
		return config;
	},
	getDefaultConfig: function() {
		var rangeInfo = {
			lheader: {
				visible: false
			},
			sheader: this.sheader.getDefaultRangeSpan(),
			ulefter: {
				visible: false
			},
			slefter: this.slefter.getDefaultRangeSpan(),
			ltregion: {
				visible: false
			},
			lregion: {
				visible: false
			},
			tregion: {
				visible: false
			},
			cregion: this.cregion.getDefaultRangeSpan()
		};
		var sm = this.getSelectionModel();
		var config = {
			rangeInfo: rangeInfo,
			selection: sm.getDefaultSelection(),
			focusCell: sm.getDefaultFocusCell(),
			reference: []
		};
		return config;
	},
	prepareSheetConfig: function(config, skipUpdate) {
		var flag = this.prepareFreezeConfig(config);
		if(this.prepareSplitConfig(config)) {
			flag = true;
		}
		this.updateCurrentBackground(config.background);
		if(flag && !skipUpdate) {
			this.updateSheetConfig(true);
		}
	},
	prepareSplitConfig: function(config) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var splitPos = config.splitPos,
			rangeInfo = config.rangeInfo;
		if(splitPos) {
			var frow = splitPos.row,
				fcol = splitPos.col,
				srow = splitPos.startRow || 1,
				scol = splitPos.startCol || 1;
			var reset = splitPos.reset;
			if(!reset) {
				return;
			}
			delete splitPos.startCol;
			delete splitPos.startRow;
			delete splitPos.row;
			delete splitPos.col;
			delete splitPos.reset;
			splitPos.width = scol < fcol ? store.getRangeWidth(sheetId, scol, fcol - 1, undefined, true) : 0;
			splitPos.height = srow < frow ? store.getRangeHeight(sheetId, srow, frow - 1, undefined, true) : 0;
			if(1 < frow) {
				rangeInfo.ulefter = rangeInfo.ulefter || {};
				Ext.apply(rangeInfo.ulefter, {
					visible: srow < frow,
					range: {
						rowStart: srow,
						rowEnd: frow - 1,
						colStart: 0,
						colEnd: 0
					},
					colBound: {
						min: 0,
						low: 0,
						high: true
					},
					rowBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
				rangeInfo.tregion = rangeInfo.tregion || {};
				Ext.apply(rangeInfo.tregion, {
					visible: srow < frow,
					range: {
						rowStart: srow,
						rowEnd: frow - 1,
						colStart: fcol
					},
					colBound: {
						min: 1,
						low: 1,
						high: false
					},
					rowBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
				Ext.apply(rangeInfo.slefter, {
					range: {
						rowStart: frow,
						colStart: 0,
						colEnd: 0
					},
					colBound: {
						min: 0,
						low: 0,
						high: true
					},
					rowBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
			}
			if(1 < fcol) {
				rangeInfo.lheader = rangeInfo.lheader || {};
				Ext.apply(rangeInfo.lheader, {
					visible: scol < fcol,
					range: {
						colStart: scol,
						colEnd: fcol - 1,
						rowStart: 0,
						rowEnd: 0
					},
					rowBound: {
						min: 0,
						low: 0,
						high: true
					},
					colBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
				rangeInfo.lregion = rangeInfo.lregion || {};
				Ext.apply(rangeInfo.lregion, {
					visible: scol < fcol,
					range: {
						colStart: scol,
						colEnd: fcol - 1,
						rowStart: frow
					},
					rowBound: {
						min: 1,
						low: 1,
						high: false
					},
					colBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
				Ext.apply(rangeInfo.sheader, {
					range: {
						colStart: fcol,
						rowStart: 0,
						rowEnd: 0
					},
					rowBound: {
						min: 0,
						low: 0,
						high: true
					},
					colBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
			}
			if(srow < frow || scol < fcol) {
				Ext.apply(rangeInfo.cregion, {
					range: {
						rowStart: frow,
						colStart: fcol
					},
					colBound: {
						min: 1,
						low: 1,
						high: false
					},
					rowBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
			}
			if(srow < frow && scol < fcol) {
				rangeInfo.ltregion = rangeInfo.ltregion || {};
				Ext.apply(rangeInfo.ltregion, {
					visible: true,
					range: {
						colStart: scol,
						colEnd: fcol - 1,
						rowStart: srow,
						rowEnd: frow - 1
					},
					rowBound: {
						min: 1,
						low: 1,
						high: false
					},
					colBound: {
						min: 1,
						low: 1,
						high: false
					}
				});
			}
			return true;
		}
	},
	prepareFreezeConfig: function(config) {
		var freezePos = config.freezePos,
			rangeInfo = config.rangeInfo;
		if(freezePos) {
			var frow = freezePos.row,
				fcol = freezePos.col,
				srow = freezePos.startRow || 1,
				scol = freezePos.startCol || 1;
			var reset = freezePos.reset;
			if(!reset) {
				return;
			}
			delete freezePos.startCol;
			delete freezePos.startRow;
			delete freezePos.reset;
			if(1 < frow) {
				rangeInfo.ulefter = rangeInfo.ulefter || {};
				Ext.apply(rangeInfo.ulefter, {
					visible: srow < frow,
					range: {
						rowStart: srow,
						rowEnd: frow - 1,
						colStart: 0,
						colEnd: 0
					},
					colBound: {
						min: 0,
						low: 0,
						high: true
					},
					rowBound: {
						min: srow,
						low: srow,
						high: frow - 1
					}
				});
				rangeInfo.tregion = rangeInfo.tregion || {};
				Ext.apply(rangeInfo.tregion, {
					visible: srow < frow,
					range: {
						rowStart: srow,
						rowEnd: frow - 1,
						colStart: fcol
					},
					colBound: {
						min: scol,
						low: fcol,
						high: false
					},
					rowBound: {
						min: srow,
						low: frow - 1,
						high: frow - 1
					}
				});
				Ext.apply(rangeInfo.slefter, {
					range: {
						rowStart: frow,
						colStart: 0,
						colEnd: 0
					},
					colBound: {
						min: 0,
						low: 0,
						high: true
					},
					rowBound: {
						min: srow,
						low: frow,
						high: false
					}
				});
			}
			if(1 < fcol) {
				rangeInfo.lheader = rangeInfo.lheader || {};
				Ext.apply(rangeInfo.lheader, {
					visible: scol < fcol,
					range: {
						colStart: scol,
						colEnd: fcol - 1,
						rowStart: 0,
						rowEnd: 0
					},
					rowBound: {
						min: 0,
						low: 0,
						high: true
					},
					colBound: {
						min: scol,
						low: scol,
						high: fcol - 1
					}
				});
				rangeInfo.lregion = rangeInfo.lregion || {};
				Ext.apply(rangeInfo.lregion, {
					visible: scol < fcol,
					range: {
						colStart: scol,
						colEnd: fcol - 1,
						rowStart: frow
					},
					rowBound: {
						min: srow,
						low: frow,
						high: false
					},
					colBound: {
						min: scol,
						low: fcol - 1,
						high: fcol - 1
					}
				});
				Ext.apply(rangeInfo.sheader, {
					range: {
						colStart: fcol,
						rowStart: 0,
						rowEnd: 0
					},
					rowBound: {
						min: 0,
						low: 0,
						high: true
					},
					colBound: {
						min: scol,
						low: fcol,
						high: false
					}
				});
			}
			if(1 < frow || 1 < fcol) {
				Ext.apply(rangeInfo.cregion, {
					range: {
						rowStart: frow,
						colStart: fcol
					},
					colBound: {
						min: scol,
						low: fcol,
						high: false
					},
					rowBound: {
						min: srow,
						low: frow,
						high: false
					}
				});
			}
			if(srow < frow && scol < fcol) {
				rangeInfo.ltregion = rangeInfo.ltregion || {};
				Ext.apply(rangeInfo.ltregion, {
					visible: true,
					range: {
						colStart: scol,
						colEnd: fcol - 1,
						rowStart: srow,
						rowEnd: frow - 1
					},
					rowBound: {
						min: srow,
						low: frow - 1,
						high: frow - 1
					},
					colBound: {
						min: scol,
						low: fcol - 1,
						high: fcol - 1
					}
				});
			}
			return true;
		}
	},
	setSheetConfig: function(config, skipUpdate) {
		config = Ext.applyIf(config || {}, this.getDefaultConfig());
		this.prepareSheetConfig(config, skipUpdate);
		if(config.freezePos) {
			this.freezePos = Ext.apply({}, config.freezePos);
		} else {
			delete this.freezePos;
		}
		if(config.splitPos) {
			this.splitPos = Ext.apply({}, config.splitPos);
		} else {
			delete this.splitPos;
		}
		this.setRangeInfo(config.rangeInfo);
		Ext.apply(this.store, {
			rowNameHidden: config.rowNameHidden,
			colNameHidden: config.colNameHidden
		});
		if(config.colNameHidden || config.rowNameHidden) {
			this.ltcorner.hide();
		} else {
			this.ltcorner.show();
		}
		this.checkLefterWidth(true, true);
		var sm = this.getSelectionModel();
		if(config.selection) {
			sm.selectRange(config.selection.startPos, config.selection.endPos);
		}
		if(config.reference) {
			var rm = this.getReferenceModel();
			rm.setReference(config.reference, true);
		}
		if(config.focusCell) {
			sm.setFocusCell(config.focusCell.row, config.focusCell.col);
		}
		if(config.noGridLine) {
			this.hideGridLine(true);
		} else {
			this.showGridLine(true);
		}
	},
	syncSheetFloating: function(suspendEvent, skipUpdateConfig) {
		var needLayout = this.mixins.basic.syncSheetFloating.apply(this, arguments) || false;
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var data = store.getCell(sheetId, 0, 0, true);
		if(this.enableRowColGroup) {
			needLayout = this.setGroups(store.getGroupsBySheetId(sheetId));
		}
		var config = Ext.decode(data.config);
		this.setSheetConfig(config, skipUpdateConfig);
		this.setFloors(store.getFloorsBySheetId(sheetId));
		this.refreshFloor();
		return needLayout;
	},
	go2Sheet: function(sheetId, callback, scope) {
		var oldSheetId = this.getSheetId();
		if(oldSheetId != sheetId) {
			var store = this.getStore();
			store.loadSheet(sheetId, function(success) {
				if(success) {
					this.switchSheet(sheetId, function() {
						if(callback) {
							callback.call(scope);
						}
					}, this);
				} else {
					this.loadMask.hide();
				}
			}, this);
		}
	},
	switchSheet: function(sheetId, callback, scope) {
		var oldSheetId = this.getSheetId();
		if(oldSheetId != sheetId) {
			if(false !== this.fireEvent("beforeswitchsheet", oldSheetId, sheetId, this)) {
				var store = this.getStore();
				if(store.getSheetById(oldSheetId)) {
					this.updateSheetConfig(true);
					if(this.enableRowColGroup) {
						this.updateRowGroups();
						this.updateColumnGroups();
					}
				}
				store.setActivedSheetId(sheetId);
				this.setSheetId(sheetId);
				var config = store.getSheetConfig(sheetId);
				var zoom = config.zoom || 1;
				var needLayout = this.syncSheetFloating(undefined, true);
				this.updateCurrentBackground(config.background);
				if(zoom !== store.getZoom()) {
					this.changeZoom(zoom, undefined, true);
				}
				this.refreshRange(null, true, undefined, function() {
					if(needLayout) {
						if(Ext.isFunction(this.doLayout)) {
							this.doLayout();
						} else if(Ext.isFunction(this.updateLayout)) {
							this.updateLayout();
						}
					}
					this.syncPageBreak();
					this.fireEvent("switchsheet", oldSheetId, sheetId, this);
					if(callback) {
						callback.call(scope);
					}
				}, this);
			}
		} else {
			if(callback) {
				callback.call(scope);
			}
		}
	},
	refreshRange: function(ranges, reCalCells, skipUpdateValue, callback, scope) {
		var ratio = 0.3;
		var fn = function(ranges) {
			if(!ranges) {
				this.refresh();
				return;
			}
			var region = this.getCurrentRegion();
			var cache = {},
				sheetId = this.getSheetId(),
				flag = false,
				rows = {};
			var len = ranges.length;
			if(20 < len) {
				flag = true;
			} else {
				for(var i = 0; i < len; i++) {
					var range = ranges[i];
					if(sheetId == range[0]) {
						if(0 == range[1] || 0 == range[2] || 0 == range[3] || 0 == range[4]) {
							flag = true;
							break;
						} else {
							for(var j = range[1]; j <= range[3]; j++) {
								var minCol = range[2];
								rows[j] = minCol;
								for(var k = minCol; k <= range[4]; k++) {
									var key = j + "$" + k;
									cache[key] = [j, k];
									if(1 < j) {
										key = j - 1 + "$" + k;
										cache[key] = [j - 1, k];
									}
									if(1 < k) {
										key = j + "$" + (k - 1);
										cache[key] = [j, k - 1];
									}
									key = j + 1 + "$" + k;
									cache[key] = [j + 1, k];
									key = j + "$" + (k + 1);
									cache[key] = [j, k + 1];
								}
							}
						}
					}
				}
			}
			if(!flag) {
				var lookup = this.bodyRegionLookup,
					update = [];
				for(var i = 0, len = lookup.length; i < len; i++) {
					var region = this[lookup[i]];
					if(region.isVisible()) {
						for(var p in rows) {
							if(rows.hasOwnProperty(p)) {
								var row = Number(p),
									col = rows[p];
								if(region.isInRange(row, col)) {
									var prev = this.findPrevNonEmptyColIndex(sheetId, row, col, region);
									if(prev) {
										cache[row + "$" + prev] = [row, prev];
									}
								}
							}
						}
						for(var p in cache) {
							var row = cache[p][0],
								col = cache[p][1];
							if(region.isInRange(row, col)) {
								update.push([region, row, col]);
							}
						}
					}
				}
				var count = update.length;
				var sum = this.countCell();
				if(count < sum * ratio) {
					for(var i = 0; i < count; i++) {
						var it = update[i];
						var region = it[0],
							row = it[1],
							col = it[2];
						region.refreshCell(row, col);
					}
					this.checkLefterWidth();
					return;
				}
			}
			this.refresh();
		};
		if(reCalCells) {
			this.refreshCalCdt(reCalCells, false === SCOM.typeOf(ranges), skipUpdateValue, ranges, function(ret) {
				if(ranges) {
					ranges = ranges.concat(ret);
				}
				fn.call(this, ranges);
				if(callback) {
					callback.call(scope);
				}
			}, this);
		} else {
			fn.call(this, ranges);
			if(callback) {
				callback.call(scope);
			}
		}
	},
	syncReferenceForCalculate: function(value, disableReferFlag, clearFlag) {
		if(this.calculate) {
			var me = this;
			var rm = this.getReferenceModel();
			if(clearFlag) {
				rm.clearSelection();
			}
			var sheetId = this.getSheetId();
			var v = value;
			if(this.calculate.couldbeCalculate(v)) {
				if(!disableReferFlag) {
					this.disableSelect();
					this.enableRefer();
				}
				var arr = this.checkReferenceNamesInCal(v, 0);
				var colorIndex = 0;
				EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg.lastIndex = 0;
				v.replace(EnterpriseSheet.sheet.calculate.Coordinate.prototype.spanReg, function(w) {
					var pos = arguments[arguments.length - 2];
					var str = arguments[arguments.length - 1];
					var ret = EnterpriseSheet.sheet.calculate.Coordinate.prototype.assembleCoordByRegResult(arguments);
					if(!ret) {
						return w;
					}
					var span = ret.span;
					if(!Ext.isNumber(span[0])) {
						if(span[0]) {
							var foundSheetId = me.getStore().getSheetIdByName(span[0]);
							if(Ext.isDefined(foundSheetId)) {
								span[0] = foundSheetId;
							}
						} else {
							span[0] = sheetId;
						}
					}
					if(Ext.isNumber(span[0]) && span[3] <= SCONST.MAX_ROW_NUMBER && span[4] <= SCONST.MAX_COLUMN_NUMBER) {
						arr.push({
							span: span,
							colorIndex: colorIndex
						});
					}
					colorIndex++;
				});
				if(0 < arr.length) {
					rm.setReference(arr, true, false, "ss-cal-ref");
					rm.show();
					return true;
				}
			} else {
				this.enableSelect();
				this.disableRefer();
			}
		}
	},
	checkReferenceNamesInCal: function(calStr, colorIndex) {
		var store = this.getStore();
		var lookup = store.getNamedFuncConfigLookup();
		var arr = [];
		calStr.replace(EnterpriseSheet.sheet.calculate.Calculate.prototype.refNameReg, function(w) {
			var found = lookup[w];
			if(found && "ref" === found.ctype) {
				var json = found.jsonObj;
				if(!Ext.isArray(json)) {
					json = [json];
				}
				for(var i = 0, len = json.length; i < len; i++) {
					var it = json[i];
					arr.push({
						span: it.span,
						colorIndex: colorIndex,
						cls: "ss-rm-name"
					});
				}
			}
		});
		return arr;
	},
	walkBodyRegions: function(fn, scope) {
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++) {
			var p = this.bodyRegionLookup[i];
			var region = this[p];
			fn.call(scope, region, p, this);
		}
	},
	walkFloorRegions: function(fn, scope) {
		for(var i = 0, len = this.floorRegionLookup.length; i < len; i++) {
			var p = this.floorRegionLookup[i];
			var region = this[p];
			fn.call(scope, region, p, this);
		}
	},
	registerFloor: function(floor, suspendEvent, register2SheetId) {
		this.floorLookup = this.floorLookup || {};
		if(Ext.isDefined(register2SheetId)) {
			floor.sheetId = register2SheetId;
		} else {
			floor.sheetId = this.getSheetId();
		}
		var action = "update";
		if(!this.floorLookup[floor.getId()]) {
			action = "create";
		}
		this.floorLookup[floor.getId()] = floor;
		if(!suspendEvent && floor.getFloorInfo) {
			this.syncFloors(floor, action);
		}
	},
	unregisterFloor: function(floor, suspendUpdate) {
		if(this.floorLookup) {
			delete this.floorLookup[floor.getId()];
			if(!suspendUpdate && floor.getFloorInfo) {
				this.syncFloors(floor, "remove");
			}
		}
	},
	clearFloor: function(suspendUpdate, suspendEvent) {
		if(this.floorLookup) {
			for(var p in this.floorLookup) {
				var floor = this.floorLookup[p];
				if(!floor.isLocalKit()) {
					floor.destroy(suspendUpdate, suspendEvent);
				}
			}
			delete this.floorLookup;
		}
	},
	prepareSource: function(source) {
		var curSheetId = this.getSheetId();
		var series = source.series;
		for(var i = 0, len = series.length; i < len; i++) {
			var it = series[i];
			if("" == it[0] || SCOM.nullOrUndefined(it[0])) {
				it[0] = curSheetId;
			}
		}
		var labels = source.labels;
		if(labels) {
			for(var i = 0, len = labels.length; i < len; i++) {
				var it = labels[i];
				if("" == it[0] || SCOM.nullOrUndefined(it[0])) {
					it[0] = curSheetId;
				}
			}
		}
		var categories = source.categories;
		if(categories) {
			for(var i = 0, len = categories.length; i < len; i++) {
				var it = categories[i];
				if("" == it[0] || SCOM.nullOrUndefined(it[0])) {
					it[0] = curSheetId;
				}
			}
		}
	},
	removeFloor: function(name, sheetId) {
		var id = name + "-" + sheetId;
		if(this.floorLookup && this.floorLookup[id]) {
			var it = this.floorLookup[id];
			delete this.floorLookup[id];
			it.destroy(true, true);
		}
	},
	setFloors: function(floors) {
		for(var i = 0, len = floors.length; i < len; i++) {
			var floor = floors[i];
			var id = floor.id + "-" + floor.sheetId;
			if(this.floorLookup && this.floorLookup[id]) {
				var it = this.floorLookup[id];
				delete this.floorLookup[id];
				it.destroy(true, true);
			}
			var floorType = floor.floorType;
			if("picture" == floorType) {
				this.createPicture(floor.url, floor, true, true);
			} else if("wedgit" == floorType) {
				this.createWedgit(floor.url, floor, true, true);
			} else if("chart" == floorType) {
				var source = floor.source;
				source.seriesPosition = floor.seriesPosition;
				source.cacheFields = SCOM.copy(source.cacheFields);
				source.firstRowLabel = floor.firstRowLabel;
				source.firstColLabel = floor.firstColLabel;
				this.prepareSource(source);
				var rangeStore = this.createRangeStore(source);
				this.createChart(floor.chartType, rangeStore, floor, true, true);
			}
		}
	},
	getFloorById: function(floorId) {
		return this.floorLookup[floorId];
	},
	getFloorSet: function() {
		return this.floorLookup;
	},
	hideCurrentOptionFloors: function() {
		var sheetId = this.getSheetId();
		for(var p in this.floorLookup) {
			if(this.floorLookup.hasOwnProperty(p)) {
				var floor = this.floorLookup[p];
				if(sheetId == floor.sheetId && "function" != Ext.typeOf(floor.getFloorInfo)) {
					floor.hide();
				}
			}
		}
	},
	refreshFloor: function() {
		var sheetId = this.getSheetId();
		for(var p in this.floorLookup) {
			if(this.floorLookup.hasOwnProperty(p)) {
				var floor = this.floorLookup[p];
				if(sheetId == floor.sheetId) {
					floor.show();
				} else {
					floor.hide();
				}
			}
		}
	},
	getActiveFloorInfo: function() {
		var info = [];
		var sheetId = this.getSheetId();
		for(var p in this.floorLookup) {
			if(this.floorLookup.hasOwnProperty(p)) {
				var floor = this.floorLookup[p];
				if(sheetId == floor.sheetId && "function" == Ext.typeOf(floor.getFloorInfo)) {
					info.push(floor.getFloorInfo());
				}
			}
		}
		if(0 < info.length) {
			return info;
		}
	},
	deleteRow: function(pos) {
		var store = this.getStore();
		if(!pos) {
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}
		var sheetId = Ext.isDefined(pos.sheetId) ? pos.sheetId : this.getSheetId();
		var minrow = pos.minrow,
			maxrow = pos.maxrow;
		if(minrow < 1) {
			minrow = 1;
		}
		if(maxrow < 1) {
			maxrow = 1;
		}
		this.doDeleteRow(sheetId, minrow, maxrow, SCONFIG.skipHiddenRowWhenDeleteFromUI);
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	deleteColumn: function(pos) {
		var store = this.getStore();
		if(!pos) {
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}
		var sheetId = Ext.isDefined(pos.sheetId) ? pos.sheetId : this.getSheetId();
		var mincol = pos.mincol,
			maxcol = pos.maxcol;
		if(mincol < 1) {
			mincol = 1;
		}
		if(maxcol < 1) {
			maxcol = 1;
		}
		this.doDeleteColumn(sheetId, mincol, maxcol);
		if(Ext.isFunction(this.refreshFocus)) {
			this.refreshFocus();
		}
	},
	sortSelection: function(keys, dir) {
		var sm = this.getSelectionModel();
		var span = sm.selection2Span();
		this.checkSortSpan(span, keys, dir);
	},
	beyondSortLimit: function(span) {
		var store = this.getStore(),
			rowCount = span[3] - span[1] + 1;
		if(SCONST.sortLimitCellCount <= store.getTotalCellCount() || SCONST.sortLimitRowCount <= rowCount) {
			return true;
		}
	},
	heavySortHint: function(span, callback, scope) {
		var store = this.getStore(),
			rowCount = span[3] - span[1] + 1,
			cellCount = store.getTotalCellCount();
		if(rowCount == 1) {
			rowCount = cellCount;
		}
		if(SCONST.sortLimitRowCount <= rowCount) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.beyond_sort_limit,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
			return false;
		}
		if(1000 <= rowCount || 100 < rowCount && 10000 <= cellCount) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.sort_time_cost,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OKCANCEL,
				fn: function(bid) {
					if("ok" === bid) {
						if(callback) {
							callback.call(scope);
						}
					}
				},
				scope: this
			});
		} else if(callback) {
			callback.call(scope);
		}
	},
	checkSortSpan: function(span, keys, dir) {
		if(span[1] === span[3] && span[2] === span[4] && 0 !== span[1] && 0 !== span[2] || 0 === span[1] && 0 === span[2]) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.can_not_sort_range,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		} else if(this.beyondSortLimit(span)) {
			Ext.Msg.show({
				title: SLANG.hint,
				msg: SLANG.beyond_sort_limit,
				icon: Ext.Msg.INFO,
				buttons: Ext.Msg.OK
			});
		} else {
			this.heavySortHint(span, function() {
				var store = this.getStore(),
					withMerged = false,
					expand;
				SPOP.showSortColumnOption({
					applyCallback: {
						fn: function(opt) {
							if(0 == opt) {
								expand = true;
							} else {
								expand = false;
							}
							this.doCheckSortSpan(span, keys, dir, expand, false);
						},
						scope: this
					}
				});
			}, this);
		}
	},
	getFilter: function() {
		if(this.filter) {
			return this.filter;
		}
	},
	setPropertyForSelection: function(modified, deleted, suspendRefresh, suspendEvent) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty(modified, deleted, suspendRefresh, suspendEvent);
		this.focus(this.focusDelayTime);
	},
	insertRange: function() {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		if(0 == minrow && 0 == mincol) {
			return;
		} else if(0 == minrow) {
			this.insertColumn();
		} else if(0 == mincol) {
			this.insertRow();
		} else {
			this.insertCell();
		}
	},
	insertCellMoveRight: function(sheetId, pos, insertCellCache) {
		var dir = "right";
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		var brokenMergeFlag = store.withBrokenMergedCell([
			[sheetId, minrow, mincol, maxrow, 0]
		]);
		if(!brokenMergeFlag) {
			var brokenTplFlag = store.withBrokenTplCell([
				[sheetId, minrow, mincol, maxrow, 0]
			]);
			if(!brokenTplFlag) {
				this.doInsertCellMoveRight(sheetId, pos, insertCellCache);
			} else {
				Ext.Msg.alert(SLANG.hint, SLANG.broken_tpl_cell_hint);
			}
		} else {
			Ext.Msg.alert(SLANG.hint, SLANG.broken_merge_cell_hint);
		}
	},
	doInsertCellMoveRight: function(sheetId, pos, insertCellCache) {
		var dir = "right";
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		store.insertCell(sheetId, minrow, mincol, rowSpan, colSpan, dir, undefined, insertCellCache);
		var relatedRows = this.getRelatedRowsForAutoHeight([
			[sheetId, minrow, mincol, maxrow, 0]
		], undefined, undefined, true);
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		this.fireEvent("cellinserted", sheetId, minrow, mincol, rowSpan, colSpan, dir, changedHeights, this);
		if(insertCellCache) {
			this.refreshRange([
				[sheetId, minrow, mincol, maxrow, maxcol]
			]);
		}
		this.refreshFocus();
	},
	insertCellMoveBottom: function(sheetId, pos, insertCellCache) {
		var dir = "bottom";
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		var brokenMergeFlag = store.withBrokenMergedCell([
			[sheetId, minrow, mincol, 0, maxcol]
		]);
		if(!brokenMergeFlag) {
			var brokenTplFlag = store.withBrokenTplCell([
				[sheetId, minrow, mincol, 0, maxcol]
			]);
			if(!brokenTplFlag) {
				this.doInsertCellMoveBottom(sheetId, pos, insertCellCache);
			} else {
				Ext.Msg.alert(SLANG.hint, SLANG.broken_tpl_cell_hint);
			}
		} else {
			Ext.Msg.alert(SLANG.hint, SLANG.broken_merge_cell_hint);
		}
	},
	doInsertCellMoveBottom: function(sheetId, pos, insertCellCache) {
		var dir = "bottom";
		var store = this.getStore();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		var relatedRows = this.getRelatedRowsForAutoHeight([
			[sheetId, minrow, mincol, 0, maxcol]
		], undefined, undefined, true);
		store.insertCell(sheetId, minrow, mincol, rowSpan, colSpan, dir, undefined, insertCellCache);
		Ext.applyIf(relatedRows, this.getRelatedRowsForAutoHeight([
			[sheetId, minrow, mincol, 0, maxcol]
		], undefined, undefined, true));
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		this.fireEvent("cellinserted", sheetId, minrow, mincol, rowSpan, colSpan, dir, changedHeights, this);
		if(insertCellCache) {
			this.refreshRange([
				[sheetId, minrow, mincol, maxrow, maxcol]
			]);
		}
		this.refreshFocus();
	},
	insertCell: function(sheetId, pos, insertCellCache) {
		if(SCOM.nullOrUndefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos) {
			pos = sm.getMinMaxPos();
		}
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		var rowSpan = maxrow - minrow + 1,
			colSpan = maxcol - mincol + 1;
		if(0 == minrow || 0 == mincol) {
			return;
		} else if(SPOP) {
			SPOP.showInsertCellOption({
				applyCallback: {
					fn: function(opt) {
						if(opt < 2) {
							var dir = 0 == opt ? "bottom" : "right";
							if("right" == dir) {
								this.insertCellMoveRight(sheetId, pos, insertCellCache);
							} else {
								this.insertCellMoveBottom(sheetId, pos, insertCellCache);
							}
						} else if(2 == opt) {
							this.doInsertRow(sheetId, minrow, rowSpan, undefined, insertCellCache);
						} else if(3 == opt) {
							this.doInsertColumn(sheetId, mincol, colSpan, undefined, insertCellCache);
						}
					},
					scope: this
				}
			});
		}
	},
	insertRow: function() {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var minrow = pos.minrow,
			maxrow = pos.maxrow;
		var span = maxrow - minrow + 1;
		if(minrow < 1) {
			minrow = 1;
		}
		this.doInsertRow(sheetId, minrow, span);
	},
	insertColumn: function() {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var mincol = pos.mincol,
			maxcol = pos.maxcol;
		var span = maxcol - mincol + 1;
		if(mincol < 1) {
			mincol = 1;
		}
		this.doInsertColumn(sheetId, mincol, span);
	},
	deleteRange: function() {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		if(0 == minrow && 0 == mincol) {
			return;
		} else if(0 == minrow) {
			this.deleteColumn({
				mincol: mincol,
				maxcol: maxcol
			});
		} else if(0 == mincol) {
			this.deleteRow({
				minrow: minrow,
				maxrow: maxrow
			});
		} else {
			this.deleteCell();
		}
	},
	deleteCell: function() {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var minrow = pos.minrow,
			maxrow = pos.maxrow,
			mincol = pos.mincol,
			maxcol = pos.maxcol;
		if(0 == minrow || 0 == mincol) {
			return;
		} else if(SPOP) {
			SPOP.showRemoveCellOption({
				applyCallback: {
					fn: function(opt) {
						if(opt < 2) {
							var dir = 1 == opt ? "left" : "top";
							if("left" == dir) {
								this.deleteCellMoveLeft(sheetId, pos);
							} else {
								this.deleteCellMoveTop(sheetId, pos);
							}
						} else if(2 == opt) {
							this.deleteRow({
								minrow: minrow,
								maxrow: maxrow
							});
						} else if(3 == opt) {
							this.deleteColumn({
								mincol: mincol,
								maxcol: maxcol
							});
						}
						this.refreshFocus();
					},
					scope: this
				}
			});
		}
	},
	setRowHeight: function(h, pos) {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos) {
			pos = sm.getMinMaxPos();
		}
		this.mixins.basic.setRowHeight.apply(this, arguments);
		this.refreshRange();
		sm.refreshSelection();
	},
	setColumnWidth: function(w, pos) {
		var sheetId = this.getSheetId();
		var store = this.getStore();
		var sm = this.getSelectionModel();
		if(!pos) {
			pos = sm.getMinMaxPos();
		}
		var mincol = pos.mincol,
			maxcol = pos.maxcol,
			old = {},
			cur = {};
		if(0 == mincol) {
			if(5 > w) {
				w = 5;
			}
			var cornerPro = store.getCell(sheetId, 0, 0);
			if(cornerPro.width === w) {
				return;
			}
			old[0] = cornerPro.width;
			cur[0] = w;
			store.setWhole(sheetId, {
				width: w
			}, null, true);
			this.refreshRange();
			sm.refreshSelection();
		} else {
			if(0 >= w) {
				for(var i = mincol; i <= maxcol; i++) {
					old[i] = true;
					cur[i] = false;
				}
				store.hideColumn(sheetId, mincol, maxcol, true);
				this.refreshRange();
				sm.refreshSelection();
			} else {
				if(mincol == maxcol) {
					old[mincol] = store.getColWidth(sheetId, mincol, true, true);
					cur[mincol] = w;
					store.setColumnWidth(sheetId, mincol, w, true);
				} else {
					for(var i = mincol; i <= maxcol; i++) {
						old[i] = store.getColWidth(sheetId, i, true, true);
						cur[i] = w;
						store.setColumnWidth(sheetId, i, w, true, true);
					}
					this.refreshRange();
					sm.refreshSelection();
				}
			}
		}
		this.fireEvent("columnresized", maxcol, old, cur, this);
	},
	hideRow: function(pos, sheetId) {
		if(!pos) {
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}
		var visibles = this.mixins.basic.hideRow.call(this, pos, sheetId);
		this.checkLefterWidth();
		this.syncPageBreak();
		return visibles;
	},
	hideColumn: function(pos, sheetId) {
		if(!pos) {
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
		}
		var ret = this.mixins.basic.hideColumn.call(this, pos, sheetId);
		this.syncPageBreak();
		return ret;
	},
	showRow: function(pos, sheetId) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		if(!pos) {
			var sm = this.getSelectionModel(),
				store = this.getStore();
			pos = sm.getMinMaxPos();
			if(2 === pos.minrow || pos.minrow == pos.maxrow) {
				if(!store.isVisibleRow(sheetId, 1)) {
					pos.minrow = 1;
				}
			}
		}
		var hidden = this.mixins.basic.showRow.call(this, pos, sheetId);
		this.checkLefterWidth();
		this.syncPageBreak();
		return hidden;
	},
	showColumn: function(pos, sheetId) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
		}
		if(!pos) {
			var sm = this.getSelectionModel();
			pos = sm.getMinMaxPos();
			if(2 === pos.mincol || pos.maxcol == pos.mincol) {
				if(!store.isVisibleColumn(sheetId, 1)) {
					pos.mincol = 1;
				}
			}
		}
		var ret = this.mixins.basic.showColumn.call(this, pos, sheetId);
		this.syncPageBreak();
		return ret;
	},
	includedMergedCell: function(pos) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		for(var i = pos.minrow; i <= pos.maxrow; i++) {
			for(var j = pos.mincol; j <= pos.maxcol; j++) {
				if(store.isMergedCell(null, sheetId, i, j)) {
					return true;
				}
			}
		}
		return false;
	},
	includedTableTplCell: function(pos, sheetId) {
		var store = this.getStore();
		sheetId = Ext.isDefined(sheetId) ? sheetId : this.getSheetId();
		for(var i = pos.minrow; i <= pos.maxrow; i++) {
			for(var j = pos.mincol; j <= pos.maxcol; j++) {
				var cell = store.getCell(sheetId, i, j);
				if(cell.tpl) {
					return true;
				}
			}
		}
		return false;
	},
	mergeCellForSpan: function(span, suspendEvent, suspendRefresh) {
		if(this.includedTableTplCell({
				minrow: span[1],
				mincol: span[2],
				maxrow: span[3],
				maxcol: span[4]
			})) {
			Ext.Msg.alert(SLANG.hint, SLANG.cannot_operate_table_tpl);
		} else {
			this.mergeCell(span, suspendEvent, suspendRefresh);
		}
	},
	mergeCellandAlignCenter: function() {
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)) {
			Ext.Msg.alert(SLANG.hint, SLANG.cannot_operate_table_tpl);
		} else {
			store.setCell(this.getSheetId(), pos.minrow, pos.mincol, {
				ta: "center"
			}, null, true);
			this.mergeCell([null, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]);
		}
	},
	mergeSelectedCell: function() {
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)) {
			Ext.Msg.alert(SLANG.hint, SLANG.cannot_operate_table_tpl);
		} else {
			this.mergeCell([null, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]);
		}
	},
	mergeCellInColumn: function() {
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)) {
			Ext.Msg.alert(SLANG.hint, SLANG.cannot_operate_table_tpl);
		} else {
			var minrow = pos.minrow,
				maxrow = pos.maxrow;
			for(var i = pos.mincol; i <= pos.maxcol; i++) {
				this.mergeCell([null, minrow, i, maxrow, i]);
			}
		}
	},
	mergeCellInRow: function() {
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(this.includedTableTplCell(pos)) {
			Ext.Msg.alert(SLANG.hint, SLANG.cannot_operate_table_tpl);
		} else {
			var mincol = pos.mincol,
				maxcol = pos.maxcol;
			for(var i = pos.minrow; i <= pos.maxrow; i++) {
				this.mergeCell([null, i, mincol, i, maxcol]);
			}
		}
	},
	cancelMergeCell: function() {
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		this.unmergeCell([null, pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]);
	},
	addCurrentDateOrTime: function(fm, dfm) {
		var sm = this.getSelectionModel(),
			focusCell = sm.getFocusCell();
		if(focusCell) {
			var row = focusCell.row,
				col = focusCell.col;
			var currentDate = Ext.Date.format(new Date, SCONST.DEFAULT_DATE_FORMAT);
			var dateObjs = {
				data: currentDate,
				fm: fm,
				dfm: dfm
			};
			this.setCell(this.getSheetId(), row, col, dateObjs, null, false);
		}
	},
	setTextFormatForSelection: function(format) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			fm: format,
			dfm: null
		});
	},
	setNumberFormatForSelection: function(format, coord) {
		var sm = this.getSelectionModel();
		coord = coord || sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			fm: SCONST.FORMAT_NUMBER,
			dfm: format
		});
	},
	setLocaleFormatForSelection: function(format, options) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		format = format ? format : SCONFIG.default_locale;
		formatObj = {
			locale: format,
			options: options
		};
		range.setProperty({
			fm: SCONST.FORMAT_LOCALE,
			dfm: formatObj
		});
	},
	setPercentFormatForSelection: function(format) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			fm: SCONST.FORMAT_PERCENT,
			dfm: format
		});
	},
	setDateFormatForSelection: function(dateFormat) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			fm: SCONST.FORMAT_DATE,
			dfm: dateFormat
		});
	},
	setTimeFormatForSelection: function(dateFormat) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			fm: SCONST.FORMAT_TIME,
			dfm: dateFormat
		});
	},
	setDateTimeFormatForSelection: function(dateTimeFormat) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			fm: SCONST.FORMAT_DATE_TIME,
			dfm: dateTimeFormat
		});
	},
	setSpecialFormatForSelection: function(format) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			fm: SCONST.FORMAT_SPECIAL,
			dfm: format
		});
	},
	moveDecimalPoint: function(offset) {
		if(0 != offset) {
			var sm = this.getSelectionModel();
			var focusCell = sm.getFocusCell();
			var cell = this.getCellData(this.getSheetId(), focusCell.row, focusCell.col);
			var dpd = Number(cell.dpd),
				digital = 0;
			if(Ext.isNumber(dpd)) {
				digital = dpd;
			} else {
				var num = Number(cell.data);
				if(Ext.isNumber(num)) {
					var arr = num.toString().split(".");
					if(2 == arr.length) {
						digital = arr[1].length;
					}
				}
			}
			digital += offset;
			if(0 > digital) {
				digital = 0;
			} else if(this.maxDigital < digital) {
				digital = this.maxDigital;
			}
			var coord = sm.selection2Coord();
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: coord
			});
			range.moveDecimalPoint(digital);
		}
	},
	setRangeBorder: function(dir, color, width, style, suspendRefresh, suspendEvent) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setRangeBorder(dir, color, width, style, suspendRefresh, suspendEvent);
		this.focus(this.focusDelayTime);
	},
	setConditionForRange: function(ranges, condition, option, suspendRefresh, suspendEvent, cdtId) {
		var store = this.getStore();
		store.checkLoadCoord(ranges, function() {
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: ranges
			});
			var newCdtId = range.setCondition(condition, option, suspendRefresh, suspendEvent, cdtId);
			this.refreshFocus();
		}, this);
	},
	setConditionForSelection: function(condition, option, sheetId, suspendRefresh) {
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
		}
		var store = this.getStore();
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var minrow = pos.minrow,
			mincol = pos.mincol,
			maxrow = pos.maxrow,
			maxcol = pos.maxcol;
		this.setConditionForRange([
			[sheetId, minrow, mincol, maxrow, maxcol]
		], condition, option, suspendRefresh);
	},
	clearConditionForSelection: function(sheetId) {
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
		}
		var sm = this.getSelectionModel();
		var pos = sm.getMinMaxPos();
		var minrow = pos.minrow,
			mincol = pos.mincol,
			maxrow = pos.maxrow,
			maxcol = pos.maxcol;
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: [
				[sheetId, minrow, mincol, maxrow, maxcol]
			]
		});
		range.clearCondition();
		this.refreshFocus();
	},
	clearConditonForSheet: function(sheetId) {
		var store = this.getStore();
		if(false == SCOM.typeOf(sheetId)) {
			sheetId = this.getSheetId();
		}
		var styles = ["cdtVal"].concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.styles);
		var floatings = store.getFloatingBySheet(sheetId, "cdt"),
			oldCdts = {};
		var coord = [];
		for(var i = 0, len = floatings.length; i < len; i++) {
			var it = floatings[i];
			oldCdts[it.name] = it;
			var cdt = Ext.decode(it.json);
			var rng = cdt.rng;
			for(var j = 0, count = rng.length; j < count; j++) {
				coord.push(rng[j].span);
			}
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		if(false !== this.fireEvent("beforeconditionchange", range, this)) {
			var result = this.getRelatedCdtCoord(coord);
			this.fireEvent("prepareconditionchange", range, this, oldCdts, result.coord);
			for(var p in oldCdts) {
				if(oldCdts.hasOwnProperty(p)) {
					var it = oldCdts[p];
					store.setFloatingItem(it.sheet, it.name, "cdt");
				}
			}
			range.setProperty({
				cdt: ""
			}, styles, true, true, true);
			var concatCoord = ss.processRelatedCdt(coord, true, result);
			this.refreshRange(concatCoord.concat(coord), true);
			this.fireEvent("conditionchange", range, this, oldCdts, concatCoord);
		}
		this.refreshFocus();
	},
	walkSelection: function(fn, scope) {
		var store = this.getStore(),
			sm = this.getSelectionModel(),
			sheetId = this.getSheetId();
		var mm = sm.getMinMaxPos();
		var ranges = [
			[sheetId, mm.minrow, mm.mincol, mm.maxrow, mm.maxcol]
		];
		store.walkRange(ranges, fn, scope);
	},
	getAverageOfSelection: function(decimalNumber) {
		var avg = 0,
			count = 0;
		this.walkSelection(function(rd, span, store) {
			var o = store.getCellData(rd.data.sheet, rd.data.row, rd.data.col);
			if(SCOM.canbeNumber(o.data)) {
				avg += Number(o.data);
				count++;
			}
		});
		if(0 < count) {
			avg = avg / count;
		}
		if(false != SCOM.typeOf(decimalNumber)) {
			var b = Math.pow(10, decimalNumber);
			avg = Math.round(avg * b) / b;
		}
		return avg;
	},
	cleanSelection: function(which, skipHiddenCell) {
		var sm = this.getSelectionModel(),
			store = this.getStore();
		var coord = sm.selection2Coord();
		if(skipHiddenCell) {
			coord = store.skipHiddenForCoord(coord);
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		if("content" == which) {
			range.cleanContent();
		} else if("style" == which) {
			range.cleanStyle();
		} else {
			range.clean();
		}
		this.focus(this.focusDelayTime);
		this.refreshFocus();
	},
	setCal2Selection: function(cal) {
		var sm = this.getSelectionModel();
		var span = sm.selection2Span();
		var maxrow = span[3],
			maxcol = span[4];
		var flag = true;
		if(span[1] != span[3]) {
			maxrow++;
			flag = false;
		}
		if(span[2] != span[4]) {
			maxcol++;
			flag = false;
		}
		this.focus(this.focusDelayTime);
		if(!flag) {
			var str = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String([{
				span: span,
				type: SCONST.RELATIVE_COORD
			}], "");
			str = "=" + cal.toUpperCase() + "(" + str + ")";
			this.setCellData(span[0], maxrow, maxcol, {
				data: str
			}, null);
			sm.selectRange({
				row: span[1],
				col: span[2]
			}, {
				row: maxrow,
				col: maxcol
			});
			return str;
		}
	},
	moveSelection: function(fromSpan, toSpan, sm, move2Insert, insertDir) {
		var me = this;
		var store = this.getStore(),
			sheetId = this.getSheetId();
		if(fromSpan.length == toSpan.length) {
			var flag = true;
			for(var i = 0, len = fromSpan.length; i < len; i++) {
				if(fromSpan[i] != toSpan[i]) {
					flag = false;
					break;
				}
			}
			if(flag) {
				return;
			}
		}
		var coord = [fromSpan, toSpan];
		if(store.withBrokenMergedCell(coord)) {
			Ext.Msg.alert(SLANG.hint, SLANG.can_not_change_part_merged_cell);
			return;
		}
		var removeAfterMove, sameSpan;
		if(true === move2Insert) {
			var colSpan = toSpan[4] - toSpan[2] + 1,
				rowSpan = toSpan[3] - toSpan[1] + 1;
			if(0 == toSpan[1]) {
				if(toSpan[2] !== fromSpan[2]) {
					if(toSpan[2] < fromSpan[2]) {
						fromSpan[2] += colSpan;
						fromSpan[4] += colSpan;
					}
					removeAfterMove = "col";
				}
			} else if(0 == toSpan[2]) {
				if(toSpan[1] !== fromSpan[1]) {
					if(toSpan[1] < fromSpan[1]) {
						fromSpan[1] += rowSpan;
						fromSpan[3] += rowSpan;
					}
					removeAfterMove = "row";
				}
			} else {
				if(toSpan[1] !== fromSpan[1] || toSpan[2] !== fromSpan[2]) {
					var valid = false;
					if("right" === insertDir) {
						sameSpan = fromSpan[1] === toSpan[1] && fromSpan[3] === toSpan[3];
						if(toSpan[2] > fromSpan[4]) {
							valid = true;
						} else if(sameSpan && toSpan[2] <= fromSpan[2]) {
							if(toSpan[2] < fromSpan[2]) {
								fromSpan[2] += colSpan;
								fromSpan[4] += colSpan;
							}
							valid = true;
						} else if(fromSpan[1] > toSpan[3] || fromSpan[3] < toSpan[1]) {
							valid = true;
						}
					} else {
						sameSpan = fromSpan[2] === toSpan[2] && fromSpan[4] === toSpan[4];
						if(toSpan[1] > fromSpan[3]) {
							valid = true;
						} else if(sameSpan && toSpan[1] <= fromSpan[1]) {
							if(toSpan[1] < fromSpan[1]) {
								fromSpan[1] += rowSpan;
								fromSpan[3] += rowSpan;
							}
							valid = true;
						} else if(fromSpan[2] > toSpan[4] || fromSpan[4] < toSpan[2]) {
							valid = true;
						}
					}
					if(valid) {
						removeAfterMove = "cell";
					}
				}
			}
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		if(false !== this.fireEvent("beforerangemove", range, this)) {
			if(removeAfterMove) {
				this.fireEvent("preparemoveforinsert", range, this);
				if("col" === removeAfterMove) {
					store.insertColumn(toSpan[0], toSpan[2], colSpan);
				} else if("row" === removeAfterMove) {
					store.insertRow(toSpan[0], toSpan[1], rowSpan);
				} else if("cell" === removeAfterMove) {
					store.insertCell(toSpan[0], toSpan[1], toSpan[2], rowSpan, colSpan, insertDir);
				}
			}
			var reCalCells = this.getRecalculateCellsByCoord(coord);
			var oldCdt = this.getCdtsFromCoord(range.getCoord());
			var changedHeights = {};
			this.fireEvent("preparerangemove", range, this, oldCdt, reCalCells, changedHeights);
			var fsheet = fromSpan[0],
				fminrow = fromSpan[1],
				fmincol = fromSpan[2],
				fmaxrow = fromSpan[3],
				fmaxcol = fromSpan[4];
			var tsheet = toSpan[0],
				tminrow = toSpan[1],
				tmincol = toSpan[2],
				tmaxrow = toSpan[3],
				tmaxcol = toSpan[4];
			var sroff = tminrow - fminrow,
				scoff = tmincol - fmincol;
			var cellDataCache = {};
			store.walkRange([fromSpan, toSpan], function(rd) {
				var r = rd.data.row,
					c = rd.data.col;
				var cd = store.getCellProperty(rd.data.sheet, r, c, true);
				cellDataCache[rd.data.sheet + "-" + r + "-" + c] = cd;
			}, this);
			this.syncAutoExtendCdt(toSpan, fromSpan, oldCdt);
			var lookup = {},
				refs = [];
			var clearMove = function(callback, scope) {
				var toRange = new EnterpriseSheet.sheet.range.Range({
					sheet: me,
					coord: [toSpan]
				});
				toRange.clean(true, null, true);
				var arr = [];
				store.walkRange([fromSpan], function(rd) {
					var r = rd.data.row,
						c = rd.data.col;
					var i = r + sroff,
						j = c + scoff;
					var span = callback.call(scope, fsheet, r, c, tsheet, i, j);
					if(span) {
						arr.push(span);
					}
				}, scope);
				var fromRange = new EnterpriseSheet.sheet.range.Range({
					sheet: me,
					coord: [fromSpan]
				});
				toRange.coord = toRange.coord.concat(arr);
				fromRange.clean(true, toRange, true);
				if(0 < arr.length) {
					Ext.Msg.alert(SLANG.hint, SLANG.skip_process_action_on_disabled_cell);
				}
			};
			clearMove(function(fs, r, c, ts, i, j) {
				var cd = cellDataCache[fs + "-" + r + "-" + c],
					curCd = cellDataCache[ts + "-" + i + "-" + j];
				if((!curCd || !store.isDisabledForMe(curCd.dsd)) && (!cd || !store.isDisabledForMe(cd.dsd))) {
					cd = this.prepareForMoveCell(cd, ts, i, j, fs, r, c, lookup, "default", true);
					if(cd.cal && cd.refs) {
						refs = refs.concat(cd.refs);
					}
					if(!(fs === ts && r === i && c === j)) {
						store.setCell(ts, i, j, cd, null, true, "clear");
					}
				} else {
					if(store.isDisabledForMe(curCd.dsd)) {
						return [fs, r, c, r, c];
					}
				}
			}, this);
			if(EnterpriseSheet.sheet.range.Range.prototype.isCellCoord(coord)) {
				Ext.apply(changedHeights, this.checkAutoHeightForCoord(null, coord, false, true));
			}
			var reCals = this.getCalCdtCellsFromCoord([toSpan]);
			Ext.applyIf(reCalCells, reCals);
			if(0 < refs.length) {
				this.loadMask.show(SLANG.calculating, this.calMaskDelayTime);
				store.checkLoadCoord(refs, function() {
					var arr = refs.concat(coord);
					this.refreshRange(arr, reCalCells);
					this.loadMask.hide();
				}, this);
			} else {
				this.refreshRange(coord, reCalCells);
			}
			this.fireEvent("rangemove", range, this, reCalCells);
			if(removeAfterMove) {
				if("col" === removeAfterMove) {
					store.removeColumn(fromSpan[0], fromSpan[2], fromSpan[4]);
				} else if("row" === removeAfterMove) {
					store.removeRow(fromSpan[0], fromSpan[1], fromSpan[3]);
				} else if("cell" === removeAfterMove && sameSpan) {
					store.removeCell(fromSpan[0], fromSpan[1], fromSpan[3], fromSpan[2], fromSpan[4], "right" === insertDir ? "left" : "up");
				}
				this.fireEvent("moveforinsert", range, this);
			}
		}
	},
	createRangeStore: function(config) {
		config = config || {};
		var sm = this.getSelectionModel();
		var coordSpan = sm.selection2Span();
		var chartType = config.chartType;
		if("pie" === chartType) {
			if(coordSpan[1] === coordSpan[3]) {
				config.seriesPosition = "row";
			} else if(coordSpan[2] === coordSpan[4]) {
				config.seriesPosition = "col";
			} else {
				var rowSpan = coordSpan[3] - coordSpan[1] + 1,
					colSpan = coordSpan[4] - coordSpan[2] + 1;
				if(rowSpan > colSpan) {
					config.seriesPosition = "col";
				} else {
					config.seriesPosition = "row";
				}
			}
		}
		var store = new EnterpriseSheet.sheet.data.RangeStore(Ext.applyIf({
			sheet: this,
			coord: [coordSpan]
		}, config));
		return store;
	},
	onChartFocus: function(coordReference) {
		var rm = this.getReferenceModel();
		rm.enableSelect(undefined, undefined, undefined, undefined, true);
		rm.setReference(coordReference);
		rm.show();
	},
	afterLoad: function(store) {
		if(!this.getEl()) {
			this.on("afterrender", function() {
				this.afterLoad(store);
			}, this, {
				single: true
			});
			return;
		}
		var rm = this.getReferenceModel();
		rm.clearSelection();
		this.clearFloor(true, true);
		var sheetId = store.getActivedSheetId();
		this.setSheetId(sheetId);
		var needLayout = this.syncSheetFloating(true);
		this.refreshRange(null, true, true, function() {
			if(this.splitPos) {
				if(this.ulefter.isVisible()) {
					this.ulefter.getEl().setHeight(this.ulefter.getHeight());
				}
				if(this.ltregion.isVisible()) {
					this.ltregion.getEl().setHeight(this.ltregion.getHeight());
				}
				if(this.tregion.isVisible()) {
					this.tregion.getEl().setHeight(this.tregion.getHeight());
				}
			}
			if(needLayout) {
				if(Ext.isFunction(this.doLayout)) {
					this.doLayout();
				} else if(Ext.isFunction(this.updateLayout)) {
					this.updateLayout();
				}
			}
			this.syncPageBreak();
			this.refreshFocus();
			this.fireEvent("changing", this);
			this.setReadOnly(this.readOnly);
			this.fireEvent("afterloadsheet", store, this);
			this.processAfterLoadSheet();
		}, this);
	},
	processAfterLoadSheet: function() {
		this.loadMask.hide();
	},
	createChart: function(chartType, rangeStore, config, suspendEvent, suspendPulling) {
		if("column" == chartType) {
			return this.createColumnChart(rangeStore, config, suspendEvent, suspendPulling);
		} else if("area" == chartType) {
			return this.createAreaChart(rangeStore, config, suspendEvent, suspendPulling);
		} else if("pie" == chartType) {
			return this.createPieChart(rangeStore, config, suspendEvent, suspendPulling);
		} else if("line" == chartType) {
			return this.createLineChart(rangeStore, config, suspendEvent, suspendPulling);
		} else if("bar" == chartType) {
			return this.createBarChart(rangeStore, config, suspendEvent, suspendPulling);
		} else if("scatter" == chartType) {
			return this.createScatterChart(rangeStore, config, suspendEvent, suspendPulling);
		} else if("radar" == chartType) {
			return this.createRadarChart(rangeStore, config, suspendEvent, suspendPulling);
		}
	},
	createColumnChart: function(rangeStore, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatechart", "column", config, rangeStore, this)) {
				return;
			}
			this.fireEvent("preparecreatechart", "column", config, rangeStore, this);
		}
		if(!rangeStore) {
			rangeStore = this.createRangeStore();
		} else if(rangeStore.useAbs) {
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor("column", Ext.apply({
			sheet: this,
			store: rangeStore,
			x: x,
			y: y,
			width: width,
			height: height
		}, config), suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createchart", "column", chart, rangeStore, this);
		} else if(transfered) {
			this.fireEvent("floorresize", chart);
		}
		return chart;
	},
	createPieChart: function(rangeStore, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatechart", "pie", config, rangeStore, this)) {
				return;
			}
			this.fireEvent("preparecreatechart", "pie", config, rangeStore, this);
		}
		if(!rangeStore) {
			rangeStore = this.createRangeStore({
				useAbs: true,
				chartType: "pie"
			});
		} else if(!rangeStore.useAbs) {
			rangeStore.useAbs = true;
			rangeStore.regenerateData();
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor("pie", Ext.apply({
			sheet: this,
			store: rangeStore,
			x: x,
			y: y,
			width: width,
			height: height
		}, config), suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createchart", "pie", chart, rangeStore, this);
		} else if(transfered) {
			this.fireEvent("floorresize", chart);
		}
		return chart;
	},
	createAreaChart: function(rangeStore, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatechart", "area", config, rangeStore, this)) {
				return;
			}
			this.fireEvent("preparecreatechart", "area", config, rangeStore, this);
		}
		if(!rangeStore) {
			rangeStore = this.createRangeStore({
				useAbs: true
			});
		} else if(!rangeStore.useAbs) {
			rangeStore.useAbs = true;
			rangeStore.regenerateData();
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor("area", Ext.apply({
			sheet: this,
			store: rangeStore,
			x: x,
			y: y,
			width: width,
			height: height
		}, config), suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createchart", "area", chart, rangeStore, this);
		} else if(transfered) {
			this.fireEvent("floorresize", chart);
		}
		return chart;
	},
	createLineChart: function(rangeStore, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatechart", "line", config, rangeStore, this)) {
				return;
			}
			this.fireEvent("preparecreatechart", "line", config, rangeStore, this);
		}
		if(!rangeStore) {
			rangeStore = this.createRangeStore();
		} else if(rangeStore.useAbs) {
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor("line", Ext.apply({
			sheet: this,
			store: rangeStore,
			x: x,
			y: y,
			width: width,
			height: height
		}, config), suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createchart", "line", chart, rangeStore, this);
		} else if(transfered) {
			this.fireEvent("floorresize", chart);
		}
		return chart;
	},
	createBarChart: function(rangeStore, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatechart", "bar", config, rangeStore, this)) {
				return;
			}
			this.fireEvent("preparecreatechart", "bar", config, rangeStore, this);
		}
		if(!rangeStore) {
			rangeStore = this.createRangeStore();
		} else if(rangeStore.useAbs) {
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor("bar", Ext.apply({
			sheet: this,
			store: rangeStore,
			x: x,
			y: y,
			width: width,
			height: height
		}, config), suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createchart", "bar", chart, rangeStore, this);
		} else if(transfered) {
			this.fireEvent("floorresize", chart);
		}
		return chart;
	},
	createScatterChart: function(rangeStore, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatechart", "scatter", config, rangeStore, this)) {
				return;
			}
			this.fireEvent("preparecreatechart", "scatter", config, rangeStore, this);
		}
		if(!rangeStore) {
			rangeStore = this.createRangeStore();
		} else if(rangeStore.useAbs) {
			rangeStore.useAbs = false;
			rangeStore.regenerateData();
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor("scatter", Ext.apply({
			sheet: this,
			store: rangeStore,
			x: x,
			y: y,
			width: width,
			height: height
		}, config), suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createchart", "scatter", chart, rangeStore, this);
		} else if(transfered) {
			this.fireEvent("floorresize", chart);
		}
		return chart;
	},
	createRadarChart: function(rangeStore, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatechart", "radar", config, rangeStore, this)) {
				return;
			}
			this.fireEvent("preparecreatechart", "radar", config, rangeStore, this);
		}
		if(!rangeStore) {
			rangeStore = this.createRangeStore({
				useAbs: true
			});
		} else if(!rangeStore.useAbs) {
			rangeStore.useAbs = true;
			rangeStore.regenerateData();
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var chart = new EnterpriseSheet.sheet.floating.chart.ChartFloor("radar", Ext.apply({
			sheet: this,
			store: rangeStore,
			x: x,
			y: y,
			width: width,
			height: height
		}, config), suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createchart", "radar", chart, rangeStore, this);
		} else if(transfered) {
			if(typeof floor != "undefined") {
				this.fireEvent("floorresize", floor);
			}
		}
		return chart;
	},
	createWedgit: function(url, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatewedgit", url, config, this)) {
				return;
			}
			this.fireEvent("preparecreatewedgit", url, config, this);
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 400,
			height = 300,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var floor = new EnterpriseSheet.sheet.floating.wedgit.WedgitFloor(url, {
			sheet: this,
			sheetId: config.sheetId,
			floatingConfig: Ext.apply({
				x: x,
				y: y,
				width: width,
				height: height
			}, config)
		}, suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createwedgit", url, floor, this);
		} else if(transfered) {
			this.fireEvent("floorresize", floor);
		}
	},
	createPicture: function(url, config, suspendEvent, suspendPulling) {
		config = config || {};
		if(!suspendEvent) {
			if(false === this.fireEvent("beforecreatepicture", url, config, this)) {
				return;
			}
			this.fireEvent("preparecreatepicture", url, config, this);
		}
		var transfered = this.preparePicturePosition(config);
		var pos = this.cregion.getIfPosOfCenter(),
			width = 200,
			height = 200,
			x = pos.x - Math.floor(width / 2),
			y = pos.y - Math.floor(height / 2);
		var floor = new EnterpriseSheet.sheet.floating.picture.PictureFloor(url, {
			sheet: this,
			sheetId: config.sheetId,
			floatingConfig: Ext.apply({
				x: x,
				y: y,
				width: width,
				height: height
			}, config)
		}, suspendPulling);
		if(!suspendEvent) {
			this.fireEvent("createpicture", url, floor, this);
		} else if(transfered) {
			this.fireEvent("floorresize", floor);
		}
	},
	createInCellPicture: function(url) {
		var sm = this.getSelectionModel();
		var focusCell = sm.getFocusCell();
		if(focusCell) {
			var range = new EnterpriseSheet.sheet.range.Range({
				coord: [
					[this.getSheetId(), focusCell.row, focusCell.col, focusCell.row, focusCell.col]
				],
				sheet: this
			});
			range.setProperty({
				icp: url
			});
		}
	},
	preparePicturePosition: function(config) {
		var store = this.getStore();
		if(config && Ext.isDefined(config.sr)) {
			var sr = config.sr + 1,
				sc = config.sc + 1,
				er = config.er + 1,
				ec = config.ec + 1;
			var sx = config.sx,
				sy = config.sy,
				ex = config.ex,
				ey = config.ey;
			var sheetId = this.getSheetId();
			var w = store.getRangeWidth(sheetId, sc, ec - 1, undefined, true) - sx + ex;
			var h = store.getRangeHeight(sheetId, sr, er - 1, undefined, true) - sy + ey;
			var x = store.getRangeWidth(sheetId, 1, sc - 1, undefined, true) + sx;
			var y = store.getRangeHeight(sheetId, 1, sr - 1, undefined, true) + sy;
			w = store.zoomSize(w, true);
			h = store.zoomSize(h, true);
			x = store.zoomSize(x, true);
			y = store.zoomSize(y, true);
			delete config.sr;
			delete config.er;
			delete config.sc;
			delete config.ec;
			delete config.sx;
			delete config.sy;
			delete config.ex;
			delete config.ey;
			Ext.apply(config, {
				x: x,
				y: y,
				width: w,
				height: h
			});
			return true;
		} else {
			if(config.width) {
				config.width = store.zoomSize(config.width, true);
			}
			if(config.height) {
				config.height = store.zoomSize(config.height, true);
			}
			if(config.x) {
				config.x = store.zoomSize(config.x, true);
			}
			if(config.y) {
				config.y = store.zoomSize(config.y, true);
			}
		}
	},
	syncFloors: function(floors, action) {
		var store = this.getStore();
		if(!Ext.isArray(floors)) {
			floors = [floors];
		}
		if("remove" == action) {
			for(var i = 0, len = floors.length; i < len; i++) {
				var floor = floors[i];
				store.setFloatingItem(floor.sheetId, floor.getName(), "floor");
			}
		} else {
			for(var i = 0, len = floors.length; i < len; i++) {
				var floor = floors[i];
				if("function" == Ext.typeOf(floor.getFloorInfo)) {
					var json = Ext.encode(floor.getFloorInfo());
					store.setFloatingItem(floor.sheetId, floor.getName(), "floor", json);
				}
			}
		}
	},
	createCircleShape: function() {
		new EnterpriseSheet.sheet.floating.Floor({
			sheet: this,
			floatingConfig: {
				xtype: "drawcomponent",
				style: "cursor:default;",
				x: 100,
				y: 100,
				width: 110,
				height: 110,
				viewBox: false,
				items: [{
					type: "circle",
					fill: "#79BB3F",
					radius: 50,
					x: 50,
					y: 50
				}]
			}
		});
	},
	createHyperlink: function(url, sheetId, row, col) {
		if(!Ext.isDefined(sheetId)) {
			sheetId = this.getSheetId();
			var sm = this.getSelectionModel();
			var focusCell = sm.getFocusCell();
			row = focusCell.row;
			col = focusCell.col;
		}
		var store = this.getStore();
		var cell = store.getCell(sheetId, row, col);
		var md = {
			link: url,
			fm: "link"
		};
		if(SCOM.nullOrUndefined(cell.data)) {
			md.data = url;
			this.setCellData(sheetId, row, col, md);
		} else {
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: [
					[sheetId, row, col, row, col]
				]
			});
			range.setProperty(md);
		}
	},
	insertComment: function(comment, pos) {
		var coord;
		if(pos) {
			coord = [
				[pos.sheet, pos.row, pos.col, pos.row, pos.col]
			];
		} else {
			var sm = this.getSelectionModel();
			var focusCell = sm.getFocusCell();
			var sheetId = this.getSheetId();
			var row = focusCell.row,
				col = focusCell.col;
			coord = [
				[sheetId, row, col, row, col]
			];
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		range.setProperty({
			comment: comment
		});
	},
	deleteComment: function(coord, suspendRefresh, suspendEvent) {
		if(!coord) {
			var sm = this.getSelectionModel();
			coord = sm.selection2Coord();
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		range.setProperty(null, ["comment"], suspendRefresh, suspendEvent);
	},
	processCalculateException: function(e, scope) {
		var info = SCALEXP.getExceptionInfo(e);
		var html = "<div class=\"ss-exception-sign\" style=\"z-index:" + SCONST.CORNER_Z_INDEX + ";\"></div>";
		var title = info.title,
			msg = info.msg;
		var expTip = "<div class=\"ss-exception-title\">" + title + "</div>" + msg;
		return {
			data: info.code,
			ltcorner: html,
			expTip: expTip
		};
	},
	activeCoordSpan: function(coord, colorIndex) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			if(region.isVisible()) {
				var refModel = region.getReferenceModel();
				if(refModel) {
					refModel.activeCoordSpan(coord, colorIndex);
				}
			}
		}
	},
	deactiveCoordSpan: function(coord) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			if(region.isVisible()) {
				var refModel = region.getReferenceModel();
				if(refModel) {
					refModel.deactiveCoordSpan(coord);
				}
			}
		}
	},
	processColumnGroup: function(colData, sheetId, row, col) {
		if(this.colGroupLookup) {
			var groups = this.colGroupLookup[col];
			if(groups) {
				var arr = [],
					colorLen = SCOM.colors.length;
				for(var i in groups) {
					var obj = groups[i];
					var span = obj.span,
						level = obj.level;
					color = SCOM.colors[(level - 1) % colorLen];
					var min = col == span[0],
						max = col == span[1];
					var cls = min ? "ss-col-group-start" : max ? "ss-col-group-end" : "";
					if(obj.collapsed) {
						cls += " ss-collasped-group";
					}
					var html = SLAYOUT.group.apply({
						name: i,
						start: span[0],
						end: span[1],
						dir: "col",
						cls: cls,
						min: min,
						max: max,
						color: color,
						top: -this.groupOffset * level
					});
					arr.push(html);
				}
				colData.data += arr.join("");
			}
		}
	},
	processRowGroup: function(rowData, sheetId, row, col) {
		if(this.rowGroupLookup) {
			var groups = this.rowGroupLookup[row];
			if(groups) {
				var arr = [],
					colorLen = SCOM.colors.length;
				for(var i in groups) {
					var obj = groups[i];
					var span = obj.span,
						level = obj.level;
					var color = SCOM.colors[(level - 1) % colorLen];
					var min = row == span[0],
						max = row == span[1];
					var cls = min ? "ss-row-group-start" : max ? "ss-row-group-end" : "";
					if(obj.collapsed) {
						cls += " ss-collasped-group";
					}
					var html = SLAYOUT.group.apply({
						name: i,
						start: span[0],
						end: span[1],
						dir: "row",
						cls: cls,
						min: min,
						max: max,
						color: color,
						left: -this.groupOffset * level
					});
					arr.push(html);
				}
				rowData.data += arr.join("");
			}
		}
	},
	toggleGroupNo: function(dir, level, state) {
		var colorLen = SCOM.colors.length;
		var pnode;
		if("row" == dir) {
			pnode = this.getRowGroupPin().dom;
		} else {
			pnode = this.getColumnGroupPin().dom;
		}
		var len = pnode.childNodes.length;
		var noEl = Ext.get(pnode.childNodes[len - level]);
		if(state) {
			noEl.removeCls("ss-group-level-collapsed");
			for(var i = 0; i < len; i++) {
				var child = pnode.childNodes[i];
				var childEl = Ext.get(child);
				var color = SCOM.colors[(len - 1 - i) % colorLen];
				childEl.setStyle("color", "white");
				childEl.setStyle("border", "1px solid white");
				childEl.setStyle("background-color", color);
				if(child == noEl.dom) {
					break;
				}
				childEl.removeCls("ss-group-level-collapsed");
			}
		} else {
			noEl.addCls("ss-group-level-collapsed");
			for(var i = len - 1; 0 <= i; i--) {
				var child = pnode.childNodes[i];
				var childEl = Ext.get(child);
				var color = SCOM.colors[(len - 1 - i) % colorLen];
				childEl.setStyle("color", color);
				childEl.setStyle("border", "1px solid " + color);
				childEl.setStyle("background-color", "white");
				if(child == noEl.dom) {
					break;
				}
				childEl.addCls("ss-group-level-collapsed");
			}
		}
	},
	toggleGroupLevel: function(dir, level, state) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var action, reaction, update, event, oldGroups, oldLevels = this.getGroupLevel(dir);
		if("row" != dir) {
			dir = "col";
			update = "updateColumnGroups";
			action = state ? "showColumn" : "hideColumn";
			reaction = !state ? "showColumn" : "hideColumn";
			event = "togglecolgrouplevel";
			oldGroups = SCOM.copy(this.colGroups);
		} else {
			update = "updateRowGroups";
			action = state ? "showRow" : "hideRow";
			reaction = !state ? "showRow" : "hideRow";
			event = "togglerowgrouplevel";
			oldGroups = SCOM.copy(this.rowGroups);
		}
		this.toggleGroupNo(dir, level, state);
		var groups = this[dir + "Groups"],
			showns = {},
			hiddens = {};
		if(state) {
			var others = [];
			for(var i = 0, len = groups.length; i < len; i++) {
				var group = groups[i],
					span = group.span;
				if(group.level >= level) {
					delete group.collapsed;
					var arr = store[action](sheetId, span[0] + 1, span[1], true);
					for(var k = 0, size = arr.length; k < size; k++) {
						showns[arr[k]] = true;
					}
				} else {
					others.push(group);
				}
			}
			for(var i = 0, len = others.length; i < len; i++) {
				var group = others[i],
					span = group.span;
				group.collapsed = true;
				var arr = store[reaction](sheetId, span[0] + 1, span[1], true);
				for(var k = 0, size = arr.length; k < size; k++) {
					hiddens[arr[k]] = true;
				}
			}
		} else {
			var others = [];
			for(var i = 0, len = groups.length; i < len; i++) {
				var group = groups[i],
					span = group.span;
				if(group.level == level) {
					others.push(group);
				} else if(group.level > level) {
					delete group.collapsed;
					var arr = store[reaction](sheetId, span[0] + 1, span[1], true);
					for(var k = 0, size = arr.length; k < size; k++) {
						showns[arr[k]] = true;
					}
				}
			}
			for(var i = 0, len = others.length; i < len; i++) {
				var group = others[i],
					span = group.span;
				group.collapsed = true;
				var arr = store[action](sheetId, span[0] + 1, span[1], true);
				for(var k = 0, size = arr.length; k < size; k++) {
					hiddens[arr[k]] = true;
				}
			}
		}
		this[update]();
		this.refresh();
		this.syncPageBreak();
		var newGroups;
		if("row" == dir) {
			newGroups = this.updateRowGroups();
		} else {
			newGroups = this.updateColumnGroups();
		}
		var newLevels = this.getGroupLevel(dir);
		this.fireEvent(event, state, sheetId, showns, hiddens, oldGroups, newGroups, oldLevels, newLevels, this);
	},
	onClickInnerCt: function(e) {
		var rowGroup = e.getTarget(".ss-row-group", null, true);
		if(rowGroup) {
			var name = rowGroup.dom.getAttribute("data-name"),
				start = rowGroup.dom.getAttribute("data-start"),
				end = rowGroup.dom.getAttribute("data-end");
			start = Number(start);
			end = Number(end);
			this.toggleRowGroup(name, rowGroup.hasCls("ss-collasped-group"), [start, end], rowGroup.hasCls("ss-row-group-end"));
		} else {
			var colGroup = e.getTarget(".ss-col-group", null, true);
			if(colGroup) {
				var name = colGroup.dom.getAttribute("data-name"),
					start = colGroup.dom.getAttribute("data-start"),
					end = colGroup.dom.getAttribute("data-end");
				start = Number(start);
				end = Number(end);
				this.toggleColumnGroup(name, colGroup.hasCls("ss-collasped-group"), [start, end], colGroup.hasCls("ss-col-group-end"));
			} else {
				var rowGroupNo = e.getTarget(".ss-row-group-no", null, true);
				if(rowGroupNo) {
					var level = rowGroupNo.dom.getAttribute("data-level");
					level = Number(level);
					if(rowGroupNo.hasCls("ss-group-level-collapsed")) {
						this.toggleGroupLevel("row", level, true);
					} else {
						this.toggleGroupLevel("row", level, false);
					}
				} else {
					var colGroupNo = e.getTarget(".ss-col-group-no", null, true);
					if(colGroupNo) {
						var level = colGroupNo.dom.getAttribute("data-level");
						level = Number(level);
						if(colGroupNo.hasCls("ss-group-level-collapsed")) {
							this.toggleGroupLevel("col", level, true);
						} else {
							this.toggleGroupLevel("col", level, false);
						}
					}
				}
			}
		}
	},
	toggleRowGroup: function(name, expand, span, atEnd) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var oldRowGroups = SCOM.copy(this.rowGroups);
		var minrow = span[0],
			maxrow = span[1],
			pinrow;
		if(atEnd) {
			maxrow--;
			pinrow = span[1];
		} else {
			minrow++;
			pinrow = span[0];
		}
		var rows = [];
		if(expand) {
			var map = this.rowGroupNameMap;
			var found = map[name],
				level = found.level;
			this.updateGroupState("row", name, false);
			var groups = this.rowGroups;
			var others = [];
			for(var i = 0, len = groups.length; i < len; i++) {
				var group = groups[i],
					span = group.span;
				if(group.level < level && group.span[0] >= span[0] && span[1] >= group.span[1]) {
					others.push(group);
				}
			}
			store.showRow(sheetId, minrow, maxrow, true);
			var arr = [];
			for(var i = 0, len = others.length; i < len; i++) {
				var group = others[i],
					span = group.span;
				if(group.collapsed) {
					if(group.collapsed === span[0]) {
						start = span[0] + 1;
						end = span[1];
						arr.push([start, end]);
						store.hideRow(sheetId, start, end, true);
					} else {
						start = span[0];
						end = span[1] - 1;
						arr.push([start, end]);
						store.hideRow(sheetId, start, end, true);
					}
				}
			}
			arr.sort(function(a, b) {
				return a[0] - b[0];
			});
			var i = minrow;
			for(var k = 0, len = arr.length; k < len;) {
				var it = arr[k],
					min = it[0];
				while(i < min) {
					rows.push(i);
					i++;
				}
				i = it[1] + 1;
				k++;
			}
			while(i <= maxrow) {
				rows.push(i);
				i++;
			}
		} else {
			this.updateGroupState("row", name, pinrow);
			rows = store.hideRow(sheetId, minrow, maxrow, true);
		}
		var rowGroups = this.updateRowGroups();
		this.refresh();
		this.syncPageBreak();
		this.fireEvent("togglerowgroup", name, expand, sheetId, rows, oldRowGroups, rowGroups, this);
	},
	toggleColumnGroup: function(name, expand, span, atEnd) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var oldColGroups = SCOM.copy(this.colGroups);
		var mincol = span[0],
			maxcol = span[1],
			pincol;
		if(atEnd) {
			maxcol--;
			pincol = span[1];
		} else {
			mincol++;
			pincol = span[0];
		}
		var columns = [];
		if(expand) {
			var map = this.colGroupNameMap;
			var found = map[name],
				level = found.level;
			this.updateGroupState("col", name, false);
			var groups = this.colGroups;
			var others = [];
			for(var i = 0, len = groups.length; i < len; i++) {
				var group = groups[i],
					span = group.span;
				if(group.level < level && group.span[0] >= span[0] && span[1] >= group.span[1]) {
					others.push(group);
				}
			}
			store.showColumn(sheetId, mincol, maxcol, true);
			var arr = [];
			for(var i = 0, len = others.length; i < len; i++) {
				var group = others[i],
					span = group.span;
				if(group.collapsed) {
					if(group.collapsed === span[0]) {
						start = span[0] + 1;
						end = span[1];
						arr.push([start, end]);
						store.hideColumn(sheetId, start, end, true);
					} else {
						start = span[0];
						end = span[1] - 1;
						arr.push([start, end]);
						store.hideColumn(sheetId, start, end, true);
					}
				}
			}
			arr.sort(function(a, b) {
				return a[0] - b[0];
			});
			var i = mincol;
			for(var k = 0, len = arr.length; k < len;) {
				var it = arr[k],
					min = it[0];
				while(i < min) {
					columns.push(i);
					i++;
				}
				i = it[1] + 1;
				k++;
			}
			while(i <= maxcol) {
				columns.push(i);
				i++;
			}
		} else {
			this.updateGroupState("col", name, pincol);
			columns = store.hideColumn(sheetId, mincol, maxcol, true);
		}
		var colGroups = this.updateColumnGroups();
		this.refresh();
		this.syncPageBreak();
		this.fireEvent("togglecolgroup", name, expand, sheetId, columns, oldColGroups, colGroups, this);
	},
	updateGroupState: function(dir, name, collapsed) {
		if("row" !== dir) {
			dir = "col";
		}
		var map = this[dir + "GroupNameMap"];
		if(map && map[name]) {
			map[name].collapsed = collapsed;
		}
	},
	add2Groups: function(dir, group, setFlag) {
		var name;
		if(group) {
			name = group.span.join("$");
			if("row" !== dir) {
				dir = "col";
			}
			var groups = this[dir + "Groups"] || [];
			groups.push(group);
			this[dir + "Groups"] = groups;
		}
		if(setFlag) {
			if("row" == dir) {
				this.setRowGroups(this.rowGroups);
			} else {
				this.setColumnGroups(this.colGroups);
			}
		}
		return name;
	},
	removeFromGroups: function(dir, removes, setFlag) {
		var groups = this[dir + "Groups"];
		if(groups) {
			for(var name in removes) {
				if(removes.hasOwnProperty(name)) {
					for(var i = 0, len = groups.length; i < len; i++) {
						var group = groups[i];
						if(group.span.join("$") == name) {
							groups.splice(i, 1);
							break;
						}
					}
				}
			}
			if(0 == groups.length) {
				delete this[dir + "Groups"];
			}
		}
		if(setFlag) {
			if("row" == dir) {
				this.setRowGroups(this.rowGroups);
			} else {
				this.setColumnGroups(this.colGroups);
			}
		}
	},
	clearGroups: function(dir, setFlag) {
		delete this[dir + "Groups"];
		if(setFlag) {
			if("row" == dir) {
				this.setRowGroups(this.rowGroups);
			} else {
				this.setColumnGroups(this.colGroups);
			}
		}
	},
	prepareGroupForAdd: function(dir, start, end) {
		var maps = this[dir + "GroupLookup"],
			lookup = this[dir + "GroupNameMap"],
			maxLevel = this[dir + "GroupMaxLevel"];
		if(maps) {
			var levels = {};
			for(var i = start; i <= end; i++) {
				var groups = maps[i];
				if(groups) {
					for(var j in groups) {
						var group = groups[j],
							span = group.span,
							level = group.level;
						levels[level] = levels[level] || {};
						levels[level][j] = group;
					}
				}
			}
			var flag = false,
				included = false,
				level = 1,
				removes = {},
				includes = {};
			for(var i = maxLevel; 1 <= i; i--) {
				var line = levels[i];
				if(line) {
					for(var n in line) {
						var group = line[n],
							span = group.span,
							name = n;
						if(span[0] == start && end == span[1]) {
							return;
						} else if(span[0] <= start && end <= span[1]) {
							break;
						} else if(span[0] >= start && end >= span[1]) {
							if(!flag) {
								included = true;
								level = i + 1;
								flag = true;
								includes[name] = true;
							} else {
								removes[name] = true;
							}
						} else if(span[0] <= start && start <= span[1]) {
							level = i;
							included = false;
							flag = true;
							start = span[0];
							if(span[1] > end) {
								end = span[1];
							}
							removes[name] = true;
						} else if(span[0] <= end && end <= span[1]) {
							level = i;
							included = false;
							flag = true;
							end = span[1];
							if(span[0] < start) {
								start = span[0];
							}
							removes[name] = true;
						} else {
							level = i;
							flag = true;
							included = false;
						}
					}
				} else {
					level = i;
					flag = true;
					break;
				}
				if(flag) {
					break;
				}
			}
			if(flag) {
				if(included) {
					var min = maxLevel,
						max = 0,
						stopFlag, tmpSet = {};
					for(var i = start; i <= end; i++) {
						var obj = maps[i];
						for(var p in obj) {
							var group = obj[p],
								lv = group.level;
							tmpSet[p] = group;
							if(lv < min) {
								min = lv;
							}
							if(lv > max) {
								max = lv;
							}
							if(maxLevel == max - min + 1) {
								stopFlag = true;
								break;
							}
						}
						if(stopFlag) {
							break;
						}
					}
					if(stopFlag) {
						var buts = {};
						for(var k = 1; k < level; k++) {
							var line = levels[k];
							if(line) {
								for(var m in line) {
									buts[m] = line[m];
								}
							}
						}
						for(var name in lookup) {
							if(!buts[name]) {
								lookup[name].level++;
							}
						}
					} else {
						level--;
						for(var p in tmpSet) {
							if(level >= tmpSet[p].level) {
								tmpSet[p].level--;
							}
						}
					}
				} else {
					Ext.apply(removes, includes);
				}
				return {
					group: {
						level: level,
						span: [start, end]
					},
					removes: removes
				};
			} else {
				var group = {
					level: 1,
					span: [start, end]
				};
				var groups = this[dir + "Groups"];
				for(var i = 0, len = groups.length; i < len; i++) {
					groups[i].level++;
				}
				return {
					group: group
				};
			}
		} else {
			return {
				group: {
					level: 1,
					span: [start, end]
				}
			};
		}
	},
	prepareGroupForCancel: function(dir, start, end) {
		var maps = this[dir + "GroupLookup"],
			maxLevel = this[dir + "GroupMaxLevel"];
		if(maps) {
			var levels = {};
			for(var i = start; i <= end; i++) {
				var groups = maps[i];
				if(groups) {
					for(var j in groups) {
						var group = groups[j],
							span = group.span,
							level = group.level;
						levels[level] = levels[level] || {};
						levels[level][j] = group;
					}
				}
			}
			var removes = {},
				flag = false,
				level;
			for(var i = 1; i <= maxLevel; i++) {
				if(flag) {
					break;
				}
				level = i;
				var line = levels[i];
				if(line) {
					for(var name in line) {
						var group = line[name],
							span = group.span;
						if(start <= span[0] && end >= span[1] || span[0] <= start && start <= span[1] || span[0] <= end && end <= span[1]) {
							flag = true;
							removes[name] = true;
						}
					}
				}
			}
			var nameMaps = this[dir + "GroupNameMap"],
				left = false;
			for(var name in nameMaps) {
				var group = nameMaps[name];
				if(group.level == level && !removes[name]) {
					left = true;
					break;
				}
			}
			if(!left) {
				for(var name in nameMaps) {
					var group = nameMaps[name];
					if(group.level > level) {
						group.level--;
					}
				}
			}
			return {
				removes: removes
			};
		}
	},
	prepareGroupForSpan: function(dir, action, start, end) {
		if("cancel" == action) {
			return this.prepareGroupForCancel(dir, start, end);
		} else {
			return this.prepareGroupForAdd(dir, start, end);
		}
	},
	getGroupsByIndex: function(dir, index) {
		var maps = this[dir + "GroupLookup"];
		if(maps) {
			return maps[index];
		}
	},
	isSelectedGroup: function(dir) {
		var sm = this.getSelectionModel();
		var span = sm.selection2Span();
		if("row" == dir) {
			if(this.rowGroupLookup) {
				var minrow = span[1],
					maxrow = span[3];
				for(var i = minrow; i <= maxrow; i++) {
					var groups = this.rowGroupLookup[i];
					if(groups && !SCOM.isEmptyObj(groups)) {
						return true;
					}
				}
			}
		} else {
			if(this.colGroupLookup) {
				var mincol = span[2],
					maxcol = span[4];
				for(var i = mincol; i <= maxcol; i++) {
					var groups = this.colGroupLookup[i];
					if(groups && !SCOM.isEmptyObj(groups)) {
						return true;
					}
				}
			}
		}
		return false;
	},
	addGroupForSelection: function() {
		this.updateGroupForSelection();
	},
	cancelGroupForSelection: function() {
		this.updateGroupForSelection("cancel");
	},
	updateGroupForSelection: function(action) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var sm = this.getSelectionModel();
		var span = sm.selection2Span();
		if(0 == span[1]) {
			this.updateColGroup(action, span[2], span[4]);
		} else if(0 == span[2]) {
			this.updateRowGroup(action, span[1], span[3]);
		}
	},
	applyGroups: function(groups, suspendUpdateStore) {
		var store = this.getStore(),
			curSheetId = this.getSheetId(),
			needLayout;
		var oldMaxLevel = this.rowGroupMaxLevel;
		var oldMaxLevel = this.colGroupMaxLevel;
		var oldRowGroups = SCOM.copy(this.rowGroups);
		var oldColGroups = SCOM.copy(this.colGroups);
		for(var i = 0, len = groups.length; i < len; i++) {
			var it = groups[i];
			var dir = it.dir,
				sheetId = Ext.isDefined(it.sheetId) ? it.sheetId : curSheetId;
			var startIndex = it.start,
				endIndex = it.end,
				action = it.action;
			if("row" === dir) {
				var obj = this.prepareGroupForSpan("row", action, startIndex, endIndex);
				if(obj) {
					this.removeFromGroups("row", obj.removes);
					this.add2Groups("row", obj.group, true);
					this.updateRowGroups(suspendUpdateStore);
					if(!needLayout) {
						needLayout = oldMaxLevel != this.colGroupMaxLevel;
					}
				}
			} else {
				var obj = this.prepareGroupForSpan("col", action, startIndex, endIndex);
				if(obj) {
					this.removeFromGroups("col", obj.removes);
					this.add2Groups("col", obj.group, true);
					this.updateColumnGroups(suspendUpdateStore);
					if(!needLayout) {
						needLayout = oldMaxLevel != this.rowGroupMaxLevel;
					}
				}
			}
		}
		this.refresh();
		if(needLayout) {
			if(Ext.isFunction(this.doLayout)) {
				this.doLayout();
			} else if(Ext.isFunction(this.updateLayout)) {
				this.updateLayout();
			}
		}
		var rowGroups = SCOM.copy(this.rowGroups);
		var colGroups = SCOM.copy(this.colGroups);
		this.fireEvent("updategroups", sheetId, oldRowGroups, oldColGroups, rowGroups, colGroups, this);
	},
	updateColGroup: function(action, mincol, maxcol, suspendUpdateStore) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var oldMaxLevel = this.colGroupMaxLevel;
		var oldColGroups = SCOM.copy(this.colGroups);
		var obj = this.prepareGroupForSpan("col", action, mincol, maxcol);
		if(obj) {
			this.removeFromGroups("col", obj.removes);
			this.add2Groups("col", obj.group, true);
			var colGroups = this.updateColumnGroups(suspendUpdateStore);
			this.refresh();
			this.fireEvent("changegroup", "col", sheetId, oldColGroups, colGroups, this);
			if(oldMaxLevel != this.colGroupMaxLevel) {
				if(Ext.isFunction(this.doLayout)) {
					this.doLayout();
				} else if(Ext.isFunction(this.updateLayout)) {
					this.updateLayout();
				}
			}
		}
	},
	updateRowGroup: function(action, minrow, maxrow, suspendUpdateStore) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var oldMaxLevel = this.rowGroupMaxLevel;
		var oldRowGoups = SCOM.copy(this.rowGroups);
		var obj = this.prepareGroupForSpan("row", action, minrow, maxrow);
		if(obj) {
			this.removeFromGroups("row", obj.removes);
			this.add2Groups("row", obj.group, true);
			var rowGroups = this.updateRowGroups(suspendUpdateStore);
			this.refresh();
			this.fireEvent("changegroup", "row", sheetId, oldRowGoups, rowGroups, this);
			if(oldMaxLevel != this.rowGroupMaxLevel) {
				if(Ext.isFunction(this.doLayout)) {
					this.doLayout();
				} else if(Ext.isFunction(this.updateLayout)) {
					this.updateLayout();
				}
			}
		}
	},
	onFloorMoveResize: function(floor) {
		this.syncFloors(floor, "update");
	},
	onRangeStoreCoordChange: function(rangeStore) {
		var floorSet = this.getFloorSet();
		var relatedFloors = [];
		for(var p in floorSet) {
			var floor = floorSet[p];
			if("function" == Ext.typeOf(floor.getRangeStore)) {
				if(floor.getRangeStore() == rangeStore) {
					relatedFloors.push(floor);
				}
			}
		}
		if(0 < relatedFloors.length) {
			this.syncFloors(relatedFloors, "update");
		}
	},
	onChartChange: function(chartFloor) {
		this.syncFloors(chartFloor, "update");
	},
	changeSheetOrder: function(preIndex, curIndex, callback, scope) {
		this.getStore().changeSheetOrder(preIndex, curIndex, callback, scope);
	},
	focus: function(delay) {
		this.getEditor().focus(delay);
	},
	onPrepareAutofill: function(sm) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			var selModel = region.getSelectionModel();
			if(selModel != sm) {
				selModel.prepareForAutofill(true);
			}
		}
	},
	onResetAutofill: function(sm) {
		for(var i = 0, len = this.regionLookup.length; i < len; i++) {
			var region = this[this.regionLookup[i]];
			var selModel = region.getSelectionModel();
			if(selModel != sm) {
				selModel.resetAutofill(true);
			}
		}
	},
	setItemForSelection: function(itemType, itemName) {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		var modified = {
			it: itemType || "",
			itn: itemName || "",
			itchk: false
		};
		range.setProperty(modified);
	},
	clearItemForSelection: function() {
		var sm = this.getSelectionModel();
		var coord = sm.selection2Coord();
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		range.setProperty({
			it: "",
			itn: ""
		}, ["itchk"]);
	},
	onClickCellItem: function(tagName, target, rowCol, region) {
		if("INPUT" == tagName) {
			this.fireEvent("prepareclickitem", tagName, target, rowCol, this);
			target = Ext.get(target);
			var checked = target.getAttribute("checked");
			var row = rowCol[0],
				col = rowCol[1];
			var sheetId = this.getSheetId(),
				store = this.getStore();
			var cell = this.getCellProperty(sheetId, row, col);
			var itemType = cell.it,
				itemName = cell.itn,
				itchk = cell.itchk;
			if(this.isReadOnly()) {
				if(itchk) {
					target.dom.checked = "checked";
				} else {
					target.dom.checked = "";
				}
				return;
			}
			var coord;
			if("radio" == itemType) {
				var arr = [
					[sheetId, row, col, row, col]
				];
				store.walkRange([
					[sheetId, 0, 0, 0, 0]
				], function(rd) {
					var r = rd.data.row,
						c = rd.data.col;
					var cell = this.getCellProperty(rd.data.sheet, r, c);
					if(itemName == cell.itn && cell.itchk && itemType == cell.it && !(row == r && col == c)) {
						arr.push([rd.data.sheet, r, c, r, c]);
					}
				}, this, true);
				coord = arr;
			} else {
				coord = [
					[sheetId, row, col, row, col]
				];
			}
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: coord
			});
			if(checked) {
				if("radio" == itemType) {
					range.toggleItemCheck(sheetId, row, col);
				} else if("checkbox" === itemType) {
					store.setCell(sheetId, row, col, {
						itchk: true
					});
				} else {
					range.setProperty({
						itchk: true
					});
				}
			} else {
				if("checkbox" === itemType) {
					store.setCell(sheetId, row, col, undefined, ["itchk"]);
				} else {
					range.setProperty(null, ["itchk"]);
				}
			}
		} else if("BUTTON" == tagName) {
			this.fireEvent("prepareclickitem", tagName, target, rowCol, this);
			var row = rowCol[0],
				col = rowCol[1];
			var sheetId = this.getSheetId(),
				store = this.getStore();
			var cell = store.getCellProperty(sheetId, row, col);
			if(cell.onBtnClickFn) {
				this.onCellEventCallback("onBtnClickFn", sheetId, row, col);
			}
		} else if("TRIGGER" == tagName) {
			var row = rowCol[0],
				col = rowCol[1];
			var sheetId = this.getSheetId();
			this.fireEvent("clickcelltrigger", sheetId, row, col, region, this, target);
		}
	},
	beforeCellMouseDown: function(row, col, region, e) {
		var xy = e.getXY(),
			store = this.getStore();
		var cell = store.getCell(this.getSheetId(), row, col);
		if(Ext.isDefined(cell.minrow)) {
			row += cell.minrow;
			col += cell.mincol;
		}
		var cellEl = region.getCellEl(row, col);
		if(cellEl) {
			var inputEl = cellEl.down("input"),
				buttonEl = cellEl.down("button"),
				triggerEl = cellEl.down(".ss-trigger");
			if(inputEl) {
				var left = inputEl.getLeft(),
					top = inputEl.getTop(),
					right = inputEl.getRight(),
					bottom = inputEl.getBottom();
				var x = xy[0],
					y = xy[1];
				if(left <= x && x <= right && top <= y && y <= bottom) {
					if(inputEl.getAttribute("checked") && "checkbox" === inputEl.dom.type) {
						inputEl.dom.checked = "";
					} else {
						inputEl.dom.checked = "checked";
					}
					this.onClickCellItem("INPUT", inputEl, [row, col], region);
					return false;
				}
			}
			if(buttonEl) {
				var left = buttonEl.getLeft(),
					top = buttonEl.getTop(),
					right = buttonEl.getRight(),
					bottom = buttonEl.getBottom();
				var x = xy[0],
					y = xy[1];
				if(left <= x && x <= right && top <= y && y <= bottom) {
					this.onClickCellItem("BUTTON", buttonEl, [row, col], region);
					return false;
				}
			}
			if(triggerEl) {
				var left = triggerEl.getLeft(),
					top = triggerEl.getTop(),
					right = triggerEl.getRight(),
					bottom = triggerEl.getBottom();
				var x = xy[0],
					y = xy[1];
				if(left <= x && x <= right && top <= y && y <= bottom) {
					this.onClickCellItem("TRIGGER", triggerEl, [row, col], region);
					return false;
				}
			}
		}
	},
	onCellMouseDown: function(row, col, region, e) {
		var sm = region.getSelectionModel();
		if(!sm.disabled) {
			if(0 == row && 0 == col) {
				if(this.ltregion.isVisible()) {
					region = this.ltregion;
				} else if(this.tregion.isVisible()) {
					region = this.tregion;
				} else if(this.lregion.isVisible()) {
					region = this.lregion;
				} else {
					region = this.cregion;
				}
				row = region.rowStart;
				col = region.colStart;
			} else if(0 == row) {
				if(this.ltregion.isVisible()) {
					region = this.ltregion;
				} else if(this.lregion.isVisible()) {
					region = this.lregion;
				} else {
					region = this.cregion;
				}
				row = region.rowStart;
			} else if(0 == col) {
				if(this.ltregion.isVisible()) {
					region = this.ltregion;
				} else if(this.tregion.isVisible()) {
					region = this.lregion;
				} else {
					region = this.cregion;
				}
				col = region.colStart;
			}
			sm.setFocusCell(row, col);
			this.onCellEventCallback("onCellMouseDownFn", region.getSheetId(), row, col);
		}
	},
	onColumnResized: function(col, old, cur) {
		var mincol = false,
			maxcol = false,
			relatedRows = {};
		var sheetId = this.getSheetId();
		for(var p in cur) {
			if(cur.hasOwnProperty(p)) {
				var col = Number(p);
				if(Ext.isNumber(col)) {
					Ext.apply(relatedRows, this.getRelatedRowsForAutoHeight([
						[sheetId, 0, col, 0, col]
					]));
				}
			}
		}
		var changedHeights = this.checkAutoHeightForRows(relatedRows);
		this.syncPageBreak();
		this.fireEvent("aftercolumnresized", col, old, cur, changedHeights, this);
	},
	onRowResized: function() {
		this.syncPageBreak();
	},
	onSelectedColumnResized: function(w, mincol, maxcol) {
		w = this.getStore().unzoomSize(w, true);
		this.setColumnWidth(w, {
			mincol: mincol,
			maxcol: maxcol
		});
		this.syncPageBreak();
		return false;
	},
	onSelectedRowResized: function(h, minrow, maxrow) {
		h = this.getStore().unzoomSize(h, true);
		this.setRowHeight(h, {
			minrow: minrow,
			maxrow: maxrow
		});
		this.syncPageBreak();
		return false;
	},
	getRelatedRowsForAutoHeight: function(coord, modified, deleted, checkNoWrap, skipDefaultHeight) {
		var store = this.getStore();
		var dh = store.defaultProperty.height;
		if(!modified && !deleted || modified && (modified.fz || modified.ws) || deleted && (-1 != Ext.Array.indexOf(deleted, "fz") || -1 != Ext.Array.indexOf(deleted, "ws"))) {
			var relatedRows = {};
			store.walkRange(coord, function(rec) {
				var sheetId = rec.data.sheet,
					row = rec.data.row,
					col = rec.data.col;
				if(0 !== row && 0 !== col) {
					var id = sheetId + "-" + row;
					var rowPro = store.getCellProperty(sheetId, row, 0);
					if(!relatedRows[id]) {
						if(!SCOM.canbeNumber(rowPro.height)) {
							var autoHeight = Number(rowPro.autoHeight);
							if(!skipDefaultHeight || Ext.isNumber(autoHeight) && autoHeight > dh) {
								if(!checkNoWrap) {
									var cellPro = store.getCellProperty(sheetId, row, col);
									if("normal" == cellPro.ws) {
										relatedRows[id] = {
											sheetId: sheetId,
											row: row,
											autoHeight: rowPro.autoHeight
										};
									}
								} else {
									relatedRows[id] = {
										sheetId: sheetId,
										row: row,
										autoHeight: rowPro.autoHeight
									};
								}
							}
						}
					}
				}
			}, this, true);
			return relatedRows;
		}
	},
	checkAutoHeightForRows: function(relatedRows, suspendRefresh) {
		var store = this.getStore(),
			dh = store.defaultProperty.height;
		var oldHeights = {},
			newHeights = {},
			minRow = false;
		for(var p in relatedRows) {
			if(relatedRows.hasOwnProperty(p)) {
				var it = relatedRows[p];
				var oldHeight;
				if(SCOM.nullOrUndefined(it.autoHeight) || "" === it.autoHeight) {
					oldHeight = dh;
				} else {
					oldHeight = it.autoHeight;
				}
				var h = this.cregion.guessMaxRowHeight(it.sheetId, it.row);
				var isNum = Ext.isNumber(h);
				if(h !== oldHeight) {
					var id = it.sheetId + "-" + it.row;
					oldHeights[id] = {
						sheetId: it.sheetId,
						row: it.row,
						ah: oldHeight
					};
					newHeights[id] = {
						sheetId: it.sheetId,
						row: it.row,
						ah: h
					};
					if(false === minRow || minRow > it.row) {
						minRow = it.row;
					}
					if(isNum) {
						store.setRow(it.sheetId, it.row, {
							autoHeight: h
						}, null, true, suspendRefresh, null, true);
					} else {
						store.setRow(it.sheetId, it.row, null, ["autoHeight"], true, suspendRefresh, null, true);
					}
				}
			}
		}
		if(this.isFreezed()) {
			if(minRow <= this.freezePos.row) {
				this.onUpperRowResize();
			}
		}
		return {
			oldHeights: oldHeights,
			newHeights: newHeights
		};
	},
	checkAutoHeightForCoord: function(avoidCoord, coord, suspendRefresh, checkNoWrap, skipDefaultHeight) {
		var relatedRows = {};
		var store = this.getStore();
		var dh = store.defaultProperty.height;
		store.walkRange(coord, function(rec) {
			var sheetId = rec.data.sheet,
				row = rec.data.row,
				col = rec.data.col;
			if(!avoidCoord || !EnterpriseSheet.sheet.range.Range.prototype.isIncluded(sheetId, row, col, avoidCoord)) {
				if(0 !== row && 0 !== col) {
					var id = sheetId + "-" + row;
					var rowPro = store.getCellProperty(sheetId, row, 0);
					if(!SCOM.canbeNumber(rowPro.height)) {
						var autoHeight = Number(rowPro.autoHeight);
						if(!skipDefaultHeight || Ext.isNumber(autoHeight) && autoHeight > dh) {
							if(!checkNoWrap) {
								var cellPro = store.getCellProperty(sheetId, row, col);
								if("normal" == cellPro.ws) {
									relatedRows[id] = {
										sheetId: sheetId,
										row: row,
										autoHeight: rowPro.autoHeight
									};
								}
							} else {
								relatedRows[id] = {
									sheetId: sheetId,
									row: row,
									autoHeight: rowPro.autoHeight
								};
							}
						}
					}
				}
			}
		});
		return this.checkAutoHeightForRows(relatedRows, suspendRefresh);
	},
	adjusAutotHeightForColumn: function(sheetId, mincol, maxcol, suspendRefresh, checkNoWrap, skipDefaultHeight) {
		return this.checkAutoHeightForCoord(null, [
			[sheetId, 0, mincol, 0, maxcol]
		], suspendRefresh, checkNoWrap, skipDefaultHeight);
	},
	markSelection: function() {
		var me = this,
			store = me.getStore();
		var refs = store.getNamedFuncConfig();
		var sm = me.getSelectionModel(),
			calculate = me.getCalculate();
		var coord = sm.selection2Coord();
		SPOP.showReferenceNameBox({
			sheet: this,
			title: SLANG.define_reference,
			fieldLabel: SLANG.input_reference_name,
			refList: refs,
			refValue: coord,
			applyCallback: {
				fn: function(name, val, ctype, scope, comment) {
					this.updateNamedFunc(name, val, scope, comment);
				},
				scope: this
			},
			deleteCallback: {
				fn: function(ctype, name, scope) {
					this.deleteNamedFunc(name, scope);
				},
				scope: this
			},
			checkValid: function(win) {
				var name = win.nameField.getValue();
				var calculate = me.calculate;
				if(name && calculate) {
					var cals = calculate.calculates;
					var upper = name.toUpperCase();
					var lower = name.toLowerCase();
					if(cals[upper] || cals[lower]) {
						Ext.Msg.alert(SLANG.hint, SLANG.name_repeated_with_calculate);
						return false;
					} else {
						var str2Coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(upper);
						if(-1 != upper.indexOf(" ") || Ext.isNumber(Number(upper)) || !/^[a-zA-Z_]/.test(upper) || 0 < str2Coord.length) {
							Ext.Msg.alert(SLANG.hint, SLANG.reference_name_invalid);
							return false;
						}
					}
				}
				return true;
			}
		});
	},
	showLinkKit: function(pos, cd) {
		var kitOffset = this.kitOffset;
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var x = store.getRangeWidth(sheetId, 1, pos.col - 1, undefined, true);
		var y = store.getRangeHeight(sheetId, 1, pos.row, undefined, true);
		if(kitOffset) {
			x += kitOffset[0];
			y += kitOffset[1];
		}
		var linkRef = store.getCellLink(cd);
		var link = SLANG.go_to_link + ": <a href=\"" + linkRef + "\" target=\"_blank\" class=\"ss-cell-link\">" + linkRef + "</a>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"ss-link-remove\">" + SLANG.remove + "</span>";
		if(!this.linkKit) {
			this.linkKit = new EnterpriseSheet.sheet.floating.Floor({
				sheet: this,
				localKit: true,
				floatingConfig: {
					xtype: "component",
					cls: "ss-link-kit",
					html: link,
					x: x,
					y: y,
					ddConfig: false,
					resizeConfig: false,
					destroyMenu: false,
					listeners: {
						afterrender: {
							fn: function(comp) {
								var el = comp.getEl();
								this.mon(el, "click", this.clickLinkKit, this);
							},
							scope: this
						}
					}
				}
			});
		} else {
			this.linkKit.eachFloating(function(comp) {
				comp.update(link);
			}, this);
			this.registerFloor(this.linkKit, true);
			this.linkKit.setXY([x, y]);
			this.linkKit.show();
		}
	},
	hideLinkKit: function() {
		if(this.linkKit && !this.suspendHideFlag) {
			this.linkKit.destroy();
			delete this.linkKit;
		}
	},
	clickLinkKit: function(e) {
		var target = e.getTarget("span.ss-link-remove");
		if(target) {
			var sm = this.getSelectionModel(),
				sheetId = this.getSheetId();
			var focusCell = sm.getFocusCell();
			var row = focusCell.row,
				col = focusCell.col;
			var range = new EnterpriseSheet.sheet.range.Range({
				sheet: this,
				coord: [
					[sheetId, row, col, row, col]
				]
			});
			range.setProperty(null, ["link"]);
			this.refreshFocus(row, col);
		} else {
			target = e.getTarget("a.ss-cell-link");
			if(target) {
				var val = target.innerHTML;
				if(!val || 0 !== val.indexOf("http://")) {
					e.stopEvent();
					this.go2CoordSpan(val);
				}
			}
		}
	},
	go2CoordSpan: function(val) {
		try {
			var me = this,
				store = me.getStore();
			if(val.indexOf("http") == -1) {
				var refConfigs = store.getNamedFuncConfig();
				for(var i = 0, len = refConfigs.length; i < len; i++) {
					var it = refConfigs[i];
					if(it.name == val && it.ctype == "named_func") {
						var json = Ext.decode(it.json);
						val = json[0].cal;
						break;
					}
				}
			}
			var coord = EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(val);
			if(0 < coord.length) {
				var span = coord[0].span,
					store = this.getStore();
				var sheetId = this.getSheetId(),
					curSheetId = sheetId;
				if("" !== span[0]) {
					sheetId = store.getSheetIdByName(span[0]);
				}
				if(Ext.isDefined(sheetId)) {
					if(sheetId === curSheetId) {
						this.go2Pos(span[1], span[2]);
					} else {
						this.go2Sheet(sheetId, function() {
							this.go2Pos(span[1], span[2]);
						}, this);
					}
				}
				return true;
			}
		} catch(e) {}
	},
	onCellMouseMove: function(row, col, region, e) {
		this.anchorTipForCell(row, col, region);
		this.showCellCustomBindingData(row, col, region);
		this.onCellEventCallback("onCellMouseMoveFn", region.getSheetId(), row, col);
	},
	anchorTipForCell: function(row, col, region) {
		var store = this.getStore();
		var sheetId = this.getSheetId();
		var cd = this.getCellData(sheetId, row, col);
		var cellEl, comment = cd.comment,
			commentDecorate = cd.commentStyle;
		if(comment) {
			var pos = this.commentTip.currentPos;
			var curPos = {
				sheet: sheetId,
				row: row,
				col: col
			};
			this.commentTip.currentPos = curPos;
			this.commentTip.comment = comment;
			if(!this.commentTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)) {
				cellEl = region.getCellEl(row, col);
				this.commentTip.showBy(cellEl);
				if(commentDecorate && commentDecorate == "b") {
					comment = "<b>" + comment + "</b>";
				} else if(commentDecorate && commentDecorate == "u") {
					comment = "<u>" + comment + "</u>";
				} else if(commentDecorate && commentDecorate == "i") {
					comment = "<i>" + comment + "</i>";
				}
				this.commentTip.updateComment(comment);
			}
		} else {
			this.commentTip.hide();
		}
		if(cd.commentEdit == "hide") {
			this.commentTip.hideBtn();
		} else if(comment) {
			this.commentTip.showBtn();
		}
		var vname = cd.vname,
			vnameEdit = cd.vnameEdit;
		if(vname && "hide" !== vnameEdit) {
			var pos = this.variableTip.currentPos;
			var curPos = {
				sheet: sheetId,
				row: row,
				col: col
			};
			this.variableTip.currentPos = curPos;
			this.variableTip.vname = vname;
			if(!this.variableTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)) {
				cellEl = region.getCellEl(row, col);
				if(this.commentTip.isVisible()) {
					this.variableTip.showBy(this.commentTip.getEl(), "tl-bl?");
				} else {
					this.variableTip.showBy(cellEl);
				}
				this.variableTip.updateContent(vname);
			}
		} else {
			this.variableTip.hide();
		}
		if(cd.vnameEdit == "hide") {
			this.variableTip.hideBtn();
		} else if(vname) {
			this.variableTip.showBtn();
		}
		this.showCustomBindingInfo({
			info: cd.info
		}, sheetId, row, col, region);
		var val = cd.value;
		if(Ext.isObject(val) && val._isExp) {
			cellEl = cellEl || region.getCellEl(row, col);
			this.exceptionTip.showBy(cellEl);
			this.exceptionTip.removeCls("ss-validate-hint");
			var info = this.processCalculateException(val);
			this.exceptionTip.update(info.expTip);
		} else if(Ext.isDefined(cd.hint)) {
			var hint = cd.hint;
			if(Ext.isObject(hint)) {
				hint = EnterpriseSheet.sheet.calculate.Condition.prototype.generateHint(hint);
			}
			cellEl = cellEl || region.getCellEl(row, col);
			this.exceptionTip.showBy(cellEl);
			this.exceptionTip.addCls("ss-validate-hint");
			this.exceptionTip.update("<div class=\"ss-exception-title\">" + SLANG.invalid_cell_content + "</div>" + hint);
		} else {
			this.exceptionTip.delayHide();
		}
	},
	showCustomBindingInfo: function(obj, sheetId, row, col, region) {
		var anchorEl, alignPos;
		if(this.variableTip.isVisible()) {
			anchorEl = this.variableTip.getEl();
			alignPos = "tl-bl?";
		} else if(this.commentTip.isVisible()) {
			anchorEl = this.commentTip.getEl();
			alignPos = "tl-bl?";
		} else {
			anchorEl = region.getCellEl(row, col);
		}
		if(false !== this.fireEvent("beforeshowcustombindinginfo", obj, sheetId, row, col, region, anchorEl, alignPos, this)) {
			var info = obj.info;
			if(info) {
				var pos = this.customBindingDataTip.currentPos;
				var curPos = {
					sheet: sheetId,
					row: row,
					col: col
				};
				this.customBindingDataTip.currentPos = curPos;
				this.customBindingDataTip.info = info;
				if(!this.customBindingDataTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)) {
					this.customBindingDataTip.showBy(anchorEl, alignPos);
					this.customBindingDataTip.updateContent(info);
				}
			} else {
				this.customBindingDataTip.hide();
			}
		} else {
			this.customBindingDataTip.hide();
		}
	},
	concatRng: function(bus, rng) {
		for(var i = 0, len = rng.length; i < len; i++) {
			var it = rng[i];
			if(Ext.isArray(it)) {
				bus.push(it);
			} else if(it.span) {
				bus.push(it.span);
			}
		}
		return bus;
	},
	changeConditions: function(changedCdts, preCdtCache, posCdtCache) {
		var sheet = this;
		var deleteCdtStyles = [].concat(EnterpriseSheet.pure.sheet.calculate.Condition.prototype.styles);
		var store = sheet.getStore();
		var coord = [],
			changedCells = [],
			updateCdts = [],
			oldCdts = {};
		for(var p in changedCdts) {
			if(changedCdts.hasOwnProperty(p)) {
				var cdt = preCdtCache[p];
				oldCdts[p] = store.getFloatingById(p, cdt.sheet);
				coord = sheet.concatRng(coord, cdt.rng);
				if("update" == changedCdts[p]) {
					updateCdts.push(posCdtCache[p]);
				}
			}
		}
		for(var i = 0, len = updateCdts.length; i < len; i++) {
			var it = updateCdts[i];
			coord = sheet.concatRng(coord, it.rng);
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: sheet
		});
		if(false !== sheet.fireEvent("beforeconditionchange", range, sheet)) {
			var result = this.getRelatedCdtCoord(coord);
			sheet.fireEvent("prepareconditionchange", range, sheet, oldCdts, result.coord);
			for(var p in changedCdts) {
				if(changedCdts.hasOwnProperty(p)) {
					var cdt = preCdtCache[p];
					store.setFloatingItem(cdt.sheet, cdt.id, "cdt");
				}
			}
			for(var i = 0, len = updateCdts.length; i < len; i++) {
				var it = updateCdts[i];
				sheet.setConditionForRange(it.rng, it.name, it.opt, true, true, it.id);
			}
			var concatCoord = sheet.processRelatedCdt(coord, true, result);
			sheet.refreshRange(concatCoord.concat(coord));
			sheet.fireEvent("conditionchange", range, sheet, oldCdts, concatCoord);
		}
	},
	setValidation: function(json, suspendRefresh, suspendEvent, cdtId, action) {
		var sheetId = this.getSheetId();
		if("delete" == action) {
			var changedCdts = {};
			changedCdts[cdtId] = "deleted";
			var store = this.getStore();
			var oldCdt = store.getConditionById(cdtId, sheetId);
			oldCdt.sheet = sheetId;
			var preCdtCache = {};
			preCdtCache[cdtId] = oldCdt;
			this.changeConditions(changedCdts, preCdtCache, preCdtCache);
		} else {
			var coord = json.coord;
			delete json.coord;
			if(!cdtId) {
				var range = new EnterpriseSheet.sheet.range.Range({
					sheet: this,
					coord: coord
				});
				var newCdtId = range.setCondition("vd", json, suspendRefresh, suspendEvent, cdtId);
				this.refreshFocus();
				return newCdtId;
			} else {
				var changedCdts = {};
				changedCdts[cdtId] = "update";
				var store = this.getStore();
				var oldCdt = store.getConditionById(cdtId, sheetId);
				oldCdt.sheet = sheetId;
				var preCdtCache = {};
				preCdtCache[cdtId] = oldCdt;
				var newCdt = Ext.apply({}, oldCdt);
				newCdt.rng = coord;
				newCdt.opt = json;
				var posCdtCache = {};
				posCdtCache[cdtId] = newCdt;
				this.changeConditions(changedCdts, preCdtCache, posCdtCache);
			}
		}
	},
	beforeCompleteEdit: function(sheetId, row, col, editor) {
		var store = this.getStore(),
			condition = this.condition;
		var cell = store.getCellData(sheetId, row, col);
		cell.data = editor.getValue();
		var cdt = this.getConditionOfCell(sheetId, row, col, true);
		if(0 < cdt.length) {
			for(var i = 0, len = cdt.length; i < len; i++) {
				var found = cdt[i];
				if(found && "vd" == found.name) {
					var opt = found.opt;
					if(!opt.allow) {
						if(!condition.checkValidate(cell, opt)) {
							var cellEl = editor.region.getCellEl(row, col);
							if(cellEl) {
								this.exceptionTip.showBy(cellEl);
								this.exceptionTip.addCls("ss-validate-hint");
								var hint = opt.hint;
								if(!hint) {
									hint = EnterpriseSheet.sheet.calculate.Condition.prototype.generateHint(opt);
								}
								this.exceptionTip.update(hint);
							}
							return false;
						}
					}
				}
			}
		}
	},
	toggleEditableForSelection: function() {
		var store = this.getStore(),
			sm = this.getSelectionModel();
	},
	onChanging: function() {
		this.simulateFocusChange();
	},
	coord2StringWithSheetName: function(coords, sep, withSheet) {
		if(!Ext.isDefined(sep)) {
			sep = EnterpriseSheet.sheet.calculate.Coordinate.prototype.separator;
		}
		var store = this.getStore(),
			arr = [];
		for(var i = 0, len = coords.length; i < len; i++) {
			var it = coords[i];
			if(Ext.isObject(it)) {
				it = [].concat(it.span);
			} else {
				it = [].concat(it);
			}
			if(Ext.isNumber(it[0])) {
				it[0] = store.getSheetNameById(it[0]);
			} else {
				it[0] = store.getSheetNameById(this.getSheetId());
			}
			arr.push({
				span: it,
				type: SCONST.ABSOLUTE_COORD
			});
		}
		var coordStr = EnterpriseSheet.sheet.calculate.Coordinate.prototype.coord2String(arr, sep, withSheet);
		return coordStr;
	},
	isValidVariable: function(varName) {
		return this.getStore().isValidVariable(varName);
	},
	insertVariable: function(sheetId, row, col, varName) {
		var coord = [
			[sheetId, row, col, row, col]
		];
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		range.setProperty({
			vname: varName
		});
	},
	deleteVariable: function(coord) {
		if(!coord) {
			var sm = this.getSelectionModel();
			coord = sm.selection2Coord();
		}
		var range = new EnterpriseSheet.sheet.range.Range({
			coord: coord,
			sheet: this
		});
		range.setProperty(null, ["vname"]);
	},
	insertSequenceNo: function() {
		var sm = this.getSelectionModel(),
			focusCell = sm.focusCell;
		var coord = [
			[this.getSheetId(), focusCell.row, focusCell.col, focusCell.row, focusCell.col]
		];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		var modified = {
			seq: "#1."
		};
		range.setProperty(modified);
	},
	insertDropList: function(json) {
		var sm = this.getSelectionModel(),
			mm = sm.getMinMaxPos();
		var coord = [
			[this.getSheetId(), mm.minrow, mm.mincol, mm.maxrow, mm.maxcol]
		];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		var modified = {
			drop: json.drop
		};
		if(json.ovil) {
			modified.ovil = true;
		}
		range.setProperty(modified);
	},
	withGridLine: function(sheetId) {
		var activedSheetId = this.getSheetId(),
			store = this.getStore();
		if(!Ext.isDefined(sheetId) || sheetId === activedSheetId) {
			var el = this.getEl();
			return !el.hasCls("ss-no-gridline");
		} else {
			var obj = store.getCell(sheetId, 0, 0),
				config = obj.config;
			if(!config) {
				config = {};
			} else {
				config = Ext.decode(config);
			}
			return !config.noGridLine;
		}
	},
	showGridLine: function(suspendEvent, sheetId) {
		var activedSheetId = this.getSheetId(),
			store = this.getStore();
		if(!Ext.isDefined(sheetId) || sheetId === activedSheetId) {
			this.getEl().removeCls("ss-no-gridline");
			this.updateSheetConfig(suspendEvent);
		} else {
			var obj = store.getCell(sheetId, 0, 0);
			var config = obj.config;
			if(config) {
				config = Ext.decode(config);
				delete config.noGridLine;
				store.updateSheetConfig(sheetId, config, suspendEvent);
			}
		}
	},
	hideGridLine: function(suspendEvent, sheetId) {
		var activedSheetId = this.getSheetId(),
			store = this.getStore();
		if(!Ext.isDefined(sheetId) || sheetId === activedSheetId) {
			this.getEl().addCls("ss-no-gridline");
			this.updateSheetConfig(suspendEvent);
		} else {
			var obj = store.getCell(sheetId, 0, 0);
			var config = obj.config;
			if(config) {
				config = Ext.decode(config);
			} else {
				config = {};
			}
			config.noGridLine = true;
			store.updateSheetConfig(sheetId, config, suspendEvent);
		}
	},
	isReadOnly: function() {
		return this.readOnly;
	},
	setReadOnly: function(readOnly) {
		if(readOnly) {
			this.disableEdit();
			this.disableSelect();
			for(var p in this.regionLookup) {
				if(this.regionLookup.hasOwnProperty(p)) {
					var region = this[this.regionLookup[p]];
					region.setReadOnly(true);
					if(region.getSelectionModel) {
						var sm = region.getSelectionModel();
						sm.hide();
					}
					if(region.getReferenceModel) {
						var rm = region.getReferenceModel();
						if(rm) {
							rm.hide();
						}
					}
				}
			}
			this.hideLinkKit();
		} else {
			this.enableEdit();
			this.enableSelect();
			for(var p in this.regionLookup) {
				if(this.regionLookup.hasOwnProperty(p)) {
					var region = this[this.regionLookup[p]];
					region.setReadOnly(false);
					if(region.getSelectionModel) {
						var sm = region.getSelectionModel();
						sm.show();
					}
				}
			}
			var sm = this.getSelectionModel();
			sm.selectRange(sm.startPos, sm.endPos);
		}
		this.mixins.basic.setReadOnly.call(this, readOnly);
	},
	saveJsonFile: function(config, callback, scope) {
		var store = this.getStore();
		this.loadMask.show();
		store.saveJsonFile(config, function(newFileId) {
			this.setSheetId(store.getActivedSheetId());
			this.loadMask.hide();
			if(callback) {
				callback.call(scope, newFileId);
			}
		}, this);
	},
	getJsonData: function(compress) {
		var store = this.getStore();
		return store.getJsonData(compress);
	},
	onKeyDown: function(e) {
		var key = e.getKey(),
			sm = this.getSelectionModel(),
			store = this.getStore();
		var pos = sm.getMinMaxPos(),
			minX = pos.minrow,
			minY = pos.mincol,
			maxX = pos.maxrow,
			maxY = pos.maxcol;
		if(46 == key || 8 == key) {
			this.cleanSelection("content", true);
			return false;
		}
	},
	onLoadingMore: function(sheetId, store) {
		var sheetObj = store.getSheetById(sheetId);
		var currentCellCount = sheetObj.currentCellCount || 0;
		var currentFloatingCount = sheetObj.currentFloatingCount || 0;
		var totalCellCount = sheetObj.totalCellCount || 0;
		var totalFloatingCount = sheetObj.totalFloatingCount || 0;
		var count = currentCellCount + currentFloatingCount,
			total = totalCellCount + totalFloatingCount;
		var percent = 0 === total ? 1 : count / total;
		if(this.loadMask) {
			this.loadMask.updatePercent(percent);
		}
	},
	deleteRepeatItem: function() {
		var sm = this.getSelectionModel(),
			store = this.getStore();
		var pos = sm.getMinMaxPos(),
			coord = [
				[store.getActivedSheetId(), pos.minrow, pos.mincol, pos.maxrow, pos.maxcol]
			];
		coord = store.shrinkCoordWithContent(coord);
		var span = coord[0];
		sm.selectRange({
			row: span[1],
			col: span[2]
		}, {
			row: span[3],
			col: span[4]
		});
		if(!this.deleteRepeatOption) {
			this.deleteRepeatOption = Ext.create("EnterpriseSheet.sheet.floating.DeleteRepeatOption", {
				sheet: this
			});
		}
		var data = [];
		for(var i = span[2]; i <= span[4]; i++) {
			data.push({
				col: i,
				display: SLANG.column + store.getColName(i)
			});
		}
		this.deleteRepeatOption.prepare(data);
		this.deleteRepeatOption.showBy(sm.getEl(), "tl-tr?");
	},
	setArrayFormulaForSelection: function(json) {
		var sm = this.getSelectionModel(),
			store = this.getStore();
		var pos = sm.getMinMaxPos(),
			span = [store.getActivedSheetId(), pos.minrow, pos.mincol, pos.maxrow, pos.maxcol];
		this.setArrayFormulaForSpan(span, json);
	},
	setArrayFormulaForSpan: function(span, json) {
		var store = this.getStore();
		var sheetId = span[0],
			minrow = span[1],
			mincol = span[2],
			maxrow = span[3],
			maxcol = span[4];
		if(0 !== maxrow && 0 !== maxcol) {
			var data = "=" + store.getColName(mincol) + minrow;
			for(var i = minrow; i <= maxrow; i++) {
				for(var j = mincol; j <= maxcol; j++) {
					if(i === minrow && j === mincol) {
						this.setCellData(sheetId, i, j, Ext.apply({
							afrow: minrow - i,
							afcol: mincol - j,
							aerow: maxrow - i,
							aecol: maxcol - j
						}, json), ["value"]);
					} else {
						this.setCellData(sheetId, i, j, Ext.applyIf({
							afrow: minrow - i,
							afcol: mincol - j,
							data: data
						}, json), ["value"]);
					}
				}
			}
		}
	},
	onTry2ChangePartOfArrayFormula: function() {
		Ext.Msg.alert(SLANG.hint, SLANG.can_not_only_change_part_of_array_formula);
	},
	isTitleRegionVisible: function() {
		return this.ltcorner.isVisible();
	},
	onCellEventCallback: function(eventType, sheetId, row, col) {
		var store = this.getStore();
		var cd = store.getCell(sheetId, row, col);
		var callback = cd[eventType];
		if(callback && window[callback]) {
			cd = this.getCellValue(sheetId, row, col);
			window[callback](cd.data, row, col, sheetId, cd, store);
		}
	},
	checkCustomizedEvent: function(eventName, sheetId, row, col, opt) {
		var store = this.getStore();
		var cd = store.getCellProperty(sheetId, row, col);
		var event = cd[eventName];
		if(event) {
			return this.fireEvent(event, sheetId, row, col, cd, this, opt);
		}
	},
	showCellCustomBindingData: function(row, col, region) {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var cd = store.getCellData(sheetId, row, col);
		var customBindingFn = cd.onCustomBindingFn;
		if(customBindingFn && "" != customBindingFn) {
			var callFn = customBindingFn + "(" + Ext.encode(cd) + "," + row + "," + col + ")";
			var result = (function() {
				return eval(callFn);
			})();
			if(result && result.length > 0) {
				var pos = this.customBindingDataTip.currentPos;
				var curPos = {
					sheet: sheetId,
					row: row,
					col: col
				};
				this.customBindingDataTip.currentPos = curPos;
				if(!this.customBindingDataTip.isVisible() || !pos || !(pos.sheet === curPos.sheet && pos.row === curPos.row && pos.col === curPos.col)) {
					var cellEl = region.getCellEl(row, col);
					this.customBindingDataTip.showBy(cellEl);
					this.customBindingDataTip.updateContent(result);
				}
			}
		} else {
			this.customBindingDataTip.hide();
		}
	},
	hideTitleRegion: function() {},
	hideTitleRegion: function() {},
	getCellVariables: function() {
		var store = this.getStore();
		var vnames = {};
		store.each(function(rec) {
			var sheetId = rec.data.sheet,
				row = rec.data.row,
				col = rec.data.col;
			var json = rec.data.json,
				vn = json.vname;
			if(vn) {
				var parts = vn.split(".");
				if(1 < parts.length) {
					parts.pop();
					var vng = parts.join("."),
						vals = [this.getCellValue(sheetId, row, col).data];
					var i = row + 1;
					while(true) {
						var cell = store.getCell(sheetId, i, 0);
						if(cell.vng === vng) {
							var val = this.getCellValue(sheetId, i, col).data;
							if(!SCOM.isEmptyValue(val)) {
								vals.push(val);
							}
						} else {
							break;
						}
						i++;
					}
					vnames[vn] = vals;
				} else {
					vnames[vn] = this.getCellValue(sheetId, row, col).data;
				}
			}
		}, this);
		return vnames;
	},
	setValueToVariable: function(vnVals) {
		var store = this.getStore();
		var changedCells = store.setValueToVariable(vnVals, true);
		this.refreshRange(undefined, this.findDirectRecalculateCellsForCells(changedCells));
	},
	clearAllVariables: function() {
		var store = this.getStore();
		store.each(function(rec) {
			var json = rec.data.json;
			if(json.vng) {
				delete json.vng;
			}
			if(json.vname) {
				delete json.vname;
			}
		}, this);
		this.refreshRange();
	},
	getItemValueByName: function(name) {
		var store = this.getStore(),
			itype, value;
		store.each(function(rec) {
			var json = rec.data.json,
				sheetId = rec.data.sheet,
				row = rec.data.row,
				col = rec.data.col;
			if(name === json.itn) {
				if(!Ext.isDefined(itype)) {
					itype = json.it;
				}
				if(json.it === itype) {
					if("radio" === itype) {
						if(json.itchk) {
							value = this.getCellValue(sheetId, row, col).data;
							return false;
						}
					} else if("checkbox" === itype) {
						if(json.itchk) {
							value = value || [];
							value.push(this.getCellValue(sheetId, row, col).data);
						}
					}
				}
			}
		}, this);
		if(Ext.isDefined(itype)) {
			return {
				itemType: itype,
				itemValue: value
			};
		}
	},
	createPivotTable: function() {},
	setSelectedRowAsHeaderTitle: function() {
		var sm = this.getSelectionModel(),
			store = this.getStore();
		var mm = sm.getMinMaxPos(),
			sheetId = this.getSheetId();
		var span = [sheetId, mm.minrow, mm.mincol, mm.minrow, mm.maxcol],
			coord = [span];
		this.fireEvent("preparesetheadertitle", span, this);
		var titles = {};
		store.walkRange(coord, function(rec, walkSpan, store, internalId) {
			var obj = this.getCellValue(rec.data.sheet, rec.data.row, rec.data.col);
			var data = obj.data;
			store.setCell(rec.data.sheet, 0, rec.data.col, {
				data: data
			}, undefined, true);
			var id = internalId;
			titles[id] = data;
		}, this);
		this.refreshRange([
			[sheetId, 0, mm.mincol, 0, mm.maxcol]
		]);
		this.fireEvent("setheadertitle", span, titles, this);
	},
	setColumnTitle: function(sheetId, col, title) {
		var activeSheetId = this.getSheetId();
		if(sheetId != null) {
			activeSheetId = sheetId;
		}
		this.getStore().setCell(activeSheetId, 0, col, {
			data: title
		});
	},
	setColumnIcon: function(col, iconPath) {
		this.setCell(this.getSheetId(), 0, col, {
			ticon: iconPath
		});
	},
	cleanColumnIcon: function(col) {
		this.setCell(this.getSheetId(), 0, col, null, ["ticon"]);
	},
	addCellDataRender: function(obj) {
		SCRENDER.addRender(obj);
	},
	processCellDataRender: function(cell, scope) {
		if(cell.render) {
			var render = SCRENDER.getRender(cell.render);
			if(render) {
				var data = render(scope.sheet, scope.row, scope.col, cell, this);
				if(Ext.isDefined(data)) {
					cell.data = data;
				}
			}
		}
		return cell;
	},
	processCellDataConfig: function(cell, scope) {
		return this.dtProcessor.processCellDataConfig(cell, scope);
	},
	checkDataTypeConfigBeforeEdit: function(sheetId, row, col, region) {
		return this.dtProcessor.checkBeforeEdit(sheetId, row, col, region);
	},
	setColumnTitleVisible: function(visible, startCol, endCol) {
		var coord = [
			[this.getSheetId(), 0, startCol, 0, endCol]
		];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: this,
			coord: coord
		});
		if(!visible) {
			range.setProperty({
				hideTitle: true
			});
		} else {
			range.setProperty(undefined, ["hideTitle"]);
		}
	},
	getConditionOfCell: function(sheetId, row, col, withDataTypeConfig) {
		var conditions = this.mixins.basic.getConditionOfCell.apply(this, arguments);
		if(withDataTypeConfig) {
			var dataTypeConfig = this.dtProcessor.getDataTypeConfigForCell(sheetId, row, col);
			if(dataTypeConfig) {
				conditions.push({
					name: "vd",
					opt: dataTypeConfig
				});
			}
		}
		return conditions;
	},
	getCdtFloatingOfCell: function(sheetId, row, col, withDataTypeConfig) {
		var conditions = this.mixins.basic.getCdtFloatingOfCell.apply(this, arguments);
		if(withDataTypeConfig) {
			var dataTypeConfig = this.dtProcessor.getDataTypeConfigForCell(sheetId, row, col);
			if(dataTypeConfig) {
				conditions.push({
					jsonObj: {
						id: dataTypeConfig.id,
						name: "vd",
						opt: dataTypeConfig
					}
				});
			}
		}
		return conditions;
	},
	savePrintSettingForSheet: function(sheetId, setting, callback, scope) {
		this.store.saveExtraInfo(sheetId, {
			printSetting: setting
		}, "apply", callback, scope);
	},
	setColNameVisible: function(visible, sheetId, suspendEvent) {
		this.store.colNameHidden = !visible;
		if(this.store.colNameHidden || this.store.rowNameHidden) {
			this.ltcorner.hide();
		} else {
			this.ltcorner.show();
		}
		var activedSheetId = this.getSheetId(),
			store = this.getStore();
		if(!Ext.isDefined(sheetId) || sheetId === activedSheetId) {
			this.updateSheetConfig(suspendEvent);
		} else {
			var obj = store.getCell(sheetId, 0, 0);
			var config = obj.config;
			if(config) {
				config = Ext.decode(config);
				config.colNameHidden = this.store.colNameHidden;
				store.updateSheetConfig(sheetId, config, suspendEvent);
			}
		}
		this.refresh();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
	},
	setRowNameVisible: function(visible, sheetId, suspendEvent) {
		this.store.rowNameHidden = !visible;
		if(this.store.colNameHidden || this.store.rowNameHidden) {
			this.ltcorner.hide();
		} else {
			this.ltcorner.show();
		}
		var activedSheetId = this.getSheetId(),
			store = this.getStore();
		if(!Ext.isDefined(sheetId) || sheetId === activedSheetId) {
			this.updateSheetConfig(suspendEvent);
		} else {
			var obj = store.getCell(sheetId, 0, 0);
			var config = obj.config;
			if(config) {
				config = Ext.decode(config);
				config.rowNameHidden = this.store.rowNameHidden;
				store.updateSheetConfig(sheetId, config, suspendEvent);
			}
		}
		this.refresh();
		if(Ext.isFunction(this.doLayout)) {
			this.doLayout();
		} else if(Ext.isFunction(this.updateLayout)) {
			this.updateLayout();
		}
	},
	afterDataChange: function(timestamp, sheet, row, col, modified, deleted, originJson, currentJson, store, suspendRefresh) {
		var region = this.getCurrentRegion();
		var prev = this.findPrevNonEmptyColIndex(sheet, row, col, region);
		if(prev) {
			this.refreshRange([
				[sheet, row, prev, row, prev]
			]);
		}
	},
	maskBeforeCalculating: function(msg, deleyTime) {
		this.loadMask.show(msg, deleyTime);
	},
	refreshAfterDataChange: function(coord) {
		this.refreshRange(coord);
		this.loadMask.hide();
	},
	changeZoom: function(zoom, suspendStore, suspendRefresh) {
		var store = this.getStore(),
			sheetId = store.getActivedSheetId(),
			oldZoom = store.getZoom();
		for(var p in this.floorLookup) {
			if(this.floorLookup.hasOwnProperty(p)) {
				var floor = this.floorLookup[p];
				if(sheetId == floor.sheetId) {
					var obj = floor.getPositionSize();
					if(obj) {
						obj.width = store.zoomSize(obj.width, zoom);
						obj.height = store.zoomSize(obj.height, zoom);
						obj.x = store.zoomSize(obj.x, zoom);
						obj.y = store.zoomSize(obj.y, zoom);
						floor.setPositionSize(obj);
					}
				}
			}
		}
		store.setZoom(zoom);
		if(!suspendStore) {
			var config = store.getSheetConfig(sheetId);
			config.zoom = zoom;
			store.updateSheetConfig(sheetId, config, true);
		}
		if(!suspendRefresh) {
			this.refresh();
		}
		this.fireEvent("zoomchanged", oldZoom, zoom, this);
	},
	addFormulaAlias: function(alias) {
		var map = this.calculate.getFormulaAliasMap();
		var hintPro = EnterpriseSheet.sheet.floating.CalculateHint.prototype;
		var arr = [];
		for(var p in alias) {
			if(alias.hasOwnProperty(p)) {
				var it = alias[p];
				map[p.toUpperCase()] = it.originName;
				arr.push(it.hint);
			}
		}
		hintPro.addHint(arr);
	},
	updateCurrentBackground: function(url) {
		this.sheetTabBackground = url;
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++) {
			var name = this.bodyRegionLookup[i];
			var region = this[name];
			region.setRegionBackground(url);
		}
	},
	insertSheetTabBackground: function(sheetId, url) {
		var activedSheetId = this.getSheetId(),
			store = this.getStore();
		if(!Ext.isDefined(sheetId)) {
			sheetId = activedSheetId;
		}
		var config = store.getSheetConfig(sheetId);
		if(url) {
			config.background = url;
		} else {
			delete config.background;
		}
		store.updateSheetConfig(sheetId, config);
		if(activedSheetId === sheetId) {
			this.updateCurrentBackground(url);
		}
	},
	syncPageBreak: function() {
		var store = this.getStore(),
			sheetId = this.getSheetId();
		var floatings = store.floatings,
			innerEl = this.getInnerEl();
		var doms = Ext.DomQuery.jsSelect("div[class*=ss-pb-line]", innerEl.dom);
		for(var i = 0, len = doms.length; i < len; i++) {
			var dom = doms[i];
			Ext.removeNode(dom);
		}
		var lookup = this.bodyRegionLookup;
		for(var p in floatings) {
			if(floatings.hasOwnProperty(p)) {
				var it = floatings[p],
					jsonObj = it.jsonObj;
				if("pb" === it.ftype && sheetId === it.sheet) {
					for(var i = 0, len = lookup.length; i < len; i++) {
						var region = this[lookup[i]];
						if(region.isVisible()) {
							region.addPageBreakLine(jsonObj.r, jsonObj.c);
						}
					}
				}
			}
		}
	},
	insertPageBreakAtFocus: function() {
		var sm = this.getSelectionModel(),
			store = this.getStore();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		if(1 < row || 1 < col) {
			if(0 < row) {
				row--;
			}
			if(0 < col) {
				col--;
			}
			this.insertPageBreak(this.getSheetId(), row, col);
		}
	},
	insertPageBreak: function(sheetId, row, col, suspendRefresh, suspendEvent) {
		var name = ["pb", row, col].join("-"),
			store = this.getStore();
		if(!store.getFloatingItem(sheetId, name)) {
			store.setFloatingItem(sheetId, name, "pb", Ext.encode({
				r: row,
				c: col
			}));
			if(!suspendRefresh && sheetId === this.getSheetId()) {
				this.refresh();
			}
			this.syncPageBreak();
			if(!suspendEvent) {
				this.fireEvent("insertpagebreak", sheetId, row, col, this);
			}
		}
	},
	deletePageBreakAtFocus: function() {
		var sm = this.getSelectionModel(),
			store = this.getStore();
		var focusCell = sm.getFocusCell();
		var sheetId = this.getSheetId();
		var row = focusCell.row,
			col = focusCell.col;
		if(1 < row || 1 < col) {
			if(0 < row) {
				row--;
			}
			if(0 < col) {
				col--;
			}
			this.deletePageBreak(sheetId, row, col);
		}
	},
	deletePageBreak: function(sheetId, row, col, suspendRefresh, suspendEvent) {
		var name = ["pb", row, col].join("-"),
			store = this.getStore();
		if(store.getFloatingItem(sheetId, name)) {
			store.setFloatingItem(sheetId, name, "pb");
			if(!suspendRefresh && sheetId === this.getSheetId()) {
				this.refresh();
			}
			this.syncPageBreak();
			if(!suspendEvent) {
				this.fireEvent("deletepagebreak", sheetId, row, col, this);
			}
		}
	},
	getCustomizedEditorForCell: function(sheetId, row, col, cellObj) {}
});

Ext.define("EnterpriseSheet.sheet.RollingSheet", {
	extend: "EnterpriseSheet.sheet.Sheet",
	alias: "widget.swiftoosheet",
	constructor: function() {
		this.callParent(arguments);
	},
	scrollingCheckBuffer: 1000,
	bindListeners: function() {
		this.callParent(arguments);
		this.on("rowscrolling", this.onRowScrolling, this);
		this.on("colscrolling", this.onColumnScrolling, this);
		this.store.on("prepareloadrange", this.beforeLoadRange, this);
		this.store.on("afterloadrange", this.afterLoadRange, this);
		this.on("filtering", this.processAfterLoadSheet, this);
		this.on("rowhide", this.processAfterLoadSheet, this);
		this.on("columnhide", this.processAfterLoadSheet, this);
		this.on("resetloadedblocks", this.resetLoadedBlocks, this, {
			buffer: 500
		});
		this.store.on("beforeholdremoverow", this.processForInsertRemove, this);
		this.store.on("beforeholdremovecolumn", this.processForInsertRemove, this);
		this.store.on("beforeholdinsertrow", this.processForInsertRemove, this);
		this.store.on("beforeholdinsertcolumn", this.processForInsertRemove, this);
		this.store.on("beforeholdremovecell", this.processForInsertRemove, this);
		this.store.on("beforeholdinsertcell", this.processForInsertRemove, this);
		this.store.on("addsortormove", function() {
			this.loadMask.show();
		}, this);
		this.store.on("pullsortormove", function() {
			this.processForInsertRemove(this.store.getActivedSheetId());
			this.loadMask.hide();
		}, this);
	},
	processForInsertRemove: function(sheetId) {
		var store = this.store;
		if(!store.isAllCellLoadedInSheet(sheetId)) {
			this.pauseLoadRange = true;
			this.store.on("pullover", function() {
				delete this.pauseLoadRange;
				this.fireEvent("resetloadedblocks", sheetId, this);
			}, this, {
				single: true
			});
		}
	},
	resetLoadedBlocks: function(sheetId) {
		var store = this.getStore();
		var tab = store.getSheetById(sheetId);
		tab.loadedBlocks = {};
		this.processAfterLoadSheet();
	},
	findRegionMapKey: function(region) {
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++) {
			var key = this.bodyRegionLookup[i];
			var it = this[key];
			if(it === region) {
				return key;
			}
		}
	},
	checkLoadRange: function(coord, justCheck) {
		if(!Ext.isFunction(this.store.checkLoadRange) || this.pauseLoadRange) {
			return;
		}
		this.store.checkLoadRange(coord, function(flag) {
			this.loadMask.hide();
		}, this, justCheck);
	},
	onRowScrolling: function(offset, region, scroller) {
		this.processRowColScrolling(region, scroller);
	},
	onColumnScrolling: function(offset, region, scroller) {
		this.processRowColScrolling(region, scroller);
	},
	processRowColScrolling: function(region, scroller) {
		if(!scroller.mdFlag) {
			var coord = region.getVisibleCoord();
			this.checkLoadRange(coord, scroller.mdFlag);
		} else if(!this.loadMask.isVisible()) {
			if(Ext.isFunction(this.store.isSpansLoaded)) {
				var coord = region.getVisibleCoord();
				if(!this.store.isSpansLoaded(coord)) {
					this.loadMask.show(SLANG.locating_mouseup_render);
				}
			}
		}
	},
	processAfterLoadSheet: function() {
		if(!Ext.isFunction(this.store.checkLoadRange)) {
			this.loadMask.hide();
			return;
		}
		var regions = [];
		for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++) {
			var it = this[this.bodyRegionLookup[i]];
			if(it.isVisible()) {
				regions.push(it);
			}
		}
		var coord = [];
		for(var i = 0, len = regions.length; i < len; i++) {
			var region = regions[i];
			coord = coord.concat(region.getVisibleCoord());
		}
		this.checkLoadRange(coord);
	},
	go2Pos: function() {
		this.callParent(arguments);
		this.processAfterLoadSheet();
	},
	beforeLoadRange: function() {
		this.loadMask.show(SLANG.rendering);
	},
	afterLoadRange: function(coord, store) {
		this.refreshRange(coord, false, true);
		this.loadMask.hide();
	},
	switchSheet: function(sheetId, callback, scope) {
		this.callParent([sheetId, function() {
			if(!Ext.isFunction(this.store.checkLoadRange)) {
				return;
			}
			var regions = [];
			for(var i = 0, len = this.bodyRegionLookup.length; i < len; i++) {
				var it = this[this.bodyRegionLookup[i]];
				if(it.isVisible()) {
					regions.push(it);
				}
			}
			var coord = [];
			for(var i = 0, len = regions.length; i < len; i++) {
				var region = regions[i];
				coord = coord.concat(region.getVisibleCoord());
			}
			this.store.checkLoadRange(coord);
			if(callback) {
				callback.call(scope);
			}
		}, this]);
	}
});

Ext.define("EnterpriseSheet.api.SheetAppHandle", {
	constructor: function(config) {
		Ext.apply(this, config);
		this.callParent(arguments)
	},
	getRefer: function(name) {
		return this[name]
	},
	getSheet: function() {
		return this.getRefer("sheet")
	},
	getStore: function() {
		return this.getRefer("store")
	},
	getAppContainer: function() {
		return this.getRefer("appCt")
	},
	getToolbar: function() {
		return this.getRefer("toolbar")
	},
	getContentbar: function() {
		return this.getRefer("contentbar")
	},
	getTitlebar: function() {
		return this.getRefer("titlebar")
	},
	getSidebar: function() {
		return this.getRefer("sidebar")
	}
});
Ext.define("EnterpriseSheet.api.SheetAPI", {
	requires: ["EnterpriseSheet.pure.lang.Language", "EnterpriseSheet.sheet.action.HotKey", "EnterpriseSheet.sheet.menu.ContextMenu", "EnterpriseSheet.sheet.data.RollingStore", "EnterpriseSheet.sheet.toolbar.MenuTitlebar", "EnterpriseSheet.sheet.toolbar.SheetTabbar", "EnterpriseSheet.sheet.toolbar.Toolbar", "EnterpriseSheet.sheet.toolbar.Sidebar", "EnterpriseSheet.sheet.toolbar.Contentbar", "EnterpriseSheet.sheet.floating.Arrow", "EnterpriseSheet.sheet.floating.ActionPane", "EnterpriseSheet.sheet.floating.CalculateHint", "EnterpriseSheet.sheet.plugin.SequenceNumber", "EnterpriseSheet.sheet.plugin.DropList", "EnterpriseSheet.sheet.RollingSheet", "EnterpriseSheet.api.SheetAppHandle", "EnterpriseSheet.sheet.pop.ErrorReportWin"],
	constructor: function(config) {
		Ext.apply(this, config);
		Ext.tip.QuickTipManager.init();
		SQTIP.init();
		SABOX.updateConfig({
			openFileByOnlyLoadDataFlag: this.openFileByOnlyLoadDataFlag
		});
		if(SCONST.PULLING_TIMEOUT) {
			Ext.Ajax.timeout = SCONST.PULLING_TIMEOUT
		}
		if(Ext.isIE) {
			Ext.getBody().addCls("x-ie")
		}
		if(!Ext.isMac && Ext.isWebKit) {
			Ext.getBody().addCls("iScroll")
		}
		this.callParent(arguments)
	},
	createSheetApp: function(config) {
		config = config || {};
		var store;
		if(config.store) {
			store = config.store
		} else {
			store = Ext.create("EnterpriseSheet.sheet.data.RollingStore", {
				fileId: config.fileId
			})
		}
		var plugins = config.plugins || [],
			lookup = {},
			dockedItems = [];
		var arrowConfig = config.arrowConfig || {};
		Ext.applyIf(arrowConfig, {
			itemsInMenu: SCONFIG.arrowmenu_items
		});
		var arrow = new EnterpriseSheet.sheet.floating.Arrow(arrowConfig);
		plugins.push(arrow);
		lookup.arrow = arrow;
		if(config.actionPaneConfig) {
			var actionPaneConfig = config.actionPaneConfig;
			var actionPaneClassName = actionPaneConfig.actionPaneClassName || "EnterpriseSheet.sheet.floating.DynamicRangePane";
			var actionPane = Ext.create(actionPaneClassName, actionPaneConfig);
			plugins.push(actionPane);
			lookup.actionPane = actionPane
		}
		var dropListConfig = config.dropListConfig || {};
		var dropList = new EnterpriseSheet.sheet.plugin.DropList(dropListConfig);
		plugins.push(dropList);
		lookup.dropList = dropList;
		var hint = new EnterpriseSheet.sheet.floating.CalculateHint();
		plugins.push(hint);
		lookup.hint = hint;
		var contextMenuConfig = config.contextMenuConfig || {};
		Ext.applyIf(contextMenuConfig, {
			itemsInMenu: SCONFIG.contextmenu_items
		});
		var contextMenu = new EnterpriseSheet.sheet.menu.ContextMenu(contextMenuConfig);
		plugins.push(contextMenu);
		lookup.contextMenu = contextMenu;
		var seqNumber = Ext.create("EnterpriseSheet.sheet.plugin.SequenceNumber");
		plugins.push(seqNumber);
		lookup.seqNumber = seqNumber;
		if(!config.withoutTitlebar) {
			var mtCfg = config.menuTitlebarConfig || {};
			var titlebar = new EnterpriseSheet.sheet.toolbar.MenuTitlebar(Ext.apply(mtCfg, {
				dock: "top"
			}));
			plugins.push(titlebar);
			dockedItems.push(titlebar);
			lookup.titlebar = titlebar
		}
		if(!config.withoutSheetbar) {
			var sbCfg = config.sheetBarConfig || {};
			var sheetBarClassName = config.sheetBarClassName || "EnterpriseSheet.sheet.toolbar.SheetTabbar";
			var sheetbar = Ext.create(sheetBarClassName, Ext.apply(sbCfg, {
				dock: SCONFIG.sheet_tab_bar_position
			}));
			plugins.push(sheetbar);
			dockedItems.push(sheetbar);
			lookup.sheetbar = sheetbar
		}
		if(!config.withoutToolbar) {
			var toolbarClassName = config.toolbarClassName || "EnterpriseSheet.sheet.toolbar.Toolbar";
			var tbCfg = config.toolbarConfig || {};
			var toolbar = Ext.create(toolbarClassName, Ext.apply(tbCfg, {
				dock: "top"
			}));
			plugins.push(toolbar);
			dockedItems.push(toolbar);
			lookup.toolbar = toolbar
		} else {
			var toolbarClassName = config.toolbarClassName || "EnterpriseSheet.sheet.toolbar.Toolbar";
			var tbCfg = config.toolbarConfig || {};
			var toolbar = Ext.create(toolbarClassName, Ext.apply(tbCfg, {
				dock: "top"
			}));
			plugins.push(toolbar)
		}
		if(!config.withoutSidebar) {
			var sidebar = new EnterpriseSheet.sheet.toolbar.Sidebar({
				dock: "right",
				bodyStyle: "border-right:none;"
			});
			plugins.push(sidebar);
			dockedItems.push(sidebar);
			lookup.sidebar = sidebar
		}
		if(!config.withoutContentbar) {
			var contentbar = new EnterpriseSheet.sheet.toolbar.Contentbar({
				dock: "top",
				disableCalEditorStyle: config.disableCalEditorStyle,
				showValueInCalEditor: config.showValueInCalEditor
			});
			plugins.push(contentbar);
			lookup.contentbar = contentbar
		}
		var sheetClassName = config.sheetClassName || "EnterpriseSheet.sheet.RollingSheet";
		var sheet = Ext.create(sheetClassName, {
			style: "border:none;",
			loadMask: {
				msg: SLANG.processing
			},
			rowNameHidden: config.rowNameHidden,
			colNameHidden: config.colNameHidden,
			store: store,
			plugins: plugins,
			disableCalEditorStyle: config.disableCalEditorStyle,
			showValueInCalEditor: config.showValueInCalEditor,
			scrollerAlwaysVisible: config.scrollerAlwaysVisible
		});
		var inner;
		if(!config.withoutContentbar) {
			inner = {
				border: false,
				layout: "fit",
				bodyStyle: "border:none;",
				items: [sheet],
				dockedItems: [contentbar]
			}
		} else {
			inner = sheet
		}
		var panel = Ext.create("Ext.panel.Panel", Ext.applyIf({
			border: false,
			layout: "fit",
			bodyStyle: "border:none;",
			items: [inner],
			dockedItems: dockedItems
		}, config));
		if(sidebar && titlebar) {
			var me = this;
			var findReplace = function() {
				sidebar.toggleOption(sidebar.searchBtn)
			};
			var showcellstyles = function() {
				sidebar.toggleOption(sidebar.cellStyleBtn)
			};
			var showCharts = function() {
				sidebar.toggleOption(sidebar.chartBtn)
			};
			var showTables = function() {
				sidebar.toggleOption(sidebar.tableStyleBtn)
			};
			var showinsertimage = function() {
				sidebar.toggleOption(sidebar.pictureBtn)
			};
			var showconditionmgr = function() {
				sidebar.toggleOption(sidebar.conditionStyleBtn)
			};
			titlebar.on("findreplace", findReplace);
			titlebar.on("showcellstyles", showcellstyles);
			titlebar.on("showCharts", showCharts);
			titlebar.on("showTables", showTables);
			titlebar.on("showconditionmgr", showconditionmgr);
			titlebar.on("showinsertimage", showinsertimage);
			PHKey.bindHotKey(70, true, false, false, findReplace)
		}
		this.checkBeforeUnload(store);
		store.on("reportservererror", this.reportServerError, this);
		return Ext.create("EnterpriseSheet.api.SheetAppHandle", Ext.apply({
			appCt: panel,
			sheet: sheet,
			store: store
		}, lookup))
	},
	createSheetWin: function(sheetConfig, winConfig) {
		sheetConfig = sheetConfig || {};
		winConfig = winConfig || {};
		delete(sheetConfig.renderTo);
		delete(winConfig.items);
		delete(winConfig.layout);
		var hd = this.createSheetApp(sheetConfig);
		var win = Ext.create("Ext.window.Window", Ext.apply({
			layout: "fit",
			items: [hd.appCt]
		}, winConfig, {
			modal: true,
			closeAction: "hide",
			width: 1000,
			height: 700
		}));
		hd.appWin = win;
		return hd
	},
	checkBeforeUnload: function(store) {
		try {
			if(!window.onbeforeunload) {
				window.onbeforeunload = function() {
					if(!store.isEmptyQueue()) {
						store.doPulling();
						return SLANG.save_change_before_reload
					} else {
						if(store.isPulling()) {
							return SLANG.save_change_before_reload
						}
					}
				}
			}
		} catch(e) {}
	},
	loadFile: function(hd, fileId, callback, scope) {
		if(callback) {
			hd.sheet.on("afterloadsheet", function() {
				callback.apply(scope, arguments)
			}, this, {
				single: true
			})
		}
		hd.store.loadFile({
			fileId: fileId
		})
	},
	loadData: function(hd, json, callback, scope) {
		if(json) {
			if(callback) {
				hd.sheet.on("afterloadsheet", function() {
					if(hd.sheet.loadMask) {
						hd.sheet.loadMask.hide()
					}
					callback.call(scope)
				}, this, {
					single: true
				})
			}
			if(hd.sheet.loadMask) {
				hd.sheet.loadMask.show()
			}
			Ext.Function.defer(function() {
				hd.store.loadJsonFile(json)
			}, 5)
		}
	},
	loadTabData: function(hd, json, callback, scope) {
		if(json) {
			var sheet = hd.sheet;
			hd.store.loadTabJsonFile(json, function() {}, this);
			if(Ext.isFunction(sheet.refresh)) {
				sheet.refresh()
			}
		}
		if(callback) {
			callback.call(scope)
		}
	},
	loadMoreData: function(hd, json, callback, scope) {
		if(json) {
			var sheet = hd.sheet;
			hd.store.loadMoreJsonFile(json);
			if(Ext.isFunction(sheet.refresh)) {
				sheet.refresh()
			}
		}
		if(callback) {
			callback.call(scope)
		}
	},
	refreshSheet: function(hd) {
		var sheet = hd.sheet;
		if(Ext.isFunction(sheet.refresh)) {
			sheet.refresh()
		}
	},
	updateCells: function(hd, cellObjs, callback, scope) {
		hd.sheet.updateCells(cellObjs, callback, scope)
	},
	saveData: function(hd, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		SSAVE.popup({
			callback: function(fileName, exname, fileId) {
				sheet.saveJsonFile({
					id: fileId,
					name: fileName,
					exname: exname
				}, function(newFileId) {
					store.loadFile({
						fileId: newFileId
					}, function() {
						Ext.Msg.alert(SLANG.hint, SLANG.all_changes_are_saved);
						if(callback) {
							callback.call(scope, newFileId, store)
						}
					}, this)
				}, this)
			},
			scope: this
		})
	},
	saveDataSclient: function(hd, fileId, fileName, exname, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		sheet.saveJsonFile({
			id: fileId,
			name: fileName,
			exname: exname
		}, function(newFileId) {
			store.loadFile({
				fileId: newFileId
			}, function() {
				if(callback) {
					callback.call(scope, newFileId, store)
				}
			}, this)
		}, this)
	},
	setReadOnly: function(hd, readOnly) {
		hd.sheet.setReadOnly(readOnly)
	},
	getJsonData: function(hd, compress) {
		var json = hd.sheet.getJsonData(compress);
		return json
	},
	addCalculates: function(calculates) {
		var calculate = EnterpriseSheet.sheet.calculate.Calculate.prototype,
			hint = EnterpriseSheet.sheet.floating.CalculateHint.prototype,
			fails = [];
		for(var p in calculates) {
			if(calculates.hasOwnProperty(p)) {
				var it = calculates[p],
					calFun = it.fn,
					calHint = it.hint;
				if(calculate.addCalculate(p, calFun)) {
					if(calHint) {
						hint.addHint(calHint)
					}
				} else {
					fails.push(p)
				}
			}
		}
		if(0 < fails.length) {
			return fails
		}
	},
	addCalculateExceptions: function(calExceptions) {
		var fails = [];
		for(var p in calExceptions) {
			if(calExceptions.hasOwnProperty(p)) {
				var it = calExceptions[p];
				if(!SCALEXP.addExceptionInfo(p, it)) {
					fails.push(p)
				}
			}
		}
		if(0 < fails.length) {
			return fails
		}
	},
	getSheetTabData: function(hd) {
		var store = hd.sheet.getStore();
		var sheets = store.getSheets(),
			arr = [],
			activedSheetId = store.getActivedSheetId();
		for(var i = 0, len = sheets.length; i < len; i++) {
			var it = sheets[i];
			arr.push({
				id: it.id,
				name: it.name,
				actived: activedSheetId === it.id,
				color: it.color
			})
		}
		return arr
	},
	getActivedSheetId: function(hd) {
		var store = hd.sheet.getStore();
		return store.getActivedSheetId()
	},
	getTabnameById: function(hd, tabId) {
		var store = hd.sheet.getStore();
		var sheets = store.getSheets();
		for(var i = 0, len = sheets.length; i < len; i++) {
			var it = sheets[i];
			if(it.id == tabId) {
				return it.name
			}
		}
		return null
	},
	addSheetTab: function(hd, sheetTabConfig, callback, scope, notSwitchToNewSheet) {
		var sheet = hd.sheet,
			store = hd.store;
		store.addSheet(sheetTabConfig, function(data) {
			var sheetId = data.id;
			if(!notSwitchToNewSheet) {
				sheet.loadSwitchSheet(sheetId, function() {
					if(callback) {
						callback.call(scope, sheetId, hd)
					}
				}, this)
			} else {
				if(callback) {
					callback.call(scope, sheetId, hd)
				}
			}
		}, this)
	},
	updateSheetTab: function(hd, sheetTabConfig, callback, scope, notSwitchToNewSheet) {
		var sheet = hd.sheet,
			store = hd.store;
		store.updateSheetTab(sheetTabConfig.sheetId, sheetTabConfig, function(sheetId) {
			if(!notSwitchToNewSheet) {
				sheet.loadSwitchSheet(sheetId, function() {
					if(callback) {
						callback.call(scope, sheetId, hd)
					}
				}, this)
			} else {
				if(callback) {
					callback.call(scope, sheetId, hd)
				}
			}
		}, this)
	},
	deleteSheetTab: function(hd, sheetTabId, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		store.deleteSheet(sheetTabId, function() {
			var activedSheetId = store.getActivedSheetId();
			sheet.loadSwitchSheet(activedSheetId, function() {
				if(callback) {
					callback.call(scope, hd)
				}
			}, this)
		}, this)
	},
	copySheetTab: function(hd, sheetTabId, newName, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		return store.copySheet(sheetTabId, newName, function(newSheet) {
			if(callback) {
				callback.call(scope, newSheet.id, hd)
			}
		}, this)
	},
	toggleGridLine: function(hd, hideLine, sheetId) {
		var sheet = hd.sheet;
		if(hideLine) {
			sheet.hideGridLine(undefined, sheetId)
		} else {
			sheet.showGridLine(undefined, sheetId)
		}
	},
	getCell: function(hd, sheetId, rowIndex, colIndex) {
		var sheet = hd.sheet;
		if(!Ext.isDefined(sheetId)) {
			sheetId = sheet.getSheetId()
		}
		return sheet.getCellData(sheetId, rowIndex, colIndex)
	},
	getCellValue: function(hd, sheetId, rowIndex, colIndex) {
		var sheet = hd.sheet;
		if(!Ext.isDefined(sheetId)) {
			sheetId = sheet.getSheetId()
		}
		return sheet.getCellValue(sheetId, rowIndex, colIndex)
	},
	insertFloatingItem: function(hd, sheetTabId, config, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		if(!Ext.isDefined(sheetTabId)) {
			sheetTabId = store.getActivedSheetId()
		}
		var ftype = config.ftype;
		delete(config.ftype);
		if("wedgit" === ftype) {
			var url = config.url;
			delete(config.url);
			sheet.createWedgit(url, Ext.apply({
				sheetId: sheetTabId
			}, config))
		} else {
			if("picture" === ftype) {
				var url = config.url;
				delete(config.url);
				sheet.createPicture(url, Ext.apply({
					sheetId: sheetTabId
				}, config))
			} else {
				if("chart" === ftype) {
					var source = config.source;
					config.sheetId = sheetTabId;
					source.seriesPosition = config.seriesPosition;
					source.cacheFields = SCOM.copy(source.cacheFields);
					sheet.prepareSource(source);
					var rangeStore = sheet.createRangeStore(source);
					sheet.createChart(config.chartType, rangeStore, config, true, true)
				}
			}
		}
		sheet.refreshFloor()
	},
	insertDynamicRange: function(hd, config, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		var sheetTabId = config.sheet;
		if(!Ext.isDefined(sheetTabId)) {
			sheetTabId = store.getActivedSheetId()
		}
		var name = config.name;
		if(!store.getFloatingItem(sheetTabId, name)) {
			var json = config.json;
			if(!json && config.jsonObj) {
				json = Ext.encode(config.jsonObj)
			}
			store.setFloatingItem(sheetTabId, name, "dynamicRange", json)
		} else {
			return false
		}
	},
	setMergeCells: function(hd, floatings, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		var len = floatings.length;
		for(var i = 0; i < len; i++) {
			var data = floatings[i],
				ftype = data.ftype,
				sheetId = parseInt(data.sheet);
			if(ftype === "meg") {
				var span = data.json;
				if(typeof span === "string" || span instanceof String) {
					span = Ext.decode(span)
				}
				span = [sheetId].concat(span);
				sheet.mergeCellForSpan(span, false, false)
			}
		}
		sheet.refresh();
		if(callback) {
			callback.call(scope, false)
		}
	},
	updateFloatings: function(hd, floatings, callback, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		var len = floatings.length;
		for(var i = 0; i < len; i++) {
			var data = floatings[i],
				ftype = data.ftype,
				sheetId = parseInt(data.sheet);
			if(ftype === "meg") {
				var span = data.json;
				if(typeof span === "string" || span instanceof String) {
					span = Ext.decode(span)
				}
				span = [sheetId].concat(span);
				sheet.mergeCellForSpan(span, false, false)
			}
		}
		sheet.refresh();
		if(callback) {
			callback.call(scope, false)
		}
	},
	addDropdownStore: function(hd, storeName, config, callback, scope) {
		var sheet = hd.sheet;
		sheet.addDropdownStore(storeName, config, callback, scope)
	},
	getFilename: function(hd) {
		var store = hd.sheet.getStore();
		return store.getLoadedFileName()
	},
	toggleFreeze: function(hd) {
		var ss = hd.sheet;
		if(ss.isFreezed()) {
			ss.unfreeze()
		} else {
			var sm = ss.getSelectionModel();
			var pos = sm.getMinMaxPos();
			ss.freeze(pos.minrow, pos.mincol);
			return ss.freezePos
		}
	},
	insertRow: function(hd, sheetId, row, rowSpan, expandCalInNext) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		var insertedRowNo = 1;
		if(rowSpan && rowSpan > 1) {
			insertedRowNo = rowSpan
		}
		store.insertRow(sheetId, row, insertedRowNo, undefined, undefined, undefined, expandCalInNext);
		if(Ext.isFunction(sheet.refreshFocus)) {
			sheet.refreshFocus()
		}
	},
	insertColumn: function(hd, sheetId, column, colSpan, expandCalInNext) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		var insertedColNo = 1;
		if(colSpan && colSpan > 1) {
			insertedColNo = colSpan
		}
		store.insertColumn(sheetId, column, insertedColNo, undefined, undefined, undefined, expandCalInNext);
		if(Ext.isFunction(sheet.refreshFocus)) {
			sheet.refreshFocus()
		}
	},
	freezeSheet: function(hd, row, column) {
		var ss = hd.sheet;
		if(ss.isFreezed()) {
			ss.unfreeze()
		}
		ss.freeze(row + 1, column + 1);
		return ss.freezePos
	},
	applyRangeBorder: function(hd, sheetId, startRow, startCol, endRow, endCol, position, color, width, lineType) {
		var sheet = hd.sheet;
		var coord = [
			[sheetId, startRow, startCol, endRow, endCol]
		];
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		if(!width) {
			width = 1
		}
		if(!lineType) {
			lineType = "solid"
		}
		if(!color) {
			color = "black"
		}
		range.setRangeBorder(position, color, width, lineType)
	},
	applyCellsBorder: function(hd, coord, conf) {
		var sheet = hd.sheet;
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		var width = conf.width,
			lineType = conf.lineType,
			color = conf.color;
		if(!width) {
			width = 1
		}
		if(!lineType) {
			lineType = "solid"
		}
		if(!color) {
			color = "black"
		}
		range.setRangeBorder(conf.position, color, width, lineType)
	},
	clearCellsBorder: function(hd, coord) {
		var sheet = hd.sheet;
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		range.setRangeBorder("all", "", 1, "solid")
	},
	applyTableTpl: function(hd, sheetId, startRow, startCol, endRow, endCol, tpl, trigger) {
		var sheet = hd.sheet;
		if(trigger == null) {
			trigger = true
		}
		var tpl = {
			id: tpl,
			span: [sheetId, startRow, startCol, endRow, endCol]
		};
		var cellObjs = [];
		for(var i = startRow; i <= endRow; i++) {
			for(var j = startCol; j <= endCol; j++) {
				if(trigger == false && i == startRow) {
					cellObjs.push({
						sheet: sheetId,
						row: i,
						col: j,
						json: {
							tpl: Ext.encode(tpl),
							trigger: false
						},
						applyWay: "apply"
					})
				} else {
					cellObjs.push({
						sheet: sheetId,
						row: i,
						col: j,
						json: {
							tpl: Ext.encode(tpl)
						},
						applyWay: "apply"
					})
				}
			}
		}
		this.updateCells(hd, cellObjs)
	},
	clearTableTpl: function(hd, span) {
		var sheet = hd.sheet;
		var tableTpl = sheet.getTableTpl();
		if(tableTpl) {
			tableTpl.clearTplForSpan(span)
		}
	},
	setWholeRowHeight: function(hd, height) {
		var sheet = hd.sheet,
			pos = {
				minrow: 0
			};
		sheet.setRowHeight(height, pos)
	},
	reportServerError: function(serverFailure) {
		if(!SCONFIG.NOT_REPORT_ERROR2SERVER) {
			if(!this.errorReportWin) {
				this.errorReportWin = Ext.create("EnterpriseSheet.sheet.pop.ErrorReportWin", {
					reportCallback: {
						fn: function(comment) {
							Ext.Ajax.request({
								url: SCONFIG.urls.createServerErrorReport,
								params: {
									action: serverFailure.action,
									params: Ext.encode(serverFailure.params),
									comment: comment
								}
							})
						},
						scope: this
					}
				})
			}
			this.errorReportWin.show()
		}
	},
	showSidebarBtnWin: function(hd, btn, callback, scope) {
		var sidebar = hd.sidebar;
		if(sidebar) {
			if(btn == "chart") {
				btn = sidebar.chartBtn
			} else {
				if(btn == "cellStyle") {
					btn = sidebar.cellStyleBtn
				} else {
					if(btn == "tableStyle") {
						btn = sidebar.tableStyleBtn
					} else {
						if(btn == "search") {
							btn = sidebar.searchBtn
						} else {
							if(btn == "picture") {
								btn = sidebar.pictureBtn
							} else {
								if(btn == "widget") {
									btn = sidebar.wedgitBtn
								} else {
									if(btn == "condition") {
										btn = sidebar.conditionStyleBtn
									}
								}
							}
						}
					}
				}
			}
			sidebar.toggleOption(btn, undefined, function() {
				if(callback) {
					callback.call(scope, sidebar, hd)
				}
			})
		}
	},
	showRow: function(hd, startRow, endRow, sheetId) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		sheet.showRow({
			minrow: startRow,
			maxrow: endRow
		}, sheetId);
		if(Ext.isFunction(sheet.refreshFocus)) {
			sheet.refreshFocus()
		}
	},
	hideRow: function(hd, startRow, endRow, sheetId) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		sheet.hideRow({
			minrow: startRow,
			maxrow: endRow
		}, sheetId);
		if(Ext.isFunction(sheet.refreshFocus)) {
			sheet.refreshFocus()
		}
	},
	hideColumn: function(hd, startCol, endCol, sheetId) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		sheet.hideColumn({
			mincol: startCol,
			maxcol: endCol
		}, sheetId);
		if(Ext.isFunction(sheet.refreshFocus)) {
			sheet.refreshFocus()
		}
	},
	showColumn: function(hd, startCol, endCol, sheetId) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		sheet.showColumn({
			mincol: startCol,
			maxcol: endCol
		}, sheetId);
		if(Ext.isFunction(sheet.refreshFocus)) {
			sheet.refreshFocus()
		}
	},
	setCondition: function(hd, coord, cdtName, config) {
		var sheet = hd.sheet;
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		range.setCondition(cdtName, config);
		sheet.refreshFocus()
	},
	clearCondition: function(hd, coord) {
		var sheet = hd.sheet;
		var range = new EnterpriseSheet.sheet.range.Range({
			sheet: sheet,
			coord: coord
		});
		range.clearCondition();
		sheet.refreshFocus()
	},
	updateGroups: function(hd, groups) {
		var sheet = hd.sheet;
		sheet.applyGroups(groups);
		sheet.refreshFocus()
	},
	cancelGroup: function(hd, dir, start, end) {
		var sheet = hd.sheet;
		if("col" == dir) {
			sheet.updateColGroup("cancel", start, end)
		} else {
			if("row" == dir) {
				sheet.updateRowGroup("cancel", start, end)
			}
		}
		sheet.refreshFocus()
	},
	getSelectedRangeData: function(hd) {
		var ss = hd.sheet,
			sm = ss.getSelectionModel(),
			pos = sm.getMinMaxPos();
		var minX = pos.minrow,
			minY = pos.mincol,
			maxX = pos.maxrow,
			maxY = pos.maxcol;
		var sheetId = ss.getSheetId();
		var result = [];
		for(var i = minX; i <= maxX; i++) {
			for(var j = minY; j <= maxY; j++) {
				var cell = ss.getCellData(sheetId, i, j);
				var cellObj = {
					row: i,
					col: j,
					val: cell.data
				};
				result.push(cellObj)
			}
		}
		return result
	},
	getCellsComment: function(hd, sheetId) {
		var sheet = hd.sheet,
			store = hd.store,
			result = [];
		if(sheetId == null) {
			sheetId = sheet.getSheetId()
		}
		var coord = [
			[sheetId, 0, 0, 0, 0]
		];
		store.walkRange(coord, function(rd) {
			var row = rd.data.row,
				col = rd.data.col,
				currentSheetId = rd.data.sheet;
			if(0 !== row && 0 !== col && rd.data.json.comment) {
				var cell = store.getCellData(sheetId, row, col),
					data = cell.data;
				if(cell.comment) {
					if(rd.data.json.cal) {
						cell = SHEET_API.getCellValue(SHEET_API_HD, sheetId, row, col);
						data = cell.data
					}
					var cellObj = {
						sheetId: sheetId,
						x: row,
						y: col,
						comment: cell.comment,
						result: data
					};
					result.push(cellObj)
				}
			}
		}, this);
		return result
	},
	setValueToVariable: function(hd, vnVals) {
		var sheet = hd.sheet;
		sheet.fireEvent("disablehistory", sheet);
		sheet.setValueToVariable(vnVals, true);
		sheet.fireEvent("enablehistory", sheet)
	},
	getCellVariables: function(hd) {
		var sheet = hd.sheet;
		return sheet.getCellVariables()
	},
	clearAllVariables: function(hd) {
		hd.sheet.clearAllVariables()
	},
	copyPasteRange: function(hd, fromCoord, toCoord, pasteType, cutFlag, callback, scope, skipHiddenCell) {
		var sheet = hd.sheet;
		sheet.pasteRange(fromCoord, toCoord, pasteType, cutFlag, callback, scope, skipHiddenCell)
	},
	sortCellByAsc: function(hd, span) {
		var sheet = hd.sheet;
		sheet.checkSortSpan(span, null, "asc")
	},
	sortCellByDesc: function(hd, span) {
		var sheet = hd.sheet;
		sheet.checkSortSpan(span, null, "desc")
	},
	isMergedCell: function(hd, sheetId, row, col) {
		var sheet = hd.sheet,
			store = hd.store;
		var cell = store.getCell(sheetId, row, col);
		return store.isMergedCell(cell, sheetId, row, col)
	},
	mergeCellForSpan: function(hd, span, suspendEvent, suspendRefresh) {
		var sheet = hd.sheet;
		sheet.mergeCellForSpan(span, suspendEvent, suspendRefresh)
	},
	deleteCommentForCoord: function(hd, coord, suspendEvent, suspendRefresh) {
		var sheet = hd.sheet;
		sheet.deleteComment(coord, suspendEvent, suspendRefresh)
	},
	getItemValueByName: function(hd, name) {
		var sheet = hd.sheet;
		return sheet.getItemValueByName(name)
	},
	setFocus: function(hd, row, col) {
		var sm = hd.sheet.getSelectionModel();
		sm.selectRange({
			row: row,
			col: col
		}, {
			row: row,
			col: col
		}, false);
		sm.setFocusCell(row, col, false)
	},
	setMaxRowNumber: function(maxRow) {
		if(Ext.isNumber(Number(maxRow)) && maxRow > 20) {
			SCONST.MAX_ROW_NUMBER = maxRow
		}
	},
	setMaxColNumber: function(maxCol) {
		if(Ext.isNumber(Number(maxCol)) && maxCol > 5) {
			SCONST.MAX_COLUMN_NUMBER = maxCol
		}
	},
	setColNameVisible: function(hd, sheetId, visible) {
		hd.sheet.setColNameVisible(visible, sheetId)
	},
	setRowNameVisible: function(hd, sheetId, visible) {
		hd.sheet.setRowNameVisible(visible, sheetId)
	},
	getDefinedNameContent: function(hd, definedName) {
		return hd.store.getDefinedNameContent(definedName)
	},
	toggleTitleBar: function(hd, visible) {
		var titleBar = hd.getTitlebar();
		if(titleBar) {
			if(SCOM.isEmptyValue(visible)) {
				visible = !titleBar.isVisible()
			}
			if(true === visible) {
				titleBar.show()
			} else {
				if(false === visible) {
					titleBar.hide()
				}
			}
			hd.getAppContainer().doLayout()
		}
	},
	toggleToolBar: function(hd, visible) {
		var toolbar = hd.getToolbar();
		if(toolbar) {
			if(SCOM.isEmptyValue(visible)) {
				visible = !toolbar.isVisible()
			}
			if(true === visible) {
				toolbar.show()
			} else {
				if(false === visible) {
					toolbar.hide()
				}
			}
			hd.getAppContainer().doLayout()
		}
	},
	addFilter2Span: function(hd, span, filterCdts, persist) {
		var sheet = hd.sheet,
			filter = sheet.getFilter();
		filter.createFilterForSpan(span, false, filterCdts, !persist)
	},
	removeFilter: function(hd, sheetId, persist) {
		var sheet = hd.sheet,
			filter = sheet.getFilter();
		filter.cleanFilterForSheet(sheetId, false, !persist)
	},
	getDefinedNameContent: function(hd, definedName) {
		return hd.store.getDefinedNameContent(definedName)
	},
	getDefinedNamedRange: function(hd, name, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		var nameRefObj = store.getNamedFuncConfigByName(name);
		var nameObj = null;
		if(nameRefObj && nameRefObj.ctype == "named_func") {
			var nameRefJson = nameRefObj.json;
			var nameRefArr = Ext.decode(nameRefJson);
			var refPos = null;
			for(var i = 0, len = nameRefArr.length; i < len; i++) {
				var refScope = nameRefArr[i].scope;
				if((refScope == null && scope == null) || refScope == scope) {
					refPos = i;
					break
				}
			}
			if(refPos !== null) {
				var cells = this.getCellsByAddress(hd, nameRefArr[refPos].cal);
				nameObj = {
					name: nameRefObj.name,
					rangeOfAddress: nameRefArr[refPos].cal,
					comment: nameRefArr[refPos].comment,
					scopeSheetId: nameRefArr[refPos].scope,
					cells: cells
				}
			}
		}
		return nameObj
	},
	getAllDefinedNamedRangeNames: function(hd) {
		var sheet = hd.sheet,
			store = hd.store,
			funcs = [];
		var refList = store.getNamedFuncConfig();
		for(var i = 0, len = refList.length; i < len; i++) {
			var it = refList[i],
				ctype = it.ctype;
			if("named_func" == ctype) {
				var cal = it.json,
					scope, flag = true;
				try {
					var jsonObj = Ext.decode(it.json);
					if(!Ext.isArray(jsonObj)) {
						jsonObj = [jsonObj]
					}
					for(var k = 0, size = jsonObj.length; k < size; k++) {
						var jsonIt = jsonObj[k];
						scope = jsonIt.scope;
						cal = jsonIt.cal;
						funcs.push({
							id: it.id,
							name: it.name,
							scopeSheetId: (!Ext.isDefined(scope)) ? null : Number(scope),
							rangeOfAddress: cal,
							comment: jsonIt.comment
						})
					}
				} catch(e) {
					funcs.push({
						id: it.id,
						name: it.name,
						scopeSheetId: (!Ext.isDefined(scope)) ? null : Number(scope),
						rangeOfAddress: cal
					})
				}
			}
		}
		return funcs
	},
	createNamedRange: function(hd, nameRangeObj) {
		var sheet = hd.sheet,
			store = hd.store,
			calculate = sheet.calculate,
			name = nameRangeObj.name,
			scopeSheetId = nameRangeObj.scopeSheetId;
		var result = {
			result: true
		};
		var cals = calculate.calculates;
		var upper = name.toUpperCase();
		var lower = name.toLowerCase();
		if(cals[upper] || cals[lower]) {
			return {
				msg: "name is pre-defined as formula name",
				result: false,
				errorcode: 1
			}
		} else {
			if(-1 != upper.indexOf(" ") || 0 < EnterpriseSheet.sheet.calculate.Coordinate.prototype.string2Coord(upper).length || Ext.isNumber(Number(upper)) || !(/^[a-zA-Z_]/.test(upper))) {
				return {
					msg: "name is not valid",
					result: false,
					errorcode: 2
				}
			}
		}
		var result = store.isNameFnExistWithNameScope(name, scopeSheetId);
		if(!result) {
			sheet.updateNamedFunc(name, nameRangeObj.rangeOfAddress, nameRangeObj.scopeSheetId, nameRangeObj.comment)
		} else {
			return {
				msg: "name already in use",
				result: false,
				errorcode: 3
			}
		}
		return result
	},
	deleteNamedRangeByName: function(hd, name, scope) {
		var sheet = hd.sheet,
			store = hd.store;
		var nameRefObj = store.getNamedFuncConfigByName(name);
		var result = false;
		if(nameRefObj && nameRefObj.ctype == "named_func") {
			sheet.deleteNamedFunc(name, scope);
			result = true
		}
		return result
	},
	updateNamedRangeAddress: function(hd, name, scopeSheetId, address) {
		var sheet = hd.sheet,
			store = hd.store,
			calculate = sheet.calculate;
		var result = false;
		var result = store.isNameFnExistWithNameScope(name, scopeSheetId);
		if(result) {
			sheet.updateNamedFunc(name, address, scopeSheetId)
		} else {
			return {
				msg: "name range is not existing yet, please create range first: " + name,
				result: false,
				errorcode: 3
			}
		}
		return result
	},
	updateNamedRangeComment: function(hd, name, scopeSheetId, comment) {
		var sheet = hd.sheet,
			store = hd.store,
			calculate = sheet.calculate;
		var result = false;
		var result = store.isNameFnExistWithNameScope(name, scopeSheetId);
		if(result) {
			sheet.updateNamedFunc(name, null, scopeSheetId, comment)
		} else {
			return {
				msg: "name range is not existing yet, please create range first: " + name,
				result: false,
				errorcode: 3
			}
		}
		return result
	},
	getCellsByAddress: function(hd, address) {
		var sheet = hd.sheet,
			store = hd.store,
			cells = [];
		var coord = EnterpriseSheet.pure.sheet.calculate.Coordinate.prototype.string2Coord(address);
		if(coord && 0 < coord.length) {
			coord = coord[0].span,
				sheetId = null;
			if(!Ext.isNumber(coord[0])) {
				sheetId = store.getSheetIdByName(coord[0]);
				if(SCOM.nullOrUndefined(sheetId)) {
					return cells
				}
			}
			for(var i = coord[1]; i <= coord[3]; i++) {
				for(var j = coord[2]; j <= coord[4]; j++) {
					var cell = sheet.getCellData(sheetId, i, j);
					var cellObj = {
						sheetId: sheetId,
						row: i,
						col: j,
						val: cell.data
					};
					cells.push(cellObj)
				}
			}
		}
		return cells
	},
	undo: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		sheet.fireEvent("undo", false)
	},
	redo: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		sheet.fireEvent("redo", false)
	},
	resetHistory: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		sheet.fireEvent("resethistory", sheet)
	},
	getAllChanges: function(hd) {
		var toolbar = hd.getToolbar();
		var history = toolbar.getHistory();
		return history.getStack()
	},
	purgeChangeList: function(hd, step) {
		if(step == null || step < 1) {
			step = 1
		} else {
			if(step > 20) {
				step = 20
			}
		}
		var sheet = hd.sheet,
			store = hd.store;
		for(var i = 0; i < step; i++) {
			sheet.fireEvent("undo", false)
		}
	},
	redoChange: function(hd, step) {
		if(step == null || step < 1) {
			step = 1
		} else {
			if(step > 20) {
				step = 20
			}
		}
		var sheet = hd.sheet,
			store = hd.store;
		for(var i = 0; i < step; i++) {
			sheet.fireEvent("redo", false)
		}
	},
	cut: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var clipboard = sheet.getClipboard();
		if(clipboard) {
			clipboard.cut()
		}
	},
	copy: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var clipboard = sheet.getClipboard();
		if(clipboard) {
			clipboard.copy()
		}
	},
	paste: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var clipboard = sheet.getClipboard();
		if(clipboard) {
			clipboard.paste()
		}
	},
	bold: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var data = sheet.getFocusCellData();
		var flag = "bold" != data.fw;
		if(false !== sheet.fireEvent("cmd", "bold", flag, sheet)) {
			if(flag) {
				sheet.setPropertyForSelection({
					fw: "bold"
				})
			} else {
				sheet.setPropertyForSelection({
					fw: ""
				})
			}
		}
	},
	italic: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var data = sheet.getFocusCellData();
		var flag = "italic" != data.fs;
		if(false !== sheet.fireEvent("cmd", "italic", flag, sheet)) {
			if(flag) {
				sheet.setPropertyForSelection({
					fs: "italic"
				})
			} else {
				sheet.setPropertyForSelection({
					fs: ""
				})
			}
		}
	},
	underline: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var data = sheet.getFocusCellData();
		var flag = "underline" != data.u;
		if(false !== sheet.fireEvent("cmd", "underline", flag, sheet)) {
			if(flag) {
				sheet.setPropertyForSelection({
					u: "underline"
				})
			} else {
				sheet.setPropertyForSelection({
					u: ""
				})
			}
		}
	},
	strikeline: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var data = sheet.getFocusCellData();
		var flag = "line-through" != data.u;
		if(false !== sheet.fireEvent("cmd", "strikethrough", flag, sheet)) {
			if(flag) {
				sheet.setPropertyForSelection({
					s: "line-through"
				})
			} else {
				sheet.setPropertyForSelection({
					s: ""
				})
			}
		}
	},
	fontFamily: function(hd, ff) {
		var sheet = hd.sheet,
			store = hd.store;
		var editor = sheet.editor;
		if(editor && editor.isVisible()) {
			editor.focus()
		}
		ff = ff || "Arial";
		if(false !== sheet.fireEvent("cmd", "fontName", ff, sheet)) {
			sheet.setPropertyForSelection({
				ff: ff
			})
		}
	},
	fontSize: function(hd, fz) {
		var sheet = hd.sheet,
			store = hd.store;
		var editor = sheet.editor;
		if(editor && editor.isVisible()) {
			editor.focus()
		}
		fz = fz || "10";
		if(false !== sheet.fireEvent("cmd", "fontSize", fz, sheet)) {
			sheet.setPropertyForSelection({
				fz: fz
			})
		}
	},
	fillBackgroundColor: function(hd, color) {
		var sheet = hd.sheet,
			store = hd.store;
		sheet.setPropertyForSelection({
			bgc: color || ""
		})
	},
	fontColor: function(hd, color) {
		var sheet = hd.sheet,
			store = hd.store;
		var editor = sheet.editor;
		if(editor && editor.isVisible()) {
			editor.focus()
		}
		var fc = color;
		if(false !== sheet.fireEvent("cmd", "forecolor", fc, sheet)) {
			sheet.setPropertyForSelection({
				color: fc
			})
		}
	},
	incFontSize: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var data = sheet.getFocusCellData();
		var fz = parseInt(data.fz);
		if(!Ext.isNumber(fz)) {
			fz = store.defaultFontSize
		}
		fz += 2;
		sheet.setPropertyForSelection({
			fz: fz
		})
	},
	desFontSize: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var data = sheet.getFocusCellData();
		var fz = parseInt(data.fz);
		if(!Ext.isNumber(fz)) {
			fz = store.defaultFontSize
		}
		if(fz - 2 > store.minFontSize) {
			fz -= 2
		} else {
			fz = store.minFontSize
		}
		sheet.setPropertyForSelection({
			fz: fz
		})
	},
	alignSet: function(hd, dir) {
		var sheet = hd.sheet,
			store = hd.getStore();
		if(dir == "left" || dir == "center" || dir == "right") {
			sheet.setPropertyForSelection({
				ta: dir || "left"
			})
		} else {
			sheet.setPropertyForSelection({
				va: dir || "top"
			})
		}
	},
	setRangeBorder: function(hd, dir, color, width, style, suspendRefresh) {
		var sheet = hd.sheet,
			store = hd.getStore();
		dir = dir || "all";
		if(false == SCOM.typeOf(color)) {
			color = "black"
		}
		if(false == SCOM.typeOf(width)) {
			width = 1
		}
		sheet.setRangeBorder(dir, color, width, style, suspendRefresh)
	},
	wordWrap: function(hd) {
		var sheet = hd.getSheet(),
			store = hd.getStore();
		var data = sheet.getFocusCellData();
		var ws = "nowrap",
			ww = "normal";
		if(!data.ws || data.ws == ws) {
			ws = "normal";
			ww = "break-word"
		}
		sheet.setPropertyForSelection({
			ws: ws,
			ww: ww
		})
	},
	rotateText: function(hd, angle) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var data = sheet.getFocusCellData();
		var flag = angle != data.rotation;
		if(false !== sheet.fireEvent("cmd", "rotation", flag, sheet)) {
			if(flag) {
				sheet.setPropertyForSelection({
					rotation: angle
				})
			} else {
				sheet.setPropertyForSelection({
					rotation: ""
				})
			}
		}
	},
	mergeCell: function(hd) {
		hd.sheet.mergeSelectedCell()
	},
	mergeCellInColumn: function(hd) {
		hd.sheet.mergeCellInColumn()
	},
	mergeCellInRow: function(hd) {
		hd.sheet.mergeCellInRow()
	},
	cancelMergeCell: function(hd) {
		hd.sheet.cancelMergeCell()
	},
	moveDecimalPoint: function(hd, num) {
		hd.sheet.moveDecimalPoint(num)
	},
	toggleColumnName: function(hd) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		if(!store.colNameHidden) {
			sheet.setColNameVisible(false)
		} else {
			sheet.setColNameVisible(true)
		}
	},
	toggleRowName: function(hd) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		if(!store.rowNameHidden) {
			sheet.setRowNameVisible(false)
		} else {
			sheet.setRowNameVisible(true)
		}
	},
	zoom: function(hd, zoom) {
		var sheet = hd.sheet,
			store = sheet.getStore();
		sheet.changeZoom(zoom)
	},
	currencyFormat: function(hd, currencyName, decimalNo, negativeFormat, showName) {
		var name = SCONST.money_code[currencyName];
		if(showName) {
			name = currencyName.toUpperCase()
		}
		currencyName = currencyName || SCONFIG.default_currency;
		decimalNo = decimalNo || "2";
		negativeFormat = negativeFormat || "none";
		var format = "money|" + name + "|" + decimalNo + "|" + negativeFormat;
		if(format) {
			hd.sheet.setTextFormatForSelection(format)
		}
	},
	currencyFormatWin: function(hd, currencyName) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var openMoneyWin = Ext.create("EnterpriseSheet.sheet.pop.money.MoneySelectWin", {});
		openMoneyWin.bindSheet(sheet);
		if(currencyName) {
			openMoneyWin.popup(currencyName)
		} else {
			openMoneyWin.popup()
		}
	},
	numberFormat: function(hd, fm) {
		fm = fm || SCONST.DEFAULT_COMMA_FORMAT;
		hd.sheet.setNumberFormatForSelection(fm)
	},
	localeFormat: function(hd, locale, options) {
		locale = locale || SCONFIG.default_locale;
		hd.sheet.setLocaleFormatForSelection(locale, options)
	},
	percentFormat: function(hd, fm) {
		fm = fm || SCONST.DEFAULT_PERCENT_FORMAT;
		hd.sheet.setPercentFormatForSelection(fm)
	},
	commaFormat: function(hd) {
		hd.sheet.setTextFormatForSelection(SCONST.FORMAT_COMMA)
	},
	scienceFormat: function(hd) {
		hd.sheet.setTextFormatForSelection(SCONST.FORMAT_SCIENCE)
	},
	dateFormat: function(hd, fm) {
		fm = fm || SCONST.jsDateFm[0];
		hd.sheet.setDateFormatForSelection(fm)
	},
	timeFormat: function(hd, fm) {
		fm = fm || SCONST.jsTimeFm[0];
		hd.sheet.setTimeFormatForSelection(fm)
	},
	dateTimeFormat: function(hd, fm) {
		fm = fm || SCONST.jsDateTimeFm[0];
		hd.sheet.setDateTimeFormatForSelection(fm)
	},
	insertBackgroundImage: function(hd) {
		var backgroundWin = Ext.create("EnterpriseSheet.sheet.pop.BackgroundWin", {});
		backgroundWin.popup()
	},
	insertPageBreak: function(hd) {
		hd.sheet.insertPageBreakAtFocus()
	},
	deletePageBreak: function(hd) {
		hd.sheet.deletePageBreakAtFocus()
	},
	insertComment: function(hd, scope) {
		SPOP.showCommentBox({
			title: SLANG.insert_comment,
			applyCallback: {
				fn: function(comment) {
					hd.sheet.insertComment(comment)
				},
				scope: scope
			}
		})
	},
	insertDropList: function(hd, scope) {
		var ss = hd.sheet;
		SPOP.showDropListConfig({
			title: SLANG.setup_droplist,
			fileId: ss.getStore().fileId,
			sheet: ss,
			applyCallback: {
				fn: function(json) {
					ss.insertDropList(json)
				},
				scope: scope
			}
		})
	},
	insertCheckbox: function(hd) {
		hd.sheet.setItemForSelection("checkbox", SCOM.genTimeStamp())
	},
	insertRadio: function(hd) {
		hd.sheet.setItemForSelection("radio", SCOM.genTimeStamp())
	},
	insertDatePicker: function(hd) {
		hd.sheet.insertDropList({
			drop: "date"
		})
	},
	clearItem: function(hd) {
		hd.sheet.clearItemForSelection()
	},
	nameRange: function(hd) {
		hd.sheet.markSelection()
	},
	insertHyperlink: function(hd, scope) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var sheetId = sheet.sheetId;
		var sm = sheet.getSelectionModel();
		var focusCell = sm.getFocusCell();
		var row = focusCell.row,
			col = focusCell.col;
		SPOP.showLinkBox({
			sheet: hd.sheet,
			title: SLANG.insert_hyperlink,
			width: 400,
			height: 150,
			applyCallback: {
				fn: function(url) {
					sheet.createHyperlink(url, sheetId, row, col)
				},
				scope: scope
			},
			urlValidator: function(val) {
				if(SCONST.urlReg.test(val)) {
					return true
				} else {
					if(EnterpriseSheet.sheet.calculate.Coordinate.prototype.isCoordSpan(val)) {
						return true
					} else {
						if("=" === val.charAt(0)) {
							val = val.slice(1)
						}
					}
				}
				return false
			}
		})
	},
	sum: function(hd) {
		this.getFunction(hd, "sum")
	},
	average: function(hd) {
		this.getFunction(hd, "average")
	},
	count: function(hd) {
		this.getFunction(hd, "count")
	},
	maxValue: function(hd) {
		this.getFunction(hd, "max")
	},
	minValue: function(hd) {
		this.getFunction(hd, "min")
	},
	insertFormula: function(hd) {
		var insertFormulaWin = Ext.create("EnterpriseSheet.sheet.pop.FormulaFunctionWin", {
			title: SLANG.insert_function,
			closeAction: "hide",
			spreadsheet: hd.sheet
		});
		insertFormulaWin.popup()
	},
	showValidation: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var coord = sheet.getSelectionModel().selection2Coord();
		SPOP.showValidationBox({
			sheet: sheet,
			rangeValue: coord
		})
	},
	deleteRepeatItem: function(hd) {
		hd.sheet.deleteRepeatItem()
	},
	toggleFreeze: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var sm = sheet.getSelectionModel();
		var pos = sm.getMinMaxPos();
		if(!sheet.isFreezed()) {
			if(sheet.isSplited()) {
				var row = 1,
					col = 1;
				if(sheet.ulefter.isVisible()) {
					row = sheet.ulefter.rowEnd + 1
				}
				if(ss.lheader.isVisible()) {
					col = sheet.lheader.colEnd + 1
				}
				sheet.freeze(row, col)
			} else {
				sheet.freeze(pos.minrow, pos.mincol)
			}
		} else {
			sheet.unfreeze()
		}
	},
	toggleSplit: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		if(!sheet.isSplited()) {
			if(sheet.isFreezed()) {
				var w = 0,
					h = 0;
				if(sheet.ulefter.isVisible()) {
					h = sheet.ulefter.getHeight()
				}
				if(sheet.lheader.isVisible()) {
					w = sheet.lheader.getWidth()
				}
				sheet.split(w, h)
			} else {
				var sm = sheet.getSelectionModel();
				var pos = sm.getMinMaxPos();
				var row = pos.minrow,
					col = pos.mincol;
				var rowStart = sheet.getRowStart(),
					colStart = sheet.getColStart();
				if(row > rowStart) {
					row--
				}
				if(col > colStart) {
					col--
				}
				var size = sheet.getCellPosition(row, col);
				sheet.split(size[0], size[1])
			}
		} else {
			sheet.unsplit()
		}
	},
	filter: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var filter = sheet.getFilter();
		if(filter) {
			filter.createFilterForSelecton()
		}
		sheet.focus()
	},
	toggleEditable: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var data = sheet.getFocusCellData();
		if("ed" === data.dsd) {
			sheet.setPropertyForSelection({
				dsd: ""
			})
		} else {
			sheet.setPropertyForSelection({
				dsd: "ed"
			})
		}
		var sm = sheet.getSelectionModel();
		var focusCell = sm.getFocusCell();
		sheet.fireEvent("refreshfocus", focusCell.row, focusCell.col, sm)
	},
	toggleEditableForOther: function(hd) {
		var sheet = hd.sheet,
			store = hd.getStore();
		var data = sheet.getFocusCellData();
		var userId = store.getUserInfo().id;
		if(data.dsd && "[" + userId + "]" === data.dsd) {
			sheet.setPropertyForSelection({
				dsd: ""
			})
		} else {
			sheet.setPropertyForSelection({
				dsd: Ext.encode([userId])
			})
		}
		var sm = sheet.getSelectionModel();
		var focusCell = sm.getFocusCell();
		sheet.fireEvent("refreshfocus", focusCell.row, focusCell.col, sm)
	},
	clean: function(hd, skipHiddenCell) {
		hd.sheet.cleanSelection(undefined, skipHiddenCell)
	},
	cleanContent: function(hd, skipHiddenCell) {
		hd.sheet.cleanSelection("content", skipHiddenCell)
	},
	cleanStyle: function(hd, skipHiddenCell) {
		hd.sheet.cleanSelection("style", skipHiddenCell)
	},
	getFunction: function(hd, name) {
		Ext.Function.defer(function() {
			var ss = hd.sheet,
				editor = ss.editor;
			editor.setValue("=" + name.toUpperCase() + "(");
			var region = ss.getCurrentRegion();
			var sm = region.getSelectionModel();
			var fc = sm.getFocusCell();
			editor.startEdit(fc.row, fc.col, region, null, false, true)
		}, 100, this)
	},
	listFormulaFunctions: function(hd, category) {
		var formulaData = EnterpriseSheet.sheet.floating.CalculateHint.prototype.hintData;
		var results = [];
		for(var i = 0; i < formulaData.length; i++) {
			var typeValue = (formulaData[i])[3];
			if(typeValue == category) {
				var formulaDetail = {
					name: (formulaData[i])[0],
					example: (formulaData[i])[1],
					description: (formulaData[i])[2]
				};
				results.push(formulaDetail)
			}
		}
		return results
	},
	functionListMathmatics: function(hd) {
		return this.listFormulaFunctions(hd, "numeric")
	},
	functionListLogic: function(hd) {
		return this.listFormulaFunctions(hd, "logic")
	},
	functionListLookup: function(hd) {
		return this.listFormulaFunctions(hd, "lookup")
	},
	functionListStatistical: function(hd) {
		return this.listFormulaFunctions(hd, "statistical")
	},
	functionListEngineering: function(hd) {
		return this.listFormulaFunctions(hd, "engineering")
	},
	functionListCompatibility: function(hd) {
		return this.listFormulaFunctions(hd, "compatibility")
	},
	functionListFinancial: function(hd) {
		return this.listFormulaFunctions(hd, "finicial")
	},
	functionListText: function(hd) {
		return this.listFormulaFunctions(hd, "string")
	},
	functionListDate: function(hd) {
		return this.listFormulaFunctions(hd, "date")
	},
	functionListInformation: function(hd) {
		return this.listFormulaFunctions(hd, "info")
	},
	conditionStyleStore: function(hd) {
		var json = SCOM.boolStyleStore.data;
		var results = [];
		for(var i = 0; i < json.length; i++) {
			var item = json.items[i].data;
			var detail = {
				id: item.id,
				text: item.text,
				style: item.style
			};
			results.push(detail)
		}
		return results
	},
	conditionDateOptionStore: function(hd) {
		var json = SCOM.dateOptionStore.data;
		var results = [];
		for(var i = 0; i < json.length; i++) {
			var item = json.items[i].data;
			var detail = {
				id: item.id,
				text: item.text
			};
			results.push(detail)
		}
		return results
	},
	conditionRepeatStore: function(hd) {
		var json = SCOM.repeatStore.data;
		var results = [];
		for(var i = 0; i < json.length; i++) {
			var item = json.items[i].data;
			var detail = {
				id: item.id,
				text: item.text
			};
			results.push(detail)
		}
		return results
	},
	condition_highlight_cells_bool: function(hd, type, value, style) {
		var sheet = hd.sheet,
			store = hd.store;
		var opt = {
			type: type,
			base: value,
			style: style
		};
		sheet.setConditionForSelection("boolstyle", opt, sheet.sheetId, false)
	},
	conditionGreater: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "greater", value, style)
	},
	conditionLess: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "less", value, style)
	},
	conditionEqual: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "equal", value, style)
	},
	conditionBetween: function(hd, min, max, style) {
		var base = {
			min: min,
			max: max
		};
		this.condition_highlight_cells_bool(hd, "between", base, style)
	},
	conditionInclude: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "include", value, style)
	},
	conditionDate: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "date", value, style)
	},
	conditionRepeat: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "repeat", value, style)
	},
	conditionAbove: function(hd, style) {
		this.condition_highlight_cells_bool(hd, "average", 0, style)
	},
	conditionBelow: function(hd, style) {
		this.condition_highlight_cells_bool(hd, "average", 1, style)
	},
	conditionMax: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "max", value, style)
	},
	conditionTop: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "top", value, style)
	},
	conditionMin: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "min", value, style)
	},
	conditionBottom: function(hd, value, style) {
		this.condition_highlight_cells_bool(hd, "bottom", value, style)
	},
	conditionColorBar: function(hd, color) {
		var sheet = hd.sheet,
			store = hd.store;
		var opt = {
			pos: "red",
			neg: "green"
		};
		var colorTpl = new Ext.XTemplate("rgb({0},{1},{2})").compile();
		if(color) {
			opt = {
				pos: colorTpl.apply(color),
				neg: colorTpl.apply([255 - color[0], 255 - color[1], 255 - color[2]])
			}
		}
		sheet.setConditionForSelection("colorbar", opt)
	},
	conditionColorChange: function(hd, start, stop, end) {
		var sheet = hd.sheet,
			store = hd.store;
		var opt = {
			start: [90, 190, 123],
			end: [248, 105, 107]
		};
		if(start) {
			opt = opt || {};
			opt.start = start
		}
		if(stop) {
			opt = opt || {};
			opt.stop = stop
		}
		if(end) {
			opt = opt || {};
			opt.end = end
		}
		sheet.setConditionForSelection("colorgrad", opt)
	},
	conditionIconSet: function(hd, index) {
		var sheet = hd.sheet,
			store = hd.store;
		var obj = SCOM.iconSetStore.data.items[index].data;
		var opt = {
			set: obj.set,
			level: obj.level
		};
		sheet.setConditionForSelection("iconset", opt)
	},
	searchFindMatch: function(hd, findText) {
		var sheet = hd.sheet,
			store = hd.store;
		var txt = "*" + findText + "*";
		var sm = sheet.getSelectionModel();
		var focusCell = sm.getFocusCell();
		var startRow = focusCell.row,
			startCol = focusCell.col;
		var result = new Ext.data.Store({
			model: "EnterpriseSheet.sheet.model.TargetModel",
			groupField: "sheetName"
		});
		store.findMatchCells(txt, function(matchs, nextCellId) {
			result.removeAll();
			if(matchs && 0 < matchs.length) {
				result.add(matchs)
			}
			if(result.data.length > 0) {
				var rec = result.getAt(0);
				this.searchGo2Pos(hd, rec.data.row, rec.data.col)
			}
		}, this);
		return result
	},
	searchGo2Pos: function(hd, row, col) {
		var sheet = hd.sheet,
			store = hd.store;
		var curSheetId = sheet.getSheetId();
		var sm = sheet.getSelectionModel();
		var orow = row,
			ocol = col;
		var cregion = sheet.cregion;
		if(!cregion.isInRange(row, col)) {
			row = row - Math.floor((cregion.rowEnd - cregion.rowStart) / 2);
			col = col - Math.floor((cregion.colEnd - cregion.colStart) / 2);
			if(row < 1) {
				row = 1
			}
			if(col < 1) {
				col = 1
			}
			sheet.go2Pos(row, col)
		}
		sm.selectRange({
			row: orow,
			col: ocol
		});
		sm.setFocusCell(orow, ocol)
	},
	searchPrevMatch: function(hd, store) {
		var sheet = hd.sheet;
		var sm = sheet.getSelectionModel();
		var sel = sm.getSelection();
		var curRow = sel.startPos.row,
			curCol = sel.startPos.col;
		var cur;
		for(var i = 0; i < store.data.length; i++) {
			var obj = store.getAt(i);
			if(curRow == obj.data.row && curCol == obj.data.col) {
				cur = obj;
				break
			}
		}
		if(cur) {
			var index = store.indexOf(cur);
			index--;
			if(index >= 0) {
				var rec = store.getAt(index);
				this.searchGo2Pos(hd, rec.data.row, rec.data.col)
			}
		}
	},
	searchNextMatch: function(hd, store) {
		var sheet = hd.sheet;
		var sm = sheet.getSelectionModel();
		var sel = sm.getSelection();
		var curRow = sel.startPos.row,
			curCol = sel.startPos.col;
		var cur;
		for(var i = 0; i < store.data.length; i++) {
			var obj = store.getAt(i);
			if(curRow == obj.data.row && curCol == obj.data.col) {
				cur = obj;
				break
			}
		}
		if(cur) {
			var index = store.indexOf(cur);
			index++;
			if(index < store.data.length) {
				var rec = store.getAt(index);
				this.searchGo2Pos(hd, rec.data.row, rec.data.col)
			}
		}
	},
	searchReplaceSelect: function(hd, replaceTxt, findTxt) {
		var sheet = hd.sheet,
			store = hd.store;
		var sm = sheet.getSelectionModel();
		var sels = this.getSelectedRangeData(hd);
		if(0 < sels.length) {
			var sel = sels[0];
			var modified, deleted;
			var originalData = sel.val;
			var reg = new RegExp(findTxt, "gi");
			if(SCOM.nullOrUndefined(replaceTxt)) {
				replaceTxt = ""
			}
			replaceTxt = originalData.replace(reg, replaceTxt);
			if(!SCOM.nullOrUndefined(replaceTxt) && "" != replaceTxt) {
				modified = {
					data: replaceTxt
				}
			} else {
				deleted = ["data"]
			}
			var cellDatail = store.getCellProperty(sheet, sel.row, sel.col);
			if(cellDatail.dsd && cellDatail.dsd === "ed") {} else {
				sheet.setCellData(sheet.sheetId, sel.row, sel.col, modified, deleted)
			}
		} else {
			Ext.Msg.alert(SLANG.hint, SLANG.no_selection_replace)
		}
	},
	searchReplaceAll: function(hd, replaceTxt, findTxt) {
		var sheet = hd.sheet,
			store = hd.store;
		var modified, deleted;
		var datas = this.searchFindMatch(hd, findTxt);
		datas.each(function(rec) {
			var originalData = rec.data.data + "";
			var reg = new RegExp(findTxt, "gi");
			if(SCOM.nullOrUndefined(replaceTxt)) {
				replaceTxt = ""
			}
			var replacedTxt = originalData.replace(reg, replaceTxt);
			if(!SCOM.nullOrUndefined(replacedTxt) && "" != replacedTxt) {
				modified = {
					data: replacedTxt
				}
			} else {
				deleted = ["data"]
			}
			var cellDatail = store.getCellProperty(sheet.sheetId, rec.data.row, rec.data.col);
			if(cellDatail.dsd && cellDatail.dsd === "ed") {} else {
				sheet.setCellData(sheet.sheetId, rec.data.row, rec.data.col, modified, deleted, true)
			}
		}, this);
		sheet.getStore().pullingAction();
		sheet.refreshRange(null, true)
	},
	refreshRange: function(hd, pos) {
		var sheet = hd.sheet,
			store = hd.store;
		if(pos == null) {
			sheet.refreshRange(undefined, true)
		} else {
			var changes = {};
			changes[pos.join(store.separateChar)] = pos;
			var cals = sheet.findDirectRecalculateCellsForCells(changes);
			sheet.refreshRange(undefined, cals)
		}
	},
	pictureInsert: function(hd, url, incell) {
		var sheet = hd.sheet,
			store = hd.store;
		if(url) {
			if(incell) {
				sheet.createInCellPicture(url)
			} else {
				sheet.createPicture(url)
			}
			sheet.fireEvent("done", sheet)
		}
	},
	insertCommentDirect: function(hd, comment, sheetId, row, col) {
		var sheet = hd.sheet,
			store = hd.store;
		var pos;
		if(row && col) {
			if(sheetId == null) {
				sheetId = sheet.sheetId
			}
			pos = {
				sheet: sheetId,
				row: row,
				col: col
			}
		}
		hd.sheet.insertComment(comment, pos)
	},
	getAllRangeMeTreeRefered: function(hd, sheetId, row, column) {
		var allFormula = [];
		var result = this.loopFormulaTree(hd, sheetId, row, column, allFormula);
		return result
	},
	loopFormulaTree: function(hd, sheetId, row, column, allFormula) {
		var cell = this.getCell(hd, sheetId, row, column),
			refs = cell.refs,
			child = [];
		var result = {
			sheetId: sheetId,
			row: row,
			column: column
		};
		var temp = [sheetId, row, column].join();
		if(Ext.Array.contains(allFormula, temp)) {
			return null
		} else {
			allFormula.push(temp)
		}
		if(refs == null || refs.length == 0) {
			return result
		}
		for(var i = 0; i < refs.length; i++) {
			var ref = refs[i];
			var childSheetId = ref[0],
				x1 = ref[1],
				y1 = ref[2],
				x2 = ref[3],
				y2 = ref[4];
			if(x2 >= x1 && y2 >= y1) {
				for(var k = x1; k <= x2; k++) {
					for(var j = y1; j <= y2; j++) {
						var tempResult = this.getAllRangeMeTreeRefered(hd, childSheetId, k, j);
						if(tempResult) {
							child.push(tempResult)
						}
					}
				}
			}
		}
		Ext.apply(result, {
			child: child
		});
		return result
	},
	addCombo: function(hd, sheetId, row, col, dataSourceName) {
		hd.sheet.addCombo(sheetId, row, col, dataSourceName)
	},
	addComboByStore: function(hd, sheetId, row, col, storeJson) {
		hd.sheet.addComboByStore(sheetId, row, col, storeJson)
	},
	removeCombo: function(hd, sheetId, row, col) {
		hd.sheet.removeCombo(sheetId, row, col)
	},
	refreshCombo: function(hd, sheetId, row, col) {
		hd.sheet.refreshCombo(sheetId, row, col)
	},
	refreshComboByStore: function(hd, sheetId, row, col, storeJson) {
		hd.sheet.removeCombo(sheetId, row, col);
		hd.sheet.addComboByStore(sheetId, row, col, storeJson)
	},
	createMergedRegion: function(hd, mergeObj) {
		var sheet = hd.sheet,
			store = hd.store;
		var len = mergeObj.length;
		for(var i = 0; i < len; i++) {
			var data = mergeObj[i],
				sheetId = parseInt(data.sheet);
			var span = data.range;
			if(typeof span === "string" || span instanceof String) {
				span = Ext.decode(span)
			}
			span = [sheetId].concat(span);
			sheet.mergeCellForSpan(span, false, false)
		}
		sheet.refresh()
	},
	getMergedRegion: function(hd, name) {
		var sheet = hd.sheet,
			store = hd.store;
		var merges = store.getMergeFloatings();
		var result = [];
		for(var p in merges) {
			var obj = merges[p];
			if(name == obj.name) {
				result.push(obj)
			}
		}
		return result
	},
	deleteMergedRegion: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var merges = store.getMergeFloatings();
		for(var p in merges) {
			var obj = merges[p];
			var sheetId = obj.sheet;
			var json = obj.json;
			if(typeof json === "string" || json instanceof String) {
				json = Ext.decode(json)
			}
			json = [sheetId].concat(json);
			sheet.unmergeCell(json)
		}
		sheet.refresh()
	},
	getAllMergedRegions: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var merges = store.getMergeFloatings();
		var result = [];
		for(var p in merges) {
			var obj = merges[p];
			result.push(obj)
		}
		return result
	},
	getAllMergedRegionCells: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var merges = store.getMergeFloatings();
		var result = [];
		for(var p in merges) {
			var obj = merges[p];
			var sheetId = obj.sheet;
			var json = obj.json;
			if(typeof json === "string" || json instanceof String) {
				json = Ext.decode(json)
			}
			var minrow = json[0],
				mincol = json[1],
				maxrow = json[2],
				maxcol = json[3];
			for(var i = minrow; i <= maxrow; i++) {
				for(var j = mincol; j <= maxcol; j++) {
					var cell = store.getCell(sheetId, i, j);
					result.push(cell)
				}
			}
		}
		return result
	},
	getMergedRegionHeadCell: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var merges = store.getMergeFloatings();
		var result = [];
		for(var p in merges) {
			var obj = merges[p];
			var sheetId = obj.sheet;
			var json = obj.json;
			if(typeof json === "string" || json instanceof String) {
				json = Ext.decode(json)
			}
			var minrow = json[0],
				mincol = json[1];
			var cell = store.getCell(sheetId, minrow, mincol);
			result.push(cell)
		}
		return result
	},
	getMergedRegionHiddenCells: function(hd) {
		var sheet = hd.sheet,
			store = hd.store;
		var merges = store.getMergeFloatings();
		var result = [];
		for(var p in merges) {
			var obj = merges[p];
			var sheetId = obj.sheet;
			var json = obj.json;
			if(typeof json === "string" || json instanceof String) {
				json = Ext.decode(json)
			}
			var minrow = json[0],
				mincol = json[1],
				maxrow = json[2],
				maxcol = json[3];
			for(var i = minrow; i <= maxrow; i++) {
				for(var j = mincol; j <= maxcol; j++) {
					if(i == minrow && j == mincol) {
						continue
					}
					var cell = store.getCell(sheetId, i, j);
					result.push(cell)
				}
			}
		}
		return result
	},
	isMergedCell: function(hd, sheetId, row, col) {
		var sheet = hd.sheet,
			store = hd.store;
		return store.isMergedCell(null, sheetId, row, col)
	},
	isMergeHeadCell: function(hd, sheetId, row, col) {
		var sheet = hd.sheet,
			store = hd.store;
		var merges = store.getMergeFloatings();
		var flag = false;
		for(var p in merges) {
			var obj = merges[p];
			var json = obj.json;
			if(typeof json === "string" || json instanceof String) {
				json = Ext.decode(json)
			}
			var minrow = json[0],
				mincol = json[1];
			if(row == minrow && col == mincol) {
				flag = true
			}
		}
		return flag && store.isMergedCell(null, sheetId, row, col)
	},
	isMergeHiddenCell: function(hd, sheetId, row, col) {
		return !isMergeHeadCell(hd, sheetId, row, col)
	},
	formatBrush: function(hd) {
		var sheet = hd.sheet;
		var brushFromCoord;
		var brush = Ext.core.DomHelper.append(document.body, '<div class="ss-brush icon-brush" style="z-index:' + SCONST.TOP_Z_INDEX + ';"></div>', true);
		brush.hide();
		Ext.getDoc().on("mousemove", function(e) {
			var xy = e.getXY();
			var sel = sheet.getEl();
			var left = sel.getLeft(),
				top = sel.getTop(),
				right = sel.getRight(),
				bottom = sel.getBottom();
			if(left <= xy[0] && xy[0] <= right && top <= xy[1] && xy[1] <= bottom) {
				var x = xy[0] + 16,
					y = xy[1] - 5;
				brush.setLeft(x);
				brush.setTop(y);
				brush.show()
			} else {
				brush.hide()
			}
		}, this);
		sheet.on("cellmouseup", function(e) {
			var sm = sheet.getSelectionModel();
			var fromSpan = brushFromCoord[0];
			var toSpan = sm.selection2Span();
			var res = sm.calculateRowColSpan(fromSpan);
			if(!res.hasMerged) {
				res.hasMerged = true;
				res.rowSpan = fromSpan[3] - fromSpan[1] + 1;
				res.colSpan = fromSpan[4] - fromSpan[2] + 1
			}
			toSpan = sm.adjustToSpanForMerged(fromSpan, toSpan, res);
			if(toSpan) {
				sheet.applyBrush(brushFromCoord, [toSpan])
			} else {
				Ext.Msg.alert(SLANG.hint, SLANG.target_range_shouldbe_same_size)
			}
			Ext.removeNode(brush.dom);
			delete(brush)
		}, this, {
			single: true
		});
		var sm = sheet.getSelectionModel(),
			rm = sheet.getReferenceModel();
		brushFromCoord = sm.selection2Coord()
	}
}, function() {});